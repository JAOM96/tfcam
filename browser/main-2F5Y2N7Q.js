var lK=Object.create;var Ux=Object.defineProperty,cK=Object.defineProperties,uK=Object.getOwnPropertyDescriptor,pK=Object.getOwnPropertyDescriptors,fK=Object.getOwnPropertyNames,Yk=Object.getOwnPropertySymbols,dK=Object.getPrototypeOf,Qk=Object.prototype.hasOwnProperty,hK=Object.prototype.propertyIsEnumerable;var Zk=(t,n,e)=>n in t?Ux(t,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[n]=e,Ye=(t,n)=>{for(var e in n||={})Qk.call(n,e)&&Zk(t,e,n[e]);if(Yk)for(var e of Yk(n))hK.call(n,e)&&Zk(t,e,n[e]);return t},Gn=(t,n)=>cK(t,pK(n));var So=(t,n)=>()=>(n||t((n={exports:{}}).exports,n),n.exports),Xt=(t,n)=>{for(var e in n)Ux(t,e,{get:n[e],enumerable:!0})},mK=(t,n,e,r)=>{if(n&&typeof n=="object"||typeof n=="function")for(let o of fK(n))!Qk.call(t,o)&&o!==e&&Ux(t,o,{get:()=>n[o],enumerable:!(r=uK(n,o))||r.enumerable});return t};var wa=(t,n,e)=>(e=t!=null?lK(dK(t)):{},mK(n||!t||!t.__esModule?Ux(e,"default",{value:t,enumerable:!0}):e,t));var te=(t,n,e)=>new Promise((r,o)=>{var s=l=>{try{a(e.next(l))}catch(c){o(c)}},i=l=>{try{a(e.throw(l))}catch(c){o(c)}},a=l=>l.done?r(l.value):Promise.resolve(l.value).then(s,i);a((e=e.apply(t,n)).next())});var pF=So(uF=>{"use strict";(function(){"use strict";function t(h){var g=0;return function(){return g<h.length?{done:!1,value:h[g++]}:{done:!0}}}var n=typeof Object.defineProperties=="function"?Object.defineProperty:function(h,g,m){return h==Array.prototype||h==Object.prototype||(h[g]=m.value),h};function e(h){h=[typeof globalThis=="object"&&globalThis,h,typeof window=="object"&&window,typeof self=="object"&&self,typeof global=="object"&&global];for(var g=0;g<h.length;++g){var m=h[g];if(m&&m.Math==Math)return m}throw Error("Cannot find global object")}var r=e(this);function o(h,g){if(g)e:{var m=r;h=h.split(".");for(var y=0;y<h.length-1;y++){var x=h[y];if(!(x in m))break e;m=m[x]}h=h[h.length-1],y=m[h],g=g(y),g!=y&&g!=null&&n(m,h,{configurable:!0,writable:!0,value:g})}}function s(h){var g=typeof Symbol<"u"&&Symbol.iterator&&h[Symbol.iterator];return g?g.call(h):{next:t(h)}}var i=typeof Object.assign=="function"?Object.assign:function(h,g){for(var m=1;m<arguments.length;m++){var y=arguments[m];if(y)for(var x in y)Object.prototype.hasOwnProperty.call(y,x)&&(h[x]=y[x])}return h};o("Object.assign",function(h){return h||i}),o("Array.prototype.fill",function(h){return h||function(g,m,y){var x=this.length||0;for(0>m&&(m=Math.max(0,x+m)),(y==null||y>x)&&(y=x),y=Number(y),0>y&&(y=Math.max(0,x+y)),m=Number(m||0);m<y;m++)this[m]=g;return this}});function a(h){return h||Array.prototype.fill}o("Int8Array.prototype.fill",a),o("Uint8Array.prototype.fill",a),o("Uint8ClampedArray.prototype.fill",a),o("Int16Array.prototype.fill",a),o("Uint16Array.prototype.fill",a),o("Int32Array.prototype.fill",a),o("Uint32Array.prototype.fill",a),o("Float32Array.prototype.fill",a),o("Float64Array.prototype.fill",a);var l=this||self;function c(h,g){h=h.split(".");var m=l;h[0]in m||typeof m.execScript>"u"||m.execScript("var "+h[0]);for(var y;h.length&&(y=h.shift());)h.length||g===void 0?m[y]&&m[y]!==Object.prototype[y]?m=m[y]:m=m[y]={}:m[y]=g}var u={color:"white",lineWidth:4,radius:6,visibilityMin:.5};function p(h){return h=h||{},Object.assign({},u,{fillColor:h.color},h)}function f(h,g){return h instanceof Function?h(g):h}function d(h,g,m){return Math.max(Math.min(g,m),Math.min(Math.max(g,m),h))}c("clamp",d),c("drawLandmarks",function(h,g,m){if(g){m=p(m),h.save();var y=h.canvas,x=0;g=s(g);for(var C=g.next();!C.done;C=g.next())if(C=C.value,C!==void 0&&(C.visibility===void 0||C.visibility>m.visibilityMin)){h.fillStyle=f(m.fillColor,{index:x,from:C}),h.strokeStyle=f(m.color,{index:x,from:C}),h.lineWidth=f(m.lineWidth,{index:x,from:C});var I=new Path2D;I.arc(C.x*y.width,C.y*y.height,f(m.radius,{index:x,from:C}),0,2*Math.PI),h.fill(I),h.stroke(I),++x}h.restore()}}),c("drawConnectors",function(h,g,m,y){if(g&&m){y=p(y),h.save();var x=h.canvas,C=0;m=s(m);for(var I=m.next();!I.done;I=m.next()){var D=I.value;h.beginPath(),I=g[D[0]],D=g[D[1]],I&&D&&(I.visibility===void 0||I.visibility>y.visibilityMin)&&(D.visibility===void 0||D.visibility>y.visibilityMin)&&(h.strokeStyle=f(y.color,{index:C,from:I,to:D}),h.lineWidth=f(y.lineWidth,{index:C,from:I,to:D}),h.moveTo(I.x*x.width,I.y*x.height),h.lineTo(D.x*x.width,D.y*x.height)),++C,h.stroke()}h.restore()}}),c("drawRectangle",function(h,g,m){m=p(m),h.save();var y=h.canvas;h.beginPath(),h.lineWidth=f(m.lineWidth,{}),h.strokeStyle=f(m.color,{}),h.fillStyle=f(m.fillColor,{}),h.translate(g.xCenter*y.width,g.yCenter*y.height),h.rotate(g.rotation*Math.PI/180),h.rect(-g.width/2*y.width,-g.height/2*y.height,g.width*y.width,g.height*y.height),h.translate(-g.xCenter*y.width,-g.yCenter*y.height),h.stroke(),h.fill(),h.restore()}),c("lerp",function(h,g,m,y,x){return d(y*(1-(h-g)/(m-g))+x*(1-(m-h)/(m-g)),y,x)})}).call(uF)});var dF=So(fF=>{"use strict";(function(){"use strict";function t(F){var G=0;return function(){return G<F.length?{done:!1,value:F[G++]}:{done:!0}}}var n=typeof Object.defineProperties=="function"?Object.defineProperty:function(F,G,ee){return F==Array.prototype||F==Object.prototype||(F[G]=ee.value),F};function e(F){F=[typeof globalThis=="object"&&globalThis,F,typeof window=="object"&&window,typeof self=="object"&&self,typeof global=="object"&&global];for(var G=0;G<F.length;++G){var ee=F[G];if(ee&&ee.Math==Math)return ee}throw Error("Cannot find global object")}var r=e(this);function o(F,G){if(G)e:{var ee=r;F=F.split(".");for(var Q=0;Q<F.length-1;Q++){var oe=F[Q];if(!(oe in ee))break e;ee=ee[oe]}F=F[F.length-1],Q=ee[F],G=G(Q),G!=Q&&G!=null&&n(ee,F,{configurable:!0,writable:!0,value:G})}}o("Symbol",function(F){function G(ae){if(this instanceof G)throw new TypeError("Symbol is not a constructor");return new ee(Q+(ae||"")+"_"+oe++,ae)}function ee(ae,J){this.g=ae,n(this,"description",{configurable:!0,writable:!0,value:J})}if(F)return F;ee.prototype.toString=function(){return this.g};var Q="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",oe=0;return G}),o("Symbol.iterator",function(F){if(F)return F;F=Symbol("Symbol.iterator");for(var G="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),ee=0;ee<G.length;ee++){var Q=r[G[ee]];typeof Q=="function"&&typeof Q.prototype[F]!="function"&&n(Q.prototype,F,{configurable:!0,writable:!0,value:function(){return s(t(this))}})}return F});function s(F){return F={next:F},F[Symbol.iterator]=function(){return this},F}function i(F){var G=typeof Symbol<"u"&&Symbol.iterator&&F[Symbol.iterator];return G?G.call(F):{next:t(F)}}function a(){this.i=!1,this.g=null,this.o=void 0,this.j=1,this.m=0,this.h=null}function l(F){if(F.i)throw new TypeError("Generator is already running");F.i=!0}a.prototype.l=function(F){this.o=F};function c(F,G){F.h={F:G,G:!0},F.j=F.m}a.prototype.return=function(F){this.h={return:F},this.j=this.m};function u(F){this.g=new a,this.h=F}function p(F,G){l(F.g);var ee=F.g.g;return ee?f(F,"return"in ee?ee.return:function(Q){return{value:Q,done:!0}},G,F.g.return):(F.g.return(G),d(F))}function f(F,G,ee,Q){try{var oe=G.call(F.g.g,ee);if(!(oe instanceof Object))throw new TypeError("Iterator result "+oe+" is not an object");if(!oe.done)return F.g.i=!1,oe;var ae=oe.value}catch(J){return F.g.g=null,c(F.g,J),d(F)}return F.g.g=null,Q.call(F.g,ae),d(F)}function d(F){for(;F.g.j;)try{var G=F.h(F.g);if(G)return F.g.i=!1,{value:G.value,done:!1}}catch(ee){F.g.o=void 0,c(F.g,ee)}if(F.g.i=!1,F.g.h){if(G=F.g.h,F.g.h=null,G.G)throw G.F;return{value:G.return,done:!0}}return{value:void 0,done:!0}}function h(F){this.next=function(G){return l(F.g),F.g.g?G=f(F,F.g.g.next,G,F.g.l):(F.g.l(G),G=d(F)),G},this.throw=function(G){return l(F.g),F.g.g?G=f(F,F.g.g.throw,G,F.g.l):(c(F.g,G),G=d(F)),G},this.return=function(G){return p(F,G)},this[Symbol.iterator]=function(){return this}}function g(F){function G(Q){return F.next(Q)}function ee(Q){return F.throw(Q)}return new Promise(function(Q,oe){function ae(J){J.done?Q(J.value):Promise.resolve(J.value).then(G,ee).then(ae,oe)}ae(F.next())})}o("Promise",function(F){function G(J){this.h=0,this.i=void 0,this.g=[],this.o=!1;var re=this.j();try{J(re.resolve,re.reject)}catch(se){re.reject(se)}}function ee(){this.g=null}function Q(J){return J instanceof G?J:new G(function(re){re(J)})}if(F)return F;ee.prototype.h=function(J){if(this.g==null){this.g=[];var re=this;this.i(function(){re.l()})}this.g.push(J)};var oe=r.setTimeout;ee.prototype.i=function(J){oe(J,0)},ee.prototype.l=function(){for(;this.g&&this.g.length;){var J=this.g;this.g=[];for(var re=0;re<J.length;++re){var se=J[re];J[re]=null;try{se()}catch(pe){this.j(pe)}}}this.g=null},ee.prototype.j=function(J){this.i(function(){throw J})},G.prototype.j=function(){function J(pe){return function(xe){se||(se=!0,pe.call(re,xe))}}var re=this,se=!1;return{resolve:J(this.A),reject:J(this.l)}},G.prototype.A=function(J){if(J===this)this.l(new TypeError("A Promise cannot resolve to itself"));else if(J instanceof G)this.C(J);else{e:switch(typeof J){case"object":var re=J!=null;break e;case"function":re=!0;break e;default:re=!1}re?this.v(J):this.m(J)}},G.prototype.v=function(J){var re=void 0;try{re=J.then}catch(se){this.l(se);return}typeof re=="function"?this.D(re,J):this.m(J)},G.prototype.l=function(J){this.u(2,J)},G.prototype.m=function(J){this.u(1,J)},G.prototype.u=function(J,re){if(this.h!=0)throw Error("Cannot settle("+J+", "+re+"): Promise already settled in state"+this.h);this.h=J,this.i=re,this.h===2&&this.B(),this.H()},G.prototype.B=function(){var J=this;oe(function(){if(J.I()){var re=r.console;typeof re<"u"&&re.error(J.i)}},1)},G.prototype.I=function(){if(this.o)return!1;var J=r.CustomEvent,re=r.Event,se=r.dispatchEvent;return typeof se>"u"?!0:(typeof J=="function"?J=new J("unhandledrejection",{cancelable:!0}):typeof re=="function"?J=new re("unhandledrejection",{cancelable:!0}):(J=r.document.createEvent("CustomEvent"),J.initCustomEvent("unhandledrejection",!1,!0,J)),J.promise=this,J.reason=this.i,se(J))},G.prototype.H=function(){if(this.g!=null){for(var J=0;J<this.g.length;++J)ae.h(this.g[J]);this.g=null}};var ae=new ee;return G.prototype.C=function(J){var re=this.j();J.s(re.resolve,re.reject)},G.prototype.D=function(J,re){var se=this.j();try{J.call(re,se.resolve,se.reject)}catch(pe){se.reject(pe)}},G.prototype.then=function(J,re){function se(Te,Se){return typeof Te=="function"?function(Re){try{pe(Te(Re))}catch(De){xe(De)}}:Se}var pe,xe,be=new G(function(Te,Se){pe=Te,xe=Se});return this.s(se(J,pe),se(re,xe)),be},G.prototype.catch=function(J){return this.then(void 0,J)},G.prototype.s=function(J,re){function se(){switch(pe.h){case 1:J(pe.i);break;case 2:re(pe.i);break;default:throw Error("Unexpected state: "+pe.h)}}var pe=this;this.g==null?ae.h(se):this.g.push(se),this.o=!0},G.resolve=Q,G.reject=function(J){return new G(function(re,se){se(J)})},G.race=function(J){return new G(function(re,se){for(var pe=i(J),xe=pe.next();!xe.done;xe=pe.next())Q(xe.value).s(re,se)})},G.all=function(J){var re=i(J),se=re.next();return se.done?Q([]):new G(function(pe,xe){function be(Re){return function(De){Te[Re]=De,Se--,Se==0&&pe(Te)}}var Te=[],Se=0;do Te.push(void 0),Se++,Q(se.value).s(be(Te.length-1),xe),se=re.next();while(!se.done)})},G});var m=typeof Object.assign=="function"?Object.assign:function(F,G){for(var ee=1;ee<arguments.length;ee++){var Q=arguments[ee];if(Q)for(var oe in Q)Object.prototype.hasOwnProperty.call(Q,oe)&&(F[oe]=Q[oe])}return F};o("Object.assign",function(F){return F||m});var y=this||self,x={facingMode:"user",width:640,height:480};function C(F,G){this.video=F,this.i=0,this.h=Object.assign(Object.assign({},x),G)}C.prototype.stop=function(){var F=this,G,ee,Q,oe;return g(new h(new u(function(ae){if(F.g){for(G=F.g.getTracks(),ee=i(G),Q=ee.next();!Q.done;Q=ee.next())oe=Q.value,oe.stop();F.g=void 0}ae.j=0})))},C.prototype.start=function(){var F=this,G;return g(new h(new u(function(ee){return navigator.mediaDevices&&navigator.mediaDevices.getUserMedia||alert("No navigator.mediaDevices.getUserMedia exists."),G=F.h,ee.return(navigator.mediaDevices.getUserMedia({video:{facingMode:G.facingMode,width:G.width,height:G.height}}).then(function(Q){D(F,Q)}).catch(function(Q){var oe="Failed to acquire camera feed: "+Q;throw console.error(oe),alert(oe),Q}))})))};function I(F){window.requestAnimationFrame(function(){O(F)})}function D(F,G){F.g=G,F.video.srcObject=G,F.video.onloadedmetadata=function(){F.video.play(),I(F)}}function O(F){var G=null;F.video.paused||F.video.currentTime===F.i||(F.i=F.video.currentTime,G=F.h.onFrame()),G?G.then(function(){I(F)}):I(F)}var L=["Camera"],B=y;L[0]in B||typeof B.execScript>"u"||B.execScript("var "+L[0]);for(var V;L.length&&(V=L.shift());)L.length||C===void 0?B[V]&&B[V]!==Object.prototype[V]?B=B[V]:B=B[V]={}:B[V]=C}).call(fF)});var PE=So(hF=>{"use strict";(function(){"use strict";var t;function n(w){var E=0;return function(){return E<w.length?{done:!1,value:w[E++]}:{done:!0}}}var e=typeof Object.defineProperties=="function"?Object.defineProperty:function(w,E,k){return w==Array.prototype||w==Object.prototype||(w[E]=k.value),w};function r(w){w=[typeof globalThis=="object"&&globalThis,w,typeof window=="object"&&window,typeof self=="object"&&self,typeof global=="object"&&global];for(var E=0;E<w.length;++E){var k=w[E];if(k&&k.Math==Math)return k}throw Error("Cannot find global object")}var o=r(this);function s(w,E){if(E)e:{var k=o;w=w.split(".");for(var q=0;q<w.length-1;q++){var ie=w[q];if(!(ie in k))break e;k=k[ie]}w=w[w.length-1],q=k[w],E=E(q),E!=q&&E!=null&&e(k,w,{configurable:!0,writable:!0,value:E})}}s("Symbol",function(w){function E(me){if(this instanceof E)throw new TypeError("Symbol is not a constructor");return new k(q+(me||"")+"_"+ie++,me)}function k(me,ce){this.g=me,e(this,"description",{configurable:!0,writable:!0,value:ce})}if(w)return w;k.prototype.toString=function(){return this.g};var q="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",ie=0;return E}),s("Symbol.iterator",function(w){if(w)return w;w=Symbol("Symbol.iterator");for(var E="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),k=0;k<E.length;k++){var q=o[E[k]];typeof q=="function"&&typeof q.prototype[w]!="function"&&e(q.prototype,w,{configurable:!0,writable:!0,value:function(){return i(n(this))}})}return w});function i(w){return w={next:w},w[Symbol.iterator]=function(){return this},w}function a(w){var E=typeof Symbol<"u"&&Symbol.iterator&&w[Symbol.iterator];return E?E.call(w):{next:n(w)}}function l(w){if(!(w instanceof Array)){w=a(w);for(var E,k=[];!(E=w.next()).done;)k.push(E.value);w=k}return w}var c=typeof Object.create=="function"?Object.create:function(w){function E(){}return E.prototype=w,new E},u;if(typeof Object.setPrototypeOf=="function")u=Object.setPrototypeOf;else{var p;e:{var f={a:!0},d={};try{d.__proto__=f,p=d.a;break e}catch(w){}p=!1}u=p?function(w,E){if(w.__proto__=E,w.__proto__!==E)throw new TypeError(w+" is not extensible");return w}:null}var h=u;function g(w,E){if(w.prototype=c(E.prototype),w.prototype.constructor=w,h)h(w,E);else for(var k in E)if(k!="prototype")if(Object.defineProperties){var q=Object.getOwnPropertyDescriptor(E,k);q&&Object.defineProperty(w,k,q)}else w[k]=E[k];w.ea=E.prototype}function m(){this.l=!1,this.i=null,this.h=void 0,this.g=1,this.s=this.m=0,this.j=null}function y(w){if(w.l)throw new TypeError("Generator is already running");w.l=!0}m.prototype.o=function(w){this.h=w};function x(w,E){w.j={U:E,V:!0},w.g=w.m||w.s}m.prototype.return=function(w){this.j={return:w},this.g=this.s};function C(w,E,k){return w.g=k,{value:E}}function I(w){this.g=new m,this.h=w}function D(w,E){y(w.g);var k=w.g.i;return k?O(w,"return"in k?k.return:function(q){return{value:q,done:!0}},E,w.g.return):(w.g.return(E),L(w))}function O(w,E,k,q){try{var ie=E.call(w.g.i,k);if(!(ie instanceof Object))throw new TypeError("Iterator result "+ie+" is not an object");if(!ie.done)return w.g.l=!1,ie;var me=ie.value}catch(ce){return w.g.i=null,x(w.g,ce),L(w)}return w.g.i=null,q.call(w.g,me),L(w)}function L(w){for(;w.g.g;)try{var E=w.h(w.g);if(E)return w.g.l=!1,{value:E.value,done:!1}}catch(k){w.g.h=void 0,x(w.g,k)}if(w.g.l=!1,w.g.j){if(E=w.g.j,w.g.j=null,E.V)throw E.U;return{value:E.return,done:!0}}return{value:void 0,done:!0}}function B(w){this.next=function(E){return y(w.g),w.g.i?E=O(w,w.g.i.next,E,w.g.o):(w.g.o(E),E=L(w)),E},this.throw=function(E){return y(w.g),w.g.i?E=O(w,w.g.i.throw,E,w.g.o):(x(w.g,E),E=L(w)),E},this.return=function(E){return D(w,E)},this[Symbol.iterator]=function(){return this}}function V(w,E){return E=new B(new I(E)),h&&w.prototype&&h(E,w.prototype),E}function F(w,E){w instanceof String&&(w+="");var k=0,q=!1,ie={next:function(){if(!q&&k<w.length){var me=k++;return{value:E(me,w[me]),done:!1}}return q=!0,{done:!0,value:void 0}}};return ie[Symbol.iterator]=function(){return ie},ie}var G=typeof Object.assign=="function"?Object.assign:function(w,E){for(var k=1;k<arguments.length;k++){var q=arguments[k];if(q)for(var ie in q)Object.prototype.hasOwnProperty.call(q,ie)&&(w[ie]=q[ie])}return w};s("Object.assign",function(w){return w||G}),s("Promise",function(w){function E(ce){this.h=0,this.i=void 0,this.g=[],this.o=!1;var ye=this.j();try{ce(ye.resolve,ye.reject)}catch(ke){ye.reject(ke)}}function k(){this.g=null}function q(ce){return ce instanceof E?ce:new E(function(ye){ye(ce)})}if(w)return w;k.prototype.h=function(ce){if(this.g==null){this.g=[];var ye=this;this.i(function(){ye.l()})}this.g.push(ce)};var ie=o.setTimeout;k.prototype.i=function(ce){ie(ce,0)},k.prototype.l=function(){for(;this.g&&this.g.length;){var ce=this.g;this.g=[];for(var ye=0;ye<ce.length;++ye){var ke=ce[ye];ce[ye]=null;try{ke()}catch(Pe){this.j(Pe)}}}this.g=null},k.prototype.j=function(ce){this.i(function(){throw ce})},E.prototype.j=function(){function ce(Pe){return function(dt){ke||(ke=!0,Pe.call(ye,dt))}}var ye=this,ke=!1;return{resolve:ce(this.C),reject:ce(this.l)}},E.prototype.C=function(ce){if(ce===this)this.l(new TypeError("A Promise cannot resolve to itself"));else if(ce instanceof E)this.F(ce);else{e:switch(typeof ce){case"object":var ye=ce!=null;break e;case"function":ye=!0;break e;default:ye=!1}ye?this.u(ce):this.m(ce)}},E.prototype.u=function(ce){var ye=void 0;try{ye=ce.then}catch(ke){this.l(ke);return}typeof ye=="function"?this.G(ye,ce):this.m(ce)},E.prototype.l=function(ce){this.s(2,ce)},E.prototype.m=function(ce){this.s(1,ce)},E.prototype.s=function(ce,ye){if(this.h!=0)throw Error("Cannot settle("+ce+", "+ye+"): Promise already settled in state"+this.h);this.h=ce,this.i=ye,this.h===2&&this.D(),this.A()},E.prototype.D=function(){var ce=this;ie(function(){if(ce.B()){var ye=o.console;typeof ye<"u"&&ye.error(ce.i)}},1)},E.prototype.B=function(){if(this.o)return!1;var ce=o.CustomEvent,ye=o.Event,ke=o.dispatchEvent;return typeof ke>"u"?!0:(typeof ce=="function"?ce=new ce("unhandledrejection",{cancelable:!0}):typeof ye=="function"?ce=new ye("unhandledrejection",{cancelable:!0}):(ce=o.document.createEvent("CustomEvent"),ce.initCustomEvent("unhandledrejection",!1,!0,ce)),ce.promise=this,ce.reason=this.i,ke(ce))},E.prototype.A=function(){if(this.g!=null){for(var ce=0;ce<this.g.length;++ce)me.h(this.g[ce]);this.g=null}};var me=new k;return E.prototype.F=function(ce){var ye=this.j();ce.J(ye.resolve,ye.reject)},E.prototype.G=function(ce,ye){var ke=this.j();try{ce.call(ye,ke.resolve,ke.reject)}catch(Pe){ke.reject(Pe)}},E.prototype.then=function(ce,ye){function ke(kt,gt){return typeof kt=="function"?function(Xe){try{Pe(kt(Xe))}catch(v){dt(v)}}:gt}var Pe,dt,zt=new E(function(kt,gt){Pe=kt,dt=gt});return this.J(ke(ce,Pe),ke(ye,dt)),zt},E.prototype.catch=function(ce){return this.then(void 0,ce)},E.prototype.J=function(ce,ye){function ke(){switch(Pe.h){case 1:ce(Pe.i);break;case 2:ye(Pe.i);break;default:throw Error("Unexpected state: "+Pe.h)}}var Pe=this;this.g==null?me.h(ke):this.g.push(ke),this.o=!0},E.resolve=q,E.reject=function(ce){return new E(function(ye,ke){ke(ce)})},E.race=function(ce){return new E(function(ye,ke){for(var Pe=a(ce),dt=Pe.next();!dt.done;dt=Pe.next())q(dt.value).J(ye,ke)})},E.all=function(ce){var ye=a(ce),ke=ye.next();return ke.done?q([]):new E(function(Pe,dt){function zt(Xe){return function(v){kt[Xe]=v,gt--,gt==0&&Pe(kt)}}var kt=[],gt=0;do kt.push(void 0),gt++,q(ke.value).J(zt(kt.length-1),dt),ke=ye.next();while(!ke.done)})},E}),s("Object.is",function(w){return w||function(E,k){return E===k?E!==0||1/E===1/k:E!==E&&k!==k}}),s("Array.prototype.includes",function(w){return w||function(E,k){var q=this;q instanceof String&&(q=String(q));var ie=q.length;for(k=k||0,0>k&&(k=Math.max(k+ie,0));k<ie;k++){var me=q[k];if(me===E||Object.is(me,E))return!0}return!1}}),s("String.prototype.includes",function(w){return w||function(E,k){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(E instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(E,k||0)!==-1}}),s("Array.prototype.keys",function(w){return w||function(){return F(this,function(E){return E})}});var ee=this||self;function Q(w,E){w=w.split(".");var k=ee;w[0]in k||typeof k.execScript>"u"||k.execScript("var "+w[0]);for(var q;w.length&&(q=w.shift());)w.length||E===void 0?k[q]&&k[q]!==Object.prototype[q]?k=k[q]:k=k[q]={}:k[q]=E}function oe(w,E){return E=String.fromCharCode.apply(null,E),w==null?E:w+E}var ae,J=typeof TextDecoder<"u",re,se=typeof TextEncoder<"u";function pe(w){if(se)w=(re||(re=new TextEncoder)).encode(w);else{var E=void 0;E=E===void 0?!1:E;for(var k=0,q=new Uint8Array(3*w.length),ie=0;ie<w.length;ie++){var me=w.charCodeAt(ie);if(128>me)q[k++]=me;else{if(2048>me)q[k++]=me>>6|192;else{if(55296<=me&&57343>=me){if(56319>=me&&ie<w.length){var ce=w.charCodeAt(++ie);if(56320<=ce&&57343>=ce){me=1024*(me-55296)+ce-56320+65536,q[k++]=me>>18|240,q[k++]=me>>12&63|128,q[k++]=me>>6&63|128,q[k++]=me&63|128;continue}else ie--}if(E)throw Error("Found an unpaired surrogate");me=65533}q[k++]=me>>12|224,q[k++]=me>>6&63|128}q[k++]=me&63|128}}w=q.subarray(0,k)}return w}var xe={},be=null;function Te(w,E){E===void 0&&(E=0),De(),E=xe[E];for(var k=Array(Math.floor(w.length/3)),q=E[64]||"",ie=0,me=0;ie<w.length-2;ie+=3){var ce=w[ie],ye=w[ie+1],ke=w[ie+2],Pe=E[ce>>2];ce=E[(ce&3)<<4|ye>>4],ye=E[(ye&15)<<2|ke>>6],ke=E[ke&63],k[me++]=Pe+ce+ye+ke}switch(Pe=0,ke=q,w.length-ie){case 2:Pe=w[ie+1],ke=E[(Pe&15)<<2]||q;case 1:w=w[ie],k[me]=E[w>>2]+E[(w&3)<<4|Pe>>4]+ke+q}return k.join("")}function Se(w){var E=w.length,k=3*E/4;k%3?k=Math.floor(k):"=.".indexOf(w[E-1])!=-1&&(k="=.".indexOf(w[E-2])!=-1?k-2:k-1);var q=new Uint8Array(k),ie=0;return Re(w,function(me){q[ie++]=me}),q.subarray(0,ie)}function Re(w,E){function k(ke){for(;q<w.length;){var Pe=w.charAt(q++),dt=be[Pe];if(dt!=null)return dt;if(!/^[\s\xa0]*$/.test(Pe))throw Error("Unknown base64 encoding at char: "+Pe)}return ke}De();for(var q=0;;){var ie=k(-1),me=k(0),ce=k(64),ye=k(64);if(ye===64&&ie===-1)break;E(ie<<2|me>>4),ce!=64&&(E(me<<4&240|ce>>2),ye!=64&&E(ce<<6&192|ye))}}function De(){if(!be){be={};for(var w="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),E=["+/=","+/","-_=","-_.","-_"],k=0;5>k;k++){var q=w.concat(E[k].split(""));xe[k]=q;for(var ie=0;ie<q.length;ie++){var me=q[ie];be[me]===void 0&&(be[me]=ie)}}}}var Oe=typeof Uint8Array.prototype.slice=="function",We;function et(w,E,k){return E===k?We||(We=new Uint8Array(0)):Oe?w.slice(E,k):new Uint8Array(w.subarray(E,k))}var je=0,tt=0;function qe(w,E){E=E===void 0?{}:E,E=E.v===void 0?!1:E.v,this.h=null,this.g=this.j=this.l=0,this.m=!1,this.v=E,w&&Rt(this,w)}function Rt(w,E){E=E.constructor===Uint8Array?E:E.constructor===ArrayBuffer?new Uint8Array(E):E.constructor===Array?new Uint8Array(E):E.constructor===String?Se(E):E instanceof Uint8Array?new Uint8Array(E.buffer,E.byteOffset,E.byteLength):new Uint8Array(0),w.h=E,w.l=0,w.j=w.h.length,w.g=w.l}qe.prototype.reset=function(){this.g=this.l};function Bt(w){for(var E=128,k=0,q=0,ie=0;4>ie&&128<=E;ie++)E=w.h[w.g++],k|=(E&127)<<7*ie;if(128<=E&&(E=w.h[w.g++],k|=(E&127)<<28,q|=(E&127)>>4),128<=E)for(ie=0;5>ie&&128<=E;ie++)E=w.h[w.g++],q|=(E&127)<<7*ie+3;if(128>E)return w=k>>>0,E=q>>>0,(q=E&2147483648)&&(w=~w+1>>>0,E=~E>>>0,w==0&&(E=E+1>>>0)),w=4294967296*E+(w>>>0),q?-w:w;w.m=!0}qe.prototype.i=function(){var w=this.h,E=w[this.g],k=E&127;return 128>E?(this.g+=1,k):(E=w[this.g+1],k|=(E&127)<<7,128>E?(this.g+=2,k):(E=w[this.g+2],k|=(E&127)<<14,128>E?(this.g+=3,k):(E=w[this.g+3],k|=(E&127)<<21,128>E?(this.g+=4,k):(E=w[this.g+4],k|=(E&15)<<28,128>E?(this.g+=5,k>>>0):(this.g+=5,128<=w[this.g++]&&128<=w[this.g++]&&128<=w[this.g++]&&128<=w[this.g++]&&this.g++,k)))))},qe.prototype.o=function(){var w=this.h[this.g],E=this.h[this.g+1],k=this.h[this.g+2],q=this.h[this.g+3];return this.g+=4,k=(w<<0|E<<8|k<<16|q<<24)>>>0,w=2*(k>>31)+1,E=k>>>23&255,k&=8388607,E==255?k?NaN:1/0*w:E==0?w*Math.pow(2,-149)*k:w*Math.pow(2,E-150)*(k+Math.pow(2,23))};var pn=[];function Nt(){this.g=new Uint8Array(64),this.h=0}Nt.prototype.push=function(w){if(!(this.h+1<this.g.length)){var E=this.g;this.g=new Uint8Array(Math.ceil(1+2*this.g.length)),this.g.set(E)}this.g[this.h++]=w},Nt.prototype.length=function(){return this.h},Nt.prototype.end=function(){var w=this.g,E=this.h;return this.h=0,et(w,0,E)};function St(w,E){for(;127<E;)w.push(E&127|128),E>>>=7;w.push(E)}function Ht(w){var E={},k=E.N===void 0?!1:E.N;this.o={v:E.v===void 0?!1:E.v},this.N=k,E=this.o,pn.length?(k=pn.pop(),E&&(k.v=E.v),w&&Rt(k,w),w=k):w=new qe(w,E),this.g=w,this.m=this.g.g,this.h=this.i=this.l=-1,this.j=!1}Ht.prototype.reset=function(){this.g.reset(),this.h=this.l=-1};function Dt(w){var E=w.g;if((E=E.g==E.j)||(E=w.j)||(E=w.g,E=E.m||0>E.g||E.g>E.j),E)return!1;w.m=w.g.g,E=w.g.i();var k=E&7;return k!=0&&k!=5&&k!=1&&k!=2&&k!=3&&k!=4?(w.j=!0,!1):(w.i=E,w.l=E>>>3,w.h=k,!0)}function or(w){switch(w.h){case 0:if(w.h!=0)or(w);else{for(w=w.g;w.h[w.g]&128;)w.g++;w.g++}break;case 1:w.h!=1?or(w):(w=w.g,w.g+=8);break;case 2:if(w.h!=2)or(w);else{var E=w.g.i();w=w.g,w.g+=E}break;case 5:w.h!=5?or(w):(w=w.g,w.g+=4);break;case 3:E=w.l;do{if(!Dt(w)){w.j=!0;break}if(w.h==4){w.l!=E&&(w.j=!0);break}or(w)}while(!0);break;default:w.j=!0}}function $n(w,E,k){var q=w.g.j,ie=w.g.i(),me=w.g.g+ie;if(w.g.j=me,k(E,w),k=me-w.g.g,k!==0)throw Error("Message parsing ended unexpectedly. Expected to read "+ie+" bytes, instead read "+(ie-k)+" bytes, either the data ended unexpectedly or the message misreported its own length");return w.g.g=me,w.g.j=q,E}function yn(w){return w.g.o()}function sr(w){var E=w.g.i();w=w.g;var k=w.g;w.g+=E,w=w.h;var q;if(J)(q=ae)||(q=ae=new TextDecoder("utf-8",{fatal:!1})),q=q.decode(w.subarray(k,k+E));else{E=k+E;for(var ie=[],me=null,ce,ye,ke;k<E;)ce=w[k++],128>ce?ie.push(ce):224>ce?k>=E?ie.push(65533):(ye=w[k++],194>ce||(ye&192)!==128?(k--,ie.push(65533)):ie.push((ce&31)<<6|ye&63)):240>ce?k>=E-1?ie.push(65533):(ye=w[k++],(ye&192)!==128||ce===224&&160>ye||ce===237&&160<=ye||((q=w[k++])&192)!==128?(k--,ie.push(65533)):ie.push((ce&15)<<12|(ye&63)<<6|q&63)):244>=ce?k>=E-2?ie.push(65533):(ye=w[k++],(ye&192)!==128||(ce<<28)+(ye-144)>>30!==0||((q=w[k++])&192)!==128||((ke=w[k++])&192)!==128?(k--,ie.push(65533)):(ce=(ce&7)<<18|(ye&63)<<12|(q&63)<<6|ke&63,ce-=65536,ie.push((ce>>10&1023)+55296,(ce&1023)+56320))):ie.push(65533),8192<=ie.length&&(me=oe(me,ie),ie.length=0);q=oe(me,ie)}return q}function cs(w,E,k){var q=w.g.i();for(q=w.g.g+q;w.g.g<q;)k.push(E.call(w.g))}function jr(w,E){w.h==2?cs(w,qe.prototype.o,E):E.push(yn(w))}function br(){this.h=[],this.i=0,this.g=new Nt}function ir(w,E){E.length!==0&&(w.h.push(E),w.i+=E.length)}function oo(w){var E=w.i+w.g.length();if(E===0)return new Uint8Array(0);E=new Uint8Array(E);for(var k=w.h,q=k.length,ie=0,me=0;me<q;me++){var ce=k[me];ce.length!==0&&(E.set(ce,ie),ie+=ce.length)}return k=w.g,q=k.h,q!==0&&(E.set(k.g.subarray(0,q),ie),k.h=0),w.h=[E],E}function Hn(w,E,k){if(k!=null){St(w.g,8*E+5),w=w.g;var q=k;q=(k=0>q?1:0)?-q:q,q===0?0<1/q?je=tt=0:(tt=0,je=2147483648):isNaN(q)?(tt=0,je=2147483647):34028234663852886e22<q?(tt=0,je=(k<<31|2139095040)>>>0):11754943508222875e-54>q?(q=Math.round(q/Math.pow(2,-149)),tt=0,je=(k<<31|q)>>>0):(E=Math.floor(Math.log(q)/Math.LN2),q*=Math.pow(2,-E),q=Math.round(8388608*q),16777216<=q&&++E,tt=0,je=(k<<31|E+127<<23|q&8388607)>>>0),k=je,w.push(k>>>0&255),w.push(k>>>8&255),w.push(k>>>16&255),w.push(k>>>24&255)}}var us=typeof Uint8Array=="function";function ga(w,E,k){if(w!=null)return typeof w=="object"?us&&w instanceof Uint8Array?k(w):ya(w,E,k):E(w)}function ya(w,E,k){if(Array.isArray(w)){for(var q=Array(w.length),ie=0;ie<w.length;ie++)q[ie]=ga(w[ie],E,k);return Array.isArray(w)&&w.W&&wr(q),q}q={};for(ie in w)q[ie]=ga(w[ie],E,k);return q}function Vf(w){return typeof w=="number"?isFinite(w)?w:String(w):w}var xa={W:{value:!0,configurable:!0}};function wr(w){return Array.isArray(w)&&!Object.isFrozen(w)&&Object.defineProperties(w,xa),w}var Un;function ar(w,E,k){var q=Un;Un=null,w||(w=q),q=this.constructor.ca,w||(w=q?[q]:[]),this.j=q?0:-1,this.m=this.g=null,this.h=w;e:{if(q=this.h.length,w=q-1,q&&(q=this.h[w],!(q===null||typeof q!="object"||Array.isArray(q)||us&&q instanceof Uint8Array))){this.l=w-this.j,this.i=q;break e}E!==void 0&&-1<E?(this.l=Math.max(E,w+1-this.j),this.i=null):this.l=Number.MAX_VALUE}if(k)for(E=0;E<k.length;E++)w=k[E],w<this.l?(w+=this.j,(q=this.h[w])?wr(q):this.h[w]=Co):(Wu(this),(q=this.i[w])?wr(q):this.i[w]=Co)}var Co=Object.freeze(wr([]));function Wu(w){var E=w.l+w.j;w.h[E]||(w.i=w.h[E]={})}function In(w,E,k){return E===-1?null:k!==void 0&&k||E>=w.l?w.i?w.i[E]:void 0:w.h[E+w.j]}function qu(w,E){var k=k===void 0?!1:k,q=In(w,E,k);return q==null&&(q=Co),q===Co&&(q=wr([]),Mt(w,E,q,k)),q}function Lg(w){var E=qu(w,3);if(w.m||(w.m={}),!w.m[3]){for(var k=0;k<E.length;k++)E[k]=+E[k];w.m[3]=!0}return E}function _i(w,E,k){return w=In(w,E),w??k}function ps(w,E,k){return w=In(w,E),w=w==null?w:+w,w??(k===void 0?0:k)}function Mt(w,E,k,q){q!==void 0&&q||E>=w.l?(Wu(w),w.i[E]=k):w.h[E+w.j]=k}function Ex(w,E,k){if(k===-1)return null;if(w.g||(w.g={}),!w.g[k]){var q=In(w,k,!1);q&&(w.g[k]=new E(q))}return w.g[k]}function Uf(w,E){w.g||(w.g={});var k=w.g[1];if(!k){var q=qu(w,1);k=[];for(var ie=0;ie<q.length;ie++)k[ie]=new E(q[ie]);w.g[1]=k}return k}function Ku(w,E,k){var q=q===void 0?!1:q;w.g||(w.g={});var ie=k&&Ri(k,!1);w.g[E]=k,Mt(w,E,ie,q)}function Xu(w,E,k,q){var ie=Uf(w,k);E=E||new k,w=qu(w,1),q!=null?(ie.splice(q,0,E),w.splice(q,0,Ri(E,!1))):(ie.push(E),w.push(Ri(E,!1)))}ar.prototype.toJSON=function(){var w=Ri(this,!1);return ya(w,Vf,Te)};function Ri(w,E){if(w.g)for(var k in w.g){var q=w.g[k];if(Array.isArray(q))for(var ie=0;ie<q.length;ie++)q[ie]&&Ri(q[ie],E);else q&&Ri(q,E)}return w.h}ar.prototype.toString=function(){return Ri(this,!1).toString()};function Gf(w,E){if(w=w.o){ir(E,E.g.end());for(var k=0;k<w.length;k++)ir(E,w[k])}}function fs(w,E){if(E.h==4)return!1;var k=E.m;return or(E),E.N||(E=et(E.g.h,k,E.g.g),(k=w.o)?k.push(E):w.o=[E]),!0}function Mi(w){ar.call(this,w,-1,dI)}g(Mi,ar),Mi.prototype.getRows=function(){return In(this,1)},Mi.prototype.getCols=function(){return In(this,2)},Mi.prototype.getPackedDataList=function(){return Lg(this)},Mi.prototype.getLayout=function(){return _i(this,4,0)};function Nx(w,E){for(;Dt(E);)switch(E.i){case 8:var k=E.g.i();Mt(w,1,k);break;case 16:k=E.g.i(),Mt(w,2,k);break;case 29:case 26:jr(E,w.getPackedDataList());break;case 32:k=Bt(E.g),Mt(w,4,k);break;default:if(!fs(w,E))return w}return w}var dI=[3];function Ar(w,E){var k=void 0;return new(k||(k=Promise))(function(q,ie){function me(ke){try{ye(E.next(ke))}catch(Pe){ie(Pe)}}function ce(ke){try{ye(E.throw(ke))}catch(Pe){ie(Pe)}}function ye(ke){ke.done?q(ke.value):new k(function(Pe){Pe(ke.value)}).then(me,ce)}ye((E=E.apply(w,void 0)).next())})}function Oi(w){ar.call(this,w)}g(Oi,ar);function Dx(w,E){for(;Dt(E);)switch(E.i){case 8:var k=E.g.i();Mt(w,1,k);break;case 21:k=yn(E),Mt(w,2,k);break;case 26:k=sr(E),Mt(w,3,k);break;case 34:k=sr(E),Mt(w,4,k);break;default:if(!fs(w,E))return w}return w}function jf(w){ar.call(this,w,-1,kx)}g(jf,ar),jf.prototype.addClassification=function(w,E){return Xu(this,w,Oi,E),this};var kx=[1];function Jl(w){ar.call(this,w)}g(Jl,ar);function hI(w,E){for(;Dt(E);)switch(E.i){case 13:var k=yn(E);Mt(w,1,k);break;case 21:k=yn(E),Mt(w,2,k);break;case 29:k=yn(E),Mt(w,3,k);break;case 37:k=yn(E),Mt(w,4,k);break;case 45:k=yn(E),Mt(w,5,k);break;default:if(!fs(w,E))return w}return w}function Ax(w){ar.call(this,w,-1,Rx)}g(Ax,ar);function _x(w){e:{var E=new Ax;for(w=new Ht(w);Dt(w);)switch(w.i){case 10:var k=$n(w,new Jl,hI);Xu(E,k,Jl,void 0);break;default:if(!fs(E,w))break e}}return E}var Rx=[1];function Hf(w){ar.call(this,w)}g(Hf,ar);function va(w){ar.call(this,w,-1,gI)}g(va,ar),va.prototype.getVertexType=function(){return _i(this,1,0)},va.prototype.getPrimitiveType=function(){return _i(this,2,0)},va.prototype.getVertexBufferList=function(){return Lg(this)},va.prototype.getIndexBufferList=function(){return qu(this,4)};function mI(w,E){for(;Dt(E);)switch(E.i){case 8:var k=Bt(E.g);Mt(w,1,k);break;case 16:k=Bt(E.g),Mt(w,2,k);break;case 29:case 26:jr(E,w.getVertexBufferList());break;case 32:case 34:k=E;var q=w.getIndexBufferList();k.h==2?cs(k,qe.prototype.i,q):q.push(k.g.i());break;default:if(!fs(w,E))return w}return w}var gI=[3,4];function Wf(w){ar.call(this,w)}g(Wf,ar),Wf.prototype.getMesh=function(){return Ex(this,va,1)},Wf.prototype.getPoseTransformMatrix=function(){return Ex(this,Mi,2)};function Mx(w){e:{var E=new Wf;for(w=new Ht(w);Dt(w);)switch(w.i){case 10:var k=$n(w,new va,mI);Ku(E,1,k);break;case 18:k=$n(w,new Mi,Nx),Ku(E,2,k);break;default:if(!fs(E,w))break e}}return E}function Pg(w,E,k){if(k=w.createShader(k===0?w.VERTEX_SHADER:w.FRAGMENT_SHADER),w.shaderSource(k,E),w.compileShader(k),!w.getShaderParameter(k,w.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+w.getShaderInfoLog(k));return k}function Bg(w){return Uf(w,Oi).map(function(E){return{index:_i(E,1,0),Y:ps(E,2),label:In(E,3)!=null?_i(E,3,""):void 0,displayName:In(E,4)!=null?_i(E,4,""):void 0}})}function zg(w){return{x:ps(w,1),y:ps(w,2),z:ps(w,3),visibility:In(w,4)!=null?ps(w,4):void 0}}function Yu(w,E){this.h=w,this.g=E,this.l=0}function ec(w,E,k){return ds(w,E),typeof w.g.canvas.transferToImageBitmap=="function"?Promise.resolve(w.g.canvas.transferToImageBitmap()):k?Promise.resolve(w.g.canvas):typeof createImageBitmap=="function"?createImageBitmap(w.g.canvas):(w.i===void 0&&(w.i=document.createElement("canvas")),new Promise(function(q){w.i.height=w.g.canvas.height,w.i.width=w.g.canvas.width,w.i.getContext("2d",{}).drawImage(w.g.canvas,0,0,w.g.canvas.width,w.g.canvas.height),q(w.i)}))}function ds(w,E){var k=w.g;if(w.m===void 0){var q=Pg(k,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),ie=Pg(k,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),me=k.createProgram();if(k.attachShader(me,q),k.attachShader(me,ie),k.linkProgram(me),!k.getProgramParameter(me,k.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+k.getProgramInfoLog(me));q=w.m=me,k.useProgram(q),ie=k.getUniformLocation(q,"sampler0"),w.j={I:k.getAttribLocation(q,"aVertex"),H:k.getAttribLocation(q,"aTex"),da:ie},w.s=k.createBuffer(),k.bindBuffer(k.ARRAY_BUFFER,w.s),k.enableVertexAttribArray(w.j.I),k.vertexAttribPointer(w.j.I,2,k.FLOAT,!1,0,0),k.bufferData(k.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),k.STATIC_DRAW),k.bindBuffer(k.ARRAY_BUFFER,null),w.o=k.createBuffer(),k.bindBuffer(k.ARRAY_BUFFER,w.o),k.enableVertexAttribArray(w.j.H),k.vertexAttribPointer(w.j.H,2,k.FLOAT,!1,0,0),k.bufferData(k.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),k.STATIC_DRAW),k.bindBuffer(k.ARRAY_BUFFER,null),k.uniform1i(ie,0)}q=w.j,k.useProgram(w.m),k.canvas.width=E.width,k.canvas.height=E.height,k.viewport(0,0,E.width,E.height),k.activeTexture(k.TEXTURE0),w.h.bindTexture2d(E.glName),k.enableVertexAttribArray(q.I),k.bindBuffer(k.ARRAY_BUFFER,w.s),k.vertexAttribPointer(q.I,2,k.FLOAT,!1,0,0),k.enableVertexAttribArray(q.H),k.bindBuffer(k.ARRAY_BUFFER,w.o),k.vertexAttribPointer(q.H,2,k.FLOAT,!1,0,0),k.bindFramebuffer(k.DRAW_FRAMEBUFFER?k.DRAW_FRAMEBUFFER:k.FRAMEBUFFER,null),k.clearColor(0,0,0,0),k.clear(k.COLOR_BUFFER_BIT),k.colorMask(!0,!0,!0,!0),k.drawArrays(k.TRIANGLE_FAN,0,4),k.disableVertexAttribArray(q.I),k.disableVertexAttribArray(q.H),k.bindBuffer(k.ARRAY_BUFFER,null),w.h.bindTexture2d(0)}function yI(w){this.g=w}var xI=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function Ox(w,E){return E+w}function Vg(w,E){window[w]=E}function Vo(w){var E=document.createElement("script");return E.setAttribute("src",w),E.setAttribute("crossorigin","anonymous"),new Promise(function(k){E.addEventListener("load",function(){k()},!1),E.addEventListener("error",function(){k()},!1),document.body.appendChild(E)})}function Fx(){return Ar(this,function w(){return V(w,function(E){switch(E.g){case 1:return E.m=2,C(E,WebAssembly.instantiate(xI),4);case 4:E.g=3,E.m=0;break;case 2:return E.m=0,E.j=null,E.return(!1);case 3:return E.return(!0)}})})}function ba(w){if(this.g=w,this.listeners={},this.j={},this.F={},this.m={},this.s={},this.G=this.o=this.R=!0,this.C=Promise.resolve(),this.P="",this.B={},this.locateFile=w&&w.locateFile||Ox,typeof window=="object")var E=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")E=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.S=E,w.options){E=a(Object.keys(w.options));for(var k=E.next();!k.done;k=E.next()){k=k.value;var q=w.options[k].default;q!==void 0&&(this.j[k]=typeof q=="function"?q():q)}}}t=ba.prototype,t.close=function(){return this.i&&this.i.delete(),Promise.resolve()};function $x(w,E){return w.g.files===void 0?[]:typeof w.g.files=="function"?w.g.files(E):w.g.files}function Ug(w){return Ar(w,function E(){var k=this,q,ie,me,ce,ye,ke,Pe,dt,zt,kt,gt;return V(E,function(Xe){switch(Xe.g){case 1:return q=k,k.R?(ie=$x(k,k.j),C(Xe,Fx(),2)):Xe.return();case 2:if(me=Xe.h,typeof window=="object")return Vg("createMediapipeSolutionsWasm",{locateFile:k.locateFile}),Vg("createMediapipeSolutionsPackedAssets",{locateFile:k.locateFile}),ke=ie.filter(function(v){return v.data!==void 0}),Pe=ie.filter(function(v){return v.data===void 0}),dt=Promise.all(ke.map(function(v){var N=tc(q,v.url);if(v.path!==void 0){var M=v.path;N=N.then(function(P){return q.overrideFile(M,P),Promise.resolve(P)})}return N})),zt=Promise.all(Pe.map(function(v){return v.simd===void 0||v.simd&&me||!v.simd&&!me?Vo(q.locateFile(v.url,q.S)):Promise.resolve()})).then(function(){return Ar(q,function v(){var N,M,P=this;return V(v,function(W){if(W.g==1)return N=window.createMediapipeSolutionsWasm,M=window.createMediapipeSolutionsPackedAssets,C(W,N(M),2);P.h=W.h,W.g=0})})}),kt=(function(){return Ar(q,function v(){var N=this;return V(v,function(M){return N.g.graph&&N.g.graph.url?M=C(M,tc(N,N.g.graph.url),0):(M.g=0,M=void 0),M})})})(),C(Xe,Promise.all([zt,dt,kt]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return ce=ie.filter(function(v){return v.simd===void 0||v.simd&&me||!v.simd&&!me}).map(function(v){return q.locateFile(v.url,q.S)}),importScripts.apply(null,l(ce)),C(Xe,createMediapipeSolutionsWasm(Module),6);case 6:k.h=Xe.h,k.l=new OffscreenCanvas(1,1),k.h.canvas=k.l,ye=k.h.GL.createContext(k.l,{antialias:!1,alpha:!1,ba:typeof WebGL2RenderingContext<"u"?2:1}),k.h.GL.makeContextCurrent(ye),Xe.g=4;break;case 7:if(k.l=document.createElement("canvas"),gt=k.l.getContext("webgl2",{}),!gt&&(gt=k.l.getContext("webgl",{}),!gt))return alert("Failed to create WebGL canvas context when passing video frame."),Xe.return();k.D=gt,k.h.canvas=k.l,k.h.createContext(k.l,!0,!0,{});case 4:k.i=new k.h.SolutionWasm,k.R=!1,Xe.g=0}})})}function vI(w){return Ar(w,function E(){var k=this,q,ie,me,ce,ye,ke,Pe,dt;return V(E,function(zt){if(zt.g==1){if(k.g.graph&&k.g.graph.url&&k.P===k.g.graph.url)return zt.return();if(k.o=!0,!k.g.graph||!k.g.graph.url){zt.g=2;return}return k.P=k.g.graph.url,C(zt,tc(k,k.g.graph.url),3)}for(zt.g!=2&&(q=zt.h,k.i.loadGraph(q)),ie=a(Object.keys(k.B)),me=ie.next();!me.done;me=ie.next())ce=me.value,k.i.overrideFile(ce,k.B[ce]);if(k.B={},k.g.listeners)for(ye=a(k.g.listeners),ke=ye.next();!ke.done;ke=ye.next())Pe=ke.value,wI(k,Pe);dt=k.j,k.j={},k.setOptions(dt),zt.g=0})})}t.reset=function(){return Ar(this,function w(){var E=this;return V(w,function(k){E.i&&(E.i.reset(),E.m={},E.s={}),k.g=0})})},t.setOptions=function(w,E){var k=this;if(E=E||this.g.options){for(var q=[],ie=[],me={},ce=a(Object.keys(w)),ye=ce.next();!ye.done;me={K:me.K,L:me.L},ye=ce.next()){var ke=ye.value;ke in this.j&&this.j[ke]===w[ke]||(this.j[ke]=w[ke],ye=E[ke],ye!==void 0&&(ye.onChange&&(me.K=ye.onChange,me.L=w[ke],q.push((function(Pe){return function(){return Ar(k,function dt(){var zt,kt=this;return V(dt,function(gt){if(gt.g==1)return C(gt,Pe.K(Pe.L),2);zt=gt.h,zt===!0&&(kt.o=!0),gt.g=0})})}})(me))),ye.graphOptionXref&&(ke={valueNumber:ye.type===1?w[ke]:0,valueBoolean:ye.type===0?w[ke]:!1,valueString:ye.type===2?w[ke]:""},ye=Object.assign(Object.assign(Object.assign({},{calculatorName:"",calculatorIndex:0}),ye.graphOptionXref),ke),ie.push(ye))))}(q.length!==0||ie.length!==0)&&(this.o=!0,this.A=(this.A===void 0?[]:this.A).concat(ie),this.u=(this.u===void 0?[]:this.u).concat(q))}};function bI(w){return Ar(w,function E(){var k=this,q,ie,me,ce,ye,ke,Pe;return V(E,function(dt){switch(dt.g){case 1:if(!k.o)return dt.return();if(!k.u){dt.g=2;break}q=a(k.u),ie=q.next();case 3:if(ie.done){dt.g=5;break}return me=ie.value,C(dt,me(),4);case 4:ie=q.next(),dt.g=3;break;case 5:k.u=void 0;case 2:if(k.A){for(ce=new k.h.GraphOptionChangeRequestList,ye=a(k.A),ke=ye.next();!ke.done;ke=ye.next())Pe=ke.value,ce.push_back(Pe);k.i.changeOptions(ce),ce.delete(),k.A=void 0}k.o=!1,dt.g=0}})})}t.initialize=function(){return Ar(this,function w(){var E=this;return V(w,function(k){return k.g==1?C(k,Ug(E),2):k.g!=3?C(k,vI(E),3):C(k,bI(E),0)})})};function tc(w,E){return Ar(w,function k(){var q=this,ie,me;return V(k,function(ce){return E in q.F?ce.return(q.F[E]):(ie=q.locateFile(E,""),me=fetch(ie).then(function(ye){return ye.arrayBuffer()}),q.F[E]=me,ce.return(me))})})}t.overrideFile=function(w,E){this.i?this.i.overrideFile(w,E):this.B[w]=E},t.clearOverriddenFiles=function(){this.B={},this.i&&this.i.clearOverriddenFiles()},t.send=function(w,E){return Ar(this,function k(){var q=this,ie,me,ce,ye,ke,Pe,dt,zt,kt;return V(k,function(gt){switch(gt.g){case 1:return q.g.inputs?(ie=1e3*(E??performance.now()),C(gt,q.C,2)):gt.return();case 2:return C(gt,q.initialize(),3);case 3:for(me=new q.h.PacketDataList,ce=a(Object.keys(w)),ye=ce.next();!ye.done;ye=ce.next())if(ke=ye.value,Pe=q.g.inputs[ke]){e:{var Xe=q,v=w[ke];switch(Pe.type){case"video":var N=Xe.m[Pe.stream];if(N||(N=new Yu(Xe.h,Xe.D),Xe.m[Pe.stream]=N),Xe=N,Xe.l===0&&(Xe.l=Xe.h.createTexture()),typeof HTMLVideoElement<"u"&&v instanceof HTMLVideoElement){var M=v.videoWidth;N=v.videoHeight}else typeof HTMLImageElement<"u"&&v instanceof HTMLImageElement?(M=v.naturalWidth,N=v.naturalHeight):(M=v.width,N=v.height);N={glName:Xe.l,width:M,height:N},M=Xe.g,M.canvas.width=N.width,M.canvas.height=N.height,M.activeTexture(M.TEXTURE0),Xe.h.bindTexture2d(Xe.l),M.texImage2D(M.TEXTURE_2D,0,M.RGBA,M.RGBA,M.UNSIGNED_BYTE,v),Xe.h.bindTexture2d(0),Xe=N;break e;case"detections":for(N=Xe.m[Pe.stream],N||(N=new yI(Xe.h),Xe.m[Pe.stream]=N),Xe=N,Xe.data||(Xe.data=new Xe.g.DetectionListData),Xe.data.reset(v.length),N=0;N<v.length;++N){M=v[N];var P=Xe.data,W=P.setBoundingBox,H=N,K=M.T,ne=new Hf;Mt(ne,1,K.Z),Mt(ne,2,K.$),Mt(ne,3,K.height),Mt(ne,4,K.width),Mt(ne,5,K.rotation),Mt(ne,6,K.X);var ue=K=new br;Hn(ue,1,In(ne,1)),Hn(ue,2,In(ne,2)),Hn(ue,3,In(ne,3)),Hn(ue,4,In(ne,4)),Hn(ue,5,In(ne,5));var ge=In(ne,6);if(ge!=null&&ge!=null){St(ue.g,48);var Ce=ue.g,_e=ge;ge=0>_e,_e=Math.abs(_e);var Me=_e>>>0;for(_e=Math.floor((_e-Me)/4294967296),_e>>>=0,ge&&(_e=~_e>>>0,Me=(~Me>>>0)+1,4294967295<Me&&(Me=0,_e++,4294967295<_e&&(_e=0))),je=Me,tt=_e,ge=je,Me=tt;0<Me||127<ge;)Ce.push(ge&127|128),ge=(ge>>>7|Me<<25)>>>0,Me>>>=7;Ce.push(ge)}if(Gf(ne,ue),K=oo(K),W.call(P,H,K),M.O)for(P=0;P<M.O.length;++P)ne=M.O[P],ue=!!ne.visibility,W=Xe.data,H=W.addNormalizedLandmark,K=N,ne=Object.assign(Object.assign({},ne),{visibility:ue?ne.visibility:0}),ue=new Jl,Mt(ue,1,ne.x),Mt(ue,2,ne.y),Mt(ue,3,ne.z),ne.visibility&&Mt(ue,4,ne.visibility),Ce=ne=new br,Hn(Ce,1,In(ue,1)),Hn(Ce,2,In(ue,2)),Hn(Ce,3,In(ue,3)),Hn(Ce,4,In(ue,4)),Hn(Ce,5,In(ue,5)),Gf(ue,Ce),ne=oo(ne),H.call(W,K,ne);if(M.M)for(P=0;P<M.M.length;++P){if(W=Xe.data,H=W.addClassification,K=N,ne=M.M[P],ue=new Oi,Mt(ue,2,ne.Y),ne.index&&Mt(ue,1,ne.index),ne.label&&Mt(ue,3,ne.label),ne.displayName&&Mt(ue,4,ne.displayName),Ce=ne=new br,Me=In(ue,1),Me!=null&&Me!=null)if(St(Ce.g,8),ge=Ce.g,0<=Me)St(ge,Me);else{for(_e=0;9>_e;_e++)ge.push(Me&127|128),Me>>=7;ge.push(1)}Hn(Ce,2,In(ue,2)),ge=In(ue,3),ge!=null&&(ge=pe(ge),St(Ce.g,26),St(Ce.g,ge.length),ir(Ce,Ce.g.end()),ir(Ce,ge)),ge=In(ue,4),ge!=null&&(ge=pe(ge),St(Ce.g,34),St(Ce.g,ge.length),ir(Ce,Ce.g.end()),ir(Ce,ge)),Gf(ue,Ce),ne=oo(ne),H.call(W,K,ne)}}Xe=Xe.data;break e;default:Xe={}}}switch(dt=Xe,zt=Pe.stream,Pe.type){case"video":me.pushTexture2d(Object.assign(Object.assign({},dt),{stream:zt,timestamp:ie}));break;case"detections":kt=dt,kt.stream=zt,kt.timestamp=ie,me.pushDetectionList(kt);break;default:throw Error("Unknown input config type: '"+Pe.type+"'")}}return q.i.send(me),C(gt,q.C,4);case 4:me.delete(),gt.g=0}})})};function Lx(w,E,k){return Ar(w,function q(){var ie,me,ce,ye,ke,Pe,dt=this,zt,kt,gt,Xe,v,N,M,P;return V(q,function(W){switch(W.g){case 1:if(!k)return W.return(E);for(ie={},me=0,ce=a(Object.keys(k)),ye=ce.next();!ye.done;ye=ce.next())ke=ye.value,Pe=k[ke],typeof Pe!="string"&&Pe.type==="texture"&&E[Pe.stream]!==void 0&&++me;1<me&&(dt.G=!1),zt=a(Object.keys(k)),ye=zt.next();case 2:if(ye.done){W.g=4;break}if(kt=ye.value,gt=k[kt],typeof gt=="string")return M=ie,P=kt,C(W,Px(dt,kt,E[gt]),14);if(Xe=E[gt.stream],gt.type==="detection_list"){if(Xe){for(var H=Xe.getRectList(),K=Xe.getLandmarksList(),ne=Xe.getClassificationsList(),ue=[],ge=0;ge<H.size();++ge){var Ce=H.get(ge);e:{var _e=new Hf;for(Ce=new Ht(Ce);Dt(Ce);)switch(Ce.i){case 13:var Me=yn(Ce);Mt(_e,1,Me);break;case 21:Me=yn(Ce),Mt(_e,2,Me);break;case 29:Me=yn(Ce),Mt(_e,3,Me);break;case 37:Me=yn(Ce),Mt(_e,4,Me);break;case 45:Me=yn(Ce),Mt(_e,5,Me);break;case 48:Me=Bt(Ce.g),Mt(_e,6,Me);break;default:if(!fs(_e,Ce))break e}}_e={Z:ps(_e,1),$:ps(_e,2),height:ps(_e,3),width:ps(_e,4),rotation:ps(_e,5,0),X:_i(_e,6,0)},Ce=Uf(_x(K.get(ge)),Jl).map(zg);var Le=ne.get(ge);e:for(Me=new jf,Le=new Ht(Le);Dt(Le);)switch(Le.i){case 10:Me.addClassification($n(Le,new Oi,Dx));break;default:if(!fs(Me,Le))break e}_e={T:_e,O:Ce,M:Bg(Me)},ue.push(_e)}H=ue}else H=[];ie[kt]=H,W.g=7;break}if(gt.type==="proto_list"){if(Xe){for(H=Array(Xe.size()),K=0;K<Xe.size();K++)H[K]=Xe.get(K);Xe.delete()}else H=[];ie[kt]=H,W.g=7;break}if(Xe===void 0){W.g=3;break}if(gt.type==="float_list"){ie[kt]=Xe,W.g=7;break}if(gt.type==="proto"){ie[kt]=Xe,W.g=7;break}if(gt.type!=="texture")throw Error("Unknown output config type: '"+gt.type+"'");return v=dt.s[kt],v||(v=new Yu(dt.h,dt.D),dt.s[kt]=v),C(W,ec(v,Xe,dt.G),13);case 13:N=W.h,ie[kt]=N;case 7:gt.transform&&ie[kt]&&(ie[kt]=gt.transform(ie[kt])),W.g=3;break;case 14:M[P]=W.h;case 3:ye=zt.next(),W.g=2;break;case 4:return W.return(ie)}})})}function Px(w,E,k){return Ar(w,function q(){var ie=this,me;return V(q,function(ce){return typeof k=="number"||k instanceof Uint8Array||k instanceof ie.h.Uint8BlobList?ce.return(k):k instanceof ie.h.Texture2dDataOut?(me=ie.s[E],me||(me=new Yu(ie.h,ie.D),ie.s[E]=me),ce.return(ec(me,k,ie.G))):ce.return(void 0)})})}function wI(w,E){for(var k=E.name||"$",q=[].concat(l(E.wants)),ie=new w.h.StringList,me=a(E.wants),ce=me.next();!ce.done;ce=me.next())ie.push_back(ce.value);me=w.h.PacketListener.implement({onResults:function(ye){for(var ke={},Pe=0;Pe<E.wants.length;++Pe)ke[q[Pe]]=ye.get(Pe);var dt=w.listeners[k];dt&&(w.C=Lx(w,ke,E.outs).then(function(zt){zt=dt(zt);for(var kt=0;kt<E.wants.length;++kt){var gt=ke[q[kt]];typeof gt=="object"&&gt.hasOwnProperty&&gt.hasOwnProperty("delete")&&gt.delete()}zt&&(w.C=zt)}))}}),w.i.attachMultiListener(ie,me),ie.delete()}t.onResults=function(w,E){this.listeners[E||"$"]=w},Q("Solution",ba),Q("OptionType",{BOOL:0,NUMBER:1,aa:2,0:"BOOL",1:"NUMBER",2:"STRING"});function CI(w){w=Mx(w);var E=w.getMesh();if(!E)return w;var k=new Float32Array(E.getVertexBufferList());E.getVertexBufferList=function(){return k};var q=new Uint32Array(E.getIndexBufferList());return E.getIndexBufferList=function(){return q},w}var Gg={files:[{url:"face_mesh_solution_packed_assets_loader.js"},{simd:!0,url:"face_mesh_solution_simd_wasm_bin.js"},{simd:!1,url:"face_mesh_solution_wasm_bin.js"}],graph:{url:"face_mesh.binarypb"},listeners:[{wants:["multi_face_geometry","image_transformed","multi_face_landmarks"],outs:{image:"image_transformed",multiFaceGeometry:{type:"proto_list",stream:"multi_face_geometry",transform:function(w){return w.map(CI)}},multiFaceLandmarks:{type:"proto_list",stream:"multi_face_landmarks",transform:function(w){return w.map(function(E){return Uf(_x(E),Jl).map(zg)})}}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},enableFaceGeometry:{type:0,graphOptionXref:{calculatorName:"EnableFaceGeometryConstant",calculatorType:"ConstantSidePacketCalculator",fieldName:"bool_value"}},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},maxNumFaces:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorNumFaces",fieldName:"int_value"}},refineLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorRefineLandmarks",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"facelandmarkfrontgpu__facedetectionshortrangegpu__facedetectionshortrangecommon__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"facelandmarkfrontgpu__facelandmarkgpu__ThresholdingCalculator",fieldName:"threshold"}},cameraNear:{type:1,graphOptionXref:{calculatorType:"FaceGeometryEnvGeneratorCalculator",fieldName:"near"}},cameraFar:{type:1,graphOptionXref:{calculatorType:"FaceGeometryEnvGeneratorCalculator",fieldName:"far"}},cameraVerticalFovDegrees:{type:1,graphOptionXref:{calculatorType:"FaceGeometryEnvGeneratorCalculator",fieldName:"vertical_fov_degrees"}}}},jg=[[61,146],[146,91],[91,181],[181,84],[84,17],[17,314],[314,405],[405,321],[321,375],[375,291],[61,185],[185,40],[40,39],[39,37],[37,0],[0,267],[267,269],[269,270],[270,409],[409,291],[78,95],[95,88],[88,178],[178,87],[87,14],[14,317],[317,402],[402,318],[318,324],[324,308],[78,191],[191,80],[80,81],[81,82],[82,13],[13,312],[312,311],[311,310],[310,415],[415,308]],Hg=[[263,249],[249,390],[390,373],[373,374],[374,380],[380,381],[381,382],[382,362],[263,466],[466,388],[388,387],[387,386],[386,385],[385,384],[384,398],[398,362]],Wg=[[276,283],[283,282],[282,295],[295,285],[300,293],[293,334],[334,296],[296,336]],qg=[[33,7],[7,163],[163,144],[144,145],[145,153],[153,154],[154,155],[155,133],[33,246],[246,161],[161,160],[160,159],[159,158],[158,157],[157,173],[173,133]],Kg=[[46,53],[53,52],[52,65],[65,55],[70,63],[63,105],[105,66],[66,107]],Xg=[[10,338],[338,297],[297,332],[332,284],[284,251],[251,389],[389,356],[356,454],[454,323],[323,361],[361,288],[288,397],[397,365],[365,379],[379,378],[378,400],[400,377],[377,152],[152,148],[148,176],[176,149],[149,150],[150,136],[136,172],[172,58],[58,132],[132,93],[93,234],[234,127],[127,162],[162,21],[21,54],[54,103],[103,67],[67,109],[109,10]],Bx=[].concat(l(jg),l(Hg),l(Wg),l(qg),l(Kg),l(Xg));function zx(w){w=w||{},w=Object.assign(Object.assign({},Gg),w),this.g=new ba(w)}t=zx.prototype,t.close=function(){return this.g.close(),Promise.resolve()},t.onResults=function(w){this.g.onResults(w)},t.initialize=function(){return Ar(this,function w(){var E=this;return V(w,function(k){return C(k,E.g.initialize(),0)})})},t.reset=function(){this.g.reset()},t.send=function(w){return Ar(this,function E(){var k=this;return V(E,function(q){return C(q,k.g.send(w),0)})})},t.setOptions=function(w){this.g.setOptions(w)},Q("FACE_GEOMETRY",{Layout:{COLUMN_MAJOR:0,ROW_MAJOR:1,0:"COLUMN_MAJOR",1:"ROW_MAJOR"},PrimitiveType:{TRIANGLE:0,0:"TRIANGLE"},VertexType:{VERTEX_PT:0,0:"VERTEX_PT"},DEFAULT_CAMERA_PARAMS:{verticalFovDegrees:63,near:1,far:1e4}}),Q("FaceMesh",zx),Q("FACEMESH_LIPS",jg),Q("FACEMESH_LEFT_EYE",Hg),Q("FACEMESH_LEFT_EYEBROW",Wg),Q("FACEMESH_LEFT_IRIS",[[474,475],[475,476],[476,477],[477,474]]),Q("FACEMESH_RIGHT_EYE",qg),Q("FACEMESH_RIGHT_EYEBROW",Kg),Q("FACEMESH_RIGHT_IRIS",[[469,470],[470,471],[471,472],[472,469]]),Q("FACEMESH_FACE_OVAL",Xg),Q("FACEMESH_CONTOURS",Bx),Q("FACEMESH_TESSELATION",[[127,34],[34,139],[139,127],[11,0],[0,37],[37,11],[232,231],[231,120],[120,232],[72,37],[37,39],[39,72],[128,121],[121,47],[47,128],[232,121],[121,128],[128,232],[104,69],[69,67],[67,104],[175,171],[171,148],[148,175],[118,50],[50,101],[101,118],[73,39],[39,40],[40,73],[9,151],[151,108],[108,9],[48,115],[115,131],[131,48],[194,204],[204,211],[211,194],[74,40],[40,185],[185,74],[80,42],[42,183],[183,80],[40,92],[92,186],[186,40],[230,229],[229,118],[118,230],[202,212],[212,214],[214,202],[83,18],[18,17],[17,83],[76,61],[61,146],[146,76],[160,29],[29,30],[30,160],[56,157],[157,173],[173,56],[106,204],[204,194],[194,106],[135,214],[214,192],[192,135],[203,165],[165,98],[98,203],[21,71],[71,68],[68,21],[51,45],[45,4],[4,51],[144,24],[24,23],[23,144],[77,146],[146,91],[91,77],[205,50],[50,187],[187,205],[201,200],[200,18],[18,201],[91,106],[106,182],[182,91],[90,91],[91,181],[181,90],[85,84],[84,17],[17,85],[206,203],[203,36],[36,206],[148,171],[171,140],[140,148],[92,40],[40,39],[39,92],[193,189],[189,244],[244,193],[159,158],[158,28],[28,159],[247,246],[246,161],[161,247],[236,3],[3,196],[196,236],[54,68],[68,104],[104,54],[193,168],[168,8],[8,193],[117,228],[228,31],[31,117],[189,193],[193,55],[55,189],[98,97],[97,99],[99,98],[126,47],[47,100],[100,126],[166,79],[79,218],[218,166],[155,154],[154,26],[26,155],[209,49],[49,131],[131,209],[135,136],[136,150],[150,135],[47,126],[126,217],[217,47],[223,52],[52,53],[53,223],[45,51],[51,134],[134,45],[211,170],[170,140],[140,211],[67,69],[69,108],[108,67],[43,106],[106,91],[91,43],[230,119],[119,120],[120,230],[226,130],[130,247],[247,226],[63,53],[53,52],[52,63],[238,20],[20,242],[242,238],[46,70],[70,156],[156,46],[78,62],[62,96],[96,78],[46,53],[53,63],[63,46],[143,34],[34,227],[227,143],[123,117],[117,111],[111,123],[44,125],[125,19],[19,44],[236,134],[134,51],[51,236],[216,206],[206,205],[205,216],[154,153],[153,22],[22,154],[39,37],[37,167],[167,39],[200,201],[201,208],[208,200],[36,142],[142,100],[100,36],[57,212],[212,202],[202,57],[20,60],[60,99],[99,20],[28,158],[158,157],[157,28],[35,226],[226,113],[113,35],[160,159],[159,27],[27,160],[204,202],[202,210],[210,204],[113,225],[225,46],[46,113],[43,202],[202,204],[204,43],[62,76],[76,77],[77,62],[137,123],[123,116],[116,137],[41,38],[38,72],[72,41],[203,129],[129,142],[142,203],[64,98],[98,240],[240,64],[49,102],[102,64],[64,49],[41,73],[73,74],[74,41],[212,216],[216,207],[207,212],[42,74],[74,184],[184,42],[169,170],[170,211],[211,169],[170,149],[149,176],[176,170],[105,66],[66,69],[69,105],[122,6],[6,168],[168,122],[123,147],[147,187],[187,123],[96,77],[77,90],[90,96],[65,55],[55,107],[107,65],[89,90],[90,180],[180,89],[101,100],[100,120],[120,101],[63,105],[105,104],[104,63],[93,137],[137,227],[227,93],[15,86],[86,85],[85,15],[129,102],[102,49],[49,129],[14,87],[87,86],[86,14],[55,8],[8,9],[9,55],[100,47],[47,121],[121,100],[145,23],[23,22],[22,145],[88,89],[89,179],[179,88],[6,122],[122,196],[196,6],[88,95],[95,96],[96,88],[138,172],[172,136],[136,138],[215,58],[58,172],[172,215],[115,48],[48,219],[219,115],[42,80],[80,81],[81,42],[195,3],[3,51],[51,195],[43,146],[146,61],[61,43],[171,175],[175,199],[199,171],[81,82],[82,38],[38,81],[53,46],[46,225],[225,53],[144,163],[163,110],[110,144],[52,65],[65,66],[66,52],[229,228],[228,117],[117,229],[34,127],[127,234],[234,34],[107,108],[108,69],[69,107],[109,108],[108,151],[151,109],[48,64],[64,235],[235,48],[62,78],[78,191],[191,62],[129,209],[209,126],[126,129],[111,35],[35,143],[143,111],[117,123],[123,50],[50,117],[222,65],[65,52],[52,222],[19,125],[125,141],[141,19],[221,55],[55,65],[65,221],[3,195],[195,197],[197,3],[25,7],[7,33],[33,25],[220,237],[237,44],[44,220],[70,71],[71,139],[139,70],[122,193],[193,245],[245,122],[247,130],[130,33],[33,247],[71,21],[21,162],[162,71],[170,169],[169,150],[150,170],[188,174],[174,196],[196,188],[216,186],[186,92],[92,216],[2,97],[97,167],[167,2],[141,125],[125,241],[241,141],[164,167],[167,37],[37,164],[72,38],[38,12],[12,72],[38,82],[82,13],[13,38],[63,68],[68,71],[71,63],[226,35],[35,111],[111,226],[101,50],[50,205],[205,101],[206,92],[92,165],[165,206],[209,198],[198,217],[217,209],[165,167],[167,97],[97,165],[220,115],[115,218],[218,220],[133,112],[112,243],[243,133],[239,238],[238,241],[241,239],[214,135],[135,169],[169,214],[190,173],[173,133],[133,190],[171,208],[208,32],[32,171],[125,44],[44,237],[237,125],[86,87],[87,178],[178,86],[85,86],[86,179],[179,85],[84,85],[85,180],[180,84],[83,84],[84,181],[181,83],[201,83],[83,182],[182,201],[137,93],[93,132],[132,137],[76,62],[62,183],[183,76],[61,76],[76,184],[184,61],[57,61],[61,185],[185,57],[212,57],[57,186],[186,212],[214,207],[207,187],[187,214],[34,143],[143,156],[156,34],[79,239],[239,237],[237,79],[123,137],[137,177],[177,123],[44,1],[1,4],[4,44],[201,194],[194,32],[32,201],[64,102],[102,129],[129,64],[213,215],[215,138],[138,213],[59,166],[166,219],[219,59],[242,99],[99,97],[97,242],[2,94],[94,141],[141,2],[75,59],[59,235],[235,75],[24,110],[110,228],[228,24],[25,130],[130,226],[226,25],[23,24],[24,229],[229,23],[22,23],[23,230],[230,22],[26,22],[22,231],[231,26],[112,26],[26,232],[232,112],[189,190],[190,243],[243,189],[221,56],[56,190],[190,221],[28,56],[56,221],[221,28],[27,28],[28,222],[222,27],[29,27],[27,223],[223,29],[30,29],[29,224],[224,30],[247,30],[30,225],[225,247],[238,79],[79,20],[20,238],[166,59],[59,75],[75,166],[60,75],[75,240],[240,60],[147,177],[177,215],[215,147],[20,79],[79,166],[166,20],[187,147],[147,213],[213,187],[112,233],[233,244],[244,112],[233,128],[128,245],[245,233],[128,114],[114,188],[188,128],[114,217],[217,174],[174,114],[131,115],[115,220],[220,131],[217,198],[198,236],[236,217],[198,131],[131,134],[134,198],[177,132],[132,58],[58,177],[143,35],[35,124],[124,143],[110,163],[163,7],[7,110],[228,110],[110,25],[25,228],[356,389],[389,368],[368,356],[11,302],[302,267],[267,11],[452,350],[350,349],[349,452],[302,303],[303,269],[269,302],[357,343],[343,277],[277,357],[452,453],[453,357],[357,452],[333,332],[332,297],[297,333],[175,152],[152,377],[377,175],[347,348],[348,330],[330,347],[303,304],[304,270],[270,303],[9,336],[336,337],[337,9],[278,279],[279,360],[360,278],[418,262],[262,431],[431,418],[304,408],[408,409],[409,304],[310,415],[415,407],[407,310],[270,409],[409,410],[410,270],[450,348],[348,347],[347,450],[422,430],[430,434],[434,422],[313,314],[314,17],[17,313],[306,307],[307,375],[375,306],[387,388],[388,260],[260,387],[286,414],[414,398],[398,286],[335,406],[406,418],[418,335],[364,367],[367,416],[416,364],[423,358],[358,327],[327,423],[251,284],[284,298],[298,251],[281,5],[5,4],[4,281],[373,374],[374,253],[253,373],[307,320],[320,321],[321,307],[425,427],[427,411],[411,425],[421,313],[313,18],[18,421],[321,405],[405,406],[406,321],[320,404],[404,405],[405,320],[315,16],[16,17],[17,315],[426,425],[425,266],[266,426],[377,400],[400,369],[369,377],[322,391],[391,269],[269,322],[417,465],[465,464],[464,417],[386,257],[257,258],[258,386],[466,260],[260,388],[388,466],[456,399],[399,419],[419,456],[284,332],[332,333],[333,284],[417,285],[285,8],[8,417],[346,340],[340,261],[261,346],[413,441],[441,285],[285,413],[327,460],[460,328],[328,327],[355,371],[371,329],[329,355],[392,439],[439,438],[438,392],[382,341],[341,256],[256,382],[429,420],[420,360],[360,429],[364,394],[394,379],[379,364],[277,343],[343,437],[437,277],[443,444],[444,283],[283,443],[275,440],[440,363],[363,275],[431,262],[262,369],[369,431],[297,338],[338,337],[337,297],[273,375],[375,321],[321,273],[450,451],[451,349],[349,450],[446,342],[342,467],[467,446],[293,334],[334,282],[282,293],[458,461],[461,462],[462,458],[276,353],[353,383],[383,276],[308,324],[324,325],[325,308],[276,300],[300,293],[293,276],[372,345],[345,447],[447,372],[352,345],[345,340],[340,352],[274,1],[1,19],[19,274],[456,248],[248,281],[281,456],[436,427],[427,425],[425,436],[381,256],[256,252],[252,381],[269,391],[391,393],[393,269],[200,199],[199,428],[428,200],[266,330],[330,329],[329,266],[287,273],[273,422],[422,287],[250,462],[462,328],[328,250],[258,286],[286,384],[384,258],[265,353],[353,342],[342,265],[387,259],[259,257],[257,387],[424,431],[431,430],[430,424],[342,353],[353,276],[276,342],[273,335],[335,424],[424,273],[292,325],[325,307],[307,292],[366,447],[447,345],[345,366],[271,303],[303,302],[302,271],[423,266],[266,371],[371,423],[294,455],[455,460],[460,294],[279,278],[278,294],[294,279],[271,272],[272,304],[304,271],[432,434],[434,427],[427,432],[272,407],[407,408],[408,272],[394,430],[430,431],[431,394],[395,369],[369,400],[400,395],[334,333],[333,299],[299,334],[351,417],[417,168],[168,351],[352,280],[280,411],[411,352],[325,319],[319,320],[320,325],[295,296],[296,336],[336,295],[319,403],[403,404],[404,319],[330,348],[348,349],[349,330],[293,298],[298,333],[333,293],[323,454],[454,447],[447,323],[15,16],[16,315],[315,15],[358,429],[429,279],[279,358],[14,15],[15,316],[316,14],[285,336],[336,9],[9,285],[329,349],[349,350],[350,329],[374,380],[380,252],[252,374],[318,402],[402,403],[403,318],[6,197],[197,419],[419,6],[318,319],[319,325],[325,318],[367,364],[364,365],[365,367],[435,367],[367,397],[397,435],[344,438],[438,439],[439,344],[272,271],[271,311],[311,272],[195,5],[5,281],[281,195],[273,287],[287,291],[291,273],[396,428],[428,199],[199,396],[311,271],[271,268],[268,311],[283,444],[444,445],[445,283],[373,254],[254,339],[339,373],[282,334],[334,296],[296,282],[449,347],[347,346],[346,449],[264,447],[447,454],[454,264],[336,296],[296,299],[299,336],[338,10],[10,151],[151,338],[278,439],[439,455],[455,278],[292,407],[407,415],[415,292],[358,371],[371,355],[355,358],[340,345],[345,372],[372,340],[346,347],[347,280],[280,346],[442,443],[443,282],[282,442],[19,94],[94,370],[370,19],[441,442],[442,295],[295,441],[248,419],[419,197],[197,248],[263,255],[255,359],[359,263],[440,275],[275,274],[274,440],[300,383],[383,368],[368,300],[351,412],[412,465],[465,351],[263,467],[467,466],[466,263],[301,368],[368,389],[389,301],[395,378],[378,379],[379,395],[412,351],[351,419],[419,412],[436,426],[426,322],[322,436],[2,164],[164,393],[393,2],[370,462],[462,461],[461,370],[164,0],[0,267],[267,164],[302,11],[11,12],[12,302],[268,12],[12,13],[13,268],[293,300],[300,301],[301,293],[446,261],[261,340],[340,446],[330,266],[266,425],[425,330],[426,423],[423,391],[391,426],[429,355],[355,437],[437,429],[391,327],[327,326],[326,391],[440,457],[457,438],[438,440],[341,382],[382,362],[362,341],[459,457],[457,461],[461,459],[434,430],[430,394],[394,434],[414,463],[463,362],[362,414],[396,369],[369,262],[262,396],[354,461],[461,457],[457,354],[316,403],[403,402],[402,316],[315,404],[404,403],[403,315],[314,405],[405,404],[404,314],[313,406],[406,405],[405,313],[421,418],[418,406],[406,421],[366,401],[401,361],[361,366],[306,408],[408,407],[407,306],[291,409],[409,408],[408,291],[287,410],[410,409],[409,287],[432,436],[436,410],[410,432],[434,416],[416,411],[411,434],[264,368],[368,383],[383,264],[309,438],[438,457],[457,309],[352,376],[376,401],[401,352],[274,275],[275,4],[4,274],[421,428],[428,262],[262,421],[294,327],[327,358],[358,294],[433,416],[416,367],[367,433],[289,455],[455,439],[439,289],[462,370],[370,326],[326,462],[2,326],[326,370],[370,2],[305,460],[460,455],[455,305],[254,449],[449,448],[448,254],[255,261],[261,446],[446,255],[253,450],[450,449],[449,253],[252,451],[451,450],[450,252],[256,452],[452,451],[451,256],[341,453],[453,452],[452,341],[413,464],[464,463],[463,413],[441,413],[413,414],[414,441],[258,442],[442,441],[441,258],[257,443],[443,442],[442,257],[259,444],[444,443],[443,259],[260,445],[445,444],[444,260],[467,342],[342,445],[445,467],[459,458],[458,250],[250,459],[289,392],[392,290],[290,289],[290,328],[328,460],[460,290],[376,433],[433,435],[435,376],[250,290],[290,392],[392,250],[411,416],[416,433],[433,411],[341,463],[463,464],[464,341],[453,464],[464,465],[465,453],[357,465],[465,412],[412,357],[343,412],[412,399],[399,343],[360,363],[363,440],[440,360],[437,399],[399,456],[456,437],[420,456],[456,363],[363,420],[401,435],[435,288],[288,401],[372,383],[383,353],[353,372],[339,255],[255,249],[249,339],[448,261],[261,255],[255,448],[133,243],[243,190],[190,133],[133,155],[155,112],[112,133],[33,246],[246,247],[247,33],[33,130],[130,25],[25,33],[398,384],[384,286],[286,398],[362,398],[398,414],[414,362],[362,463],[463,341],[341,362],[263,359],[359,467],[467,263],[263,249],[249,255],[255,263],[466,467],[467,260],[260,466],[75,60],[60,166],[166,75],[238,239],[239,79],[79,238],[162,127],[127,139],[139,162],[72,11],[11,37],[37,72],[121,232],[232,120],[120,121],[73,72],[72,39],[39,73],[114,128],[128,47],[47,114],[233,232],[232,128],[128,233],[103,104],[104,67],[67,103],[152,175],[175,148],[148,152],[119,118],[118,101],[101,119],[74,73],[73,40],[40,74],[107,9],[9,108],[108,107],[49,48],[48,131],[131,49],[32,194],[194,211],[211,32],[184,74],[74,185],[185,184],[191,80],[80,183],[183,191],[185,40],[40,186],[186,185],[119,230],[230,118],[118,119],[210,202],[202,214],[214,210],[84,83],[83,17],[17,84],[77,76],[76,146],[146,77],[161,160],[160,30],[30,161],[190,56],[56,173],[173,190],[182,106],[106,194],[194,182],[138,135],[135,192],[192,138],[129,203],[203,98],[98,129],[54,21],[21,68],[68,54],[5,51],[51,4],[4,5],[145,144],[144,23],[23,145],[90,77],[77,91],[91,90],[207,205],[205,187],[187,207],[83,201],[201,18],[18,83],[181,91],[91,182],[182,181],[180,90],[90,181],[181,180],[16,85],[85,17],[17,16],[205,206],[206,36],[36,205],[176,148],[148,140],[140,176],[165,92],[92,39],[39,165],[245,193],[193,244],[244,245],[27,159],[159,28],[28,27],[30,247],[247,161],[161,30],[174,236],[236,196],[196,174],[103,54],[54,104],[104,103],[55,193],[193,8],[8,55],[111,117],[117,31],[31,111],[221,189],[189,55],[55,221],[240,98],[98,99],[99,240],[142,126],[126,100],[100,142],[219,166],[166,218],[218,219],[112,155],[155,26],[26,112],[198,209],[209,131],[131,198],[169,135],[135,150],[150,169],[114,47],[47,217],[217,114],[224,223],[223,53],[53,224],[220,45],[45,134],[134,220],[32,211],[211,140],[140,32],[109,67],[67,108],[108,109],[146,43],[43,91],[91,146],[231,230],[230,120],[120,231],[113,226],[226,247],[247,113],[105,63],[63,52],[52,105],[241,238],[238,242],[242,241],[124,46],[46,156],[156,124],[95,78],[78,96],[96,95],[70,46],[46,63],[63,70],[116,143],[143,227],[227,116],[116,123],[123,111],[111,116],[1,44],[44,19],[19,1],[3,236],[236,51],[51,3],[207,216],[216,205],[205,207],[26,154],[154,22],[22,26],[165,39],[39,167],[167,165],[199,200],[200,208],[208,199],[101,36],[36,100],[100,101],[43,57],[57,202],[202,43],[242,20],[20,99],[99,242],[56,28],[28,157],[157,56],[124,35],[35,113],[113,124],[29,160],[160,27],[27,29],[211,204],[204,210],[210,211],[124,113],[113,46],[46,124],[106,43],[43,204],[204,106],[96,62],[62,77],[77,96],[227,137],[137,116],[116,227],[73,41],[41,72],[72,73],[36,203],[203,142],[142,36],[235,64],[64,240],[240,235],[48,49],[49,64],[64,48],[42,41],[41,74],[74,42],[214,212],[212,207],[207,214],[183,42],[42,184],[184,183],[210,169],[169,211],[211,210],[140,170],[170,176],[176,140],[104,105],[105,69],[69,104],[193,122],[122,168],[168,193],[50,123],[123,187],[187,50],[89,96],[96,90],[90,89],[66,65],[65,107],[107,66],[179,89],[89,180],[180,179],[119,101],[101,120],[120,119],[68,63],[63,104],[104,68],[234,93],[93,227],[227,234],[16,15],[15,85],[85,16],[209,129],[129,49],[49,209],[15,14],[14,86],[86,15],[107,55],[55,9],[9,107],[120,100],[100,121],[121,120],[153,145],[145,22],[22,153],[178,88],[88,179],[179,178],[197,6],[6,196],[196,197],[89,88],[88,96],[96,89],[135,138],[138,136],[136,135],[138,215],[215,172],[172,138],[218,115],[115,219],[219,218],[41,42],[42,81],[81,41],[5,195],[195,51],[51,5],[57,43],[43,61],[61,57],[208,171],[171,199],[199,208],[41,81],[81,38],[38,41],[224,53],[53,225],[225,224],[24,144],[144,110],[110,24],[105,52],[52,66],[66,105],[118,229],[229,117],[117,118],[227,34],[34,234],[234,227],[66,107],[107,69],[69,66],[10,109],[109,151],[151,10],[219,48],[48,235],[235,219],[183,62],[62,191],[191,183],[142,129],[129,126],[126,142],[116,111],[111,143],[143,116],[118,117],[117,50],[50,118],[223,222],[222,52],[52,223],[94,19],[19,141],[141,94],[222,221],[221,65],[65,222],[196,3],[3,197],[197,196],[45,220],[220,44],[44,45],[156,70],[70,139],[139,156],[188,122],[122,245],[245,188],[139,71],[71,162],[162,139],[149,170],[170,150],[150,149],[122,188],[188,196],[196,122],[206,216],[216,92],[92,206],[164,2],[2,167],[167,164],[242,141],[141,241],[241,242],[0,164],[164,37],[37,0],[11,72],[72,12],[12,11],[12,38],[38,13],[13,12],[70,63],[63,71],[71,70],[31,226],[226,111],[111,31],[36,101],[101,205],[205,36],[203,206],[206,165],[165,203],[126,209],[209,217],[217,126],[98,165],[165,97],[97,98],[237,220],[220,218],[218,237],[237,239],[239,241],[241,237],[210,214],[214,169],[169,210],[140,171],[171,32],[32,140],[241,125],[125,237],[237,241],[179,86],[86,178],[178,179],[180,85],[85,179],[179,180],[181,84],[84,180],[180,181],[182,83],[83,181],[181,182],[194,201],[201,182],[182,194],[177,137],[137,132],[132,177],[184,76],[76,183],[183,184],[185,61],[61,184],[184,185],[186,57],[57,185],[185,186],[216,212],[212,186],[186,216],[192,214],[214,187],[187,192],[139,34],[34,156],[156,139],[218,79],[79,237],[237,218],[147,123],[123,177],[177,147],[45,44],[44,4],[4,45],[208,201],[201,32],[32,208],[98,64],[64,129],[129,98],[192,213],[213,138],[138,192],[235,59],[59,219],[219,235],[141,242],[242,97],[97,141],[97,2],[2,141],[141,97],[240,75],[75,235],[235,240],[229,24],[24,228],[228,229],[31,25],[25,226],[226,31],[230,23],[23,229],[229,230],[231,22],[22,230],[230,231],[232,26],[26,231],[231,232],[233,112],[112,232],[232,233],[244,189],[189,243],[243,244],[189,221],[221,190],[190,189],[222,28],[28,221],[221,222],[223,27],[27,222],[222,223],[224,29],[29,223],[223,224],[225,30],[30,224],[224,225],[113,247],[247,225],[225,113],[99,60],[60,240],[240,99],[213,147],[147,215],[215,213],[60,20],[20,166],[166,60],[192,187],[187,213],[213,192],[243,112],[112,244],[244,243],[244,233],[233,245],[245,244],[245,128],[128,188],[188,245],[188,114],[114,174],[174,188],[134,131],[131,220],[220,134],[174,217],[217,236],[236,174],[236,198],[198,134],[134,236],[215,177],[177,58],[58,215],[156,143],[143,124],[124,156],[25,110],[110,7],[7,25],[31,228],[228,25],[25,31],[264,356],[356,368],[368,264],[0,11],[11,267],[267,0],[451,452],[452,349],[349,451],[267,302],[302,269],[269,267],[350,357],[357,277],[277,350],[350,452],[452,357],[357,350],[299,333],[333,297],[297,299],[396,175],[175,377],[377,396],[280,347],[347,330],[330,280],[269,303],[303,270],[270,269],[151,9],[9,337],[337,151],[344,278],[278,360],[360,344],[424,418],[418,431],[431,424],[270,304],[304,409],[409,270],[272,310],[310,407],[407,272],[322,270],[270,410],[410,322],[449,450],[450,347],[347,449],[432,422],[422,434],[434,432],[18,313],[313,17],[17,18],[291,306],[306,375],[375,291],[259,387],[387,260],[260,259],[424,335],[335,418],[418,424],[434,364],[364,416],[416,434],[391,423],[423,327],[327,391],[301,251],[251,298],[298,301],[275,281],[281,4],[4,275],[254,373],[373,253],[253,254],[375,307],[307,321],[321,375],[280,425],[425,411],[411,280],[200,421],[421,18],[18,200],[335,321],[321,406],[406,335],[321,320],[320,405],[405,321],[314,315],[315,17],[17,314],[423,426],[426,266],[266,423],[396,377],[377,369],[369,396],[270,322],[322,269],[269,270],[413,417],[417,464],[464,413],[385,386],[386,258],[258,385],[248,456],[456,419],[419,248],[298,284],[284,333],[333,298],[168,417],[417,8],[8,168],[448,346],[346,261],[261,448],[417,413],[413,285],[285,417],[326,327],[327,328],[328,326],[277,355],[355,329],[329,277],[309,392],[392,438],[438,309],[381,382],[382,256],[256,381],[279,429],[429,360],[360,279],[365,364],[364,379],[379,365],[355,277],[277,437],[437,355],[282,443],[443,283],[283,282],[281,275],[275,363],[363,281],[395,431],[431,369],[369,395],[299,297],[297,337],[337,299],[335,273],[273,321],[321,335],[348,450],[450,349],[349,348],[359,446],[446,467],[467,359],[283,293],[293,282],[282,283],[250,458],[458,462],[462,250],[300,276],[276,383],[383,300],[292,308],[308,325],[325,292],[283,276],[276,293],[293,283],[264,372],[372,447],[447,264],[346,352],[352,340],[340,346],[354,274],[274,19],[19,354],[363,456],[456,281],[281,363],[426,436],[436,425],[425,426],[380,381],[381,252],[252,380],[267,269],[269,393],[393,267],[421,200],[200,428],[428,421],[371,266],[266,329],[329,371],[432,287],[287,422],[422,432],[290,250],[250,328],[328,290],[385,258],[258,384],[384,385],[446,265],[265,342],[342,446],[386,387],[387,257],[257,386],[422,424],[424,430],[430,422],[445,342],[342,276],[276,445],[422,273],[273,424],[424,422],[306,292],[292,307],[307,306],[352,366],[366,345],[345,352],[268,271],[271,302],[302,268],[358,423],[423,371],[371,358],[327,294],[294,460],[460,327],[331,279],[279,294],[294,331],[303,271],[271,304],[304,303],[436,432],[432,427],[427,436],[304,272],[272,408],[408,304],[395,394],[394,431],[431,395],[378,395],[395,400],[400,378],[296,334],[334,299],[299,296],[6,351],[351,168],[168,6],[376,352],[352,411],[411,376],[307,325],[325,320],[320,307],[285,295],[295,336],[336,285],[320,319],[319,404],[404,320],[329,330],[330,349],[349,329],[334,293],[293,333],[333,334],[366,323],[323,447],[447,366],[316,15],[15,315],[315,316],[331,358],[358,279],[279,331],[317,14],[14,316],[316,317],[8,285],[285,9],[9,8],[277,329],[329,350],[350,277],[253,374],[374,252],[252,253],[319,318],[318,403],[403,319],[351,6],[6,419],[419,351],[324,318],[318,325],[325,324],[397,367],[367,365],[365,397],[288,435],[435,397],[397,288],[278,344],[344,439],[439,278],[310,272],[272,311],[311,310],[248,195],[195,281],[281,248],[375,273],[273,291],[291,375],[175,396],[396,199],[199,175],[312,311],[311,268],[268,312],[276,283],[283,445],[445,276],[390,373],[373,339],[339,390],[295,282],[282,296],[296,295],[448,449],[449,346],[346,448],[356,264],[264,454],[454,356],[337,336],[336,299],[299,337],[337,338],[338,151],[151,337],[294,278],[278,455],[455,294],[308,292],[292,415],[415,308],[429,358],[358,355],[355,429],[265,340],[340,372],[372,265],[352,346],[346,280],[280,352],[295,442],[442,282],[282,295],[354,19],[19,370],[370,354],[285,441],[441,295],[295,285],[195,248],[248,197],[197,195],[457,440],[440,274],[274,457],[301,300],[300,368],[368,301],[417,351],[351,465],[465,417],[251,301],[301,389],[389,251],[394,395],[395,379],[379,394],[399,412],[412,419],[419,399],[410,436],[436,322],[322,410],[326,2],[2,393],[393,326],[354,370],[370,461],[461,354],[393,164],[164,267],[267,393],[268,302],[302,12],[12,268],[312,268],[268,13],[13,312],[298,293],[293,301],[301,298],[265,446],[446,340],[340,265],[280,330],[330,425],[425,280],[322,426],[426,391],[391,322],[420,429],[429,437],[437,420],[393,391],[391,326],[326,393],[344,440],[440,438],[438,344],[458,459],[459,461],[461,458],[364,434],[434,394],[394,364],[428,396],[396,262],[262,428],[274,354],[354,457],[457,274],[317,316],[316,402],[402,317],[316,315],[315,403],[403,316],[315,314],[314,404],[404,315],[314,313],[313,405],[405,314],[313,421],[421,406],[406,313],[323,366],[366,361],[361,323],[292,306],[306,407],[407,292],[306,291],[291,408],[408,306],[291,287],[287,409],[409,291],[287,432],[432,410],[410,287],[427,434],[434,411],[411,427],[372,264],[264,383],[383,372],[459,309],[309,457],[457,459],[366,352],[352,401],[401,366],[1,274],[274,4],[4,1],[418,421],[421,262],[262,418],[331,294],[294,358],[358,331],[435,433],[433,367],[367,435],[392,289],[289,439],[439,392],[328,462],[462,326],[326,328],[94,2],[2,370],[370,94],[289,305],[305,455],[455,289],[339,254],[254,448],[448,339],[359,255],[255,446],[446,359],[254,253],[253,449],[449,254],[253,252],[252,450],[450,253],[252,256],[256,451],[451,252],[256,341],[341,452],[452,256],[414,413],[413,463],[463,414],[286,441],[441,414],[414,286],[286,258],[258,441],[441,286],[258,257],[257,442],[442,258],[257,259],[259,443],[443,257],[259,260],[260,444],[444,259],[260,467],[467,445],[445,260],[309,459],[459,250],[250,309],[305,289],[289,290],[290,305],[305,290],[290,460],[460,305],[401,376],[376,435],[435,401],[309,250],[250,392],[392,309],[376,411],[411,433],[433,376],[453,341],[341,464],[464,453],[357,453],[453,465],[465,357],[343,357],[357,412],[412,343],[437,343],[343,399],[399,437],[344,360],[360,440],[440,344],[420,437],[437,456],[456,420],[360,420],[420,363],[363,360],[361,401],[401,288],[288,361],[265,372],[372,353],[353,265],[390,339],[339,249],[249,390],[339,448],[448,255],[255,339]]),Q("matrixDataToMatrix",function(w){for(var E=w.getCols(),k=w.getRows(),q=w.getPackedDataList(),ie=[],me=0;me<k;me++)ie.push(Array(E));for(me=0;me<k;me++)for(var ce=0;ce<E;ce++){var ye=w.getLayout()===1?me*E+ce:ce*k+me;ie[me][ce]=q[ye]}return ie}),Q("VERSION","0.4.1633559619")}).call(hF)});var LF=So((POe,$F)=>{"use strict";$F.exports=Mn;var Fs=null;try{Fs=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(t){}function Mn(t,n,e){this.low=t|0,this.high=n|0,this.unsigned=!!e}Mn.prototype.__isLong__;Object.defineProperty(Mn.prototype,"__isLong__",{value:!0});function Yo(t){return(t&&t.__isLong__)===!0}Mn.isLong=Yo;var NF={},DF={};function jp(t,n){var e,r,o;return n?(t>>>=0,(o=0<=t&&t<256)&&(r=DF[t],r)?r:(e=On(t,(t|0)<0?-1:0,!0),o&&(DF[t]=e),e)):(t|=0,(o=-128<=t&&t<128)&&(r=NF[t],r)?r:(e=On(t,t<0?-1:0,!1),o&&(NF[t]=e),e))}Mn.fromInt=jp;function $s(t,n){if(isNaN(t))return n?Gp:Ls;if(n){if(t<0)return Gp;if(t>=RF)return FF}else{if(t<=-AF)return Xo;if(t+1>=AF)return OF}return t<0?$s(-t,n).neg():On(t%tm|0,t/tm|0,n)}Mn.fromNumber=$s;function On(t,n,e){return new Mn(t,n,e)}Mn.fromBits=On;var pv=Math.pow;function QE(t,n,e){if(t.length===0)throw Error("empty string");if(t==="NaN"||t==="Infinity"||t==="+Infinity"||t==="-Infinity")return Ls;if(typeof n=="number"?(e=n,n=!1):n=!!n,e=e||10,e<2||36<e)throw RangeError("radix");var r;if((r=t.indexOf("-"))>0)throw Error("interior hyphen");if(r===0)return QE(t.substring(1),n,e).neg();for(var o=$s(pv(e,8)),s=Ls,i=0;i<t.length;i+=8){var a=Math.min(8,t.length-i),l=parseInt(t.substring(i,i+a),e);if(a<8){var c=$s(pv(e,a));s=s.mul(c).add($s(l))}else s=s.mul(o),s=s.add($s(l))}return s.unsigned=n,s}Mn.fromString=QE;function pi(t,n){return typeof t=="number"?$s(t,n):typeof t=="string"?QE(t,n):On(t.low,t.high,typeof n=="boolean"?n:t.unsigned)}Mn.fromValue=pi;var kF=65536,Wte=1<<24,tm=kF*kF,RF=tm*tm,AF=RF/2,_F=jp(Wte),Ls=jp(0);Mn.ZERO=Ls;var Gp=jp(0,!0);Mn.UZERO=Gp;var em=jp(1);Mn.ONE=em;var MF=jp(1,!0);Mn.UONE=MF;var ZE=jp(-1);Mn.NEG_ONE=ZE;var OF=On(-1,2147483647,!1);Mn.MAX_VALUE=OF;var FF=On(-1,-1,!0);Mn.MAX_UNSIGNED_VALUE=FF;var Xo=On(0,-2147483648,!1);Mn.MIN_VALUE=Xo;var Fe=Mn.prototype;Fe.toInt=function(){return this.unsigned?this.low>>>0:this.low};Fe.toNumber=function(){return this.unsigned?(this.high>>>0)*tm+(this.low>>>0):this.high*tm+(this.low>>>0)};Fe.toString=function(n){if(n=n||10,n<2||36<n)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Xo)){var e=$s(n),r=this.div(e),o=r.mul(e).sub(this);return r.toString(n)+o.toInt().toString(n)}else return"-"+this.neg().toString(n);for(var s=$s(pv(n,6),this.unsigned),i=this,a="";;){var l=i.div(s),c=i.sub(l.mul(s)).toInt()>>>0,u=c.toString(n);if(i=l,i.isZero())return u+a;for(;u.length<6;)u="0"+u;a=""+u+a}};Fe.getHighBits=function(){return this.high};Fe.getHighBitsUnsigned=function(){return this.high>>>0};Fe.getLowBits=function(){return this.low};Fe.getLowBitsUnsigned=function(){return this.low>>>0};Fe.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Xo)?64:this.neg().getNumBitsAbs();for(var n=this.high!=0?this.high:this.low,e=31;e>0&&(n&1<<e)==0;e--);return this.high!=0?e+33:e+1};Fe.isZero=function(){return this.high===0&&this.low===0};Fe.eqz=Fe.isZero;Fe.isNegative=function(){return!this.unsigned&&this.high<0};Fe.isPositive=function(){return this.unsigned||this.high>=0};Fe.isOdd=function(){return(this.low&1)===1};Fe.isEven=function(){return(this.low&1)===0};Fe.equals=function(n){return Yo(n)||(n=pi(n)),this.unsigned!==n.unsigned&&this.high>>>31===1&&n.high>>>31===1?!1:this.high===n.high&&this.low===n.low};Fe.eq=Fe.equals;Fe.notEquals=function(n){return!this.eq(n)};Fe.neq=Fe.notEquals;Fe.ne=Fe.notEquals;Fe.lessThan=function(n){return this.comp(n)<0};Fe.lt=Fe.lessThan;Fe.lessThanOrEqual=function(n){return this.comp(n)<=0};Fe.lte=Fe.lessThanOrEqual;Fe.le=Fe.lessThanOrEqual;Fe.greaterThan=function(n){return this.comp(n)>0};Fe.gt=Fe.greaterThan;Fe.greaterThanOrEqual=function(n){return this.comp(n)>=0};Fe.gte=Fe.greaterThanOrEqual;Fe.ge=Fe.greaterThanOrEqual;Fe.compare=function(n){if(Yo(n)||(n=pi(n)),this.eq(n))return 0;var e=this.isNegative(),r=n.isNegative();return e&&!r?-1:!e&&r?1:this.unsigned?n.high>>>0>this.high>>>0||n.high===this.high&&n.low>>>0>this.low>>>0?-1:1:this.sub(n).isNegative()?-1:1};Fe.comp=Fe.compare;Fe.negate=function(){return!this.unsigned&&this.eq(Xo)?Xo:this.not().add(em)};Fe.neg=Fe.negate;Fe.add=function(n){Yo(n)||(n=pi(n));var e=this.high>>>16,r=this.high&65535,o=this.low>>>16,s=this.low&65535,i=n.high>>>16,a=n.high&65535,l=n.low>>>16,c=n.low&65535,u=0,p=0,f=0,d=0;return d+=s+c,f+=d>>>16,d&=65535,f+=o+l,p+=f>>>16,f&=65535,p+=r+a,u+=p>>>16,p&=65535,u+=e+i,u&=65535,On(f<<16|d,u<<16|p,this.unsigned)};Fe.subtract=function(n){return Yo(n)||(n=pi(n)),this.add(n.neg())};Fe.sub=Fe.subtract;Fe.multiply=function(n){if(this.isZero())return Ls;if(Yo(n)||(n=pi(n)),Fs){var e=Fs.mul(this.low,this.high,n.low,n.high);return On(e,Fs.get_high(),this.unsigned)}if(n.isZero())return Ls;if(this.eq(Xo))return n.isOdd()?Xo:Ls;if(n.eq(Xo))return this.isOdd()?Xo:Ls;if(this.isNegative())return n.isNegative()?this.neg().mul(n.neg()):this.neg().mul(n).neg();if(n.isNegative())return this.mul(n.neg()).neg();if(this.lt(_F)&&n.lt(_F))return $s(this.toNumber()*n.toNumber(),this.unsigned);var r=this.high>>>16,o=this.high&65535,s=this.low>>>16,i=this.low&65535,a=n.high>>>16,l=n.high&65535,c=n.low>>>16,u=n.low&65535,p=0,f=0,d=0,h=0;return h+=i*u,d+=h>>>16,h&=65535,d+=s*u,f+=d>>>16,d&=65535,d+=i*c,f+=d>>>16,d&=65535,f+=o*u,p+=f>>>16,f&=65535,f+=s*c,p+=f>>>16,f&=65535,f+=i*l,p+=f>>>16,f&=65535,p+=r*u+o*c+s*l+i*a,p&=65535,On(d<<16|h,p<<16|f,this.unsigned)};Fe.mul=Fe.multiply;Fe.divide=function(n){if(Yo(n)||(n=pi(n)),n.isZero())throw Error("division by zero");if(Fs){if(!this.unsigned&&this.high===-2147483648&&n.low===-1&&n.high===-1)return this;var e=(this.unsigned?Fs.div_u:Fs.div_s)(this.low,this.high,n.low,n.high);return On(e,Fs.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Gp:Ls;var r,o,s;if(this.unsigned){if(n.unsigned||(n=n.toUnsigned()),n.gt(this))return Gp;if(n.gt(this.shru(1)))return MF;s=Gp}else{if(this.eq(Xo)){if(n.eq(em)||n.eq(ZE))return Xo;if(n.eq(Xo))return em;var i=this.shr(1);return r=i.div(n).shl(1),r.eq(Ls)?n.isNegative()?em:ZE:(o=this.sub(n.mul(r)),s=r.add(o.div(n)),s)}else if(n.eq(Xo))return this.unsigned?Gp:Ls;if(this.isNegative())return n.isNegative()?this.neg().div(n.neg()):this.neg().div(n).neg();if(n.isNegative())return this.div(n.neg()).neg();s=Ls}for(o=this;o.gte(n);){r=Math.max(1,Math.floor(o.toNumber()/n.toNumber()));for(var a=Math.ceil(Math.log(r)/Math.LN2),l=a<=48?1:pv(2,a-48),c=$s(r),u=c.mul(n);u.isNegative()||u.gt(o);)r-=l,c=$s(r,this.unsigned),u=c.mul(n);c.isZero()&&(c=em),s=s.add(c),o=o.sub(u)}return s};Fe.div=Fe.divide;Fe.modulo=function(n){if(Yo(n)||(n=pi(n)),Fs){var e=(this.unsigned?Fs.rem_u:Fs.rem_s)(this.low,this.high,n.low,n.high);return On(e,Fs.get_high(),this.unsigned)}return this.sub(this.div(n).mul(n))};Fe.mod=Fe.modulo;Fe.rem=Fe.modulo;Fe.not=function(){return On(~this.low,~this.high,this.unsigned)};Fe.and=function(n){return Yo(n)||(n=pi(n)),On(this.low&n.low,this.high&n.high,this.unsigned)};Fe.or=function(n){return Yo(n)||(n=pi(n)),On(this.low|n.low,this.high|n.high,this.unsigned)};Fe.xor=function(n){return Yo(n)||(n=pi(n)),On(this.low^n.low,this.high^n.high,this.unsigned)};Fe.shiftLeft=function(n){return Yo(n)&&(n=n.toInt()),(n&=63)===0?this:n<32?On(this.low<<n,this.high<<n|this.low>>>32-n,this.unsigned):On(0,this.low<<n-32,this.unsigned)};Fe.shl=Fe.shiftLeft;Fe.shiftRight=function(n){return Yo(n)&&(n=n.toInt()),(n&=63)===0?this:n<32?On(this.low>>>n|this.high<<32-n,this.high>>n,this.unsigned):On(this.high>>n-32,this.high>=0?0:-1,this.unsigned)};Fe.shr=Fe.shiftRight;Fe.shiftRightUnsigned=function(n){if(Yo(n)&&(n=n.toInt()),n&=63,n===0)return this;var e=this.high;if(n<32){var r=this.low;return On(r>>>n|e<<32-n,e>>>n,this.unsigned)}else return n===32?On(e,0,this.unsigned):On(e>>>n-32,0,this.unsigned)};Fe.shru=Fe.shiftRightUnsigned;Fe.shr_u=Fe.shiftRightUnsigned;Fe.toSigned=function(){return this.unsigned?On(this.low,this.high,!1):this};Fe.toUnsigned=function(){return this.unsigned?this:On(this.low,this.high,!0)};Fe.toBytes=function(n){return n?this.toBytesLE():this.toBytesBE()};Fe.toBytesLE=function(){var n=this.high,e=this.low;return[e&255,e>>>8&255,e>>>16&255,e>>>24,n&255,n>>>8&255,n>>>16&255,n>>>24]};Fe.toBytesBE=function(){var n=this.high,e=this.low;return[n>>>24,n>>>16&255,n>>>8&255,n&255,e>>>24,e>>>16&255,e>>>8&255,e&255]};Mn.fromBytes=function(n,e,r){return r?Mn.fromBytesLE(n,e):Mn.fromBytesBE(n,e)};Mn.fromBytesLE=function(n,e){return new Mn(n[0]|n[1]<<8|n[2]<<16|n[3]<<24,n[4]|n[5]<<8|n[6]<<16|n[7]<<24,e)};Mn.fromBytesBE=function(n,e){return new Mn(n[4]<<24|n[5]<<16|n[6]<<8|n[7],n[0]<<24|n[1]<<16|n[2]<<8|n[3],e)}});var N$=So((cm,E$)=>{"use strict";var Rne=function(){if(typeof self<"u")return self;if(typeof window<"u")return window;if(typeof global<"u")return global;throw new Error("unable to locate global object")},Jp=Rne();E$.exports=cm=Jp.fetch;Jp.fetch&&(cm.default=Jp.fetch.bind(Jp));cm.Headers=Jp.Headers;cm.Request=Jp.Request;cm.Response=Jp.Response});var D$=So(()=>{"use strict"});var rL=So((nL,EN)=>{"use strict";(function(t,n,e){function r(a){var l=this,c=i();l.next=function(){var u=2091639*l.s0+l.c*23283064365386963e-26;return l.s0=l.s1,l.s1=l.s2,l.s2=u-(l.c=u|0)},l.c=1,l.s0=c(" "),l.s1=c(" "),l.s2=c(" "),l.s0-=c(a),l.s0<0&&(l.s0+=1),l.s1-=c(a),l.s1<0&&(l.s1+=1),l.s2-=c(a),l.s2<0&&(l.s2+=1),c=null}function o(a,l){return l.c=a.c,l.s0=a.s0,l.s1=a.s1,l.s2=a.s2,l}function s(a,l){var c=new r(a),u=l&&l.state,p=c.next;return p.int32=function(){return c.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,u&&(typeof u=="object"&&o(u,c),p.state=function(){return o(c,{})}),p}function i(){var a=4022871197,l=function(c){c=String(c);for(var u=0;u<c.length;u++){a+=c.charCodeAt(u);var p=.02519603282416938*a;a=p>>>0,p-=a,p*=a,a=p>>>0,p-=a,a+=p*4294967296}return(a>>>0)*23283064365386963e-26};return l}n&&n.exports?n.exports=s:e&&e.amd?e(function(){return s}):this.alea=s})(nL,typeof EN=="object"&&EN,typeof define=="function"&&define)});var sL=So((oL,NN)=>{"use strict";(function(t,n,e){function r(i){var a=this,l="";a.x=0,a.y=0,a.z=0,a.w=0,a.next=function(){var u=a.x^a.x<<11;return a.x=a.y,a.y=a.z,a.z=a.w,a.w^=a.w>>>19^u^u>>>8},i===(i|0)?a.x=i:l+=i;for(var c=0;c<l.length+64;c++)a.x^=l.charCodeAt(c)|0,a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a}function s(i,a){var l=new r(i),c=a&&a.state,u=function(){return(l.next()>>>0)/4294967296};return u.double=function(){do var p=l.next()>>>11,f=(l.next()>>>0)/4294967296,d=(p+f)/(1<<21);while(d===0);return d},u.int32=l.next,u.quick=u,c&&(typeof c=="object"&&o(c,l),u.state=function(){return o(l,{})}),u}n&&n.exports?n.exports=s:e&&e.amd?e(function(){return s}):this.xor128=s})(oL,typeof NN=="object"&&NN,typeof define=="function"&&define)});var aL=So((iL,DN)=>{"use strict";(function(t,n,e){function r(i){var a=this,l="";a.next=function(){var u=a.x^a.x>>>2;return a.x=a.y,a.y=a.z,a.z=a.w,a.w=a.v,(a.d=a.d+362437|0)+(a.v=a.v^a.v<<4^(u^u<<1))|0},a.x=0,a.y=0,a.z=0,a.w=0,a.v=0,i===(i|0)?a.x=i:l+=i;for(var c=0;c<l.length+64;c++)a.x^=l.charCodeAt(c)|0,c==l.length&&(a.d=a.x<<10^a.x>>>4),a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a.v=i.v,a.d=i.d,a}function s(i,a){var l=new r(i),c=a&&a.state,u=function(){return(l.next()>>>0)/4294967296};return u.double=function(){do var p=l.next()>>>11,f=(l.next()>>>0)/4294967296,d=(p+f)/(1<<21);while(d===0);return d},u.int32=l.next,u.quick=u,c&&(typeof c=="object"&&o(c,l),u.state=function(){return o(l,{})}),u}n&&n.exports?n.exports=s:e&&e.amd?e(function(){return s}):this.xorwow=s})(iL,typeof DN=="object"&&DN,typeof define=="function"&&define)});var cL=So((lL,kN)=>{"use strict";(function(t,n,e){function r(i){var a=this;a.next=function(){var c=a.x,u=a.i,p,f,d;return p=c[u],p^=p>>>7,f=p^p<<24,p=c[u+1&7],f^=p^p>>>10,p=c[u+3&7],f^=p^p>>>3,p=c[u+4&7],f^=p^p<<7,p=c[u+7&7],p=p^p<<13,f^=p^p<<9,c[u]=f,a.i=u+1&7,f};function l(c,u){var p,f,d=[];if(u===(u|0))f=d[0]=u;else for(u=""+u,p=0;p<u.length;++p)d[p&7]=d[p&7]<<15^u.charCodeAt(p)+d[p+1&7]<<13;for(;d.length<8;)d.push(0);for(p=0;p<8&&d[p]===0;++p);for(p==8?f=d[7]=-1:f=d[p],c.x=d,c.i=0,p=256;p>0;--p)c.next()}l(a,i)}function o(i,a){return a.x=i.x.slice(),a.i=i.i,a}function s(i,a){i==null&&(i=+new Date);var l=new r(i),c=a&&a.state,u=function(){return(l.next()>>>0)/4294967296};return u.double=function(){do var p=l.next()>>>11,f=(l.next()>>>0)/4294967296,d=(p+f)/(1<<21);while(d===0);return d},u.int32=l.next,u.quick=u,c&&(c.x&&o(c,l),u.state=function(){return o(l,{})}),u}n&&n.exports?n.exports=s:e&&e.amd?e(function(){return s}):this.xorshift7=s})(lL,typeof kN=="object"&&kN,typeof define=="function"&&define)});var pL=So((uL,AN)=>{"use strict";(function(t,n,e){function r(i){var a=this;a.next=function(){var c=a.w,u=a.X,p=a.i,f,d;return a.w=c=c+1640531527|0,d=u[p+34&127],f=u[p=p+1&127],d^=d<<13,f^=f<<17,d^=d>>>15,f^=f>>>12,d=u[p]=d^f,a.i=p,d+(c^c>>>16)|0};function l(c,u){var p,f,d,h,g,m=[],y=128;for(u===(u|0)?(f=u,u=null):(u=u+"\0",f=0,y=Math.max(y,u.length)),d=0,h=-32;h<y;++h)u&&(f^=u.charCodeAt((h+32)%u.length)),h===0&&(g=f),f^=f<<10,f^=f>>>15,f^=f<<4,f^=f>>>13,h>=0&&(g=g+1640531527|0,p=m[h&127]^=f+g,d=p==0?d+1:0);for(d>=128&&(m[(u&&u.length||0)&127]=-1),d=127,h=512;h>0;--h)f=m[d+34&127],p=m[d=d+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,m[d]=f^p;c.w=g,c.X=m,c.i=d}l(a,i)}function o(i,a){return a.i=i.i,a.w=i.w,a.X=i.X.slice(),a}function s(i,a){i==null&&(i=+new Date);var l=new r(i),c=a&&a.state,u=function(){return(l.next()>>>0)/4294967296};return u.double=function(){do var p=l.next()>>>11,f=(l.next()>>>0)/4294967296,d=(p+f)/(1<<21);while(d===0);return d},u.int32=l.next,u.quick=u,c&&(c.X&&o(c,l),u.state=function(){return o(l,{})}),u}n&&n.exports?n.exports=s:e&&e.amd?e(function(){return s}):this.xor4096=s})(uL,typeof AN=="object"&&AN,typeof define=="function"&&define)});var dL=So((fL,_N)=>{"use strict";(function(t,n,e){function r(i){var a=this,l="";a.next=function(){var u=a.b,p=a.c,f=a.d,d=a.a;return u=u<<25^u>>>7^p,p=p-f|0,f=f<<24^f>>>8^d,d=d-u|0,a.b=u=u<<20^u>>>12^p,a.c=p=p-f|0,a.d=f<<16^p>>>16^d,a.a=d-u|0},a.a=0,a.b=0,a.c=-1640531527,a.d=1367130551,i===Math.floor(i)?(a.a=i/4294967296|0,a.b=i|0):l+=i;for(var c=0;c<l.length+20;c++)a.b^=l.charCodeAt(c)|0,a.next()}function o(i,a){return a.a=i.a,a.b=i.b,a.c=i.c,a.d=i.d,a}function s(i,a){var l=new r(i),c=a&&a.state,u=function(){return(l.next()>>>0)/4294967296};return u.double=function(){do var p=l.next()>>>11,f=(l.next()>>>0)/4294967296,d=(p+f)/(1<<21);while(d===0);return d},u.int32=l.next,u.quick=u,c&&(typeof c=="object"&&o(c,l),u.state=function(){return o(l,{})}),u}n&&n.exports?n.exports=s:e&&e.amd?e(function(){return s}):this.tychei=s})(fL,typeof _N=="object"&&_N,typeof define=="function"&&define)});var hL=So(()=>{"use strict"});var gL=So((mL,mb)=>{"use strict";(function(t,n,e){var r=256,o=6,s=52,i="random",a=e.pow(r,o),l=e.pow(2,s),c=l*2,u=r-1,p;function f(C,I,D){var O=[];I=I==!0?{entropy:!0}:I||{};var L=m(g(I.entropy?[C,x(n)]:C??y(),3),O),B=new d(O),V=function(){for(var F=B.g(o),G=a,ee=0;F<l;)F=(F+ee)*r,G*=r,ee=B.g(1);for(;F>=c;)F/=2,G/=2,ee>>>=1;return(F+ee)/G};return V.int32=function(){return B.g(4)|0},V.quick=function(){return B.g(4)/4294967296},V.double=V,m(x(B.S),n),(I.pass||D||function(F,G,ee,Q){return Q&&(Q.S&&h(Q,B),F.state=function(){return h(B,{})}),ee?(e[i]=F,G):F})(V,L,"global"in I?I.global:this==e,I.state)}function d(C){var I,D=C.length,O=this,L=0,B=O.i=O.j=0,V=O.S=[];for(D||(C=[D++]);L<r;)V[L]=L++;for(L=0;L<r;L++)V[L]=V[B=u&B+C[L%D]+(I=V[L])],V[B]=I;(O.g=function(F){for(var G,ee=0,Q=O.i,oe=O.j,ae=O.S;F--;)G=ae[Q=u&Q+1],ee=ee*r+ae[u&(ae[Q]=ae[oe=u&oe+G])+(ae[oe]=G)];return O.i=Q,O.j=oe,ee})(r)}function h(C,I){return I.i=C.i,I.j=C.j,I.S=C.S.slice(),I}function g(C,I){var D=[],O=typeof C,L;if(I&&O=="object")for(L in C)try{D.push(g(C[L],I-1))}catch(B){}return D.length?D:O=="string"?C:C+"\0"}function m(C,I){for(var D=C+"",O,L=0;L<D.length;)I[u&L]=u&(O^=I[u&L]*19)+D.charCodeAt(L++);return x(I)}function y(){try{var C;return p&&(C=p.randomBytes)?C=C(r):(C=new Uint8Array(r),(t.crypto||t.msCrypto).getRandomValues(C)),x(C)}catch(O){var I=t.navigator,D=I&&I.plugins;return[+new Date,t,D,t.screen,x(n)]}}function x(C){return String.fromCharCode.apply(0,C)}if(m(e.random(),n),typeof mb=="object"&&mb.exports){mb.exports=f;try{p=hL()}catch(C){}}else typeof define=="function"&&define.amd?define(function(){return f}):e["seed"+i]=f})(typeof self<"u"?self:mL,[],Math)});var D1=So((lWe,yL)=>{"use strict";var yse=rL(),xse=sL(),vse=aL(),bse=cL(),wse=pL(),Cse=dL(),lf=gL();lf.alea=yse;lf.xor128=xse;lf.xorwow=vse;lf.xorshift7=bse;lf.xor4096=wse;lf.tychei=Cse;yL.exports=lf});var so=null,Gx=!1,TI=1,gK=null,Ds=Symbol("SIGNAL");function Ot(t){let n=so;return so=t,n}function jx(){return so}var Hx={version:0,lastCleanEpoch:0,dirty:!1,producers:void 0,producersTail:void 0,consumers:void 0,consumersTail:void 0,recomputing:!1,consumerAllowSignalWrites:!1,consumerIsAlwaysLive:!1,kind:"unknown",producerMustRecompute:()=>!1,producerRecomputeValue:()=>{},consumerMarkedDirty:()=>{},consumerOnSignalRead:()=>{}};function Wx(t){if(Gx)throw new Error("");if(so===null)return;so.consumerOnSignalRead(t);let n=so.producersTail;if(n!==void 0&&n.producer===t)return;let e,r=so.recomputing;if(r&&(e=n!==void 0?n.nextProducer:so.producers,e!==void 0&&e.producer===t)){so.producersTail=e,e.lastReadVersion=t.version;return}let o=t.consumersTail;if(o!==void 0&&o.consumer===so&&(!r||xK(o,so)))return;let s=Kf(so),i={producer:t,consumer:so,nextProducer:e,prevConsumer:o,lastReadVersion:t.version,nextConsumer:void 0};so.producersTail=i,n!==void 0?n.nextProducer=i:so.producers=i,s&&rA(t,i)}function Jk(){TI++}function eA(t){if(!(Kf(t)&&!t.dirty)&&!(!t.dirty&&t.lastCleanEpoch===TI)){if(!t.producerMustRecompute(t)&&!Kx(t)){SI(t);return}t.producerRecomputeValue(t),SI(t)}}function EI(t){if(t.consumers===void 0)return;let n=Gx;Gx=!0;try{for(let e=t.consumers;e!==void 0;e=e.nextConsumer){let r=e.consumer;r.dirty||yK(r)}}finally{Gx=n}}function NI(){return so?.consumerAllowSignalWrites!==!1}function yK(t){t.dirty=!0,EI(t),t.consumerMarkedDirty?.(t)}function SI(t){t.dirty=!1,t.lastCleanEpoch=TI}function qx(t){return t&&tA(t),Ot(t)}function tA(t){t.producersTail=void 0,t.recomputing=!0}function DI(t,n){Ot(n),t&&nA(t)}function nA(t){t.recomputing=!1;let n=t.producersTail,e=n!==void 0?n.nextProducer:t.producers;if(e!==void 0){if(Kf(t))do e=kI(e);while(e!==void 0);n!==void 0?n.nextProducer=void 0:t.producers=void 0}}function Kx(t){for(let n=t.producers;n!==void 0;n=n.nextProducer){let e=n.producer,r=n.lastReadVersion;if(r!==e.version||(eA(e),r!==e.version))return!0}return!1}function Yg(t){if(Kf(t)){let n=t.producers;for(;n!==void 0;)n=kI(n)}t.producers=void 0,t.producersTail=void 0,t.consumers=void 0,t.consumersTail=void 0}function rA(t,n){let e=t.consumersTail,r=Kf(t);if(e!==void 0?(n.nextConsumer=e.nextConsumer,e.nextConsumer=n):(n.nextConsumer=void 0,t.consumers=n),n.prevConsumer=e,t.consumersTail=n,!r)for(let o=t.producers;o!==void 0;o=o.nextProducer)rA(o.producer,o)}function kI(t){let n=t.producer,e=t.nextProducer,r=t.nextConsumer,o=t.prevConsumer;if(t.nextConsumer=void 0,t.prevConsumer=void 0,r!==void 0?r.prevConsumer=o:n.consumersTail=o,o!==void 0)o.nextConsumer=r;else if(n.consumers=r,!Kf(n)){let s=n.producers;for(;s!==void 0;)s=kI(s)}return e}function Kf(t){return t.consumerIsAlwaysLive||t.consumers!==void 0}function oA(t){gK?.(t)}function xK(t,n){let e=n.producersTail;if(e!==void 0){let r=n.producers;do{if(r===t)return!0;if(r===e)break;r=r.nextProducer}while(r!==void 0)}return!1}function sA(t,n){return Object.is(t,n)}function vK(){throw new Error}var iA=vK;function aA(t){iA(t)}function AI(t){iA=t}var bK=null;function _I(t,n){let e=Object.create(Xx);e.value=t,n!==void 0&&(e.equal=n);let r=()=>lA(e);return r[Ds]=e,oA(e),[r,i=>Zg(e,i),i=>cA(e,i)]}function lA(t){return Wx(t),t.value}function Zg(t,n){NI()||aA(t),t.equal(t.value,n)||(t.value=n,wK(t))}function cA(t,n){NI()||aA(t),Zg(t,n(t.value))}var Xx=Gn(Ye({},Hx),{equal:sA,value:void 0,kind:"signal"});function wK(t){t.version++,Jk(),EI(t),bK?.(t)}function RI(t){let n=Ot(null);try{return t()}finally{Ot(n)}}function Ct(t){return typeof t=="function"}function Xf(t){let e=t(r=>{Error.call(r),r.stack=new Error().stack});return e.prototype=Object.create(Error.prototype),e.prototype.constructor=e,e}var Yx=Xf(t=>function(e){t(this),this.message=e?`${e.length} errors occurred during unsubscription:
${e.map((r,o)=>`${o+1}) ${r.toString()}`).join(`
  `)}`:"",this.name="UnsubscriptionError",this.errors=e});function Qg(t,n){if(t){let e=t.indexOf(n);0<=e&&t.splice(e,1)}}var Wr=class t{constructor(n){this.initialTeardown=n,this.closed=!1,this._parentage=null,this._finalizers=null}unsubscribe(){let n;if(!this.closed){this.closed=!0;let{_parentage:e}=this;if(e)if(this._parentage=null,Array.isArray(e))for(let s of e)s.remove(this);else e.remove(this);let{initialTeardown:r}=this;if(Ct(r))try{r()}catch(s){n=s instanceof Yx?s.errors:[s]}let{_finalizers:o}=this;if(o){this._finalizers=null;for(let s of o)try{uA(s)}catch(i){n=n??[],i instanceof Yx?n=[...n,...i.errors]:n.push(i)}}if(n)throw new Yx(n)}}add(n){var e;if(n&&n!==this)if(this.closed)uA(n);else{if(n instanceof t){if(n.closed||n._hasParent(this))return;n._addParent(this)}(this._finalizers=(e=this._finalizers)!==null&&e!==void 0?e:[]).push(n)}}_hasParent(n){let{_parentage:e}=this;return e===n||Array.isArray(e)&&e.includes(n)}_addParent(n){let{_parentage:e}=this;this._parentage=Array.isArray(e)?(e.push(n),e):e?[e,n]:n}_removeParent(n){let{_parentage:e}=this;e===n?this._parentage=null:Array.isArray(e)&&Qg(e,n)}remove(n){let{_finalizers:e}=this;e&&Qg(e,n),n instanceof t&&n._removeParent(this)}};Wr.EMPTY=(()=>{let t=new Wr;return t.closed=!0,t})();var MI=Wr.EMPTY;function Zx(t){return t instanceof Wr||t&&"closed"in t&&Ct(t.remove)&&Ct(t.add)&&Ct(t.unsubscribe)}function uA(t){Ct(t)?t():t.unsubscribe()}var ti={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1};var Yf={setTimeout(t,n,...e){let{delegate:r}=Yf;return r?.setTimeout?r.setTimeout(t,n,...e):setTimeout(t,n,...e)},clearTimeout(t){let{delegate:n}=Yf;return(n?.clearTimeout||clearTimeout)(t)},delegate:void 0};function Qx(t){Yf.setTimeout(()=>{let{onUnhandledError:n}=ti;if(n)n(t);else throw t})}function Jg(){}var pA=OI("C",void 0,void 0);function fA(t){return OI("E",void 0,t)}function dA(t){return OI("N",t,void 0)}function OI(t,n,e){return{kind:t,value:n,error:e}}var Qu=null;function Zf(t){if(ti.useDeprecatedSynchronousErrorHandling){let n=!Qu;if(n&&(Qu={errorThrown:!1,error:null}),t(),n){let{errorThrown:e,error:r}=Qu;if(Qu=null,e)throw r}}else t()}function hA(t){ti.useDeprecatedSynchronousErrorHandling&&Qu&&(Qu.errorThrown=!0,Qu.error=t)}var Ju=class extends Wr{constructor(n){super(),this.isStopped=!1,n?(this.destination=n,Zx(n)&&n.add(this)):this.destination=SK}static create(n,e,r){return new Qf(n,e,r)}next(n){this.isStopped?$I(dA(n),this):this._next(n)}error(n){this.isStopped?$I(fA(n),this):(this.isStopped=!0,this._error(n))}complete(){this.isStopped?$I(pA,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(n){this.destination.next(n)}_error(n){try{this.destination.error(n)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}},CK=Function.prototype.bind;function FI(t,n){return CK.call(t,n)}var LI=class{constructor(n){this.partialObserver=n}next(n){let{partialObserver:e}=this;if(e.next)try{e.next(n)}catch(r){Jx(r)}}error(n){let{partialObserver:e}=this;if(e.error)try{e.error(n)}catch(r){Jx(r)}else Jx(n)}complete(){let{partialObserver:n}=this;if(n.complete)try{n.complete()}catch(e){Jx(e)}}},Qf=class extends Ju{constructor(n,e,r){super();let o;if(Ct(n)||!n)o={next:n??void 0,error:e??void 0,complete:r??void 0};else{let s;this&&ti.useDeprecatedNextContext?(s=Object.create(n),s.unsubscribe=()=>this.unsubscribe(),o={next:n.next&&FI(n.next,s),error:n.error&&FI(n.error,s),complete:n.complete&&FI(n.complete,s)}):o=n}this.destination=new LI(o)}};function Jx(t){ti.useDeprecatedSynchronousErrorHandling?hA(t):Qx(t)}function IK(t){throw t}function $I(t,n){let{onStoppedNotification:e}=ti;e&&Yf.setTimeout(()=>e(t,n))}var SK={closed:!0,next:Jg,error:IK,complete:Jg};var Jf=typeof Symbol=="function"&&Symbol.observable||"@@observable";function ni(t){return t}function PI(...t){return BI(t)}function BI(t){return t.length===0?ni:t.length===1?t[0]:function(e){return t.reduce((r,o)=>o(r),e)}}var tn=(()=>{class t{constructor(e){e&&(this._subscribe=e)}lift(e){let r=new t;return r.source=this,r.operator=e,r}subscribe(e,r,o){let s=EK(e)?e:new Qf(e,r,o);return Zf(()=>{let{operator:i,source:a}=this;s.add(i?i.call(s,a):a?this._subscribe(s):this._trySubscribe(s))}),s}_trySubscribe(e){try{return this._subscribe(e)}catch(r){e.error(r)}}forEach(e,r){return r=mA(r),new r((o,s)=>{let i=new Qf({next:a=>{try{e(a)}catch(l){s(l),i.unsubscribe()}},error:s,complete:o});this.subscribe(i)})}_subscribe(e){var r;return(r=this.source)===null||r===void 0?void 0:r.subscribe(e)}[Jf](){return this}pipe(...e){return BI(e)(this)}toPromise(e){return e=mA(e),new e((r,o)=>{let s;this.subscribe(i=>s=i,i=>o(i),()=>r(s))})}}return t.create=n=>new t(n),t})();function mA(t){var n;return(n=t??ti.Promise)!==null&&n!==void 0?n:Promise}function TK(t){return t&&Ct(t.next)&&Ct(t.error)&&Ct(t.complete)}function EK(t){return t&&t instanceof Ju||TK(t)&&Zx(t)}function NK(t){return Ct(t?.lift)}function fn(t){return n=>{if(NK(n))return n.lift(function(e){try{return t(e,this)}catch(r){this.error(r)}});throw new TypeError("Unable to lift unknown Observable type")}}function vn(t,n,e,r,o){return new zI(t,n,e,r,o)}var zI=class extends Ju{constructor(n,e,r,o,s,i){super(n),this.onFinalize=s,this.shouldUnsubscribe=i,this._next=e?function(a){try{e(a)}catch(l){n.error(l)}}:super._next,this._error=o?function(a){try{o(a)}catch(l){n.error(l)}finally{this.unsubscribe()}}:super._error,this._complete=r?function(){try{r()}catch(a){n.error(a)}finally{this.unsubscribe()}}:super._complete}unsubscribe(){var n;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){let{closed:e}=this;super.unsubscribe(),!e&&((n=this.onFinalize)===null||n===void 0||n.call(this))}}};var gA=Xf(t=>function(){t(this),this.name="ObjectUnsubscribedError",this.message="object unsubscribed"});var qr=(()=>{class t extends tn{constructor(){super(),this.closed=!1,this.currentObservers=null,this.observers=[],this.isStopped=!1,this.hasError=!1,this.thrownError=null}lift(e){let r=new e0(this,this);return r.operator=e,r}_throwIfClosed(){if(this.closed)throw new gA}next(e){Zf(()=>{if(this._throwIfClosed(),!this.isStopped){this.currentObservers||(this.currentObservers=Array.from(this.observers));for(let r of this.currentObservers)r.next(e)}})}error(e){Zf(()=>{if(this._throwIfClosed(),!this.isStopped){this.hasError=this.isStopped=!0,this.thrownError=e;let{observers:r}=this;for(;r.length;)r.shift().error(e)}})}complete(){Zf(()=>{if(this._throwIfClosed(),!this.isStopped){this.isStopped=!0;let{observers:e}=this;for(;e.length;)e.shift().complete()}})}unsubscribe(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null}get observed(){var e;return((e=this.observers)===null||e===void 0?void 0:e.length)>0}_trySubscribe(e){return this._throwIfClosed(),super._trySubscribe(e)}_subscribe(e){return this._throwIfClosed(),this._checkFinalizedStatuses(e),this._innerSubscribe(e)}_innerSubscribe(e){let{hasError:r,isStopped:o,observers:s}=this;return r||o?MI:(this.currentObservers=null,s.push(e),new Wr(()=>{this.currentObservers=null,Qg(s,e)}))}_checkFinalizedStatuses(e){let{hasError:r,thrownError:o,isStopped:s}=this;r?e.error(o):s&&e.complete()}asObservable(){let e=new tn;return e.source=this,e}}return t.create=(n,e)=>new e0(n,e),t})(),e0=class extends qr{constructor(n,e){super(),this.destination=n,this.source=e}next(n){var e,r;(r=(e=this.destination)===null||e===void 0?void 0:e.next)===null||r===void 0||r.call(e,n)}error(n){var e,r;(r=(e=this.destination)===null||e===void 0?void 0:e.error)===null||r===void 0||r.call(e,n)}complete(){var n,e;(e=(n=this.destination)===null||n===void 0?void 0:n.complete)===null||e===void 0||e.call(n)}_subscribe(n){var e,r;return(r=(e=this.source)===null||e===void 0?void 0:e.subscribe(n))!==null&&r!==void 0?r:MI}};var Kr=class extends qr{constructor(n){super(),this._value=n}get value(){return this.getValue()}_subscribe(n){let e=super._subscribe(n);return!e.closed&&n.next(this._value),e}getValue(){let{hasError:n,thrownError:e,_value:r}=this;if(n)throw e;return this._throwIfClosed(),r}next(n){super.next(this._value=n)}};var Xr=new tn(t=>t.complete());function yA(t){return t&&Ct(t.schedule)}function xA(t){return t[t.length-1]}function vA(t){return Ct(xA(t))?t.pop():void 0}function rc(t){return yA(xA(t))?t.pop():void 0}function wA(t,n,e,r){function o(s){return s instanceof e?s:new e(function(i){i(s)})}return new(e||(e=Promise))(function(s,i){function a(u){try{c(r.next(u))}catch(p){i(p)}}function l(u){try{c(r.throw(u))}catch(p){i(p)}}function c(u){u.done?s(u.value):o(u.value).then(a,l)}c((r=r.apply(t,n||[])).next())})}function bA(t){var n=typeof Symbol=="function"&&Symbol.iterator,e=n&&t[n],r=0;if(e)return e.call(t);if(t&&typeof t.length=="number")return{next:function(){return t&&r>=t.length&&(t=void 0),{value:t&&t[r++],done:!t}}};throw new TypeError(n?"Object is not iterable.":"Symbol.iterator is not defined.")}function ep(t){return this instanceof ep?(this.v=t,this):new ep(t)}function CA(t,n,e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var r=e.apply(t,n||[]),o,s=[];return o=Object.create((typeof AsyncIterator=="function"?AsyncIterator:Object).prototype),a("next"),a("throw"),a("return",i),o[Symbol.asyncIterator]=function(){return this},o;function i(d){return function(h){return Promise.resolve(h).then(d,p)}}function a(d,h){r[d]&&(o[d]=function(g){return new Promise(function(m,y){s.push([d,g,m,y])>1||l(d,g)})},h&&(o[d]=h(o[d])))}function l(d,h){try{c(r[d](h))}catch(g){f(s[0][3],g)}}function c(d){d.value instanceof ep?Promise.resolve(d.value.v).then(u,p):f(s[0][2],d)}function u(d){l("next",d)}function p(d){l("throw",d)}function f(d,h){d(h),s.shift(),s.length&&l(s[0][0],s[0][1])}}function IA(t){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var n=t[Symbol.asyncIterator],e;return n?n.call(t):(t=typeof bA=="function"?bA(t):t[Symbol.iterator](),e={},r("next"),r("throw"),r("return"),e[Symbol.asyncIterator]=function(){return this},e);function r(s){e[s]=t[s]&&function(i){return new Promise(function(a,l){i=t[s](i),o(a,l,i.done,i.value)})}}function o(s,i,a,l){Promise.resolve(l).then(function(c){s({value:c,done:a})},i)}}var t0=t=>t&&typeof t.length=="number"&&typeof t!="function";function n0(t){return Ct(t?.then)}function r0(t){return Ct(t[Jf])}function o0(t){return Symbol.asyncIterator&&Ct(t?.[Symbol.asyncIterator])}function s0(t){return new TypeError(`You provided ${t!==null&&typeof t=="object"?"an invalid object":`'${t}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`)}function DK(){return typeof Symbol!="function"||!Symbol.iterator?"@@iterator":Symbol.iterator}var i0=DK();function a0(t){return Ct(t?.[i0])}function l0(t){return CA(this,arguments,function*(){let e=t.getReader();try{for(;;){let{value:r,done:o}=yield ep(e.read());if(o)return yield ep(void 0);yield yield ep(r)}}finally{e.releaseLock()}})}function c0(t){return Ct(t?.getReader)}function _r(t){if(t instanceof tn)return t;if(t!=null){if(r0(t))return kK(t);if(t0(t))return AK(t);if(n0(t))return _K(t);if(o0(t))return SA(t);if(a0(t))return RK(t);if(c0(t))return MK(t)}throw s0(t)}function kK(t){return new tn(n=>{let e=t[Jf]();if(Ct(e.subscribe))return e.subscribe(n);throw new TypeError("Provided object does not correctly implement Symbol.observable")})}function AK(t){return new tn(n=>{for(let e=0;e<t.length&&!n.closed;e++)n.next(t[e]);n.complete()})}function _K(t){return new tn(n=>{t.then(e=>{n.closed||(n.next(e),n.complete())},e=>n.error(e)).then(null,Qx)})}function RK(t){return new tn(n=>{for(let e of t)if(n.next(e),n.closed)return;n.complete()})}function SA(t){return new tn(n=>{OK(t,n).catch(e=>n.error(e))})}function MK(t){return SA(l0(t))}function OK(t,n){var e,r,o,s;return wA(this,void 0,void 0,function*(){try{for(e=IA(t);r=yield e.next(),!r.done;){let i=r.value;if(n.next(i),n.closed)return}}catch(i){o={error:i}}finally{try{r&&!r.done&&(s=e.return)&&(yield s.call(e))}finally{if(o)throw o.error}}n.complete()})}function Go(t,n,e,r=0,o=!1){let s=n.schedule(function(){e(),o?t.add(this.schedule(null,r)):this.unsubscribe()},r);if(t.add(s),!o)return s}function u0(t,n=0){return fn((e,r)=>{e.subscribe(vn(r,o=>Go(r,t,()=>r.next(o),n),()=>Go(r,t,()=>r.complete(),n),o=>Go(r,t,()=>r.error(o),n)))})}function p0(t,n=0){return fn((e,r)=>{r.add(t.schedule(()=>e.subscribe(r),n))})}function TA(t,n){return _r(t).pipe(p0(n),u0(n))}function EA(t,n){return _r(t).pipe(p0(n),u0(n))}function NA(t,n){return new tn(e=>{let r=0;return n.schedule(function(){r===t.length?e.complete():(e.next(t[r++]),e.closed||this.schedule())})})}function DA(t,n){return new tn(e=>{let r;return Go(e,n,()=>{r=t[i0](),Go(e,n,()=>{let o,s;try{({value:o,done:s}=r.next())}catch(i){e.error(i);return}s?e.complete():e.next(o)},0,!0)}),()=>Ct(r?.return)&&r.return()})}function f0(t,n){if(!t)throw new Error("Iterable cannot be null");return new tn(e=>{Go(e,n,()=>{let r=t[Symbol.asyncIterator]();Go(e,n,()=>{r.next().then(o=>{o.done?e.complete():e.next(o.value)})},0,!0)})})}function kA(t,n){return f0(l0(t),n)}function AA(t,n){if(t!=null){if(r0(t))return TA(t,n);if(t0(t))return NA(t,n);if(n0(t))return EA(t,n);if(o0(t))return f0(t,n);if(a0(t))return DA(t,n);if(c0(t))return kA(t,n)}throw s0(t)}function Rr(t,n){return n?AA(t,n):_r(t)}function Gt(...t){let n=rc(t);return Rr(t,n)}function VI(t,n){let e=Ct(t)?t:()=>t,r=o=>o.error(e());return new tn(n?o=>n.schedule(r,0,o):r)}function d0(t){return!!t&&(t instanceof tn||Ct(t.lift)&&Ct(t.subscribe))}var tp=Xf(t=>function(){t(this),this.name="EmptyError",this.message="no elements in sequence"});function Yn(t,n){return fn((e,r)=>{let o=0;e.subscribe(vn(r,s=>{r.next(t.call(n,s,o++))}))})}var{isArray:FK}=Array;function $K(t,n){return FK(n)?t(...n):t(n)}function _A(t){return Yn(n=>$K(t,n))}var{isArray:LK}=Array,{getPrototypeOf:PK,prototype:BK,keys:zK}=Object;function RA(t){if(t.length===1){let n=t[0];if(LK(n))return{args:n,keys:null};if(VK(n)){let e=zK(n);return{args:e.map(r=>n[r]),keys:e}}}return{args:t,keys:null}}function VK(t){return t&&typeof t=="object"&&PK(t)===BK}function MA(t,n){return t.reduce((e,r,o)=>(e[r]=n[o],e),{})}function UI(...t){let n=rc(t),e=vA(t),{args:r,keys:o}=RA(t);if(r.length===0)return Rr([],n);let s=new tn(UK(r,n,o?i=>MA(o,i):ni));return e?s.pipe(_A(e)):s}function UK(t,n,e=ni){return r=>{OA(n,()=>{let{length:o}=t,s=new Array(o),i=o,a=o;for(let l=0;l<o;l++)OA(n,()=>{let c=Rr(t[l],n),u=!1;c.subscribe(vn(r,p=>{s[l]=p,u||(u=!0,a--),a||r.next(e(s.slice()))},()=>{--i||r.complete()}))},r)},r)}}function OA(t,n,e){t?Go(e,t,n):n()}function FA(t,n,e,r,o,s,i,a){let l=[],c=0,u=0,p=!1,f=()=>{p&&!l.length&&!c&&n.complete()},d=g=>c<r?h(g):l.push(g),h=g=>{s&&n.next(g),c++;let m=!1;_r(e(g,u++)).subscribe(vn(n,y=>{o?.(y),s?d(y):n.next(y)},()=>{m=!0},void 0,()=>{if(m)try{for(c--;l.length&&c<r;){let y=l.shift();i?Go(n,i,()=>h(y)):h(y)}f()}catch(y){n.error(y)}}))};return t.subscribe(vn(n,d,()=>{p=!0,f()})),()=>{a?.()}}function To(t,n,e=1/0){return Ct(n)?To((r,o)=>Yn((s,i)=>n(r,s,o,i))(_r(t(r,o))),e):(typeof n=="number"&&(e=n),fn((r,o)=>FA(r,o,t,e)))}function $A(t=1/0){return To(ni,t)}function LA(){return $A(1)}function ed(...t){return LA()(Rr(t,rc(t)))}function ey(t){return new tn(n=>{_r(t()).subscribe(n)})}function Ca(t,n){return fn((e,r)=>{let o=0;e.subscribe(vn(r,s=>t.call(n,s,o++)&&r.next(s)))})}function ty(t){return fn((n,e)=>{let r=null,o=!1,s;r=n.subscribe(vn(e,void 0,void 0,i=>{s=_r(t(i,ty(t)(n))),r?(r.unsubscribe(),r=null,s.subscribe(e)):o=!0})),o&&(r.unsubscribe(),r=null,s.subscribe(e))})}function h0(t,n){return Ct(n)?To(t,n,1):To(t,1)}function PA(t){return fn((n,e)=>{let r=!1;n.subscribe(vn(e,o=>{r=!0,e.next(o)},()=>{r||e.next(t),e.complete()}))})}function Ia(t){return t<=0?()=>Xr:fn((n,e)=>{let r=0;n.subscribe(vn(e,o=>{++r<=t&&(e.next(o),t<=r&&e.complete())}))})}function BA(t=GK){return fn((n,e)=>{let r=!1;n.subscribe(vn(e,o=>{r=!0,e.next(o)},()=>r?e.complete():e.error(t())))})}function GK(){return new tp}function GI(t){return fn((n,e)=>{try{n.subscribe(e)}finally{e.add(t)}})}function Sa(t,n){let e=arguments.length>=2;return r=>r.pipe(t?Ca((o,s)=>t(o,s,r)):ni,Ia(1),e?PA(n):BA(()=>new tp))}function m0(t){return t<=0?()=>Xr:fn((n,e)=>{let r=[];n.subscribe(vn(e,o=>{r.push(o),t<r.length&&r.shift()},()=>{for(let o of r)e.next(o);e.complete()},void 0,()=>{r=null}))})}function jI(...t){let n=rc(t);return fn((e,r)=>{(n?ed(t,e,n):ed(t,e)).subscribe(r)})}function Ta(t,n){return fn((e,r)=>{let o=null,s=0,i=!1,a=()=>i&&!o&&r.complete();e.subscribe(vn(r,l=>{o?.unsubscribe();let c=0,u=s++;_r(t(l,u)).subscribe(o=vn(r,p=>r.next(n?n(l,p,u,c++):p),()=>{o=null,a()}))},()=>{i=!0,a()}))})}function ny(t){return fn((n,e)=>{_r(t).subscribe(vn(e,()=>e.complete(),Jg)),!e.closed&&n.subscribe(e)})}function Fi(t,n,e){let r=Ct(t)||n||e?{next:t,error:n,complete:e}:t;return r?fn((o,s)=>{var i;(i=r.subscribe)===null||i===void 0||i.call(r);let a=!0;o.subscribe(vn(s,l=>{var c;(c=r.next)===null||c===void 0||c.call(r,l),s.next(l)},()=>{var l;a=!1,(l=r.complete)===null||l===void 0||l.call(r),s.complete()},l=>{var c;a=!1,(c=r.error)===null||c===void 0||c.call(r,l),s.error(l)},()=>{var l,c;a&&((l=r.unsubscribe)===null||l===void 0||l.call(r)),(c=r.finalize)===null||c===void 0||c.call(r)}))}):ni}var HI;function g0(){return HI}function $i(t){let n=HI;return HI=t,n}var zA=Symbol("NotFound");function td(t){return t===zA||t?.name==="\u0275NotFound"}var iS="https://angular.dev/best-practices/security#preventing-cross-site-scripting-xss",it=class extends Error{code;constructor(n,e){super(ly(n,e)),this.code=n}};function qK(t){return`NG0${Math.abs(t)}`}function ly(t,n){return`${qK(t)}${n?": "+n:""}`}function dn(t){for(let n in t)if(t[n]===dn)return n;throw Error("")}function Na(t){if(typeof t=="string")return t;if(Array.isArray(t))return`[${t.map(Na).join(", ")}]`;if(t==null)return""+t;let n=t.overriddenName||t.name;if(n)return`${n}`;let e=t.toString();if(e==null)return""+e;let r=e.indexOf(`
`);return r>=0?e.slice(0,r):e}function aS(t,n){return t?n?`${t} ${n}`:t:n||""}var KK=dn({__forward_ref__:dn});function w0(t){return t.__forward_ref__=w0,t.toString=function(){return Na(this())},t}function Yr(t){return lS(t)?t():t}function lS(t){return typeof t=="function"&&t.hasOwnProperty(KK)&&t.__forward_ref__===w0}function pt(t){return{token:t.token,providedIn:t.providedIn||null,factory:t.factory,value:void 0}}function ri(t){return{providers:t.providers||[],imports:t.imports||[]}}function cy(t){return XK(t,C0)}function cS(t){return cy(t)!==null}function XK(t,n){return t.hasOwnProperty(n)&&t[n]||null}function YK(t){let n=t?.[C0]??null;return n||null}function qI(t){return t&&t.hasOwnProperty(x0)?t[x0]:null}var C0=dn({\u0275prov:dn}),x0=dn({\u0275inj:dn}),nt=class{_desc;ngMetadataName="InjectionToken";\u0275prov;constructor(n,e){this._desc=n,this.\u0275prov=void 0,typeof e=="number"?this.__NG_ELEMENT_ID__=e:e!==void 0&&(this.\u0275prov=pt({token:this,providedIn:e.providedIn||"root",factory:e.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}};function uS(t){return t&&!!t.\u0275providers}var pS=dn({\u0275cmp:dn}),fS=dn({\u0275dir:dn}),dS=dn({\u0275pipe:dn}),hS=dn({\u0275mod:dn}),oy=dn({\u0275fac:dn}),ap=dn({__NG_ELEMENT_ID__:dn}),VA=dn({__NG_ENV_ID__:dn});function mS(t){return I0(t,"@NgModule"),t[hS]||null}function sc(t){return I0(t,"@Component"),t[pS]||null}function gS(t){return I0(t,"@Directive"),t[fS]||null}function HA(t){return I0(t,"@Pipe"),t[dS]||null}function I0(t,n){if(t==null)throw new it(-919,!1)}function WA(t){return typeof t=="string"?t:t==null?"":String(t)}var qA=dn({ngErrorCode:dn}),ZK=dn({ngErrorMessage:dn}),QK=dn({ngTokenPath:dn});function yS(t,n){return KA("",-200,n)}function S0(t,n){throw new it(-201,!1)}function KA(t,n,e){let r=new it(n,t);return r[qA]=n,r[ZK]=t,e&&(r[QK]=e),r}function JK(t){return t[qA]}var KI;function XA(){return KI}function hs(t){let n=KI;return KI=t,n}function xS(t,n,e){let r=cy(t);if(r&&r.providedIn=="root")return r.value===void 0?r.value=r.factory():r.value;if(e&8)return null;if(n!==void 0)return n;S0(t,"")}var eX={},np=eX,tX="__NG_DI_FLAG__",XI=class{injector;constructor(n){this.injector=n}retrieve(n,e){let r=rp(e)||0;try{return this.injector.get(n,r&8?null:np,r)}catch(o){if(td(o))return o;throw o}}};function nX(t,n=0){let e=g0();if(e===void 0)throw new it(-203,!1);if(e===null)return xS(t,void 0,n);{let r=rX(n),o=e.retrieve(t,r);if(td(o)){if(r.optional)return null;throw o}return o}}function At(t,n=0){return(XA()||nX)(Yr(t),n)}function Ae(t,n){return At(t,rp(n))}function rp(t){return typeof t>"u"||typeof t=="number"?t:0|(t.optional&&8)|(t.host&&1)|(t.self&&2)|(t.skipSelf&&4)}function rX(t){return{optional:!!(t&8),host:!!(t&1),self:!!(t&2),skipSelf:!!(t&4)}}function YI(t){let n=[];for(let e=0;e<t.length;e++){let r=Yr(t[e]);if(Array.isArray(r)){if(r.length===0)throw new it(900,!1);let o,s=0;for(let i=0;i<r.length;i++){let a=r[i],l=oX(a);typeof l=="number"?l===-1?o=a.token:s|=l:o=a}n.push(At(o,s))}else n.push(At(r))}return n}function oX(t){return t[tX]}function op(t,n){let e=t.hasOwnProperty(oy);return e?t[oy]:null}function YA(t,n,e){if(t.length!==n.length)return!1;for(let r=0;r<t.length;r++){let o=t[r],s=n[r];if(e&&(o=e(o),s=e(s)),s!==o)return!1}return!0}function ZA(t){return t.flat(Number.POSITIVE_INFINITY)}function T0(t,n){t.forEach(e=>Array.isArray(e)?T0(e,n):n(e))}function vS(t,n,e){n>=t.length?t.push(e):t.splice(n,0,e)}function uy(t,n){return n>=t.length-1?t.pop():t.splice(n,1)[0]}function QA(t,n){let e=[];for(let r=0;r<t;r++)e.push(n);return e}function JA(t,n,e,r){let o=t.length;if(o==n)t.push(e,r);else if(o===1)t.push(r,t[0]),t[0]=e;else{for(o--,t.push(t[o-1],t[o]);o>n;){let s=o-2;t[o]=t[s],o--}t[n]=e,t[n+1]=r}}function e_(t,n,e){let r=od(t,n);return r>=0?t[r|1]=e:(r=~r,JA(t,r,n,e)),r}function E0(t,n){let e=od(t,n);if(e>=0)return t[e|1]}function od(t,n){return sX(t,n,1)}function sX(t,n,e){let r=0,o=t.length>>e;for(;o!==r;){let s=r+(o-r>>1),i=t[s<<e];if(n===i)return s<<e;i>n?o=s:r=s+1}return~(o<<e)}var lp={},ks=[],cp=new nt(""),bS=new nt("",-1),wS=new nt(""),sy=class{get(n,e=np){if(e===np){let o=KA("",-201);throw o.name="\u0275NotFound",o}return e}};function sd(t){return{\u0275providers:t}}function t_(t){return sd([{provide:cp,multi:!0,useValue:t}])}function n_(...t){return{\u0275providers:CS(!0,t),\u0275fromNgModule:!0}}function CS(t,...n){let e=[],r=new Set,o,s=i=>{e.push(i)};return T0(n,i=>{let a=i;v0(a,s,[],r)&&(o||=[],o.push(a))}),o!==void 0&&r_(o,s),e}function r_(t,n){for(let e=0;e<t.length;e++){let{ngModule:r,providers:o}=t[e];IS(o,s=>{n(s,r)})}}function v0(t,n,e,r){if(t=Yr(t),!t)return!1;let o=null,s=qI(t),i=!s&&sc(t);if(!s&&!i){let l=t.ngModule;if(s=qI(l),s)o=l;else return!1}else{if(i&&!i.standalone)return!1;o=t}let a=r.has(o);if(i){if(a)return!1;if(r.add(o),i.dependencies){let l=typeof i.dependencies=="function"?i.dependencies():i.dependencies;for(let c of l)v0(c,n,e,r)}}else if(s){if(s.imports!=null&&!a){r.add(o);let c;T0(s.imports,u=>{v0(u,n,e,r)&&(c||=[],c.push(u))}),c!==void 0&&r_(c,n)}if(!a){let c=op(o)||(()=>new o);n({provide:o,useFactory:c,deps:ks},o),n({provide:wS,useValue:o,multi:!0},o),n({provide:cp,useValue:()=>At(o),multi:!0},o)}let l=s.providers;if(l!=null&&!a){let c=t;IS(l,u=>{n(u,c)})}}else return!1;return o!==t&&t.providers!==void 0}function IS(t,n){for(let e of t)uS(e)&&(e=e.\u0275providers),Array.isArray(e)?IS(e,n):n(e)}var iX=dn({provide:String,useValue:dn});function o_(t){return t!==null&&typeof t=="object"&&iX in t}function aX(t){return!!(t&&t.useExisting)}function lX(t){return!!(t&&t.useFactory)}function sp(t){return typeof t=="function"}function s_(t){return!!t.useClass}var py=new nt(""),y0={},UA={},WI;function fy(){return WI===void 0&&(WI=new sy),WI}var Cr=class{},ip=class extends Cr{parent;source;scopes;records=new Map;_ngOnDestroyHooks=new Set;_onDestroyHooks=[];get destroyed(){return this._destroyed}_destroyed=!1;injectorDefTypes;constructor(n,e,r,o){super(),this.parent=e,this.source=r,this.scopes=o,QI(n,i=>this.processProvider(i)),this.records.set(bS,nd(void 0,this)),o.has("environment")&&this.records.set(Cr,nd(void 0,this));let s=this.records.get(py);s!=null&&typeof s.value=="string"&&this.scopes.add(s.value),this.injectorDefTypes=new Set(this.get(wS,ks,{self:!0}))}retrieve(n,e){let r=rp(e)||0;try{return this.get(n,np,r)}catch(o){if(td(o))return o;throw o}}destroy(){ry(this),this._destroyed=!0;let n=Ot(null);try{for(let r of this._ngOnDestroyHooks)r.ngOnDestroy();let e=this._onDestroyHooks;this._onDestroyHooks=[];for(let r of e)r()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear(),Ot(n)}}onDestroy(n){return ry(this),this._onDestroyHooks.push(n),()=>this.removeOnDestroy(n)}runInContext(n){ry(this);let e=$i(this),r=hs(void 0),o;try{return n()}finally{$i(e),hs(r)}}get(n,e=np,r){if(ry(this),n.hasOwnProperty(VA))return n[VA](this);let o=rp(r),s,i=$i(this),a=hs(void 0);try{if(!(o&4)){let c=this.records.get(n);if(c===void 0){let u=dX(n)&&cy(n);u&&this.injectableDefInScope(u)?c=nd(ZI(n),y0):c=null,this.records.set(n,c)}if(c!=null)return this.hydrate(n,c,o)}let l=o&2?fy():this.parent;return e=o&8&&e===np?null:e,l.get(n,e)}catch(l){let c=JK(l);throw c===-200||c===-201?new it(c,null):l}finally{hs(a),$i(i)}}resolveInjectorInitializers(){let n=Ot(null),e=$i(this),r=hs(void 0),o;try{let s=this.get(cp,ks,{self:!0});for(let i of s)i()}finally{$i(e),hs(r),Ot(n)}}toString(){let n=[],e=this.records;for(let r of e.keys())n.push(Na(r));return`R3Injector[${n.join(", ")}]`}processProvider(n){n=Yr(n);let e=sp(n)?n:Yr(n&&n.provide),r=uX(n);if(!sp(n)&&n.multi===!0){let o=this.records.get(e);o||(o=nd(void 0,y0,!0),o.factory=()=>YI(o.multi),this.records.set(e,o)),e=n,o.multi.push(n)}this.records.set(e,r)}hydrate(n,e,r){let o=Ot(null);try{if(e.value===UA)throw yS(Na(n));return e.value===y0&&(e.value=UA,e.value=e.factory(void 0,r)),typeof e.value=="object"&&e.value&&fX(e.value)&&this._ngOnDestroyHooks.add(e.value),e.value}finally{Ot(o)}}injectableDefInScope(n){if(!n.providedIn)return!1;let e=Yr(n.providedIn);return typeof e=="string"?e==="any"||this.scopes.has(e):this.injectorDefTypes.has(e)}removeOnDestroy(n){let e=this._onDestroyHooks.indexOf(n);e!==-1&&this._onDestroyHooks.splice(e,1)}};function ZI(t){let n=cy(t),e=n!==null?n.factory:op(t);if(e!==null)return e;if(t instanceof nt)throw new it(204,!1);if(t instanceof Function)return cX(t);throw new it(204,!1)}function cX(t){if(t.length>0)throw new it(204,!1);let e=YK(t);return e!==null?()=>e.factory(t):()=>new t}function uX(t){if(o_(t))return nd(void 0,t.useValue);{let n=SS(t);return nd(n,y0)}}function SS(t,n,e){let r;if(sp(t)){let o=Yr(t);return op(o)||ZI(o)}else if(o_(t))r=()=>Yr(t.useValue);else if(lX(t))r=()=>t.useFactory(...YI(t.deps||[]));else if(aX(t))r=(o,s)=>At(Yr(t.useExisting),s!==void 0&&s&8?8:void 0);else{let o=Yr(t&&(t.useClass||t.provide));if(pX(t))r=()=>new o(...YI(t.deps));else return op(o)||ZI(o)}return r}function ry(t){if(t.destroyed)throw new it(205,!1)}function nd(t,n,e=!1){return{factory:t,value:n,multi:e?[]:void 0}}function pX(t){return!!t.deps}function fX(t){return t!==null&&typeof t=="object"&&typeof t.ngOnDestroy=="function"}function dX(t){return typeof t=="function"||typeof t=="object"&&t.ngMetadataName==="InjectionToken"}function QI(t,n){for(let e of t)Array.isArray(e)?QI(e,n):e&&uS(e)?QI(e.\u0275providers,n):n(e)}function io(t,n){let e;t instanceof ip?(ry(t),e=t):e=new XI(t);let r,o=$i(e),s=hs(void 0);try{return n()}finally{$i(o),hs(s)}}function i_(){return XA()!==void 0||g0()!=null}var oi=0,yt=1,It=2,Mr=3,As=4,Eo=5,id=6,ad=7,No=8,ic=9,ka=10,Or=11,ld=12,TS=13,cd=14,jo=15,ac=16,up=17,Pi=18,lc=19,ES=20,Ea=21,N0=22,dy=23,gs=24,D0=25,hy=26,ao=27,a_=1;var cc=7,my=8,pp=9,Do=10;function Aa(t){return Array.isArray(t)&&typeof t[a_]=="object"}function si(t){return Array.isArray(t)&&t[a_]===!0}function NS(t){return(t.flags&4)!==0}function fp(t){return t.componentOffset>-1}function k0(t){return(t.flags&1)===1}function uc(t){return!!t.template}function ud(t){return(t[It]&512)!==0}function dp(t){return(t[It]&256)===256}var l_="svg",c_="math";function _s(t){for(;Array.isArray(t);)t=t[oi];return t}function u_(t,n){return _s(n[t])}function Bi(t,n){return _s(n[t.index])}function A0(t,n){return t.data[n]}function zi(t,n){let e=n[t];return Aa(e)?e:e[oi]}function p_(t){return(t[It]&4)===4}function _0(t){return(t[It]&128)===128}function f_(t){return si(t[Mr])}function pd(t,n){return n==null?null:t[n]}function DS(t){t[up]=0}function kS(t){t[It]&1024||(t[It]|=1024,_0(t)&&yy(t))}function gy(t){return!!(t[It]&9216||t[gs]?.dirty)}function R0(t){t[ka].changeDetectionScheduler?.notify(8),t[It]&64&&(t[It]|=1024),gy(t)&&yy(t)}function yy(t){t[ka].changeDetectionScheduler?.notify(0);let n=oc(t);for(;n!==null&&!(n[It]&8192||(n[It]|=8192,!_0(n)));)n=oc(n)}function AS(t,n){if(dp(t))throw new it(911,!1);t[Ea]===null&&(t[Ea]=[]),t[Ea].push(n)}function d_(t,n){if(t[Ea]===null)return;let e=t[Ea].indexOf(n);e!==-1&&t[Ea].splice(e,1)}function oc(t){let n=t[Mr];return si(n)?n[Mr]:n}function _S(t){return t[ad]??=[]}function RS(t){return t.cleanup??=[]}function h_(t,n,e,r){let o=_S(n);o.push(e),t.firstCreatePass&&RS(t).push(r,o.length-1)}var Vt={lFrame:N_(null),bindingsEnabled:!0,skipHydrationRootTNode:null};var JI=!1;function m_(){return Vt.lFrame.elementDepthCount}function g_(){Vt.lFrame.elementDepthCount++}function MS(){Vt.lFrame.elementDepthCount--}function y_(){return Vt.bindingsEnabled}function OS(){return Vt.skipHydrationRootTNode!==null}function FS(t){return Vt.skipHydrationRootTNode===t}function $S(){Vt.skipHydrationRootTNode=null}function Ln(){return Vt.lFrame.lView}function Rs(){return Vt.lFrame.tView}function fd(t){return Vt.lFrame.contextLView=t,t[No]}function dd(t){return Vt.lFrame.contextLView=null,t}function ys(){let t=LS();for(;t!==null&&t.type===64;)t=t.parent;return t}function LS(){return Vt.lFrame.currentTNode}function x_(){let t=Vt.lFrame,n=t.currentTNode;return t.isParent?n:n.parent}function hd(t,n){let e=Vt.lFrame;e.currentTNode=t,e.isParent=n}function PS(){return Vt.lFrame.isParent}function BS(){Vt.lFrame.isParent=!1}function zS(){return JI}function VS(t){let n=JI;return JI=t,n}function v_(t){return Vt.lFrame.bindingIndex=t}function b_(){return Vt.lFrame.bindingIndex++}function w_(t){let n=Vt.lFrame,e=n.bindingIndex;return n.bindingIndex=n.bindingIndex+t,e}function C_(){return Vt.lFrame.inI18n}function I_(t,n){let e=Vt.lFrame;e.bindingIndex=e.bindingRootIndex=t,M0(n)}function S_(){return Vt.lFrame.currentDirectiveIndex}function M0(t){Vt.lFrame.currentDirectiveIndex=t}function T_(t){let n=Vt.lFrame.currentDirectiveIndex;return n===-1?null:t[n]}function US(){return Vt.lFrame.currentQueryIndex}function O0(t){Vt.lFrame.currentQueryIndex=t}function hX(t){let n=t[yt];return n.type===2?n.declTNode:n.type===1?t[Eo]:null}function GS(t,n,e){if(e&4){let o=n,s=t;for(;o=o.parent,o===null&&!(e&1);)if(o=hX(s),o===null||(s=s[cd],o.type&10))break;if(o===null)return!1;n=o,t=s}let r=Vt.lFrame=E_();return r.currentTNode=n,r.lView=t,!0}function F0(t){let n=E_(),e=t[yt];Vt.lFrame=n,n.currentTNode=e.firstChild,n.lView=t,n.tView=e,n.contextLView=t,n.bindingIndex=e.bindingStartIndex,n.inI18n=!1}function E_(){let t=Vt.lFrame,n=t===null?null:t.child;return n===null?N_(t):n}function N_(t){let n={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:t,child:null,inI18n:!1};return t!==null&&(t.child=n),n}function D_(){let t=Vt.lFrame;return Vt.lFrame=t.parent,t.currentTNode=null,t.lView=null,t}var jS=D_;function $0(){let t=D_();t.isParent=!0,t.tView=null,t.selectedIndex=-1,t.contextLView=null,t.elementDepthCount=0,t.currentDirectiveIndex=-1,t.currentNamespace=null,t.bindingRootIndex=-1,t.bindingIndex=-1,t.currentQueryIndex=0}function xy(){return Vt.lFrame.selectedIndex}function pc(t){Vt.lFrame.selectedIndex=t}function k_(){let t=Vt.lFrame;return A0(t.tView,t.selectedIndex)}function A_(){return Vt.lFrame.currentNamespace}var __=!0;function L0(){return __}function P0(t){__=t}function eS(t,n=null,e=null,r){let o=HS(t,n,e,r);return o.resolveInjectorInitializers(),o}function HS(t,n=null,e=null,r,o=new Set){let s=[e||ks,n_(t)];return r=r||(typeof t=="object"?void 0:Na(t)),new ip(s,n||fy(),r||null,o)}var Li=class t{static THROW_IF_NOT_FOUND=np;static NULL=new sy;static create(n,e){if(Array.isArray(n))return eS({name:""},e,n,"");{let r=n.name??"";return eS({name:r},n.parent,n.providers,r)}}static \u0275prov=pt({token:t,providedIn:"any",factory:()=>At(bS)});static __NG_ELEMENT_ID__=-1},lr=new nt(""),fc=(()=>{class t{static __NG_ELEMENT_ID__=mX;static __NG_ENV_ID__=e=>e}return t})(),tS=class extends fc{_lView;constructor(n){super(),this._lView=n}get destroyed(){return dp(this._lView)}onDestroy(n){let e=this._lView;return AS(e,n),()=>d_(e,n)}};function mX(){return new tS(Ln())}var R_=!1,M_=new nt(""),dc=(()=>{class t{taskId=0;pendingTasks=new Set;destroyed=!1;pendingTask=new Kr(!1);debugTaskTracker=Ae(M_,{optional:!0});get hasPendingTasks(){return this.destroyed?!1:this.pendingTask.value}get hasPendingTasksObservable(){return this.destroyed?new tn(e=>{e.next(!1),e.complete()}):this.pendingTask}add(){!this.hasPendingTasks&&!this.destroyed&&this.pendingTask.next(!0);let e=this.taskId++;return this.pendingTasks.add(e),this.debugTaskTracker?.add(e),e}has(e){return this.pendingTasks.has(e)}remove(e){this.pendingTasks.delete(e),this.debugTaskTracker?.remove(e),this.pendingTasks.size===0&&this.hasPendingTasks&&this.pendingTask.next(!1)}ngOnDestroy(){this.pendingTasks.clear(),this.hasPendingTasks&&this.pendingTask.next(!1),this.destroyed=!0,this.pendingTask.unsubscribe()}static \u0275prov=pt({token:t,providedIn:"root",factory:()=>new t})}return t})(),nS=class extends qr{__isAsync;destroyRef=void 0;pendingTasks=void 0;constructor(n=!1){super(),this.__isAsync=n,i_()&&(this.destroyRef=Ae(fc,{optional:!0})??void 0,this.pendingTasks=Ae(dc,{optional:!0})??void 0)}emit(n){let e=Ot(null);try{super.next(n)}finally{Ot(e)}}subscribe(n,e,r){let o=n,s=e||(()=>null),i=r;if(n&&typeof n=="object"){let l=n;o=l.next?.bind(l),s=l.error?.bind(l),i=l.complete?.bind(l)}this.__isAsync&&(s=this.wrapInTimeout(s),o&&(o=this.wrapInTimeout(o)),i&&(i=this.wrapInTimeout(i)));let a=super.subscribe({next:o,error:s,complete:i});return n instanceof Wr&&n.add(a),a}wrapInTimeout(n){return e=>{let r=this.pendingTasks?.add();setTimeout(()=>{try{n(e)}finally{r!==void 0&&this.pendingTasks?.remove(r)}})}}},Zr=nS;function b0(...t){}function WS(t){let n,e;function r(){t=b0;try{e!==void 0&&typeof cancelAnimationFrame=="function"&&cancelAnimationFrame(e),n!==void 0&&clearTimeout(n)}catch(o){}}return n=setTimeout(()=>{t(),r()}),typeof requestAnimationFrame=="function"&&(e=requestAnimationFrame(()=>{t(),r()})),()=>r()}function O_(t){return queueMicrotask(()=>t()),()=>{t=b0}}var qS="isAngularZone",iy=qS+"_ID",gX=0,ms=class t{hasPendingMacrotasks=!1;hasPendingMicrotasks=!1;isStable=!0;onUnstable=new Zr(!1);onMicrotaskEmpty=new Zr(!1);onStable=new Zr(!1);onError=new Zr(!1);constructor(n){let{enableLongStackTrace:e=!1,shouldCoalesceEventChangeDetection:r=!1,shouldCoalesceRunChangeDetection:o=!1,scheduleInRootZone:s=R_}=n;if(typeof Zone>"u")throw new it(908,!1);Zone.assertZonePatched();let i=this;i._nesting=0,i._outer=i._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(i._inner=i._inner.fork(new Zone.TaskTrackingZoneSpec)),e&&Zone.longStackTraceZoneSpec&&(i._inner=i._inner.fork(Zone.longStackTraceZoneSpec)),i.shouldCoalesceEventChangeDetection=!o&&r,i.shouldCoalesceRunChangeDetection=o,i.callbackScheduled=!1,i.scheduleInRootZone=s,vX(i)}static isInAngularZone(){return typeof Zone<"u"&&Zone.current.get(qS)===!0}static assertInAngularZone(){if(!t.isInAngularZone())throw new it(909,!1)}static assertNotInAngularZone(){if(t.isInAngularZone())throw new it(909,!1)}run(n,e,r){return this._inner.run(n,e,r)}runTask(n,e,r,o){let s=this._inner,i=s.scheduleEventTask("NgZoneEvent: "+o,n,yX,b0,b0);try{return s.runTask(i,e,r)}finally{s.cancelTask(i)}}runGuarded(n,e,r){return this._inner.runGuarded(n,e,r)}runOutsideAngular(n){return this._outer.run(n)}},yX={};function KS(t){if(t._nesting==0&&!t.hasPendingMicrotasks&&!t.isStable)try{t._nesting++,t.onMicrotaskEmpty.emit(null)}finally{if(t._nesting--,!t.hasPendingMicrotasks)try{t.runOutsideAngular(()=>t.onStable.emit(null))}finally{t.isStable=!0}}}function xX(t){if(t.isCheckStableRunning||t.callbackScheduled)return;t.callbackScheduled=!0;function n(){WS(()=>{t.callbackScheduled=!1,rS(t),t.isCheckStableRunning=!0,KS(t),t.isCheckStableRunning=!1})}t.scheduleInRootZone?Zone.root.run(()=>{n()}):t._outer.run(()=>{n()}),rS(t)}function vX(t){let n=()=>{xX(t)},e=gX++;t._inner=t._inner.fork({name:"angular",properties:{[qS]:!0,[iy]:e,[iy+e]:!0},onInvokeTask:(r,o,s,i,a,l)=>{if(bX(l))return r.invokeTask(s,i,a,l);try{return GA(t),r.invokeTask(s,i,a,l)}finally{(t.shouldCoalesceEventChangeDetection&&i.type==="eventTask"||t.shouldCoalesceRunChangeDetection)&&n(),jA(t)}},onInvoke:(r,o,s,i,a,l,c)=>{try{return GA(t),r.invoke(s,i,a,l,c)}finally{t.shouldCoalesceRunChangeDetection&&!t.callbackScheduled&&!wX(l)&&n(),jA(t)}},onHasTask:(r,o,s,i)=>{r.hasTask(s,i),o===s&&(i.change=="microTask"?(t._hasPendingMicrotasks=i.microTask,rS(t),KS(t)):i.change=="macroTask"&&(t.hasPendingMacrotasks=i.macroTask))},onHandleError:(r,o,s,i)=>(r.handleError(s,i),t.runOutsideAngular(()=>t.onError.emit(i)),!1)})}function rS(t){t._hasPendingMicrotasks||(t.shouldCoalesceEventChangeDetection||t.shouldCoalesceRunChangeDetection)&&t.callbackScheduled===!0?t.hasPendingMicrotasks=!0:t.hasPendingMicrotasks=!1}function GA(t){t._nesting++,t.isStable&&(t.isStable=!1,t.onUnstable.emit(null))}function jA(t){t._nesting--,KS(t)}var ay=class{hasPendingMicrotasks=!1;hasPendingMacrotasks=!1;isStable=!0;onUnstable=new Zr;onMicrotaskEmpty=new Zr;onStable=new Zr;onError=new Zr;run(n,e,r){return n.apply(e,r)}runGuarded(n,e,r){return n.apply(e,r)}runOutsideAngular(n){return n()}runTask(n,e,r,o){return n.apply(e,r)}};function bX(t){return F_(t,"__ignore_ng_zone__")}function wX(t){return F_(t,"__scheduler_tick__")}function F_(t,n){return!Array.isArray(t)||t.length!==1?!1:t[0]?.data?.[n]===!0}var Da=class{_console=console;handleError(n){this._console.error("ERROR",n)}},Vi=new nt("",{factory:()=>{let t=Ae(ms),n=Ae(Cr),e;return r=>{t.runOutsideAngular(()=>{n.destroyed&&!e?setTimeout(()=>{throw r}):(e??=n.get(Da),e.handleError(r))})}}}),$_={provide:cp,useValue:()=>{let t=Ae(Da,{optional:!0})},multi:!0},CX=new nt("",{factory:()=>{let t=Ae(lr).defaultView;if(!t)return;let n=Ae(Vi),e=s=>{n(s.reason),s.preventDefault()},r=s=>{s.error?n(s.error):n(new Error(s.message,{cause:s})),s.preventDefault()},o=()=>{t.addEventListener("unhandledrejection",e),t.addEventListener("error",r)};typeof Zone<"u"?Zone.root.run(o):o(),Ae(fc).onDestroy(()=>{t.removeEventListener("error",r),t.removeEventListener("unhandledrejection",e)})}});function XS(){return sd([t_(()=>{Ae(CX)})])}function hc(t,n){let[e,r,o]=_I(t,n?.equal),s=e,i=s[Ds];return s.set=r,s.update=o,s.asReadonly=L_.bind(s),s}function L_(){let t=this[Ds];if(t.readonlyFn===void 0){let n=()=>this();n[Ds]=t,t.readonlyFn=n}return t.readonlyFn}var rd=class{},vy=new nt("",{factory:()=>!0});var YS=new nt("");var ZS=(()=>{class t{static \u0275prov=pt({token:t,providedIn:"root",factory:()=>new oS})}return t})(),oS=class{dirtyEffectCount=0;queues=new Map;add(n){this.enqueue(n),this.schedule(n)}schedule(n){n.dirty&&this.dirtyEffectCount++}remove(n){let e=n.zone,r=this.queues.get(e);r.has(n)&&(r.delete(n),n.dirty&&this.dirtyEffectCount--)}enqueue(n){let e=n.zone;this.queues.has(e)||this.queues.set(e,new Set);let r=this.queues.get(e);r.has(n)||r.add(n)}flush(){for(;this.dirtyEffectCount>0;){let n=!1;for(let[e,r]of this.queues)e===null?n||=this.flushQueue(r):n||=e.run(()=>this.flushQueue(r));n||(this.dirtyEffectCount=0)}}flushQueue(n){let e=!1;for(let r of n)r.dirty&&(this.dirtyEffectCount--,e=!0,r.run());return e}},sS=class{[Ds];constructor(n){this[Ds]=n}destroy(){this[Ds].destroy()}};function _a(t){return RI(t)}function Ey(t){return{toString:t}.toString()}function MX(t){return typeof t=="function"}function pR(t,n,e,r){n!==null?n.applyValueToInputSignal(n,r):t[e]=r}var j0=class{previousValue;currentValue;firstChange;constructor(n,e,r){this.previousValue=n,this.currentValue=e,this.firstChange=r}isFirstChange(){return this.firstChange}},o2=(()=>{let t=()=>fR;return t.ngInherit=!0,t})();function fR(t){return t.type.prototype.ngOnChanges&&(t.setInput=FX),OX}function OX(){let t=hR(this),n=t?.current;if(n){let e=t.previous;if(e===lp)t.previous=n;else for(let r in n)e[r]=n[r];t.current=null,this.ngOnChanges(n)}}function FX(t,n,e,r,o){let s=this.declaredInputs[r],i=hR(t)||$X(t,{previous:lp,current:null}),a=i.current||(i.current={}),l=i.previous,c=l[s];a[s]=new j0(c&&c.currentValue,e,l===lp),pR(t,n,o,e)}var dR="__ngSimpleChanges__";function hR(t){return t[dR]||null}function $X(t,n){return t[dR]=n}var P_=[];var bn=function(t,n=null,e){for(let r=0;r<P_.length;r++){let o=P_[r];o(t,n,e)}},nn=(function(t){return t[t.TemplateCreateStart=0]="TemplateCreateStart",t[t.TemplateCreateEnd=1]="TemplateCreateEnd",t[t.TemplateUpdateStart=2]="TemplateUpdateStart",t[t.TemplateUpdateEnd=3]="TemplateUpdateEnd",t[t.LifecycleHookStart=4]="LifecycleHookStart",t[t.LifecycleHookEnd=5]="LifecycleHookEnd",t[t.OutputStart=6]="OutputStart",t[t.OutputEnd=7]="OutputEnd",t[t.BootstrapApplicationStart=8]="BootstrapApplicationStart",t[t.BootstrapApplicationEnd=9]="BootstrapApplicationEnd",t[t.BootstrapComponentStart=10]="BootstrapComponentStart",t[t.BootstrapComponentEnd=11]="BootstrapComponentEnd",t[t.ChangeDetectionStart=12]="ChangeDetectionStart",t[t.ChangeDetectionEnd=13]="ChangeDetectionEnd",t[t.ChangeDetectionSyncStart=14]="ChangeDetectionSyncStart",t[t.ChangeDetectionSyncEnd=15]="ChangeDetectionSyncEnd",t[t.AfterRenderHooksStart=16]="AfterRenderHooksStart",t[t.AfterRenderHooksEnd=17]="AfterRenderHooksEnd",t[t.ComponentStart=18]="ComponentStart",t[t.ComponentEnd=19]="ComponentEnd",t[t.DeferBlockStateStart=20]="DeferBlockStateStart",t[t.DeferBlockStateEnd=21]="DeferBlockStateEnd",t[t.DynamicComponentStart=22]="DynamicComponentStart",t[t.DynamicComponentEnd=23]="DynamicComponentEnd",t[t.HostBindingsUpdateStart=24]="HostBindingsUpdateStart",t[t.HostBindingsUpdateEnd=25]="HostBindingsUpdateEnd",t})(nn||{});function LX(t,n,e){let{ngOnChanges:r,ngOnInit:o,ngDoCheck:s}=n.type.prototype;if(r){let i=fR(n);(e.preOrderHooks??=[]).push(t,i),(e.preOrderCheckHooks??=[]).push(t,i)}o&&(e.preOrderHooks??=[]).push(0-t,o),s&&((e.preOrderHooks??=[]).push(t,s),(e.preOrderCheckHooks??=[]).push(t,s))}function PX(t,n){for(let e=n.directiveStart,r=n.directiveEnd;e<r;e++){let s=t.data[e].type.prototype,{ngAfterContentInit:i,ngAfterContentChecked:a,ngAfterViewInit:l,ngAfterViewChecked:c,ngOnDestroy:u}=s;i&&(t.contentHooks??=[]).push(-e,i),a&&((t.contentHooks??=[]).push(e,a),(t.contentCheckHooks??=[]).push(e,a)),l&&(t.viewHooks??=[]).push(-e,l),c&&((t.viewHooks??=[]).push(e,c),(t.viewCheckHooks??=[]).push(e,c)),u!=null&&(t.destroyHooks??=[]).push(e,u)}}function z0(t,n,e){mR(t,n,3,e)}function V0(t,n,e,r){(t[It]&3)===e&&mR(t,n,e,r)}function QS(t,n){let e=t[It];(e&3)===n&&(e&=16383,e+=1,t[It]=e)}function mR(t,n,e,r){let o=r!==void 0?t[up]&65535:0,s=r??-1,i=n.length-1,a=0;for(let l=o;l<i;l++)if(typeof n[l+1]=="number"){if(a=n[l],r!=null&&a>=r)break}else n[l]<0&&(t[up]+=65536),(a<s||s==-1)&&(BX(t,e,n,l),t[up]=(t[up]&4294901760)+l+2),l++}function B_(t,n){bn(nn.LifecycleHookStart,t,n);let e=Ot(null);try{n.call(t)}finally{Ot(e),bn(nn.LifecycleHookEnd,t,n)}}function BX(t,n,e,r){let o=e[r]<0,s=e[r+1],i=o?-e[r]:e[r],a=t[i];o?t[It]>>14<t[up]>>16&&(t[It]&3)===n&&(t[It]+=16384,B_(a,s)):B_(a,s)}var gd=-1,mp=class{factory;name;injectImpl;resolving=!1;canSeeViewProviders;multi;componentProviders;index;providerFactory;constructor(n,e,r,o){this.factory=n,this.name=o,this.canSeeViewProviders=e,this.injectImpl=r}};function zX(t){return(t.flags&8)!==0}function VX(t){return(t.flags&16)!==0}function UX(t,n,e){let r=0;for(;r<e.length;){let o=e[r];if(typeof o=="number"){if(o!==0)break;r++;let s=e[r++],i=e[r++],a=e[r++];t.setAttribute(n,i,a,s)}else{let s=o,i=e[++r];jX(s)?t.setProperty(n,s,i):t.setAttribute(n,s,i),r++}}return r}function GX(t){return t===3||t===4||t===6}function jX(t){return t.charCodeAt(0)===64}function s2(t,n){if(!(n===null||n.length===0))if(t===null||t.length===0)t=n.slice();else{let e=-1;for(let r=0;r<n.length;r++){let o=n[r];typeof o=="number"?e=o:e===0||(e===-1||e===2?z_(t,e,o,null,n[++r]):z_(t,e,o,null,null))}}return t}function z_(t,n,e,r,o){let s=0,i=t.length;if(n===-1)i=-1;else for(;s<t.length;){let a=t[s++];if(typeof a=="number"){if(a===n){i=-1;break}else if(a>n){i=s-1;break}}}for(;s<t.length;){let a=t[s];if(typeof a=="number")break;if(a===e){o!==null&&(t[s+1]=o);return}s++,o!==null&&s++}i!==-1&&(t.splice(i,0,n),s=i+1),t.splice(s++,0,e),o!==null&&t.splice(s++,0,o)}function gR(t){return t!==gd}function H0(t){return t&32767}function HX(t){return t>>16}function W0(t,n){let e=HX(t),r=n;for(;e>0;)r=r[cd],e--;return r}var aT=!0;function V_(t){let n=aT;return aT=t,n}var WX=256,yR=WX-1,xR=5,qX=0,Ui={};function KX(t,n,e){let r;typeof e=="string"?r=e.charCodeAt(0)||0:e.hasOwnProperty(ap)&&(r=e[ap]),r==null&&(r=e[ap]=qX++);let o=r&yR,s=1<<o;n.data[t+(o>>xR)]|=s}function q0(t,n){let e=vR(t,n);if(e!==-1)return e;let r=n[yt];r.firstCreatePass&&(t.injectorIndex=n.length,JS(r.data,t),JS(n,null),JS(r.blueprint,null));let o=AT(t,n),s=t.injectorIndex;if(gR(o)){let i=H0(o),a=W0(o,n),l=a[yt].data;for(let c=0;c<8;c++)n[s+c]=a[i+c]|l[i+c]}return n[s+8]=o,s}function JS(t,n){t.push(0,0,0,0,0,0,0,0,n)}function vR(t,n){return t.injectorIndex===-1||t.parent&&t.parent.injectorIndex===t.injectorIndex||n[t.injectorIndex+8]===null?-1:t.injectorIndex}function AT(t,n){if(t.parent&&t.parent.injectorIndex!==-1)return t.parent.injectorIndex;let e=0,r=null,o=n;for(;o!==null;){if(r=SR(o),r===null)return gd;if(e++,o=o[cd],r.injectorIndex!==-1)return r.injectorIndex|e<<16}return gd}function lT(t,n,e){KX(t,n,e)}function bR(t,n,e){if(e&8||t!==void 0)return t;S0(n,"NodeInjector")}function wR(t,n,e,r){if(e&8&&r===void 0&&(r=null),(e&3)===0){let o=t[ic],s=hs(void 0);try{return o?o.get(n,r,e&8):xS(n,r,e&8)}finally{hs(s)}}return bR(r,n,e)}function CR(t,n,e,r=0,o){if(t!==null){if(n[It]&2048&&!(r&2)){let i=QX(t,n,e,r,Ui);if(i!==Ui)return i}let s=IR(t,n,e,r,Ui);if(s!==Ui)return s}return wR(n,e,r,o)}function IR(t,n,e,r,o){let s=YX(e);if(typeof s=="function"){if(!GS(n,t,r))return r&1?bR(o,e,r):wR(n,e,r,o);try{let i;if(i=s(r),i==null&&!(r&8))S0(e);else return i}finally{jS()}}else if(typeof s=="number"){let i=null,a=vR(t,n),l=gd,c=r&1?n[jo][Eo]:null;for((a===-1||r&4)&&(l=a===-1?AT(t,n):n[a+8],l===gd||!G_(r,!1)?a=-1:(i=n[yt],a=H0(l),n=W0(l,n)));a!==-1;){let u=n[yt];if(U_(s,a,u.data)){let p=XX(a,n,e,i,r,c);if(p!==Ui)return p}l=n[a+8],l!==gd&&G_(r,n[yt].data[a+8]===c)&&U_(s,a,n)?(i=u,a=H0(l),n=W0(l,n)):a=-1}}return o}function XX(t,n,e,r,o,s){let i=n[yt],a=i.data[t+8],l=r==null?fp(a)&&aT:r!=i&&(a.type&3)!==0,c=o&1&&s===a,u=U0(a,i,e,l,c);return u!==null?Cy(n,i,u,a,o):Ui}function U0(t,n,e,r,o){let s=t.providerIndexes,i=n.data,a=s&1048575,l=t.directiveStart,c=t.directiveEnd,u=s>>20,p=r?a:a+u,f=o?a+u:c;for(let d=p;d<f;d++){let h=i[d];if(d<l&&e===h||d>=l&&h.type===e)return d}if(o){let d=i[l];if(d&&uc(d)&&d.type===e)return l}return null}function Cy(t,n,e,r,o){let s=t[e],i=n.data;if(s instanceof mp){let a=s;if(a.resolving)throw yS("");let l=V_(a.canSeeViewProviders);a.resolving=!0;let c=i[e].type||i[e],u,p=a.injectImpl?hs(a.injectImpl):null,f=GS(t,r,0);try{s=t[e]=a.factory(void 0,o,i,t,r),n.firstCreatePass&&e>=r.directiveStart&&LX(e,i[e],n)}finally{p!==null&&hs(p),V_(l),a.resolving=!1,jS()}}return s}function YX(t){if(typeof t=="string")return t.charCodeAt(0)||0;let n=t.hasOwnProperty(ap)?t[ap]:void 0;return typeof n=="number"?n>=0?n&yR:ZX:n}function U_(t,n,e){let r=1<<t;return!!(e[n+(t>>xR)]&r)}function G_(t,n){return!(t&2)&&!(t&1&&n)}var hp=class{_tNode;_lView;constructor(n,e){this._tNode=n,this._lView=e}get(n,e,r){return CR(this._tNode,this._lView,n,rp(r),e)}};function ZX(){return new hp(ys(),Ln())}function i2(t){return Ey(()=>{let n=t.prototype.constructor,e=n[oy]||cT(n),r=Object.prototype,o=Object.getPrototypeOf(t.prototype).constructor;for(;o&&o!==r;){let s=o[oy]||cT(o);if(s&&s!==e)return s;o=Object.getPrototypeOf(o)}return s=>new s})}function cT(t){return lS(t)?()=>{let n=cT(Yr(t));return n&&n()}:op(t)}function QX(t,n,e,r,o){let s=t,i=n;for(;s!==null&&i!==null&&i[It]&2048&&!ud(i);){let a=IR(s,i,e,r|2,Ui);if(a!==Ui)return a;let l=s.parent;if(!l){let c=i[ES];if(c){let u=c.get(e,Ui,r);if(u!==Ui)return u}l=SR(i),i=i[cd]}s=l}return o}function SR(t){let n=t[yt],e=n.type;return e===2?n.declTNode:e===1?t[Eo]:null}function JX(){return Id(ys(),Ln())}function Id(t,n){return new Ma(Bi(t,n))}var Ma=(()=>{class t{nativeElement;constructor(e){this.nativeElement=e}static __NG_ELEMENT_ID__=JX}return t})();function eY(t){return t instanceof Ma?t.nativeElement:t}function tY(){return this._results[Symbol.iterator]()}var K0=class{_emitDistinctChangesOnly;dirty=!0;_onDirty=void 0;_results=[];_changesDetected=!1;_changes=void 0;length=0;first=void 0;last=void 0;get changes(){return this._changes??=new qr}constructor(n=!1){this._emitDistinctChangesOnly=n}get(n){return this._results[n]}map(n){return this._results.map(n)}filter(n){return this._results.filter(n)}find(n){return this._results.find(n)}reduce(n,e){return this._results.reduce(n,e)}forEach(n){this._results.forEach(n)}some(n){return this._results.some(n)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(n,e){this.dirty=!1;let r=ZA(n);(this._changesDetected=!YA(this._results,r,e))&&(this._results=r,this.length=r.length,this.last=r[this.length-1],this.first=r[0])}notifyOnChanges(){this._changes!==void 0&&(this._changesDetected||!this._emitDistinctChangesOnly)&&this._changes.next(this)}onDirty(n){this._onDirty=n}setDirty(){this.dirty=!0,this._onDirty?.()}destroy(){this._changes!==void 0&&(this._changes.complete(),this._changes.unsubscribe())}[Symbol.iterator]=tY};function TR(t){return(t.flags&128)===128}var _T=(function(t){return t[t.OnPush=0]="OnPush",t[t.Default=1]="Default",t})(_T||{}),ER=new Map,nY=0;function rY(){return nY++}function oY(t){ER.set(t[lc],t)}function uT(t){ER.delete(t[lc])}var j_="__ngContext__";function yd(t,n){Aa(n)?(t[j_]=n[lc],oY(n)):t[j_]=n}function NR(t){return kR(t[ld])}function DR(t){return kR(t[As])}function kR(t){for(;t!==null&&!si(t);)t=t[As];return t}var sY;function RT(t){sY=t}var a2=new nt("",{factory:()=>iY}),iY="ng";var l2=new nt(""),Ny=new nt("",{providedIn:"platform",factory:()=>"unknown"});var c2=new nt("",{factory:()=>Ae(lr).body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce")||null});var AR=!1,_R=new nt("",{factory:()=>AR});var aY=(t,n,e,r)=>{};function lY(t,n,e,r){aY(t,n,e,r)}function u2(t){return(t.flags&32)===32}var cY=()=>null;function RR(t,n,e=!1){return cY(t,n,e)}function MR(t,n){let e=t.contentQueries;if(e!==null){let r=Ot(null);try{for(let o=0;o<e.length;o+=2){let s=e[o],i=e[o+1];if(i!==-1){let a=t.data[i];O0(s),a.contentQueries(2,n[i],i)}}}finally{Ot(r)}}}function pT(t,n,e){O0(0);let r=Ot(null);try{n(t,e)}finally{Ot(r)}}function OR(t,n,e){if(NS(n)){let r=Ot(null);try{let o=n.directiveStart,s=n.directiveEnd;for(let i=o;i<s;i++){let a=t.data[i];if(a.contentQueries){let l=e[i];a.contentQueries(1,l,i)}}}finally{Ot(r)}}}var ai=(function(t){return t[t.Emulated=0]="Emulated",t[t.None=2]="None",t[t.ShadowDom=3]="ShadowDom",t[t.ExperimentalIsolatedShadowDom=4]="ExperimentalIsolatedShadowDom",t})(ai||{});var fT=class{changingThisBreaksApplicationSecurity;constructor(n){this.changingThisBreaksApplicationSecurity=n}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${iS})`}};function FR(t){return t instanceof fT?t.changingThisBreaksApplicationSecurity:t}function uY(t,n){return t.createText(n)}function $R(t,n,e){return t.createElement(n,e)}function X0(t,n,e,r,o){t.insertBefore(n,e,r,o)}function LR(t,n,e){t.appendChild(n,e)}function H_(t,n,e,r,o){r!==null?X0(t,n,e,r,o):LR(t,n,e)}function pY(t,n,e,r){t.removeChild(null,n,e,r)}function fY(t,n,e){t.setAttribute(n,"style",e)}function dY(t,n,e){e===""?t.removeAttribute(n,"class"):t.setAttribute(n,"class",e)}function PR(t,n,e){let{mergedAttrs:r,classes:o,styles:s}=e;r!==null&&UX(t,n,r),o!==null&&dY(t,n,o),s!==null&&fY(t,n,s)}function BR(t){return t instanceof Function?t():t}function hY(t,n,e){let r=t.length;for(;;){let o=t.indexOf(n,e);if(o===-1)return o;if(o===0||t.charCodeAt(o-1)<=32){let s=n.length;if(o+s===r||t.charCodeAt(o+s)<=32)return o}e=o+1}}var zR="ng-template";function mY(t,n,e,r){let o=0;if(r){for(;o<n.length&&typeof n[o]=="string";o+=2)if(n[o]==="class"&&hY(n[o+1].toLowerCase(),e,0)!==-1)return!0}else if(MT(t))return!1;if(o=n.indexOf(1,o),o>-1){let s;for(;++o<n.length&&typeof(s=n[o])=="string";)if(s.toLowerCase()===e)return!0}return!1}function MT(t){return t.type===4&&t.value!==zR}function gY(t,n,e){let r=t.type===4&&!e?zR:t.value;return n===r}function yY(t,n,e){let r=4,o=t.attrs,s=o!==null?bY(o):0,i=!1;for(let a=0;a<n.length;a++){let l=n[a];if(typeof l=="number"){if(!i&&!ii(r)&&!ii(l))return!1;if(i&&ii(l))continue;i=!1,r=l|r&1;continue}if(!i)if(r&4){if(r=2|r&1,l!==""&&!gY(t,l,e)||l===""&&n.length===1){if(ii(r))return!1;i=!0}}else if(r&8){if(o===null||!mY(t,o,l,e)){if(ii(r))return!1;i=!0}}else{let c=n[++a],u=xY(l,o,MT(t),e);if(u===-1){if(ii(r))return!1;i=!0;continue}if(c!==""){let p;if(u>s?p="":p=o[u+1].toLowerCase(),r&2&&c!==p){if(ii(r))return!1;i=!0}}}}return ii(r)||i}function ii(t){return(t&1)===0}function xY(t,n,e,r){if(n===null)return-1;let o=0;if(r||!e){let s=!1;for(;o<n.length;){let i=n[o];if(i===t)return o;if(i===3||i===6)s=!0;else if(i===1||i===2){let a=n[++o];for(;typeof a=="string";)a=n[++o];continue}else{if(i===4)break;if(i===0){o+=4;continue}}o+=s?1:2}return-1}else return wY(n,t)}function VR(t,n,e=!1){for(let r=0;r<n.length;r++)if(yY(t,n[r],e))return!0;return!1}function vY(t){let n=t.attrs;if(n!=null){let e=n.indexOf(5);if((e&1)===0)return n[e+1]}return null}function bY(t){for(let n=0;n<t.length;n++){let e=t[n];if(GX(e))return n}return t.length}function wY(t,n){let e=t.indexOf(4);if(e>-1)for(e++;e<t.length;){let r=t[e];if(typeof r=="number")return-1;if(r===n)return e;e++}return-1}function CY(t,n){e:for(let e=0;e<n.length;e++){let r=n[e];if(t.length===r.length){for(let o=0;o<t.length;o++)if(t[o]!==r[o])continue e;return!0}}return!1}function W_(t,n){return t?":not("+n.trim()+")":n}function IY(t){let n=t[0],e=1,r=2,o="",s=!1;for(;e<t.length;){let i=t[e];if(typeof i=="string")if(r&2){let a=t[++e];o+="["+i+(a.length>0?'="'+a+'"':"")+"]"}else r&8?o+="."+i:r&4&&(o+=" "+i);else o!==""&&!ii(i)&&(n+=W_(s,o),o=""),r=i,s=s||!ii(r);e++}return o!==""&&(n+=W_(s,o)),n}function SY(t){return t.map(IY).join(",")}function TY(t){let n=[],e=[],r=1,o=2;for(;r<t.length;){let s=t[r];if(typeof s=="string")o===2?s!==""&&n.push(s,t[++r]):o===8&&e.push(s);else{if(!ii(o))break;o=s}r++}return e.length&&n.push(1,...e),n}var Sd={};function OT(t,n,e,r,o,s,i,a,l,c,u){let p=ao+r,f=p+o,d=EY(p,f),h=typeof c=="function"?c():c;return d[yt]={type:t,blueprint:d,template:e,queries:null,viewQuery:a,declTNode:n,data:d.slice().fill(null,p),bindingStartIndex:p,expandoStartIndex:f,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:typeof s=="function"?s():s,pipeRegistry:typeof i=="function"?i():i,firstChild:null,schemas:l,consts:h,incompleteFirstPass:!1,ssrId:u}}function EY(t,n){let e=[];for(let r=0;r<n;r++)e.push(r<t?null:Sd);return e}function NY(t){let n=t.tView;return n===null||n.incompleteFirstPass?t.tView=OT(1,null,t.template,t.decls,t.vars,t.directiveDefs,t.pipeDefs,t.viewQuery,t.schemas,t.consts,t.id):n}function FT(t,n,e,r,o,s,i,a,l,c,u){let p=n.blueprint.slice();return p[oi]=o,p[It]=r|4|128|8|64|1024,(c!==null||t&&t[It]&2048)&&(p[It]|=2048),DS(p),p[Mr]=p[cd]=t,p[No]=e,p[ka]=i||t&&t[ka],p[Or]=a||t&&t[Or],p[ic]=l||t&&t[ic]||null,p[Eo]=s,p[lc]=rY(),p[id]=u,p[ES]=c,p[jo]=n.type==2?t[jo]:p,p}function DY(t,n,e){let r=Bi(n,t),o=NY(e),s=t[ka].rendererFactory,i=$T(t,FT(t,o,null,UR(e),r,n,null,s.createRenderer(r,e),null,null,null));return t[n.index]=i}function UR(t){let n=16;return t.signals?n=4096:t.onPush&&(n=64),n}function GR(t,n,e,r){if(e===0)return-1;let o=n.length;for(let s=0;s<e;s++)n.push(r),t.blueprint.push(r),t.data.push(null);return o}function $T(t,n){return t[ld]?t[TS][As]=n:t[ld]=n,t[TS]=n,n}function kY(t,n,e,r){if(!r)if((n[It]&3)===3){let s=t.preOrderCheckHooks;s!==null&&z0(n,s,e)}else{let s=t.preOrderHooks;s!==null&&V0(n,s,0,e)}pc(e)}var p2=(function(t){return t[t.None=0]="None",t[t.SignalBased=1]="SignalBased",t[t.HasDecoratorInputTransform=2]="HasDecoratorInputTransform",t})(p2||{});function dT(t,n,e,r){let o=Ot(null);try{let[s,i,a]=t.inputs[e],l=null;(i&p2.SignalBased)!==0&&(l=n[s][Ds]),l!==null&&l.transformFn!==void 0?r=l.transformFn(r):a!==null&&(r=a.call(n,r)),t.setInput!==null?t.setInput(n,l,r,e,s):pR(n,l,s,r)}finally{Ot(o)}}var Ra=(function(t){return t[t.Important=1]="Important",t[t.DashCase=2]="DashCase",t})(Ra||{}),AY;function LT(t,n){return AY(t,n)}var xd=new Set,PT=(function(t){return t[t.CHANGE_DETECTION=0]="CHANGE_DETECTION",t[t.AFTER_NEXT_RENDER=1]="AFTER_NEXT_RENDER",t})(PT||{}),Dy=new nt(""),q_=new Set;function BT(t){q_.has(t)||(q_.add(t),performance?.mark?.("mark_feature_usage",{detail:{feature:t}}))}var jR=(()=>{class t{impl=null;execute(){this.impl?.execute()}static \u0275prov=pt({token:t,providedIn:"root",factory:()=>new t})}return t})();var HR=new nt("",{factory:()=>({queue:new Set,isScheduled:!1,scheduler:null,injector:Ae(Cr)})});function WR(t,n,e){let r=t.get(HR);if(Array.isArray(n))for(let o of n)r.queue.add(o),e?.detachedLeaveAnimationFns?.push(o);else r.queue.add(n),e?.detachedLeaveAnimationFns?.push(n);r.scheduler&&r.scheduler(t)}function _Y(t,n){for(let[e,r]of n)WR(t,r.animateFns)}function RY(t,n){let e=t.get(HR);if(Array.isArray(n))for(let r of n)e.queue.delete(r);else e.queue.delete(n)}function K_(t,n,e,r){let o=t?.[hy]?.enter;n!==null&&o&&o.has(e.index)&&_Y(r,o)}function md(t,n,e,r,o,s,i,a){if(o!=null){let l,c=!1;si(o)?l=o:Aa(o)&&(c=!0,o=o[oi]);let u=_s(o);t===0&&r!==null?(K_(a,r,s,e),i==null?LR(n,r,u):X0(n,r,u,i||null,!0)):t===1&&r!==null?(K_(a,r,s,e),X0(n,r,u,i||null,!0)):t===2?X_(a,s,e,p=>{pY(n,u,c,p)}):t===3&&X_(a,s,e,()=>{n.destroyNode(u)}),l!=null&&GY(n,t,e,l,s,r,i)}}function MY(t,n){qR(t,n),n[oi]=null,n[Eo]=null}function OY(t,n,e,r,o,s){r[oi]=o,r[Eo]=n,f2(t,r,e,1,o,s)}function qR(t,n){n[ka].changeDetectionScheduler?.notify(9),f2(t,n,n[Or],2,null,null)}function FY(t){let n=t[ld];if(!n)return eT(t[yt],t);for(;n;){let e=null;if(Aa(n))e=n[ld];else{let r=n[Do];r&&(e=r)}if(!e){for(;n&&!n[As]&&n!==t;)Aa(n)&&eT(n[yt],n),n=n[Mr];n===null&&(n=t),Aa(n)&&eT(n[yt],n),e=n&&n[As]}n=e}}function zT(t,n){let e=t[pp],r=e.indexOf(n);e.splice(r,1)}function KR(t,n){if(dp(n))return;let e=n[Or];e.destroyNode&&f2(t,n,e,3,null,null),FY(n)}function eT(t,n){if(dp(n))return;let e=Ot(null);try{n[It]&=-129,n[It]|=256,n[gs]&&Yg(n[gs]),PY(t,n),LY(t,n),n[yt].type===1&&n[Or].destroy();let r=n[ac];if(r!==null&&si(n[Mr])){r!==n[Mr]&&zT(r,n);let o=n[Pi];o!==null&&o.detachView(t)}uT(n)}finally{Ot(e)}}function X_(t,n,e,r){let o=t?.[hy];if(o?.enter?.has(n.index)&&RY(e,o.enter.get(n.index).animateFns),o==null||o.leave==null||!o.leave.has(n.index))return r(!1);t&&xd.add(t[lc]),WR(e,()=>{if(o.leave&&o.leave.has(n.index)){let i=o.leave.get(n.index),a=[];if(i){for(let l=0;l<i.animateFns.length;l++){let c=i.animateFns[l],{promise:u}=c();a.push(u)}o.detachedLeaveAnimationFns=void 0}o.running=Promise.allSettled(a),$Y(t,r)}else t&&xd.delete(t[lc]),r(!1)},o)}function $Y(t,n){let e=t[hy]?.running;if(e){e.then(()=>{t[hy].running=void 0,xd.delete(t[lc]),n(!0)});return}n(!1)}function LY(t,n){let e=t.cleanup,r=n[ad];if(e!==null)for(let i=0;i<e.length-1;i+=2)if(typeof e[i]=="string"){let a=e[i+3];a>=0?r[a]():r[-a].unsubscribe(),i+=2}else{let a=r[e[i+1]];e[i].call(a)}r!==null&&(n[ad]=null);let o=n[Ea];if(o!==null){n[Ea]=null;for(let i=0;i<o.length;i++){let a=o[i];a()}}let s=n[dy];if(s!==null){n[dy]=null;for(let i of s)i.destroy()}}function PY(t,n){let e;if(t!=null&&(e=t.destroyHooks)!=null)for(let r=0;r<e.length;r+=2){let o=n[e[r]];if(!(o instanceof mp)){let s=e[r+1];if(Array.isArray(s))for(let i=0;i<s.length;i+=2){let a=o[s[i]],l=s[i+1];bn(nn.LifecycleHookStart,a,l);try{l.call(a)}finally{bn(nn.LifecycleHookEnd,a,l)}}else{bn(nn.LifecycleHookStart,o,s);try{s.call(o)}finally{bn(nn.LifecycleHookEnd,o,s)}}}}}function XR(t,n,e){return BY(t,n.parent,e)}function BY(t,n,e){let r=n;for(;r!==null&&r.type&168;)n=r,r=n.parent;if(r===null)return e[oi];if(fp(r)){let{encapsulation:o}=t.data[r.directiveStart+r.componentOffset];if(o===ai.None||o===ai.Emulated)return null}return Bi(r,e)}function YR(t,n,e){return VY(t,n,e)}function zY(t,n,e){return t.type&40?Bi(t,e):null}var VY=zY,Y_;function VT(t,n,e,r){let o=XR(t,r,n),s=n[Or],i=r.parent||n[Eo],a=YR(i,r,n);if(o!=null)if(Array.isArray(e))for(let l=0;l<e.length;l++)H_(s,o,e[l],a,!1);else H_(s,o,e,a,!1);Y_!==void 0&&Y_(s,r,n,e,o)}function by(t,n){if(n!==null){let e=n.type;if(e&3)return Bi(n,t);if(e&4)return hT(-1,t[n.index]);if(e&8){let r=n.child;if(r!==null)return by(t,r);{let o=t[n.index];return si(o)?hT(-1,o):_s(o)}}else{if(e&128)return by(t,n.next);if(e&32)return LT(n,t)()||_s(t[n.index]);{let r=ZR(t,n);if(r!==null){if(Array.isArray(r))return r[0];let o=oc(t[jo]);return by(o,r)}else return by(t,n.next)}}}return null}function ZR(t,n){if(n!==null){let r=t[jo][Eo],o=n.projection;return r.projection[o]}return null}function hT(t,n){let e=Do+t+1;if(e<n.length){let r=n[e],o=r[yt].firstChild;if(o!==null)return by(r,o)}return n[cc]}function UT(t,n,e,r,o,s,i){for(;e!=null;){let a=r[ic];if(e.type===128){e=e.next;continue}let l=r[e.index],c=e.type;if(i&&n===0&&(l&&yd(_s(l),r),e.flags|=2),!u2(e))if(c&8)UT(t,n,e.child,r,o,s,!1),md(n,t,a,o,l,e,s,r);else if(c&32){let u=LT(e,r),p;for(;p=u();)md(n,t,a,o,p,e,s,r);md(n,t,a,o,l,e,s,r)}else c&16?QR(t,n,r,e,o,s):md(n,t,a,o,l,e,s,r);e=i?e.projectionNext:e.next}}function f2(t,n,e,r,o,s){UT(e,r,t.firstChild,n,o,s,!1)}function UY(t,n,e){let r=n[Or],o=XR(t,e,n),s=e.parent||n[Eo],i=YR(s,e,n);QR(r,0,n,e,o,i)}function QR(t,n,e,r,o,s){let i=e[jo],l=i[Eo].projection[r.projection];if(Array.isArray(l))for(let c=0;c<l.length;c++){let u=l[c];md(n,t,e[ic],o,u,r,s,e)}else{let c=l,u=i[Mr];TR(r)&&(c.flags|=128),UT(t,n,c,u,o,s,!0)}}function GY(t,n,e,r,o,s,i){let a=r[cc],l=_s(r);a!==l&&md(n,t,e,s,a,o,i);for(let c=Do;c<r.length;c++){let u=r[c];f2(u[yt],u,t,n,s,a)}}function jY(t,n,e,r,o){if(n)o?t.addClass(e,r):t.removeClass(e,r);else{let s=r.indexOf("-")===-1?void 0:Ra.DashCase;o==null?t.removeStyle(e,r,s):(typeof o=="string"&&o.endsWith("!important")&&(o=o.slice(0,-10),s|=Ra.Important),t.setStyle(e,r,o,s))}}function JR(t,n,e,r,o){let s=xy(),i=r&2;try{pc(-1),i&&n.length>ao&&kY(t,n,ao,!1);let a=i?nn.TemplateUpdateStart:nn.TemplateCreateStart;bn(a,o,e),e(r,o)}finally{pc(s);let a=i?nn.TemplateUpdateEnd:nn.TemplateCreateEnd;bn(a,o,e)}}function eM(t,n,e){KY(t,n,e),(e.flags&64)===64&&XY(t,n,e)}function GT(t,n,e=Bi){let r=n.localNames;if(r!==null){let o=n.index+1;for(let s=0;s<r.length;s+=2){let i=r[s+1],a=i===-1?e(n,t):t[i];t[o++]=a}}}function HY(t,n,e,r){let s=r.get(_R,AR)||e===ai.ShadowDom||e===ai.ExperimentalIsolatedShadowDom,i=t.selectRootElement(n,s);return WY(i),i}function WY(t){qY(t)}var qY=()=>null;function KY(t,n,e){let r=e.directiveStart,o=e.directiveEnd;fp(e)&&DY(n,e,t.data[r+e.componentOffset]),t.firstCreatePass||q0(e,n);let s=e.initialInputs;for(let i=r;i<o;i++){let a=t.data[i],l=Cy(n,t,i,e);if(yd(l,n),s!==null&&eZ(n,i-r,l,a,e,s),uc(a)){let c=zi(e.index,n);c[No]=Cy(n,t,i,e)}}}function XY(t,n,e){let r=e.directiveStart,o=e.directiveEnd,s=e.index,i=S_();try{pc(s);for(let a=r;a<o;a++){let l=t.data[a],c=n[a];M0(a),(l.hostBindings!==null||l.hostVars!==0||l.hostAttrs!==null)&&YY(l,c)}}finally{pc(-1),M0(i)}}function YY(t,n){t.hostBindings!==null&&t.hostBindings(1,n)}function ZY(t,n){let e=t.directiveRegistry,r=null;if(e)for(let o=0;o<e.length;o++){let s=e[o];VR(n,s.selectors,!1)&&(r??=[],uc(s)?r.unshift(s):r.push(s))}return r}function QY(t,n,e,r,o,s){let i=Bi(t,n);JY(n[Or],i,s,t.value,e,r,o)}function JY(t,n,e,r,o,s,i){if(s==null)t.removeAttribute(n,o,e);else{let a=i==null?WA(s):i(s,r||"",o);t.setAttribute(n,o,a,e)}}function eZ(t,n,e,r,o,s){let i=s[n];if(i!==null)for(let a=0;a<i.length;a+=2){let l=i[a],c=i[a+1];dT(r,e,l,c)}}function tM(t,n,e,r,o){let s=ao+e,i=n[yt],a=o(i,n,t,r,e);n[s]=a,hd(t,!0);let l=t.type===2;return l?(PR(n[Or],a,t),(m_()===0||k0(t))&&yd(a,n),g_()):yd(a,n),L0()&&(!l||!u2(t))&&VT(i,n,a,t),t}function nM(t){let n=t;return PS()?BS():(n=n.parent,hd(n,!1)),n}function tZ(t,n){let e=t[ic];if(!e)return;let r;try{r=e.get(Vi,null)}catch(o){r=null}r?.(n)}function rM(t,n,e,r,o){let s=t.inputs?.[r],i=t.hostDirectiveInputs?.[r],a=!1;if(i)for(let l=0;l<i.length;l+=2){let c=i[l],u=i[l+1],p=n.data[c];dT(p,e[c],u,o),a=!0}if(s)for(let l of s){let c=e[l],u=n.data[l];dT(u,c,r,o),a=!0}return a}function nZ(t,n){let e=zi(n,t),r=e[yt];rZ(r,e);let o=e[oi];o!==null&&e[id]===null&&(e[id]=RR(o,e[ic])),bn(nn.ComponentStart);try{jT(r,e,e[No])}finally{bn(nn.ComponentEnd,e[No])}}function rZ(t,n){for(let e=n.length;e<t.blueprint.length;e++)n.push(t.blueprint[e])}function jT(t,n,e){F0(n);try{let r=t.viewQuery;r!==null&&pT(1,r,e);let o=t.template;o!==null&&JR(t,n,o,1,e),t.firstCreatePass&&(t.firstCreatePass=!1),n[Pi]?.finishViewCreation(t),t.staticContentQueries&&MR(t,n),t.staticViewQueries&&pT(2,t.viewQuery,e);let s=t.components;s!==null&&oZ(n,s)}catch(r){throw t.firstCreatePass&&(t.incompleteFirstPass=!0,t.firstCreatePass=!1),r}finally{n[It]&=-5,$0()}}function oZ(t,n){for(let e=0;e<n.length;e++)nZ(t,n[e])}function oM(t,n,e,r){let o=Ot(null);try{let s=n.tView,a=t[It]&4096?4096:16,l=FT(t,s,e,a,null,n,null,null,r?.injector??null,r?.embeddedViewInjector??null,r?.dehydratedView??null),c=t[n.index];l[ac]=c;let u=t[Pi];return u!==null&&(l[Pi]=u.createEmbeddedView(s)),jT(s,l,e),l}finally{Ot(o)}}function mT(t,n){return!n||n.firstChild===null||TR(t)}function Iy(t,n,e,r,o=!1){for(;e!==null;){if(e.type===128){e=o?e.projectionNext:e.next;continue}let s=n[e.index];s!==null&&r.push(_s(s)),si(s)&&sM(s,r);let i=e.type;if(i&8)Iy(t,n,e.child,r);else if(i&32){let a=LT(e,n),l;for(;l=a();)r.push(l)}else if(i&16){let a=ZR(n,e);if(Array.isArray(a))r.push(...a);else{let l=oc(n[jo]);Iy(l[yt],l,a,r,!0)}}e=o?e.projectionNext:e.next}return r}function sM(t,n){for(let e=Do;e<t.length;e++){let r=t[e],o=r[yt].firstChild;o!==null&&Iy(r[yt],r,o,n)}t[cc]!==t[oi]&&n.push(t[cc])}function iM(t){if(t[D0]!==null){for(let n of t[D0])n.impl.addSequence(n);t[D0].length=0}}var aM=[];function sZ(t){return t[gs]??iZ(t)}function iZ(t){let n=aM.pop()??Object.create(lZ);return n.lView=t,n}function aZ(t){t.lView[gs]!==t&&(t.lView=null,aM.push(t))}var lZ=Gn(Ye({},Hx),{consumerIsAlwaysLive:!0,kind:"template",consumerMarkedDirty:t=>{yy(t.lView)},consumerOnSignalRead(){this.lView[gs]=this}});function cZ(t){let n=t[gs]??Object.create(uZ);return n.lView=t,n}var uZ=Gn(Ye({},Hx),{consumerIsAlwaysLive:!0,kind:"template",consumerMarkedDirty:t=>{let n=oc(t.lView);for(;n&&!lM(n[yt]);)n=oc(n);n&&kS(n)},consumerOnSignalRead(){this.lView[gs]=this}});function lM(t){return t.type!==2}function cM(t){if(t[dy]===null)return;let n=!0;for(;n;){let e=!1;for(let r of t[dy])r.dirty&&(e=!0,r.zone===null||Zone.current===r.zone?r.run():r.zone.run(()=>r.run()));n=e&&!!(t[It]&8192)}}var pZ=100;function uM(t,n=0){let r=t[ka].rendererFactory,o=!1;o||r.begin?.();try{fZ(t,n)}finally{o||r.end?.()}}function fZ(t,n){let e=zS();try{VS(!0),gT(t,n);let r=0;for(;gy(t);){if(r===pZ)throw new it(103,!1);r++,gT(t,1)}}finally{VS(e)}}function dZ(t,n,e,r){if(dp(n))return;let o=n[It],s=!1,i=!1;F0(n);let a=!0,l=null,c=null;s||(lM(t)?(c=sZ(n),l=qx(c)):jx()===null?(a=!1,c=cZ(n),l=qx(c)):n[gs]&&(Yg(n[gs]),n[gs]=null));try{DS(n),v_(t.bindingStartIndex),e!==null&&JR(t,n,e,2,r);let u=(o&3)===3;if(!s)if(u){let d=t.preOrderCheckHooks;d!==null&&z0(n,d,null)}else{let d=t.preOrderHooks;d!==null&&V0(n,d,0,null),QS(n,0)}if(i||hZ(n),cM(n),pM(n,0),t.contentQueries!==null&&MR(t,n),!s)if(u){let d=t.contentCheckHooks;d!==null&&z0(n,d)}else{let d=t.contentHooks;d!==null&&V0(n,d,1),QS(n,1)}gZ(t,n);let p=t.components;p!==null&&dM(n,p,0);let f=t.viewQuery;if(f!==null&&pT(2,f,r),!s)if(u){let d=t.viewCheckHooks;d!==null&&z0(n,d)}else{let d=t.viewHooks;d!==null&&V0(n,d,2),QS(n,2)}if(t.firstUpdatePass===!0&&(t.firstUpdatePass=!1),n[N0]){for(let d of n[N0])d();n[N0]=null}s||(iM(n),n[It]&=-73)}catch(u){throw s||yy(n),u}finally{c!==null&&(DI(c,l),a&&aZ(c)),$0()}}function pM(t,n){for(let e=NR(t);e!==null;e=DR(e))for(let r=Do;r<e.length;r++){let o=e[r];fM(o,n)}}function hZ(t){for(let n=NR(t);n!==null;n=DR(n)){if(!(n[It]&2))continue;let e=n[pp];for(let r=0;r<e.length;r++){let o=e[r];kS(o)}}}function mZ(t,n,e){bn(nn.ComponentStart);let r=zi(n,t);try{fM(r,e)}finally{bn(nn.ComponentEnd,r[No])}}function fM(t,n){_0(t)&&gT(t,n)}function gT(t,n){let r=t[yt],o=t[It],s=t[gs],i=!!(n===0&&o&16);if(i||=!!(o&64&&n===0),i||=!!(o&1024),i||=!!(s?.dirty&&Kx(s)),i||=!1,s&&(s.dirty=!1),t[It]&=-9217,i)dZ(r,t,r.template,t[No]);else if(o&8192){let a=Ot(null);try{cM(t),pM(t,1);let l=r.components;l!==null&&dM(t,l,1),iM(t)}finally{Ot(a)}}}function dM(t,n,e){for(let r=0;r<n.length;r++)mZ(t,n[r],e)}function gZ(t,n){let e=t.hostBindingOpCodes;if(e!==null)try{for(let r=0;r<e.length;r++){let o=e[r];if(o<0)pc(~o);else{let s=o,i=e[++r],a=e[++r];I_(i,s);let l=n[s];bn(nn.HostBindingsUpdateStart,l);try{a(2,l)}finally{bn(nn.HostBindingsUpdateEnd,l)}}}}finally{pc(-1)}}function HT(t,n){let e=zS()?64:1088;for(t[ka].changeDetectionScheduler?.notify(n);t;){t[It]|=e;let r=oc(t);if(ud(t)&&!r)return t;t=r}return null}function hM(t,n,e,r){return[t,!0,0,n,null,r,null,e,null,null]}function mM(t,n,e,r=!0){let o=n[yt];if(yZ(o,n,t,e),r){let i=hT(e,t),a=n[Or],l=a.parentNode(t[cc]);l!==null&&OY(o,t[Eo],a,n,l,i)}let s=n[id];s!==null&&s.firstChild!==null&&(s.firstChild=null)}function yT(t,n){if(t.length<=Do)return;let e=Do+n,r=t[e];if(r){let o=r[ac];o!==null&&o!==t&&zT(o,r),n>0&&(t[e-1][As]=r[As]);let s=uy(t,Do+n);MY(r[yt],r);let i=s[Pi];i!==null&&i.detachView(s[yt]),r[Mr]=null,r[As]=null,r[It]&=-129}return r}function yZ(t,n,e,r){let o=Do+r,s=e.length;r>0&&(e[o-1][As]=n),r<s-Do?(n[As]=e[o],vS(e,Do+r,n)):(e.push(n),n[As]=null),n[Mr]=e;let i=n[ac];i!==null&&e!==i&&gM(i,n);let a=n[Pi];a!==null&&a.insertView(t),R0(n),n[It]|=128}function gM(t,n){let e=t[pp],r=n[Mr];if(Aa(r))t[It]|=2;else{let o=r[Mr][jo];n[jo]!==o&&(t[It]|=2)}e===null?t[pp]=[n]:e.push(n)}var mc=class{_lView;_cdRefInjectingView;_appRef=null;_attachedToViewContainer=!1;exhaustive;get rootNodes(){let n=this._lView,e=n[yt];return Iy(e,n,e.firstChild,[])}constructor(n,e){this._lView=n,this._cdRefInjectingView=e}get context(){return this._lView[No]}set context(n){this._lView[No]=n}get destroyed(){return dp(this._lView)}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){let n=this._lView[Mr];if(si(n)){let e=n[my],r=e?e.indexOf(this):-1;r>-1&&(yT(n,r),uy(e,r))}this._attachedToViewContainer=!1}KR(this._lView[yt],this._lView)}onDestroy(n){AS(this._lView,n)}markForCheck(){HT(this._cdRefInjectingView||this._lView,4)}detach(){this._lView[It]&=-129}reattach(){R0(this._lView),this._lView[It]|=128}detectChanges(){this._lView[It]|=1024,uM(this._lView)}checkNoChanges(){}attachToViewContainerRef(){if(this._appRef)throw new it(902,!1);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null;let n=ud(this._lView),e=this._lView[ac];e!==null&&!n&&zT(e,this._lView),qR(this._lView[yt],this._lView)}attachToAppRef(n){if(this._attachedToViewContainer)throw new it(902,!1);this._appRef=n;let e=ud(this._lView),r=this._lView[ac];r!==null&&!e&&gM(r,this._lView),R0(this._lView)}};var vd=(()=>{class t{_declarationLView;_declarationTContainer;elementRef;static __NG_ELEMENT_ID__=xZ;constructor(e,r,o){this._declarationLView=e,this._declarationTContainer=r,this.elementRef=o}get ssrId(){return this._declarationTContainer.tView?.ssrId||null}createEmbeddedView(e,r){return this.createEmbeddedViewImpl(e,r)}createEmbeddedViewImpl(e,r,o){let s=oM(this._declarationLView,this._declarationTContainer,e,{embeddedViewInjector:r,dehydratedView:o});return new mc(s)}}return t})();function xZ(){return WT(ys(),Ln())}function WT(t,n){return t.type&4?new vd(n,t,Id(t,n)):null}function ky(t,n,e,r,o){let s=t.data[n];if(s===null)s=vZ(t,n,e,r,o),C_()&&(s.flags|=32);else if(s.type&64){s.type=e,s.value=r,s.attrs=o;let i=x_();s.injectorIndex=i===null?-1:i.injectorIndex}return hd(s,!0),s}function vZ(t,n,e,r,o){let s=LS(),i=PS(),a=i?s:s&&s.parent,l=t.data[n]=wZ(t,a,e,n,r,o);return bZ(t,l,s,i),l}function bZ(t,n,e,r){t.firstChild===null&&(t.firstChild=n),e!==null&&(r?e.child==null&&n.parent!==null&&(e.child=n):e.next===null&&(e.next=n,n.prev=e))}function wZ(t,n,e,r,o,s){let i=n?n.injectorIndex:-1,a=0;return OS()&&(a|=128),{type:e,index:r,insertBeforeIndex:null,injectorIndex:i,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,fieldIndex:-1,customControlIndex:-1,propertyBindings:null,flags:a,providerIndexes:0,value:o,attrs:s,mergedAttrs:null,localNames:null,initialInputs:null,inputs:null,hostDirectiveInputs:null,outputs:null,hostDirectiveOutputs:null,directiveToIndex:null,tView:null,next:null,prev:null,projectionNext:null,child:null,parent:n,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}var CZ=()=>null;function xT(t,n){return CZ(t,n)}var yM=class{},d2=class{},vT=class{resolveComponentFactory(n){throw new it(917,!1)}},Ay=class{static NULL=new vT},gp=class{};var xM=(()=>{class t{static \u0275prov=pt({token:t,providedIn:"root",factory:()=>null})}return t})();var G0={},bT=class{injector;parentInjector;constructor(n,e){this.injector=n,this.parentInjector=e}get(n,e,r){let o=this.injector.get(n,G0,r);return o!==G0||e===G0?o:this.parentInjector.get(n,e,r)}};function Y0(t,n,e){let r=e?t.styles:null,o=e?t.classes:null,s=0;if(n!==null)for(let i=0;i<n.length;i++){let a=n[i];if(typeof a=="number")s=a;else if(s==1)o=aS(o,a);else if(s==2){let l=a,c=n[++i];r=aS(r,l+": "+c+";")}}e?t.styles=r:t.stylesWithoutHost=r,e?t.classes=o:t.classesWithoutHost=o}function Oa(t,n=0){let e=Ln();if(e===null)return At(t,n);let r=ys();return CR(r,e,Yr(t),n)}function IZ(t,n,e,r,o){let s=r===null?null:{"":-1},i=o(t,e);if(i!==null){let a=i,l=null,c=null;for(let u of i)if(u.resolveHostDirectives!==null){[a,l,c]=u.resolveHostDirectives(i);break}EZ(t,n,e,a,s,l,c)}s!==null&&r!==null&&SZ(e,r,s)}function SZ(t,n,e){let r=t.localNames=[];for(let o=0;o<n.length;o+=2){let s=e[n[o+1]];if(s==null)throw new it(-301,!1);r.push(n[o],s)}}function TZ(t,n,e){n.componentOffset=e,(t.components??=[]).push(n.index)}function EZ(t,n,e,r,o,s,i){let a=r.length,l=null;for(let f=0;f<a;f++){let d=r[f];l===null&&uc(d)&&(l=d,TZ(t,e,f)),lT(q0(e,n),t,d.type)}RZ(e,t.data.length,a),l?.viewProvidersResolver&&l.viewProvidersResolver(l);for(let f=0;f<a;f++){let d=r[f];d.providersResolver&&d.providersResolver(d)}let c=!1,u=!1,p=GR(t,n,a,null);a>0&&(e.directiveToIndex=new Map);for(let f=0;f<a;f++){let d=r[f];if(e.mergedAttrs=s2(e.mergedAttrs,d.hostAttrs),DZ(t,e,n,p,d),_Z(p,d,o),i!==null&&i.has(d)){let[g,m]=i.get(d);e.directiveToIndex.set(d.type,[p,g+e.directiveStart,m+e.directiveStart])}else(s===null||!s.has(d))&&e.directiveToIndex.set(d.type,p);d.contentQueries!==null&&(e.flags|=4),(d.hostBindings!==null||d.hostAttrs!==null||d.hostVars!==0)&&(e.flags|=64);let h=d.type.prototype;!c&&(h.ngOnChanges||h.ngOnInit||h.ngDoCheck)&&((t.preOrderHooks??=[]).push(e.index),c=!0),!u&&(h.ngOnChanges||h.ngDoCheck)&&((t.preOrderCheckHooks??=[]).push(e.index),u=!0),p++}NZ(t,e,s)}function NZ(t,n,e){for(let r=n.directiveStart;r<n.directiveEnd;r++){let o=t.data[r];if(e===null||!e.has(o))Z_(0,n,o,r),Z_(1,n,o,r),J_(n,r,!1);else{let s=e.get(o);Q_(0,n,s,r),Q_(1,n,s,r),J_(n,r,!0)}}}function Z_(t,n,e,r){let o=t===0?e.inputs:e.outputs;for(let s in o)if(o.hasOwnProperty(s)){let i;t===0?i=n.inputs??={}:i=n.outputs??={},i[s]??=[],i[s].push(r),vM(n,s)}}function Q_(t,n,e,r){let o=t===0?e.inputs:e.outputs;for(let s in o)if(o.hasOwnProperty(s)){let i=o[s],a;t===0?a=n.hostDirectiveInputs??={}:a=n.hostDirectiveOutputs??={},a[i]??=[],a[i].push(r,s),vM(n,i)}}function vM(t,n){n==="class"?t.flags|=8:n==="style"&&(t.flags|=16)}function J_(t,n,e){let{attrs:r,inputs:o,hostDirectiveInputs:s}=t;if(r===null||!e&&o===null||e&&s===null||MT(t)){t.initialInputs??=[],t.initialInputs.push(null);return}let i=null,a=0;for(;a<r.length;){let l=r[a];if(l===0){a+=4;continue}else if(l===5){a+=2;continue}else if(typeof l=="number")break;if(!e&&o.hasOwnProperty(l)){let c=o[l];for(let u of c)if(u===n){i??=[],i.push(l,r[a+1]);break}}else if(e&&s.hasOwnProperty(l)){let c=s[l];for(let u=0;u<c.length;u+=2)if(c[u]===n){i??=[],i.push(c[u+1],r[a+1]);break}}a+=2}t.initialInputs??=[],t.initialInputs.push(i)}function DZ(t,n,e,r,o){t.data[r]=o;let s=o.factory||(o.factory=op(o.type,!0)),i=new mp(s,uc(o),Oa,null);t.blueprint[r]=i,e[r]=i,kZ(t,n,r,GR(t,e,o.hostVars,Sd),o)}function kZ(t,n,e,r,o){let s=o.hostBindings;if(s){let i=t.hostBindingOpCodes;i===null&&(i=t.hostBindingOpCodes=[]);let a=~n.index;AZ(i)!=a&&i.push(a),i.push(e,r,s)}}function AZ(t){let n=t.length;for(;n>0;){let e=t[--n];if(typeof e=="number"&&e<0)return e}return 0}function _Z(t,n,e){if(e){if(n.exportAs)for(let r=0;r<n.exportAs.length;r++)e[n.exportAs[r]]=t;uc(n)&&(e[""]=t)}}function RZ(t,n,e){t.flags|=1,t.directiveStart=n,t.directiveEnd=n+e,t.providerIndexes=n}function bM(t,n,e,r,o,s,i,a){let l=n[yt],c=l.consts,u=pd(c,i),p=ky(l,t,e,r,u);return s&&IZ(l,n,p,pd(c,a),o),p.mergedAttrs=s2(p.mergedAttrs,p.attrs),p.attrs!==null&&Y0(p,p.attrs,!1),p.mergedAttrs!==null&&Y0(p,p.mergedAttrs,!0),l.queries!==null&&l.queries.elementStart(l,p),p}function wM(t,n){PX(t,n),NS(n)&&t.queries.elementEnd(n)}function MZ(t,n,e,r,o,s){let i=n.consts,a=pd(i,o),l=ky(n,t,e,r,a);if(l.mergedAttrs=s2(l.mergedAttrs,l.attrs),s!=null){let c=pd(i,s);l.localNames=[];for(let u=0;u<c.length;u+=2)l.localNames.push(c[u],-1)}return l.attrs!==null&&Y0(l,l.attrs,!1),l.mergedAttrs!==null&&Y0(l,l.mergedAttrs,!0),n.queries!==null&&n.queries.elementStart(n,l),l}function CM(t,n,e){if(e===Sd)return!1;let r=t[n];return Object.is(r,e)?!1:(t[n]=e,!0)}function tT(t,n,e){return function r(o){let s=fp(t)?zi(t.index,n):n;HT(s,5);let i=n[No],a=eR(n,i,e,o),l=r.__ngNextListenerFn__;for(;l;)a=eR(n,i,l,o)&&a,l=l.__ngNextListenerFn__;return a}}function eR(t,n,e,r){let o=Ot(null);try{return bn(nn.OutputStart,n,e),e(r)!==!1}catch(s){return tZ(t,s),!1}finally{bn(nn.OutputEnd,n,e),Ot(o)}}function OZ(t,n,e,r,o,s,i,a){let l=k0(t),c=!1,u=null;if(!r&&l&&(u=$Z(n,e,s,t.index)),u!==null){let p=u.__ngLastListenerFn__||u;p.__ngNextListenerFn__=i,u.__ngLastListenerFn__=i,c=!0}else{let p=Bi(t,e),f=r?r(p):p;lY(e,f,s,a);let d=o.listen(f,s,a);if(!FZ(s)){let h=r?g=>r(_s(g[t.index])):t.index;IM(h,n,e,s,a,d,!1)}}return c}function FZ(t){return t.startsWith("animation")||t.startsWith("transition")}function $Z(t,n,e,r){let o=t.cleanup;if(o!=null)for(let s=0;s<o.length-1;s+=2){let i=o[s];if(i===e&&o[s+1]===r){let a=n[ad],l=o[s+2];return a&&a.length>l?a[l]:null}typeof i=="string"&&(s+=2)}return null}function IM(t,n,e,r,o,s,i){let a=n.firstCreatePass?RS(n):null,l=_S(e),c=l.length;l.push(o,s),a&&a.push(r,t,c,(c+1)*(i?-1:1))}function tR(t,n,e,r,o,s){let i=n[e],a=n[yt],c=a.data[e].outputs[r],p=i[c].subscribe(s);IM(t.index,a,n,o,s,p,!0)}var wT=Symbol("BINDING");var Z0=class extends Ay{ngModule;constructor(n){super(),this.ngModule=n}resolveComponentFactory(n){let e=sc(n);return new bd(e,this.ngModule)}};function LZ(t){return Object.keys(t).map(n=>{let[e,r,o]=t[n],s={propName:e,templateName:n,isSignal:(r&p2.SignalBased)!==0};return o&&(s.transform=o),s})}function PZ(t){return Object.keys(t).map(n=>({propName:t[n],templateName:n}))}function BZ(t,n,e){let r=n instanceof Cr?n:n?.injector;return r&&t.getStandaloneInjector!==null&&(r=t.getStandaloneInjector(r)||r),r?new bT(e,r):e}function zZ(t){let n=t.get(gp,null);if(n===null)throw new it(407,!1);let e=t.get(xM,null),r=t.get(rd,null);return{rendererFactory:n,sanitizer:e,changeDetectionScheduler:r,ngReflect:!1}}function VZ(t,n){let e=SM(t);return $R(n,e,e==="svg"?l_:e==="math"?c_:null)}function SM(t){return(t.selectors[0][0]||"div").toLowerCase()}var bd=class extends d2{componentDef;ngModule;selector;componentType;ngContentSelectors;isBoundToModule;cachedInputs=null;cachedOutputs=null;get inputs(){return this.cachedInputs??=LZ(this.componentDef.inputs),this.cachedInputs}get outputs(){return this.cachedOutputs??=PZ(this.componentDef.outputs),this.cachedOutputs}constructor(n,e){super(),this.componentDef=n,this.ngModule=e,this.componentType=n.type,this.selector=SY(n.selectors),this.ngContentSelectors=n.ngContentSelectors??[],this.isBoundToModule=!!e}create(n,e,r,o,s,i){bn(nn.DynamicComponentStart);let a=Ot(null);try{let l=this.componentDef,c=UZ(r,l,i,s),u=BZ(l,o||this.ngModule,n),p=zZ(u),f=p.rendererFactory.createRenderer(null,l),d=r?HY(f,r,l.encapsulation,u):VZ(l,f),h=i?.some(nR)||s?.some(y=>typeof y!="function"&&y.bindings.some(nR)),g=FT(null,c,null,512|UR(l),null,null,p,f,u,null,RR(d,u,!0));g[ao]=d,F0(g);let m=null;try{let y=bM(ao,g,2,"#host",()=>c.directiveRegistry,!0,0);PR(f,d,y),yd(d,g),eM(c,g,y),OR(c,y,g),wM(c,y),e!==void 0&&jZ(y,this.ngContentSelectors,e),m=zi(y.index,g),g[No]=m[No],jT(c,g,null)}catch(y){throw m!==null&&uT(m),uT(g),y}finally{bn(nn.DynamicComponentEnd),$0()}return new Q0(this.componentType,g,!!h)}finally{Ot(a)}}};function UZ(t,n,e,r){let o=t?["ng-version","21.1.4"]:TY(n.selectors[0]),s=null,i=null,a=0;if(e)for(let u of e)a+=u[wT].requiredVars,u.create&&(u.targetIdx=0,(s??=[]).push(u)),u.update&&(u.targetIdx=0,(i??=[]).push(u));if(r)for(let u=0;u<r.length;u++){let p=r[u];if(typeof p!="function")for(let f of p.bindings){a+=f[wT].requiredVars;let d=u+1;f.create&&(f.targetIdx=d,(s??=[]).push(f)),f.update&&(f.targetIdx=d,(i??=[]).push(f))}}let l=[n];if(r)for(let u of r){let p=typeof u=="function"?u:u.type,f=gS(p);l.push(f)}return OT(0,null,GZ(s,i),1,a,l,null,null,null,[o],null)}function GZ(t,n){return!t&&!n?null:e=>{if(e&1&&t)for(let r of t)r.create();if(e&2&&n)for(let r of n)r.update()}}function nR(t){let n=t[wT].kind;return n==="input"||n==="twoWay"}var Q0=class extends yM{_rootLView;_hasInputBindings;instance;hostView;changeDetectorRef;componentType;location;previousInputValues=null;_tNode;constructor(n,e,r){super(),this._rootLView=e,this._hasInputBindings=r,this._tNode=A0(e[yt],ao),this.location=Id(this._tNode,e),this.instance=zi(this._tNode.index,e)[No],this.hostView=this.changeDetectorRef=new mc(e,void 0),this.componentType=n}setInput(n,e){this._hasInputBindings;let r=this._tNode;if(this.previousInputValues??=new Map,this.previousInputValues.has(n)&&Object.is(this.previousInputValues.get(n),e))return;let o=this._rootLView,s=rM(r,o[yt],o,n,e);this.previousInputValues.set(n,e);let i=zi(r.index,o);HT(i,1)}get injector(){return new hp(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(n){this.hostView.onDestroy(n)}};function jZ(t,n,e){let r=t.projection=[];for(let o=0;o<n.length;o++){let s=e[o];r.push(s!=null&&s.length?Array.from(s):null)}}var xp=(()=>{class t{static __NG_ELEMENT_ID__=HZ}return t})();function HZ(){let t=ys();return EM(t,Ln())}var WZ=xp,TM=class extends WZ{_lContainer;_hostTNode;_hostLView;constructor(n,e,r){super(),this._lContainer=n,this._hostTNode=e,this._hostLView=r}get element(){return Id(this._hostTNode,this._hostLView)}get injector(){return new hp(this._hostTNode,this._hostLView)}get parentInjector(){let n=AT(this._hostTNode,this._hostLView);if(gR(n)){let e=W0(n,this._hostLView),r=H0(n),o=e[yt].data[r+8];return new hp(o,e)}else return new hp(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(n){let e=rR(this._lContainer);return e!==null&&e[n]||null}get length(){return this._lContainer.length-Do}createEmbeddedView(n,e,r){let o,s;typeof r=="number"?o=r:r!=null&&(o=r.index,s=r.injector);let i=xT(this._lContainer,n.ssrId),a=n.createEmbeddedViewImpl(e||{},s,i);return this.insertImpl(a,o,mT(this._hostTNode,i)),a}createComponent(n,e,r,o,s,i,a){let l=n&&!MX(n),c;if(l)c=e;else{let m=e||{};c=m.index,r=m.injector,o=m.projectableNodes,s=m.environmentInjector||m.ngModuleRef,i=m.directives,a=m.bindings}let u=l?n:new bd(sc(n)),p=r||this.parentInjector;if(!s&&u.ngModule==null){let y=(l?p:this.parentInjector).get(Cr,null);y&&(s=y)}let f=sc(u.componentType??{}),d=xT(this._lContainer,f?.id??null),h=d?.firstChild??null,g=u.create(p,o,h,s,i,a);return this.insertImpl(g.hostView,c,mT(this._hostTNode,d)),g}insert(n,e){return this.insertImpl(n,e,!0)}insertImpl(n,e,r){let o=n._lView;if(f_(o)){let a=this.indexOf(n);if(a!==-1)this.detach(a);else{let l=o[Mr],c=new TM(l,l[Eo],l[Mr]);c.detach(c.indexOf(n))}}let s=this._adjustIndex(e),i=this._lContainer;return mM(i,o,s,r),n.attachToViewContainerRef(),vS(nT(i),s,n),n}move(n,e){return this.insert(n,e)}indexOf(n){let e=rR(this._lContainer);return e!==null?e.indexOf(n):-1}remove(n){let e=this._adjustIndex(n,-1),r=yT(this._lContainer,e);r&&(uy(nT(this._lContainer),e),KR(r[yt],r))}detach(n){let e=this._adjustIndex(n,-1),r=yT(this._lContainer,e);return r&&uy(nT(this._lContainer),e)!=null?new mc(r):null}_adjustIndex(n,e=0){return n??this.length+e}};function rR(t){return t[my]}function nT(t){return t[my]||(t[my]=[])}function EM(t,n){let e,r=n[t.index];return si(r)?e=r:(e=hM(r,n,null,t),n[t.index]=e,$T(n,e)),KZ(e,n,t,r),new TM(e,t,n)}function qZ(t,n){let e=t[Or],r=e.createComment(""),o=Bi(n,t),s=e.parentNode(o);return X0(e,s,r,e.nextSibling(o),!1),r}var KZ=ZZ,XZ=()=>!1;function YZ(t,n,e){return XZ(t,n,e)}function ZZ(t,n,e,r){if(t[cc])return;let o;e.type&8?o=_s(r):o=qZ(n,e),t[cc]=o}var CT=class t{queryList;matches=null;constructor(n){this.queryList=n}clone(){return new t(this.queryList)}setDirty(){this.queryList.setDirty()}},IT=class t{queries;constructor(n=[]){this.queries=n}createEmbeddedView(n){let e=n.queries;if(e!==null){let r=n.contentQueries!==null?n.contentQueries[0]:e.length,o=[];for(let s=0;s<r;s++){let i=e.getByIndex(s),a=this.queries[i.indexInDeclarationView];o.push(a.clone())}return new t(o)}return null}insertView(n){this.dirtyQueriesWithMatches(n)}detachView(n){this.dirtyQueriesWithMatches(n)}finishViewCreation(n){this.dirtyQueriesWithMatches(n)}dirtyQueriesWithMatches(n){for(let e=0;e<this.queries.length;e++)qT(n,e).matches!==null&&this.queries[e].setDirty()}},J0=class{flags;read;predicate;constructor(n,e,r=null){this.flags=e,this.read=r,typeof n=="string"?this.predicate=sQ(n):this.predicate=n}},ST=class t{queries;constructor(n=[]){this.queries=n}elementStart(n,e){for(let r=0;r<this.queries.length;r++)this.queries[r].elementStart(n,e)}elementEnd(n){for(let e=0;e<this.queries.length;e++)this.queries[e].elementEnd(n)}embeddedTView(n){let e=null;for(let r=0;r<this.length;r++){let o=e!==null?e.length:0,s=this.getByIndex(r).embeddedTView(n,o);s&&(s.indexInDeclarationView=r,e!==null?e.push(s):e=[s])}return e!==null?new t(e):null}template(n,e){for(let r=0;r<this.queries.length;r++)this.queries[r].template(n,e)}getByIndex(n){return this.queries[n]}get length(){return this.queries.length}track(n){this.queries.push(n)}},TT=class t{metadata;matches=null;indexInDeclarationView=-1;crossesNgTemplate=!1;_declarationNodeIndex;_appliesToNextNode=!0;constructor(n,e=-1){this.metadata=n,this._declarationNodeIndex=e}elementStart(n,e){this.isApplyingToNode(e)&&this.matchTNode(n,e)}elementEnd(n){this._declarationNodeIndex===n.index&&(this._appliesToNextNode=!1)}template(n,e){this.elementStart(n,e)}embeddedTView(n,e){return this.isApplyingToNode(n)?(this.crossesNgTemplate=!0,this.addMatch(-n.index,e),new t(this.metadata)):null}isApplyingToNode(n){if(this._appliesToNextNode&&(this.metadata.flags&1)!==1){let e=this._declarationNodeIndex,r=n.parent;for(;r!==null&&r.type&8&&r.index!==e;)r=r.parent;return e===(r!==null?r.index:-1)}return this._appliesToNextNode}matchTNode(n,e){let r=this.metadata.predicate;if(Array.isArray(r))for(let o=0;o<r.length;o++){let s=r[o];this.matchTNodeWithReadOption(n,e,QZ(e,s)),this.matchTNodeWithReadOption(n,e,U0(e,n,s,!1,!1))}else r===vd?e.type&4&&this.matchTNodeWithReadOption(n,e,-1):this.matchTNodeWithReadOption(n,e,U0(e,n,r,!1,!1))}matchTNodeWithReadOption(n,e,r){if(r!==null){let o=this.metadata.read;if(o!==null)if(o===Ma||o===xp||o===vd&&e.type&4)this.addMatch(e.index,-2);else{let s=U0(e,n,o,!1,!1);s!==null&&this.addMatch(e.index,s)}else this.addMatch(e.index,r)}}addMatch(n,e){this.matches===null?this.matches=[n,e]:this.matches.push(n,e)}};function QZ(t,n){let e=t.localNames;if(e!==null){for(let r=0;r<e.length;r+=2)if(e[r]===n)return e[r+1]}return null}function JZ(t,n){return t.type&11?Id(t,n):t.type&4?WT(t,n):null}function eQ(t,n,e,r){return e===-1?JZ(n,t):e===-2?tQ(t,n,r):Cy(t,t[yt],e,n)}function tQ(t,n,e){if(e===Ma)return Id(n,t);if(e===vd)return WT(n,t);if(e===xp)return EM(n,t)}function NM(t,n,e,r){let o=n[Pi].queries[r];if(o.matches===null){let s=t.data,i=e.matches,a=[];for(let l=0;i!==null&&l<i.length;l+=2){let c=i[l];if(c<0)a.push(null);else{let u=s[c];a.push(eQ(n,u,i[l+1],e.metadata.read))}}o.matches=a}return o.matches}function ET(t,n,e,r){let o=t.queries.getByIndex(e),s=o.matches;if(s!==null){let i=NM(t,n,o,e);for(let a=0;a<s.length;a+=2){let l=s[a];if(l>0)r.push(i[a/2]);else{let c=s[a+1],u=n[-l];for(let p=Do;p<u.length;p++){let f=u[p];f[ac]===f[Mr]&&ET(f[yt],f,c,r)}if(u[pp]!==null){let p=u[pp];for(let f=0;f<p.length;f++){let d=p[f];ET(d[yt],d,c,r)}}}}}return r}function nQ(t,n){return t[Pi].queries[n].queryList}function DM(t,n,e){let r=new K0((e&4)===4);return h_(t,n,r,r.destroy),(n[Pi]??=new IT).queries.push(new CT(r))-1}function rQ(t,n,e){let r=Rs();return r.firstCreatePass&&(kM(r,new J0(t,n,e),-1),(n&2)===2&&(r.staticViewQueries=!0)),DM(r,Ln(),n)}function oQ(t,n,e,r){let o=Rs();if(o.firstCreatePass){let s=ys();kM(o,new J0(n,e,r),s.index),iQ(o,t),(e&2)===2&&(o.staticContentQueries=!0)}return DM(o,Ln(),e)}function sQ(t){return t.split(",").map(n=>n.trim())}function kM(t,n,e){t.queries===null&&(t.queries=new ST),t.queries.track(new TT(n,e))}function iQ(t,n){let e=t.contentQueries||(t.contentQueries=[]),r=e.length?e[e.length-1]:-1;n!==r&&e.push(t.queries.length-1,n)}function qT(t,n){return t.queries.getByIndex(n)}function aQ(t,n){let e=t[yt],r=qT(e,n);return r.crossesNgTemplate?ET(e,t,n,[]):NM(e,t,r,n)}var wd=class{},h2=class{};var e2=class extends wd{ngModuleType;_parent;_bootstrapComponents=[];_r3Injector;instance;destroyCbs=[];componentFactoryResolver=new Z0(this);constructor(n,e,r,o=!0){super(),this.ngModuleType=n,this._parent=e;let s=mS(n);this._bootstrapComponents=BR(s.bootstrap),this._r3Injector=HS(n,e,[{provide:wd,useValue:this},{provide:Ay,useValue:this.componentFactoryResolver},...r],Na(n),new Set(["environment"])),o&&this.resolveInjectorInitializers()}resolveInjectorInitializers(){this._r3Injector.resolveInjectorInitializers(),this.instance=this._r3Injector.get(this.ngModuleType)}get injector(){return this._r3Injector}destroy(){let n=this._r3Injector;!n.destroyed&&n.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(n){this.destroyCbs.push(n)}},t2=class extends h2{moduleType;constructor(n){super(),this.moduleType=n}create(n){return new e2(this.moduleType,n,[])}};var Sy=class extends wd{injector;componentFactoryResolver=new Z0(this);instance=null;constructor(n){super();let e=new ip([...n.providers,{provide:wd,useValue:this},{provide:Ay,useValue:this.componentFactoryResolver}],n.parent||fy(),n.debugName,new Set(["environment"]));this.injector=e,n.runEnvironmentInitializers&&e.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(n){this.injector.onDestroy(n)}};function _y(t,n,e=null){return new Sy({providers:t,parent:n,debugName:e,runEnvironmentInitializers:!0}).injector}var lQ=(()=>{class t{_injector;cachedInjectors=new Map;constructor(e){this._injector=e}getOrCreateStandaloneInjector(e){if(!e.standalone)return null;if(!this.cachedInjectors.has(e)){let r=CS(!1,e.type),o=r.length>0?_y([r],this._injector,""):null;this.cachedInjectors.set(e,o)}return this.cachedInjectors.get(e)}ngOnDestroy(){try{for(let e of this.cachedInjectors.values())e!==null&&e.destroy()}finally{this.cachedInjectors.clear()}}static \u0275prov=pt({token:t,providedIn:"environment",factory:()=>new t(At(Cr))})}return t})();function Ho(t){return Ey(()=>{let n=AM(t),e=Gn(Ye({},n),{decls:t.decls,vars:t.vars,template:t.template,consts:t.consts||null,ngContentSelectors:t.ngContentSelectors,onPush:t.changeDetection===_T.OnPush,directiveDefs:null,pipeDefs:null,dependencies:n.standalone&&t.dependencies||null,getStandaloneInjector:n.standalone?o=>o.get(lQ).getOrCreateStandaloneInjector(e):null,getExternalStyles:null,signals:t.signals??!1,data:t.data||{},encapsulation:t.encapsulation||ai.Emulated,styles:t.styles||ks,_:null,schemas:t.schemas||null,tView:null,id:""});n.standalone&&BT("NgStandalone"),_M(e);let r=t.dependencies;return e.directiveDefs=oR(r,cQ),e.pipeDefs=oR(r,HA),e.id=fQ(e),e})}function cQ(t){return sc(t)||gS(t)}function Gi(t){return Ey(()=>({type:t.type,bootstrap:t.bootstrap||ks,declarations:t.declarations||ks,imports:t.imports||ks,exports:t.exports||ks,transitiveCompileScopes:null,schemas:t.schemas||null,id:t.id||null}))}function uQ(t,n){if(t==null)return lp;let e={};for(let r in t)if(t.hasOwnProperty(r)){let o=t[r],s,i,a,l;Array.isArray(o)?(a=o[0],s=o[1],i=o[2]??s,l=o[3]||null):(s=o,i=o,a=p2.None,l=null),e[s]=[r,a,l],n[s]=i}return e}function pQ(t){if(t==null)return lp;let n={};for(let e in t)t.hasOwnProperty(e)&&(n[t[e]]=e);return n}function Fa(t){return Ey(()=>{let n=AM(t);return _M(n),n})}function AM(t){let n={};return{type:t.type,providersResolver:null,viewProvidersResolver:null,factory:null,hostBindings:t.hostBindings||null,hostVars:t.hostVars||0,hostAttrs:t.hostAttrs||null,contentQueries:t.contentQueries||null,declaredInputs:n,inputConfig:t.inputs||lp,exportAs:t.exportAs||null,standalone:t.standalone??!0,signals:t.signals===!0,selectors:t.selectors||ks,viewQuery:t.viewQuery||null,features:t.features||null,setInput:null,resolveHostDirectives:null,hostDirectives:null,inputs:uQ(t.inputs,n),outputs:pQ(t.outputs),debugInfo:null}}function _M(t){t.features?.forEach(n=>n(t))}function oR(t,n){return t?()=>{let e=typeof t=="function"?t():t,r=[];for(let o of e){let s=n(o);s!==null&&r.push(s)}return r}:null}function fQ(t){let n=0,e=typeof t.consts=="function"?"":t.consts,r=[t.selectors,t.ngContentSelectors,t.hostVars,t.hostAttrs,e,t.vars,t.decls,t.encapsulation,t.standalone,t.signals,t.exportAs,JSON.stringify(t.inputs),JSON.stringify(t.outputs),Object.getOwnPropertyNames(t.type.prototype),!!t.contentQueries,!!t.viewQuery];for(let s of r.join("|"))n=Math.imul(31,n)+s.charCodeAt(0)<<0;return n+=2147483648,"c"+n}function dQ(t,n,e,r,o,s,i,a){if(e.firstCreatePass){t.mergedAttrs=s2(t.mergedAttrs,t.attrs);let u=t.tView=OT(2,t,o,s,i,e.directiveRegistry,e.pipeRegistry,null,e.schemas,e.consts,null);e.queries!==null&&(e.queries.template(e,t),u.queries=e.queries.embeddedTView(t))}a&&(t.flags|=a),hd(t,!1);let l=mQ(e,n,t,r);L0()&&VT(e,n,l,t),yd(l,n);let c=hM(l,n,l,t);n[r+ao]=c,$T(n,c),YZ(c,t,n)}function hQ(t,n,e,r,o,s,i,a,l,c,u){let p=e+ao,f;if(n.firstCreatePass){if(f=ky(n,p,4,i||null,a||null),c!=null){let d=pd(n.consts,c);f.localNames=[];for(let h=0;h<d.length;h+=2)f.localNames.push(d[h],-1)}}else f=n.data[p];return dQ(f,t,n,e,r,o,s,l),c!=null&&GT(t,f,u),f}var mQ=gQ;function gQ(t,n,e,r){return P0(!0),n[Or].createComment("")}var KT=(()=>{class t{log(e){console.log(e)}warn(e){console.warn(e)}static \u0275fac=function(r){return new(r||t)};static \u0275prov=pt({token:t,factory:t.\u0275fac,providedIn:"platform"})}return t})();var XT=new nt("");function Ry(t){return!!t&&typeof t.then=="function"}function RM(t){return!!t&&typeof t.subscribe=="function"}var MM=new nt("");var YT=(()=>{class t{resolve;reject;initialized=!1;done=!1;donePromise=new Promise((e,r)=>{this.resolve=e,this.reject=r});appInits=Ae(MM,{optional:!0})??[];injector=Ae(Li);constructor(){}runInitializers(){if(this.initialized)return;let e=[];for(let o of this.appInits){let s=io(this.injector,o);if(Ry(s))e.push(s);else if(RM(s)){let i=new Promise((a,l)=>{s.subscribe({complete:a,error:l})});e.push(i)}}let r=()=>{this.done=!0,this.resolve()};Promise.all(e).then(()=>{r()}).catch(o=>{this.reject(o)}),e.length===0&&r(),this.initialized=!0}static \u0275fac=function(r){return new(r||t)};static \u0275prov=pt({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})(),m2=new nt("");function OM(){AI(()=>{let t="";throw new it(600,t)})}function FM(t){return t.isBoundToModule}var yQ=10;var Td=(()=>{class t{_runningTick=!1;_destroyed=!1;_destroyListeners=[];_views=[];internalErrorHandler=Ae(Vi);afterRenderManager=Ae(jR);zonelessEnabled=Ae(vy);rootEffectScheduler=Ae(ZS);dirtyFlags=0;tracingSnapshot=null;allTestViews=new Set;autoDetectTestViews=new Set;includeAllTestViews=!1;afterTick=new qr;get allViews(){return[...(this.includeAllTestViews?this.allTestViews:this.autoDetectTestViews).keys(),...this._views]}get destroyed(){return this._destroyed}componentTypes=[];components=[];internalPendingTask=Ae(dc);get isStable(){return this.internalPendingTask.hasPendingTasksObservable.pipe(Yn(e=>!e))}constructor(){Ae(Dy,{optional:!0})}whenStable(){let e;return new Promise(r=>{e=this.isStable.subscribe({next:o=>{o&&r()}})}).finally(()=>{e.unsubscribe()})}_injector=Ae(Cr);_rendererFactory=null;get injector(){return this._injector}bootstrap(e,r){return this.bootstrapImpl(e,r)}bootstrapImpl(e,r,o=Li.NULL){return this._injector.get(ms).run(()=>{bn(nn.BootstrapComponentStart);let i=e instanceof d2;if(!this._injector.get(YT).done){let h="";throw new it(405,h)}let l;i?l=e:l=this._injector.get(Ay).resolveComponentFactory(e),this.componentTypes.push(l.componentType);let c=FM(l)?void 0:this._injector.get(wd),u=r||l.selector,p=l.create(o,[],u,c),f=p.location.nativeElement,d=p.injector.get(XT,null);return d?.registerApplication(f),p.onDestroy(()=>{this.detachView(p.hostView),wy(this.components,p),d?.unregisterApplication(f)}),this._loadComponent(p),bn(nn.BootstrapComponentEnd,p),p})}tick(){this.zonelessEnabled||(this.dirtyFlags|=1),this._tick()}_tick(){bn(nn.ChangeDetectionStart),this.tracingSnapshot!==null?this.tracingSnapshot.run(PT.CHANGE_DETECTION,this.tickImpl):this.tickImpl()}tickImpl=()=>{if(this._runningTick)throw bn(nn.ChangeDetectionEnd),new it(101,!1);let e=Ot(null);try{this._runningTick=!0,this.synchronize()}finally{this._runningTick=!1,this.tracingSnapshot?.dispose(),this.tracingSnapshot=null,Ot(e),this.afterTick.next(),bn(nn.ChangeDetectionEnd)}};synchronize(){this._rendererFactory===null&&!this._injector.destroyed&&(this._rendererFactory=this._injector.get(gp,null,{optional:!0}));let e=0;for(;this.dirtyFlags!==0&&e++<yQ;){bn(nn.ChangeDetectionSyncStart);try{this.synchronizeOnce()}finally{bn(nn.ChangeDetectionSyncEnd)}}}synchronizeOnce(){this.dirtyFlags&16&&(this.dirtyFlags&=-17,this.rootEffectScheduler.flush());let e=!1;if(this.dirtyFlags&7){let r=!!(this.dirtyFlags&1);this.dirtyFlags&=-8,this.dirtyFlags|=8;for(let{_lView:o}of this.allViews){if(!r&&!gy(o))continue;let s=r&&!this.zonelessEnabled?0:1;uM(o,s),e=!0}if(this.dirtyFlags&=-5,this.syncDirtyFlagsWithViews(),this.dirtyFlags&23)return}e||(this._rendererFactory?.begin?.(),this._rendererFactory?.end?.()),this.dirtyFlags&8&&(this.dirtyFlags&=-9,this.afterRenderManager.execute()),this.syncDirtyFlagsWithViews()}syncDirtyFlagsWithViews(){if(this.allViews.some(({_lView:e})=>gy(e))){this.dirtyFlags|=2;return}else this.dirtyFlags&=-8}attachView(e){let r=e;this._views.push(r),r.attachToAppRef(this)}detachView(e){let r=e;wy(this._views,r),r.detachFromAppRef()}_loadComponent(e){this.attachView(e.hostView);try{this.tick()}catch(o){this.internalErrorHandler(o)}this.components.push(e),this._injector.get(m2,[]).forEach(o=>o(e))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach(e=>e()),this._views.slice().forEach(e=>e.destroy())}finally{this._destroyed=!0,this._views=[],this._destroyListeners=[]}}onDestroy(e){return this._destroyListeners.push(e),()=>wy(this._destroyListeners,e)}destroy(){if(this._destroyed)throw new it(406,!1);let e=this._injector;e.destroy&&!e.destroyed&&e.destroy()}get viewCount(){return this._views.length}static \u0275fac=function(r){return new(r||t)};static \u0275prov=pt({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();function wy(t,n){let e=t.indexOf(n);e>-1&&t.splice(e,1)}function Ed(t,n,e,r){let o=Ln(),s=b_();if(CM(o,s,n)){let i=Rs(),a=k_();QY(a,o,t,n,e,r)}return Ed}var KSe=typeof document<"u"&&typeof document?.documentElement?.getAnimations=="function";function sR(t,n,e,r,o){rM(n,t,e,o?"class":"style",r)}function ko(t,n,e,r){let o=Ln(),s=o[yt],i=t+ao,a=s.firstCreatePass?bM(i,o,2,n,ZY,y_(),e,r):s.data[i];if(tM(a,o,t,n,$M),k0(a)){let l=o[yt];eM(l,o,a),OR(l,a,o)}return r!=null&&GT(o,a),ko}function Qr(){let t=Rs(),n=ys(),e=nM(n);return t.firstCreatePass&&wM(t,e),FS(e)&&$S(),MS(),e.classesWithoutHost!=null&&zX(e)&&sR(t,e,Ln(),e.classesWithoutHost,!0),e.stylesWithoutHost!=null&&VX(e)&&sR(t,e,Ln(),e.stylesWithoutHost,!1),Qr}function Ms(t,n,e,r){return ko(t,n,e,r),Qr(),Ms}function Nd(t,n,e,r){let o=Ln(),s=o[yt],i=t+ao,a=s.firstCreatePass?MZ(i,s,2,n,e,r):s.data[i];return tM(a,o,t,n,$M),r!=null&&GT(o,a),Nd}function Dd(){let t=ys(),n=nM(t);return FS(n)&&$S(),MS(),Dd}var $M=(t,n,e,r,o)=>(P0(!0),$R(n[Or],r,A_()));function My(){return Ln()}var Oy="en-US";var xQ=Oy;function LM(t){typeof t=="string"&&(xQ=t.toLowerCase().replace(/_/g,"-"))}function kd(t,n,e){let r=Ln(),o=Rs(),s=ys();return vQ(o,r,r[Or],s,t,n,e),kd}function vQ(t,n,e,r,o,s,i){let a=!0,l=null;if((r.type&3||i)&&(l??=tT(r,n,s),OZ(r,t,n,i,e,o,s,l)&&(a=!1)),a){let c=r.outputs?.[o],u=r.hostDirectiveOutputs?.[o];if(u&&u.length)for(let p=0;p<u.length;p+=2){let f=u[p],d=u[p+1];l??=tT(r,n,s),tR(r,n,f,d,o,l)}if(c&&c.length)for(let p of c)l??=tT(r,n,s),tR(r,n,p,o,o,l)}}function bQ(t,n){let e=null,r=vY(t);for(let o=0;o<n.length;o++){let s=n[o];if(s==="*"){e=o;continue}if(r===null?VR(t,s,!0):CY(r,s))return o}return e}function Ad(t){let n=Ln()[jo][Eo];if(!n.projection){let e=t?t.length:1,r=n.projection=QA(e,null),o=r.slice(),s=n.child;for(;s!==null;){if(s.type!==128){let i=t?bQ(s,t):0;i!==null&&(o[i]?o[i].projectionNext=s:r[i]=s,o[i]=s)}s=s.next}}}function _d(t,n=0,e,r,o,s){let i=Ln(),a=Rs(),l=r?t+1:null;l!==null&&hQ(i,a,l,r,o,s,null,e);let c=ky(a,ao+t,16,null,e||null);c.projection===null&&(c.projection=n),BS();let p=!i[id]||OS();i[jo][Eo].projection[c.projection]===null&&l!==null?wQ(i,a,l):p&&!u2(c)&&UY(a,i,c)}function wQ(t,n,e){let r=ao+e,o=n.data[r],s=t[r],i=xT(s,o.tView.ssrId),a=oM(t,o,void 0,{dehydratedView:i});mM(s,a,0,mT(o,i))}function g2(t,n,e,r){return oQ(t,n,e,r),g2}function Rd(t,n,e){return rQ(t,n,e),Rd}function $a(t){let n=Ln(),e=Rs(),r=US();O0(r+1);let o=qT(e,r);if(t.dirty&&p_(n)===((o.metadata.flags&2)===2)){if(o.matches===null)t.reset([]);else{let s=aQ(n,r);t.reset(s,eY),t.notifyOnChanges()}return!0}return!1}function La(){return nQ(Ln(),US())}function B0(t,n){return t<<17|n<<2}function yp(t){return t>>17&32767}function CQ(t){return(t&2)==2}function IQ(t,n){return t&131071|n<<17}function NT(t){return t|2}function Cd(t){return(t&131068)>>2}function rT(t,n){return t&-131069|n<<2}function SQ(t){return(t&1)===1}function DT(t){return t|1}function TQ(t,n,e,r,o,s){let i=s?n.classBindings:n.styleBindings,a=yp(i),l=Cd(i);t[r]=e;let c=!1,u;if(Array.isArray(e)){let p=e;u=p[1],(u===null||od(p,u)>0)&&(c=!0)}else u=e;if(o)if(l!==0){let f=yp(t[a+1]);t[r+1]=B0(f,a),f!==0&&(t[f+1]=rT(t[f+1],r)),t[a+1]=IQ(t[a+1],r)}else t[r+1]=B0(a,0),a!==0&&(t[a+1]=rT(t[a+1],r)),a=r;else t[r+1]=B0(l,0),a===0?a=r:t[l+1]=rT(t[l+1],r),l=r;c&&(t[r+1]=NT(t[r+1])),iR(t,u,r,!0),iR(t,u,r,!1),EQ(n,u,t,r,s),i=B0(a,l),s?n.classBindings=i:n.styleBindings=i}function EQ(t,n,e,r,o){let s=o?t.residualClasses:t.residualStyles;s!=null&&typeof n=="string"&&od(s,n)>=0&&(e[r+1]=DT(e[r+1]))}function iR(t,n,e,r){let o=t[e+1],s=n===null,i=r?yp(o):Cd(o),a=!1;for(;i!==0&&(a===!1||s);){let l=t[i],c=t[i+1];NQ(l,n)&&(a=!0,t[i+1]=r?DT(c):NT(c)),i=r?yp(c):Cd(c)}a&&(t[e+1]=r?NT(o):DT(o))}function NQ(t,n){return t===null||n==null||(Array.isArray(t)?t[1]:t)===n?!0:Array.isArray(t)&&typeof n=="string"?od(t,n)>=0:!1}function y2(t,n){return DQ(t,n,null,!0),y2}function DQ(t,n,e,r){let o=Ln(),s=Rs(),i=w_(2);if(s.firstUpdatePass&&AQ(s,t,i,r),n!==Sd&&CM(o,i,n)){let a=s.data[xy()];FQ(s,a,o,o[Or],t,o[i+1]=$Q(n,e),r,i)}}function kQ(t,n){return n>=t.expandoStartIndex}function AQ(t,n,e,r){let o=t.data;if(o[e+1]===null){let s=o[xy()],i=kQ(t,e);LQ(s,r)&&n===null&&!i&&(n=!1),n=_Q(o,s,n,r),TQ(o,s,n,e,i,r)}}function _Q(t,n,e,r){let o=T_(t),s=r?n.residualClasses:n.residualStyles;if(o===null)(r?n.classBindings:n.styleBindings)===0&&(e=oT(null,t,n,e,r),e=Ty(e,n.attrs,r),s=null);else{let i=n.directiveStylingLast;if(i===-1||t[i]!==o)if(e=oT(o,t,n,e,r),s===null){let l=RQ(t,n,r);l!==void 0&&Array.isArray(l)&&(l=oT(null,t,n,l[1],r),l=Ty(l,n.attrs,r),MQ(t,n,r,l))}else s=OQ(t,n,r)}return s!==void 0&&(r?n.residualClasses=s:n.residualStyles=s),e}function RQ(t,n,e){let r=e?n.classBindings:n.styleBindings;if(Cd(r)!==0)return t[yp(r)]}function MQ(t,n,e,r){let o=e?n.classBindings:n.styleBindings;t[yp(o)]=r}function OQ(t,n,e){let r,o=n.directiveEnd;for(let s=1+n.directiveStylingLast;s<o;s++){let i=t[s].hostAttrs;r=Ty(r,i,e)}return Ty(r,n.attrs,e)}function oT(t,n,e,r,o){let s=null,i=e.directiveEnd,a=e.directiveStylingLast;for(a===-1?a=e.directiveStart:a++;a<i&&(s=n[a],r=Ty(r,s.hostAttrs,o),s!==t);)a++;return t!==null&&(e.directiveStylingLast=a),r}function Ty(t,n,e){let r=e?1:2,o=-1;if(n!==null)for(let s=0;s<n.length;s++){let i=n[s];typeof i=="number"?o=i:o===r&&(Array.isArray(t)||(t=t===void 0?[]:["",t]),e_(t,i,e?!0:n[++s]))}return t===void 0?null:t}function FQ(t,n,e,r,o,s,i,a){if(!(n.type&3))return;let l=t.data,c=l[a+1],u=SQ(c)?aR(l,n,e,o,Cd(c),i):void 0;if(!n2(u)){n2(s)||CQ(c)&&(s=aR(l,null,e,o,a,i));let p=u_(xy(),e);jY(r,i,p,o,s)}}function aR(t,n,e,r,o,s){let i=n===null,a;for(;o>0;){let l=t[o],c=Array.isArray(l),u=c?l[1]:l,p=u===null,f=e[o+1];f===Sd&&(f=p?ks:void 0);let d=p?E0(f,r):u===r?f:void 0;if(c&&!n2(d)&&(d=E0(l,r)),n2(d)&&(a=d,i))return a;let h=t[o+1];o=i?yp(h):Cd(h)}if(n!==null){let l=s?n.residualClasses:n.residualStyles;l!=null&&(a=E0(l,r))}return a}function n2(t){return t!==void 0}function $Q(t,n){return t==null||t===""||(typeof n=="string"?t=t+n:typeof t=="object"&&(t=Na(FR(t)))),t}function LQ(t,n){return(t.flags&(n?8:16))!==0}function li(t,n=""){let e=Ln(),r=Rs(),o=t+ao,s=r.firstCreatePass?ky(r,o,1,n,null):r.data[o],i=PQ(r,e,s,n);e[o]=i,L0()&&VT(r,e,i,s),hd(s,!1)}var PQ=(t,n,e,r)=>(P0(!0),uY(n[Or],r));function lR(t,n,e){let r=Rs();r.firstCreatePass&&PM(n,r.data,r.blueprint,uc(t),e)}function PM(t,n,e,r,o){if(t=Yr(t),Array.isArray(t))for(let s=0;s<t.length;s++)PM(t[s],n,e,r,o);else{let s=Rs(),i=Ln(),a=ys(),l=sp(t)?t:Yr(t.provide),c=SS(t),u=a.providerIndexes&1048575,p=a.directiveStart,f=a.providerIndexes>>20;if(sp(t)||!t.multi){let d=new mp(c,o,Oa,null),h=iT(l,n,o?u:u+f,p);h===-1?(lT(q0(a,i),s,l),sT(s,t,n.length),n.push(l),a.directiveStart++,a.directiveEnd++,o&&(a.providerIndexes+=1048576),e.push(d),i.push(d)):(e[h]=d,i[h]=d)}else{let d=iT(l,n,u+f,p),h=iT(l,n,u,u+f),g=d>=0&&e[d],m=h>=0&&e[h];if(o&&!m||!o&&!g){lT(q0(a,i),s,l);let y=VQ(o?zQ:BQ,e.length,o,r,c,t);!o&&m&&(e[h].providerFactory=y),sT(s,t,n.length,0),n.push(l),a.directiveStart++,a.directiveEnd++,o&&(a.providerIndexes+=1048576),e.push(y),i.push(y)}else{let y=BM(e[o?h:d],c,!o&&r);sT(s,t,d>-1?d:h,y)}!o&&r&&m&&e[h].componentProviders++}}}function sT(t,n,e,r){let o=sp(n),s=s_(n);if(o||s){let l=(s?Yr(n.useClass):n).prototype.ngOnDestroy;if(l){let c=t.destroyHooks||(t.destroyHooks=[]);if(!o&&n.multi){let u=c.indexOf(e);u===-1?c.push(e,[r,l]):c[u+1].push(r,l)}else c.push(e,l)}}}function BM(t,n,e){return e&&t.componentProviders++,t.multi.push(n)-1}function iT(t,n,e,r){for(let o=e;o<r;o++)if(n[o]===t)return o;return-1}function BQ(t,n,e,r,o){return kT(this.multi,[])}function zQ(t,n,e,r,o){let s=this.multi,i;if(this.providerFactory){let a=this.providerFactory.componentProviders,l=Cy(r,r[yt],this.providerFactory.index,o);i=l.slice(0,a),kT(s,i);for(let c=a;c<l.length;c++)i.push(l[c])}else i=[],kT(s,i);return i}function kT(t,n){for(let e=0;e<t.length;e++){let r=t[e];n.push(r())}return n}function VQ(t,n,e,r,o,s){let i=new mp(t,e,Oa,null);return i.multi=[],i.index=n,i.componentProviders=0,BM(i,o,r&&!e),i}function x2(t,n){return e=>{e.providersResolver=(r,o)=>lR(r,o?o(t):t,!1),n&&(e.viewProvidersResolver=(r,o)=>lR(r,o?o(n):n,!0))}}var r2=class{ngModuleFactory;componentFactories;constructor(n,e){this.ngModuleFactory=n,this.componentFactories=e}},ZT=(()=>{class t{compileModuleSync(e){return new t2(e)}compileModuleAsync(e){return Promise.resolve(this.compileModuleSync(e))}compileModuleAndAllComponentsSync(e){let r=this.compileModuleSync(e),o=mS(e),s=BR(o.declarations).reduce((i,a)=>{let l=sc(a);return l&&i.push(new bd(l)),i},[]);return new r2(r,s)}compileModuleAndAllComponentsAsync(e){return Promise.resolve(this.compileModuleAndAllComponentsSync(e))}clearCache(){}clearCacheFor(e){}getModuleId(e){}static \u0275fac=function(r){return new(r||t)};static \u0275prov=pt({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();var zM=(()=>{class t{applicationErrorHandler=Ae(Vi);appRef=Ae(Td);taskService=Ae(dc);ngZone=Ae(ms);zonelessEnabled=Ae(vy);tracing=Ae(Dy,{optional:!0});zoneIsDefined=typeof Zone<"u"&&!!Zone.root.run;schedulerTickApplyArgs=[{data:{__scheduler_tick__:!0}}];subscriptions=new Wr;angularZoneId=this.zoneIsDefined?this.ngZone._inner?.get(iy):null;scheduleInRootZone=!this.zonelessEnabled&&this.zoneIsDefined&&(Ae(YS,{optional:!0})??!1);cancelScheduledCallback=null;useMicrotaskScheduler=!1;runningTick=!1;pendingRenderTaskId=null;constructor(){this.subscriptions.add(this.appRef.afterTick.subscribe(()=>{let e=this.taskService.add();if(!this.runningTick&&(this.cleanup(),!this.zonelessEnabled||this.appRef.includeAllTestViews)){this.taskService.remove(e);return}this.switchToMicrotaskScheduler(),this.taskService.remove(e)})),this.subscriptions.add(this.ngZone.onUnstable.subscribe(()=>{this.runningTick||this.cleanup()}))}switchToMicrotaskScheduler(){this.ngZone.runOutsideAngular(()=>{let e=this.taskService.add();this.useMicrotaskScheduler=!0,queueMicrotask(()=>{this.useMicrotaskScheduler=!1,this.taskService.remove(e)})})}notify(e){if(!this.zonelessEnabled&&e===5)return;switch(e){case 0:{this.appRef.dirtyFlags|=2;break}case 3:case 2:case 4:case 5:case 1:{this.appRef.dirtyFlags|=4;break}case 6:{this.appRef.dirtyFlags|=2;break}case 12:{this.appRef.dirtyFlags|=16;break}case 13:{this.appRef.dirtyFlags|=2;break}case 11:break;default:this.appRef.dirtyFlags|=8}if(this.appRef.tracingSnapshot=this.tracing?.snapshot(this.appRef.tracingSnapshot)??null,!this.shouldScheduleTick())return;let r=this.useMicrotaskScheduler?O_:WS;this.pendingRenderTaskId=this.taskService.add(),this.scheduleInRootZone?this.cancelScheduledCallback=Zone.root.run(()=>r(()=>this.tick())):this.cancelScheduledCallback=this.ngZone.runOutsideAngular(()=>r(()=>this.tick()))}shouldScheduleTick(){return!(this.appRef.destroyed||this.pendingRenderTaskId!==null||this.runningTick||this.appRef._runningTick||!this.zonelessEnabled&&this.zoneIsDefined&&Zone.current.get(iy+this.angularZoneId))}tick(){if(this.runningTick||this.appRef.destroyed)return;if(this.appRef.dirtyFlags===0){this.cleanup();return}!this.zonelessEnabled&&this.appRef.dirtyFlags&7&&(this.appRef.dirtyFlags|=1);let e=this.taskService.add();try{this.ngZone.run(()=>{this.runningTick=!0,this.appRef._tick()},void 0,this.schedulerTickApplyArgs)}catch(r){this.applicationErrorHandler(r)}finally{this.taskService.remove(e),this.cleanup()}}ngOnDestroy(){this.subscriptions.unsubscribe(),this.cleanup()}cleanup(){if(this.runningTick=!1,this.cancelScheduledCallback?.(),this.cancelScheduledCallback=null,this.pendingRenderTaskId!==null){let e=this.pendingRenderTaskId;this.pendingRenderTaskId=null,this.taskService.remove(e)}}static \u0275fac=function(r){return new(r||t)};static \u0275prov=pt({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();function VM(){return[{provide:rd,useExisting:zM},{provide:ms,useClass:ay},{provide:vy,useValue:!0}]}function UQ(){return typeof $localize<"u"&&$localize.locale||Oy}var QT=new nt("",{factory:()=>Ae(QT,{optional:!0,skipSelf:!0})||UQ()});var jM=Symbol("InputSignalNode#UNSET"),tJ=Gn(Ye({},Xx),{transformFn:void 0,applyValueToInputSignal(t,n){Zg(t,n)}});function HM(t,n){let e=Object.create(tJ);e.value=t,e.transformFn=n?.transform;function r(){if(Wx(e),e.value===jM){let o=null;throw new it(-950,o)}return e.value}return r[Ds]=e,r}function UM(t,n){return HM(t,n)}function nJ(t){return HM(jM,t)}var WM=(UM.required=nJ,UM);var JT=new nt(""),rJ=new nt("");function Fy(t){return!t.moduleRef}function oJ(t){let n=Fy(t)?t.r3Injector:t.moduleRef.injector,e=n.get(ms);return e.run(()=>{Fy(t)?t.r3Injector.resolveInjectorInitializers():t.moduleRef.resolveInjectorInitializers();let r=n.get(Vi),o;if(e.runOutsideAngular(()=>{o=e.onError.subscribe({next:r})}),Fy(t)){let s=()=>n.destroy(),i=t.platformInjector.get(JT);i.add(s),n.onDestroy(()=>{o.unsubscribe(),i.delete(s)})}else{let s=()=>t.moduleRef.destroy(),i=t.platformInjector.get(JT);i.add(s),t.moduleRef.onDestroy(()=>{wy(t.allPlatformModules,t.moduleRef),o.unsubscribe(),i.delete(s)})}return iJ(r,e,()=>{let s=n.get(dc),i=s.add(),a=n.get(YT);return a.runInitializers(),a.donePromise.then(()=>{let l=n.get(QT,Oy);if(LM(l||Oy),!n.get(rJ,!0))return Fy(t)?n.get(Td):(t.allPlatformModules.push(t.moduleRef),t.moduleRef);if(Fy(t)){let u=n.get(Td);return t.rootComponent!==void 0&&u.bootstrap(t.rootComponent),u}else return sJ?.(t.moduleRef,t.allPlatformModules),t.moduleRef}).finally(()=>{s.remove(i)})})})}var sJ;function iJ(t,n,e){try{let r=e();return Ry(r)?r.catch(o=>{throw n.runOutsideAngular(()=>t(o)),o}):r}catch(r){throw n.runOutsideAngular(()=>t(r)),r}}var v2=null;function aJ(t=[],n){return Li.create({name:n,providers:[{provide:py,useValue:"platform"},{provide:JT,useValue:new Set([()=>v2=null])},...t]})}function lJ(t=[]){if(v2)return v2;let n=aJ(t);return v2=n,OM(),cJ(n),n}function cJ(t){let n=t.get(l2,null);io(t,()=>{n?.forEach(e=>e())})}var uJ=1e4;var VAe=uJ-1e3;var vp=(()=>{class t{static __NG_ELEMENT_ID__=pJ}return t})();function pJ(t){return fJ(ys(),Ln(),(t&16)===16)}function fJ(t,n,e){if(fp(t)&&!e){let r=zi(t.index,n);return new mc(r,r)}else if(t.type&175){let r=n[jo];return new mc(r,n)}return null}function qM(t){let{rootComponent:n,appProviders:e,platformProviders:r,platformRef:o}=t;bn(nn.BootstrapApplicationStart);try{let s=o?.injector??lJ(r),i=[VM(),$_,...e||[]],a=new Sy({providers:i,parent:s,debugName:"",runEnvironmentInitializers:!1});return oJ({r3Injector:a.injector,platformInjector:s,rootComponent:n})}catch(s){return Promise.reject(s)}finally{bn(nn.BootstrapApplicationEnd)}}var KM=null;function Pa(){return KM}function tE(t){KM??=t}var $y=class{},b2=(()=>{class t{historyGo(e){throw new Error("")}static \u0275fac=function(r){return new(r||t)};static \u0275prov=pt({token:t,factory:()=>Ae(XM),providedIn:"platform"})}return t})();var XM=(()=>{class t extends b2{_location;_history;_doc=Ae(lr);constructor(){super(),this._location=window.location,this._history=window.history}getBaseHrefFromDOM(){return Pa().getBaseHref(this._doc)}onPopState(e){let r=Pa().getGlobalEventTarget(this._doc,"window");return r.addEventListener("popstate",e,!1),()=>r.removeEventListener("popstate",e)}onHashChange(e){let r=Pa().getGlobalEventTarget(this._doc,"window");return r.addEventListener("hashchange",e,!1),()=>r.removeEventListener("hashchange",e)}get href(){return this._location.href}get protocol(){return this._location.protocol}get hostname(){return this._location.hostname}get port(){return this._location.port}get pathname(){return this._location.pathname}get search(){return this._location.search}get hash(){return this._location.hash}set pathname(e){this._location.pathname=e}pushState(e,r,o){this._history.pushState(e,r,o)}replaceState(e,r,o){this._history.replaceState(e,r,o)}forward(){this._history.forward()}back(){this._history.back()}historyGo(e=0){this._history.go(e)}getState(){return this._history.state}static \u0275fac=function(r){return new(r||t)};static \u0275prov=pt({token:t,factory:()=>new t,providedIn:"platform"})}return t})();function QM(t,n){return t?n?t.endsWith("/")?n.startsWith("/")?t+n.slice(1):t+n:n.startsWith("/")?t+n:`${t}/${n}`:t:n}function YM(t){let n=t.search(/#|\?|$/);return t[n-1]==="/"?t.slice(0,n-1)+t.slice(n):t}function gc(t){return t&&t[0]!=="?"?`?${t}`:t}var w2=(()=>{class t{historyGo(e){throw new Error("")}static \u0275fac=function(r){return new(r||t)};static \u0275prov=pt({token:t,factory:()=>Ae(hJ),providedIn:"root"})}return t})(),dJ=new nt(""),hJ=(()=>{class t extends w2{_platformLocation;_baseHref;_removeListenerFns=[];constructor(e,r){super(),this._platformLocation=e,this._baseHref=r??this._platformLocation.getBaseHrefFromDOM()??Ae(lr).location?.origin??""}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}prepareExternalUrl(e){return QM(this._baseHref,e)}path(e=!1){let r=this._platformLocation.pathname+gc(this._platformLocation.search),o=this._platformLocation.hash;return o&&e?`${r}${o}`:r}pushState(e,r,o,s){let i=this.prepareExternalUrl(o+gc(s));this._platformLocation.pushState(e,r,i)}replaceState(e,r,o,s){let i=this.prepareExternalUrl(o+gc(s));this._platformLocation.replaceState(e,r,i)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}getState(){return this._platformLocation.getState()}historyGo(e=0){this._platformLocation.historyGo?.(e)}static \u0275fac=function(r){return new(r||t)(At(b2),At(dJ,8))};static \u0275prov=pt({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})(),Md=(()=>{class t{_subject=new qr;_basePath;_locationStrategy;_urlChangeListeners=[];_urlChangeSubscription=null;constructor(e){this._locationStrategy=e;let r=this._locationStrategy.getBaseHref();this._basePath=yJ(YM(ZM(r))),this._locationStrategy.onPopState(o=>{this._subject.next({url:this.path(!0),pop:!0,state:o.state,type:o.type})})}ngOnDestroy(){this._urlChangeSubscription?.unsubscribe(),this._urlChangeListeners=[]}path(e=!1){return this.normalize(this._locationStrategy.path(e))}getState(){return this._locationStrategy.getState()}isCurrentPathEqualTo(e,r=""){return this.path()==this.normalize(e+gc(r))}normalize(e){return t.stripTrailingSlash(gJ(this._basePath,ZM(e)))}prepareExternalUrl(e){return e&&e[0]!=="/"&&(e="/"+e),this._locationStrategy.prepareExternalUrl(e)}go(e,r="",o=null){this._locationStrategy.pushState(o,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+gc(r)),o)}replaceState(e,r="",o=null){this._locationStrategy.replaceState(o,"",e,r),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+gc(r)),o)}forward(){this._locationStrategy.forward()}back(){this._locationStrategy.back()}historyGo(e=0){this._locationStrategy.historyGo?.(e)}onUrlChange(e){return this._urlChangeListeners.push(e),this._urlChangeSubscription??=this.subscribe(r=>{this._notifyUrlChangeListeners(r.url,r.state)}),()=>{let r=this._urlChangeListeners.indexOf(e);this._urlChangeListeners.splice(r,1),this._urlChangeListeners.length===0&&(this._urlChangeSubscription?.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(e="",r){this._urlChangeListeners.forEach(o=>o(e,r))}subscribe(e,r,o){return this._subject.subscribe({next:e,error:r??void 0,complete:o??void 0})}static normalizeQueryParams=gc;static joinWithSlash=QM;static stripTrailingSlash=YM;static \u0275fac=function(r){return new(r||t)(At(w2))};static \u0275prov=pt({token:t,factory:()=>mJ(),providedIn:"root"})}return t})();function mJ(){return new Md(At(w2))}function gJ(t,n){if(!t||!n.startsWith(t))return n;let e=n.substring(t.length);return e===""||["/",";","?","#"].includes(e[0])?e:n}function ZM(t){return t.replace(/\/index.html$/,"")}function yJ(t){if(new RegExp("^(https?:)?//").test(t)){let[,e]=t.split(/\/\/[^\/]+/);return e}return t}var Od=(()=>{class t{static \u0275fac=function(r){return new(r||t)};static \u0275mod=Gi({type:t});static \u0275inj=ri({})}return t})();function nE(t,n){n=encodeURIComponent(n);for(let e of t.split(";")){let r=e.indexOf("="),[o,s]=r==-1?[e,""]:[e.slice(0,r),e.slice(r+1)];if(o.trim()===n)return decodeURIComponent(s)}return null}var Ly=class{};var JM="browser";var Py=class{_doc;constructor(n){this._doc=n}manager},C2=(()=>{class t extends Py{constructor(e){super(e)}supports(e){return!0}addEventListener(e,r,o,s){return e.addEventListener(r,o,s),()=>this.removeEventListener(e,r,o,s)}removeEventListener(e,r,o,s){return e.removeEventListener(r,o,s)}static \u0275fac=function(r){return new(r||t)(At(lr))};static \u0275prov=pt({token:t,factory:t.\u0275fac})}return t})(),T2=new nt(""),iE=(()=>{class t{_zone;_plugins;_eventNameToPlugin=new Map;constructor(e,r){this._zone=r,e.forEach(i=>{i.manager=this});let o=e.filter(i=>!(i instanceof C2));this._plugins=o.slice().reverse();let s=e.find(i=>i instanceof C2);s&&this._plugins.push(s)}addEventListener(e,r,o,s){return this._findPluginFor(r).addEventListener(e,r,o,s)}getZone(){return this._zone}_findPluginFor(e){let r=this._eventNameToPlugin.get(e);if(r)return r;if(r=this._plugins.find(s=>s.supports(e)),!r)throw new it(5101,!1);return this._eventNameToPlugin.set(e,r),r}static \u0275fac=function(r){return new(r||t)(At(T2),At(ms))};static \u0275prov=pt({token:t,factory:t.\u0275fac})}return t})(),rE="ng-app-id";function eO(t){for(let n of t)n.remove()}function tO(t,n){let e=n.createElement("style");return e.textContent=t,e}function vJ(t,n,e,r){let o=t.head?.querySelectorAll(`style[${rE}="${n}"],link[${rE}="${n}"]`);if(o)for(let s of o)s.removeAttribute(rE),s instanceof HTMLLinkElement?r.set(s.href.slice(s.href.lastIndexOf("/")+1),{usage:0,elements:[s]}):s.textContent&&e.set(s.textContent,{usage:0,elements:[s]})}function sE(t,n){let e=n.createElement("link");return e.setAttribute("rel","stylesheet"),e.setAttribute("href",t),e}var aE=(()=>{class t{doc;appId;nonce;inline=new Map;external=new Map;hosts=new Set;constructor(e,r,o,s={}){this.doc=e,this.appId=r,this.nonce=o,vJ(e,r,this.inline,this.external),this.hosts.add(e.head)}addStyles(e,r){for(let o of e)this.addUsage(o,this.inline,tO);r?.forEach(o=>this.addUsage(o,this.external,sE))}removeStyles(e,r){for(let o of e)this.removeUsage(o,this.inline);r?.forEach(o=>this.removeUsage(o,this.external))}addUsage(e,r,o){let s=r.get(e);s?s.usage++:r.set(e,{usage:1,elements:[...this.hosts].map(i=>this.addElement(i,o(e,this.doc)))})}removeUsage(e,r){let o=r.get(e);o&&(o.usage--,o.usage<=0&&(eO(o.elements),r.delete(e)))}ngOnDestroy(){for(let[,{elements:e}]of[...this.inline,...this.external])eO(e);this.hosts.clear()}addHost(e){this.hosts.add(e);for(let[r,{elements:o}]of this.inline)o.push(this.addElement(e,tO(r,this.doc)));for(let[r,{elements:o}]of this.external)o.push(this.addElement(e,sE(r,this.doc)))}removeHost(e){this.hosts.delete(e)}addElement(e,r){return this.nonce&&r.setAttribute("nonce",this.nonce),e.appendChild(r)}static \u0275fac=function(r){return new(r||t)(At(lr),At(a2),At(c2,8),At(Ny))};static \u0275prov=pt({token:t,factory:t.\u0275fac})}return t})(),oE={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/",math:"http://www.w3.org/1998/Math/MathML"},lE=/%COMP%/g;var rO="%COMP%",bJ=`_nghost-${rO}`,wJ=`_ngcontent-${rO}`,CJ=!0,IJ=new nt("",{factory:()=>CJ});function SJ(t){return wJ.replace(lE,t)}function TJ(t){return bJ.replace(lE,t)}function oO(t,n){return n.map(e=>e.replace(lE,t))}var cE=(()=>{class t{eventManager;sharedStylesHost;appId;removeStylesOnCompDestroy;doc;ngZone;nonce;tracingService;rendererByCompId=new Map;defaultRenderer;constructor(e,r,o,s,i,a,l=null,c=null){this.eventManager=e,this.sharedStylesHost=r,this.appId=o,this.removeStylesOnCompDestroy=s,this.doc=i,this.ngZone=a,this.nonce=l,this.tracingService=c,this.defaultRenderer=new By(e,i,a,this.tracingService)}createRenderer(e,r){if(!e||!r)return this.defaultRenderer;let o=this.getOrCreateRenderer(e,r);return o instanceof S2?o.applyToHost(e):o instanceof zy&&o.applyStyles(),o}getOrCreateRenderer(e,r){let o=this.rendererByCompId,s=o.get(r.id);if(!s){let i=this.doc,a=this.ngZone,l=this.eventManager,c=this.sharedStylesHost,u=this.removeStylesOnCompDestroy,p=this.tracingService;switch(r.encapsulation){case ai.Emulated:s=new S2(l,c,r,this.appId,u,i,a,p);break;case ai.ShadowDom:return new I2(l,e,r,i,a,this.nonce,p,c);case ai.ExperimentalIsolatedShadowDom:return new I2(l,e,r,i,a,this.nonce,p);default:s=new zy(l,c,r,u,i,a,p);break}o.set(r.id,s)}return s}ngOnDestroy(){this.rendererByCompId.clear()}componentReplaced(e){this.rendererByCompId.delete(e)}static \u0275fac=function(r){return new(r||t)(At(iE),At(aE),At(a2),At(IJ),At(lr),At(ms),At(c2),At(Dy,8))};static \u0275prov=pt({token:t,factory:t.\u0275fac})}return t})(),By=class{eventManager;doc;ngZone;tracingService;data=Object.create(null);throwOnSyntheticProps=!0;constructor(n,e,r,o){this.eventManager=n,this.doc=e,this.ngZone=r,this.tracingService=o}destroy(){}destroyNode=null;createElement(n,e){return e?this.doc.createElementNS(oE[e]||e,n):this.doc.createElement(n)}createComment(n){return this.doc.createComment(n)}createText(n){return this.doc.createTextNode(n)}appendChild(n,e){(nO(n)?n.content:n).appendChild(e)}insertBefore(n,e,r){n&&(nO(n)?n.content:n).insertBefore(e,r)}removeChild(n,e){e.remove()}selectRootElement(n,e){let r=typeof n=="string"?this.doc.querySelector(n):n;if(!r)throw new it(-5104,!1);return e||(r.textContent=""),r}parentNode(n){return n.parentNode}nextSibling(n){return n.nextSibling}setAttribute(n,e,r,o){if(o){e=o+":"+e;let s=oE[o];s?n.setAttributeNS(s,e,r):n.setAttribute(e,r)}else n.setAttribute(e,r)}removeAttribute(n,e,r){if(r){let o=oE[r];o?n.removeAttributeNS(o,e):n.removeAttribute(`${r}:${e}`)}else n.removeAttribute(e)}addClass(n,e){n.classList.add(e)}removeClass(n,e){n.classList.remove(e)}setStyle(n,e,r,o){o&(Ra.DashCase|Ra.Important)?n.style.setProperty(e,r,o&Ra.Important?"important":""):n.style[e]=r}removeStyle(n,e,r){r&Ra.DashCase?n.style.removeProperty(e):n.style[e]=""}setProperty(n,e,r){n!=null&&(n[e]=r)}setValue(n,e){n.nodeValue=e}listen(n,e,r,o){if(typeof n=="string"&&(n=Pa().getGlobalEventTarget(this.doc,n),!n))throw new it(5102,!1);let s=this.decoratePreventDefault(r);return this.tracingService?.wrapEventListener&&(s=this.tracingService.wrapEventListener(n,e,s)),this.eventManager.addEventListener(n,e,s,o)}decoratePreventDefault(n){return e=>{if(e==="__ngUnwrap__")return n;n(e)===!1&&e.preventDefault()}}};function nO(t){return t.tagName==="TEMPLATE"&&t.content!==void 0}var I2=class extends By{hostEl;sharedStylesHost;shadowRoot;constructor(n,e,r,o,s,i,a,l){super(n,o,s,a),this.hostEl=e,this.sharedStylesHost=l,this.shadowRoot=e.attachShadow({mode:"open"}),this.sharedStylesHost&&this.sharedStylesHost.addHost(this.shadowRoot);let c=r.styles;c=oO(r.id,c);for(let p of c){let f=document.createElement("style");i&&f.setAttribute("nonce",i),f.textContent=p,this.shadowRoot.appendChild(f)}let u=r.getExternalStyles?.();if(u)for(let p of u){let f=sE(p,o);i&&f.setAttribute("nonce",i),this.shadowRoot.appendChild(f)}}nodeOrShadowRoot(n){return n===this.hostEl?this.shadowRoot:n}appendChild(n,e){return super.appendChild(this.nodeOrShadowRoot(n),e)}insertBefore(n,e,r){return super.insertBefore(this.nodeOrShadowRoot(n),e,r)}removeChild(n,e){return super.removeChild(null,e)}parentNode(n){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(n)))}destroy(){this.sharedStylesHost&&this.sharedStylesHost.removeHost(this.shadowRoot)}},zy=class extends By{sharedStylesHost;removeStylesOnCompDestroy;styles;styleUrls;constructor(n,e,r,o,s,i,a,l){super(n,s,i,a),this.sharedStylesHost=e,this.removeStylesOnCompDestroy=o;let c=r.styles;this.styles=l?oO(l,c):c,this.styleUrls=r.getExternalStyles?.(l)}applyStyles(){this.sharedStylesHost.addStyles(this.styles,this.styleUrls)}destroy(){this.removeStylesOnCompDestroy&&xd.size===0&&this.sharedStylesHost.removeStyles(this.styles,this.styleUrls)}},S2=class extends zy{contentAttr;hostAttr;constructor(n,e,r,o,s,i,a,l){let c=o+"-"+r.id;super(n,e,r,s,i,a,l,c),this.contentAttr=SJ(c),this.hostAttr=TJ(c)}applyToHost(n){this.applyStyles(),this.setAttribute(n,this.hostAttr,"")}createElement(n,e){let r=super.createElement(n,e);return super.setAttribute(r,this.contentAttr,""),r}};var E2=class t extends $y{supportsDOMEvents=!0;static makeCurrent(){tE(new t)}onAndCancel(n,e,r,o){return n.addEventListener(e,r,o),()=>{n.removeEventListener(e,r,o)}}dispatchEvent(n,e){n.dispatchEvent(e)}remove(n){n.remove()}createElement(n,e){return e=e||this.getDefaultDocument(),e.createElement(n)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(n){return n.nodeType===Node.ELEMENT_NODE}isShadowRoot(n){return n instanceof DocumentFragment}getGlobalEventTarget(n,e){return e==="window"?window:e==="document"?n:e==="body"?n.body:null}getBaseHref(n){let e=EJ();return e==null?null:NJ(e)}resetBaseElement(){Vy=null}getUserAgent(){return window.navigator.userAgent}getCookie(n){return nE(document.cookie,n)}},Vy=null;function EJ(){return Vy=Vy||document.head.querySelector("base"),Vy?Vy.getAttribute("href"):null}function NJ(t){return new URL(t,document.baseURI).pathname}var DJ=(()=>{class t{build(){return new XMLHttpRequest}static \u0275fac=function(r){return new(r||t)};static \u0275prov=pt({token:t,factory:t.\u0275fac})}return t})(),sO=["alt","control","meta","shift"],kJ={"\b":"Backspace","	":"Tab","\x7F":"Delete","\x1B":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},AJ={alt:t=>t.altKey,control:t=>t.ctrlKey,meta:t=>t.metaKey,shift:t=>t.shiftKey},iO=(()=>{class t extends Py{constructor(e){super(e)}supports(e){return t.parseEventName(e)!=null}addEventListener(e,r,o,s){let i=t.parseEventName(r),a=t.eventCallback(i.fullKey,o,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>Pa().onAndCancel(e,i.domEventName,a,s))}static parseEventName(e){let r=e.toLowerCase().split("."),o=r.shift();if(r.length===0||!(o==="keydown"||o==="keyup"))return null;let s=t._normalizeKey(r.pop()),i="",a=r.indexOf("code");if(a>-1&&(r.splice(a,1),i="code."),sO.forEach(c=>{let u=r.indexOf(c);u>-1&&(r.splice(u,1),i+=c+".")}),i+=s,r.length!=0||s.length===0)return null;let l={};return l.domEventName=o,l.fullKey=i,l}static matchEventFullKeyCode(e,r){let o=kJ[e.key]||e.key,s="";return r.indexOf("code.")>-1&&(o=e.code,s="code."),o==null||!o?!1:(o=o.toLowerCase(),o===" "?o="space":o==="."&&(o="dot"),sO.forEach(i=>{if(i!==o){let a=AJ[i];a(e)&&(s+=i+".")}}),s+=o,s===r)}static eventCallback(e,r,o){return s=>{t.matchEventFullKeyCode(s,e)&&o.runGuarded(()=>r(s))}}static _normalizeKey(e){return e==="esc"?"escape":e}static \u0275fac=function(r){return new(r||t)(At(lr))};static \u0275prov=pt({token:t,factory:t.\u0275fac})}return t})();function uE(t,n,e){return te(this,null,function*(){let r=Ye({rootComponent:t},_J(n,e));return qM(r)})}function _J(t,n){return{platformRef:n?.platformRef,appProviders:[...$J,...t?.providers??[]],platformProviders:FJ}}function RJ(){E2.makeCurrent()}function MJ(){return new Da}function OJ(){return RT(document),document}var FJ=[{provide:Ny,useValue:JM},{provide:l2,useValue:RJ,multi:!0},{provide:lr,useFactory:OJ}];var $J=[{provide:py,useValue:"root"},{provide:Da,useFactory:MJ},{provide:T2,useClass:C2,multi:!0},{provide:T2,useClass:iO,multi:!0},cE,aE,iE,{provide:gp,useExisting:cE},{provide:Ly,useClass:DJ},[]];var aO=(()=>{class t{_doc;constructor(e){this._doc=e}getTitle(){return this._doc.title}setTitle(e){this._doc.title=e||""}static \u0275fac=function(r){return new(r||t)(At(lr))};static \u0275prov=pt({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();var vt="primary",Jy=Symbol("RouteTitle"),mE=class{params;constructor(n){this.params=n||{}}has(n){return Object.prototype.hasOwnProperty.call(this.params,n)}get(n){if(this.has(n)){let e=this.params[n];return Array.isArray(e)?e[0]:e}return null}getAll(n){if(this.has(n)){let e=this.params[n];return Array.isArray(e)?e:[e]}return[]}get keys(){return Object.keys(this.params)}};function Cp(t){return new mE(t)}function pE(t,n,e){for(let r=0;r<t.length;r++){let o=t[r],s=n[r];if(o[0]===":")e[o.substring(1)]=s;else if(o!==s.path)return!1}return!0}function yO(t,n,e){let r=e.path.split("/"),o=r.indexOf("**");if(o===-1){if(r.length>t.length||e.pathMatch==="full"&&(n.hasChildren()||r.length<t.length))return null;let l={},c=t.slice(0,r.length);return pE(r,c,l)?{consumed:c,posParams:l}:null}if(o!==r.lastIndexOf("**"))return null;let s=r.slice(0,o),i=r.slice(o+1);if(s.length+i.length>t.length||e.pathMatch==="full"&&n.hasChildren()&&e.path!=="**")return null;let a={};return!pE(s,t.slice(0,s.length),a)||!pE(i,t.slice(t.length-i.length),a)?null:{consumed:t,posParams:a}}function R2(t){return new Promise((n,e)=>{t.pipe(Sa()).subscribe({next:r=>n(r),error:r=>e(r)})})}function PJ(t,n){if(t.length!==n.length)return!1;for(let e=0;e<t.length;++e)if(!ji(t[e],n[e]))return!1;return!0}function ji(t,n){let e=t?gE(t):void 0,r=n?gE(n):void 0;if(!e||!r||e.length!=r.length)return!1;let o;for(let s=0;s<e.length;s++)if(o=e[s],!xO(t[o],n[o]))return!1;return!0}function gE(t){return[...Object.keys(t),...Object.getOwnPropertySymbols(t)]}function xO(t,n){if(Array.isArray(t)&&Array.isArray(n)){if(t.length!==n.length)return!1;let e=[...t].sort(),r=[...n].sort();return e.every((o,s)=>r[s]===o)}else return t===n}function BJ(t){return t.length>0?t[t.length-1]:null}function Tp(t){return d0(t)?t:Ry(t)?Rr(Promise.resolve(t)):Gt(t)}function vO(t){return d0(t)?R2(t):Promise.resolve(t)}var zJ={exact:wO,subset:CO},bO={exact:VJ,subset:UJ,ignored:()=>!0};function lO(t,n,e){return zJ[e.paths](t.root,n.root,e.matrixParams)&&bO[e.queryParams](t.queryParams,n.queryParams)&&!(e.fragment==="exact"&&t.fragment!==n.fragment)}function VJ(t,n){return ji(t,n)}function wO(t,n,e){if(!bp(t.segments,n.segments)||!k2(t.segments,n.segments,e)||t.numberOfChildren!==n.numberOfChildren)return!1;for(let r in n.children)if(!t.children[r]||!wO(t.children[r],n.children[r],e))return!1;return!0}function UJ(t,n){return Object.keys(n).length<=Object.keys(t).length&&Object.keys(n).every(e=>xO(t[e],n[e]))}function CO(t,n,e){return IO(t,n,n.segments,e)}function IO(t,n,e,r){if(t.segments.length>e.length){let o=t.segments.slice(0,e.length);return!(!bp(o,e)||n.hasChildren()||!k2(o,e,r))}else if(t.segments.length===e.length){if(!bp(t.segments,e)||!k2(t.segments,e,r))return!1;for(let o in n.children)if(!t.children[o]||!CO(t.children[o],n.children[o],r))return!1;return!0}else{let o=e.slice(0,t.segments.length),s=e.slice(t.segments.length);return!bp(t.segments,o)||!k2(t.segments,o,r)||!t.children[vt]?!1:IO(t.children[vt],n,s,r)}}function k2(t,n,e){return n.every((r,o)=>bO[e](t[o].parameters,r.parameters))}var ui=class{root;queryParams;fragment;_queryParamMap;constructor(n=new rn([],{}),e={},r=null){this.root=n,this.queryParams=e,this.fragment=r}get queryParamMap(){return this._queryParamMap??=Cp(this.queryParams),this._queryParamMap}toString(){return HJ.serialize(this)}},rn=class{segments;children;parent=null;constructor(n,e){this.segments=n,this.children=e,Object.values(e).forEach(r=>r.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return A2(this)}},yc=class{path;parameters;_parameterMap;constructor(n,e){this.path=n,this.parameters=e}get parameterMap(){return this._parameterMap??=Cp(this.parameters),this._parameterMap}toString(){return TO(this)}};function GJ(t,n){return bp(t,n)&&t.every((e,r)=>ji(e.parameters,n[r].parameters))}function bp(t,n){return t.length!==n.length?!1:t.every((e,r)=>e.path===n[r].path)}function jJ(t,n){let e=[];return Object.entries(t.children).forEach(([r,o])=>{r===vt&&(e=e.concat(n(o,r)))}),Object.entries(t.children).forEach(([r,o])=>{r!==vt&&(e=e.concat(n(o,r)))}),e}var e1=(()=>{class t{static \u0275fac=function(r){return new(r||t)};static \u0275prov=pt({token:t,factory:()=>new xc,providedIn:"root"})}return t})(),xc=class{parse(n){let e=new xE(n);return new ui(e.parseRootSegment(),e.parseQueryParams(),e.parseFragment())}serialize(n){let e=`/${Uy(n.root,!0)}`,r=KJ(n.queryParams),o=typeof n.fragment=="string"?`#${WJ(n.fragment)}`:"";return`${e}${r}${o}`}},HJ=new xc;function A2(t){return t.segments.map(n=>TO(n)).join("/")}function Uy(t,n){if(!t.hasChildren())return A2(t);if(n){let e=t.children[vt]?Uy(t.children[vt],!1):"",r=[];return Object.entries(t.children).forEach(([o,s])=>{o!==vt&&r.push(`${o}:${Uy(s,!1)}`)}),r.length>0?`${e}(${r.join("//")})`:e}else{let e=jJ(t,(r,o)=>o===vt?[Uy(t.children[vt],!1)]:[`${o}:${Uy(r,!1)}`]);return Object.keys(t.children).length===1&&t.children[vt]!=null?`${A2(t)}/${e[0]}`:`${A2(t)}/(${e.join("//")})`}}function SO(t){return encodeURIComponent(t).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function N2(t){return SO(t).replace(/%3B/gi,";")}function WJ(t){return encodeURI(t)}function yE(t){return SO(t).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function _2(t){return decodeURIComponent(t)}function cO(t){return _2(t.replace(/\+/g,"%20"))}function TO(t){return`${yE(t.path)}${qJ(t.parameters)}`}function qJ(t){return Object.entries(t).map(([n,e])=>`;${yE(n)}=${yE(e)}`).join("")}function KJ(t){let n=Object.entries(t).map(([e,r])=>Array.isArray(r)?r.map(o=>`${N2(e)}=${N2(o)}`).join("&"):`${N2(e)}=${N2(r)}`).filter(e=>e);return n.length?`?${n.join("&")}`:""}var XJ=/^[^\/()?;#]+/;function fE(t){let n=t.match(XJ);return n?n[0]:""}var YJ=/^[^\/()?;=#]+/;function ZJ(t){let n=t.match(YJ);return n?n[0]:""}var QJ=/^[^=?&#]+/;function JJ(t){let n=t.match(QJ);return n?n[0]:""}var eee=/^[^&#]+/;function tee(t){let n=t.match(eee);return n?n[0]:""}var xE=class{url;remaining;constructor(n){this.url=n,this.remaining=n}parseRootSegment(){return this.consumeOptional("/"),this.remaining===""||this.peekStartsWith("?")||this.peekStartsWith("#")?new rn([],{}):new rn([],this.parseChildren())}parseQueryParams(){let n={};if(this.consumeOptional("?"))do this.parseQueryParam(n);while(this.consumeOptional("&"));return n}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(n=0){if(n>50)throw new it(4010,!1);if(this.remaining==="")return{};this.consumeOptional("/");let e=[];for(this.peekStartsWith("(")||e.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),e.push(this.parseSegment());let r={};this.peekStartsWith("/(")&&(this.capture("/"),r=this.parseParens(!0,n));let o={};return this.peekStartsWith("(")&&(o=this.parseParens(!1,n)),(e.length>0||Object.keys(r).length>0)&&(o[vt]=new rn(e,r)),o}parseSegment(){let n=fE(this.remaining);if(n===""&&this.peekStartsWith(";"))throw new it(4009,!1);return this.capture(n),new yc(_2(n),this.parseMatrixParams())}parseMatrixParams(){let n={};for(;this.consumeOptional(";");)this.parseParam(n);return n}parseParam(n){let e=ZJ(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){let o=fE(this.remaining);o&&(r=o,this.capture(r))}n[_2(e)]=_2(r)}parseQueryParam(n){let e=JJ(this.remaining);if(!e)return;this.capture(e);let r="";if(this.consumeOptional("=")){let i=tee(this.remaining);i&&(r=i,this.capture(r))}let o=cO(e),s=cO(r);if(n.hasOwnProperty(o)){let i=n[o];Array.isArray(i)||(i=[i],n[o]=i),i.push(s)}else n[o]=s}parseParens(n,e){let r={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){let o=fE(this.remaining),s=this.remaining[o.length];if(s!=="/"&&s!==")"&&s!==";")throw new it(4010,!1);let i;o.indexOf(":")>-1?(i=o.slice(0,o.indexOf(":")),this.capture(i),this.capture(":")):n&&(i=vt);let a=this.parseChildren(e+1);r[i??vt]=Object.keys(a).length===1&&a[vt]?a[vt]:new rn([],a),this.consumeOptional("//")}return r}peekStartsWith(n){return this.remaining.startsWith(n)}consumeOptional(n){return this.peekStartsWith(n)?(this.remaining=this.remaining.substring(n.length),!0):!1}capture(n){if(!this.consumeOptional(n))throw new it(4011,!1)}};function EO(t){return t.segments.length>0?new rn([],{[vt]:t}):t}function NO(t){let n={};for(let[r,o]of Object.entries(t.children)){let s=NO(o);if(r===vt&&s.segments.length===0&&s.hasChildren())for(let[i,a]of Object.entries(s.children))n[i]=a;else(s.segments.length>0||s.hasChildren())&&(n[r]=s)}let e=new rn(t.segments,n);return nee(e)}function nee(t){if(t.numberOfChildren===1&&t.children[vt]){let n=t.children[vt];return new rn(t.segments.concat(n.segments),n.children)}return t}function Pd(t){return t instanceof ui}function DO(t,n,e=null,r=null,o=new xc){let s=kO(t);return AO(s,n,e,r,o)}function kO(t){let n;function e(s){let i={};for(let l of s.children){let c=e(l);i[l.outlet]=c}let a=new rn(s.url,i);return s===t&&(n=a),a}let r=e(t.root),o=EO(r);return n??o}function AO(t,n,e,r,o){let s=t;for(;s.parent;)s=s.parent;if(n.length===0)return dE(s,s,s,e,r,o);let i=ree(n);if(i.toRoot())return dE(s,s,new rn([],{}),e,r,o);let a=oee(i,s,t),l=a.processChildren?jy(a.segmentGroup,a.index,i.commands):RO(a.segmentGroup,a.index,i.commands);return dE(s,a.segmentGroup,l,e,r,o)}function M2(t){return typeof t=="object"&&t!=null&&!t.outlets&&!t.segmentPath}function qy(t){return typeof t=="object"&&t!=null&&t.outlets}function uO(t,n,e){t||="\u0275";let r=new ui;return r.queryParams={[t]:n},e.parse(e.serialize(r)).queryParams[t]}function dE(t,n,e,r,o,s){let i={};for(let[c,u]of Object.entries(r??{}))i[c]=Array.isArray(u)?u.map(p=>uO(c,p,s)):uO(c,u,s);let a;t===n?a=e:a=_O(t,n,e);let l=EO(NO(a));return new ui(l,i,o)}function _O(t,n,e){let r={};return Object.entries(t.children).forEach(([o,s])=>{s===n?r[o]=e:r[o]=_O(s,n,e)}),new rn(t.segments,r)}var O2=class{isAbsolute;numberOfDoubleDots;commands;constructor(n,e,r){if(this.isAbsolute=n,this.numberOfDoubleDots=e,this.commands=r,n&&r.length>0&&M2(r[0]))throw new it(4003,!1);let o=r.find(qy);if(o&&o!==BJ(r))throw new it(4004,!1)}toRoot(){return this.isAbsolute&&this.commands.length===1&&this.commands[0]=="/"}};function ree(t){if(typeof t[0]=="string"&&t.length===1&&t[0]==="/")return new O2(!0,0,t);let n=0,e=!1,r=t.reduce((o,s,i)=>{if(typeof s=="object"&&s!=null){if(s.outlets){let a={};return Object.entries(s.outlets).forEach(([l,c])=>{a[l]=typeof c=="string"?c.split("/"):c}),[...o,{outlets:a}]}if(s.segmentPath)return[...o,s.segmentPath]}return typeof s!="string"?[...o,s]:i===0?(s.split("/").forEach((a,l)=>{l==0&&a==="."||(l==0&&a===""?e=!0:a===".."?n++:a!=""&&o.push(a))}),o):[...o,s]},[]);return new O2(e,n,r)}var $d=class{segmentGroup;processChildren;index;constructor(n,e,r){this.segmentGroup=n,this.processChildren=e,this.index=r}};function oee(t,n,e){if(t.isAbsolute)return new $d(n,!0,0);if(!e)return new $d(n,!1,NaN);if(e.parent===null)return new $d(e,!0,0);let r=M2(t.commands[0])?0:1,o=e.segments.length-1+r;return see(e,o,t.numberOfDoubleDots)}function see(t,n,e){let r=t,o=n,s=e;for(;s>o;){if(s-=o,r=r.parent,!r)throw new it(4005,!1);o=r.segments.length}return new $d(r,!1,o-s)}function iee(t){return qy(t[0])?t[0].outlets:{[vt]:t}}function RO(t,n,e){if(t??=new rn([],{}),t.segments.length===0&&t.hasChildren())return jy(t,n,e);let r=aee(t,n,e),o=e.slice(r.commandIndex);if(r.match&&r.pathIndex<t.segments.length){let s=new rn(t.segments.slice(0,r.pathIndex),{});return s.children[vt]=new rn(t.segments.slice(r.pathIndex),t.children),jy(s,0,o)}else return r.match&&o.length===0?new rn(t.segments,{}):r.match&&!t.hasChildren()?vE(t,n,e):r.match?jy(t,0,o):vE(t,n,e)}function jy(t,n,e){if(e.length===0)return new rn(t.segments,{});{let r=iee(e),o={};if(Object.keys(r).some(s=>s!==vt)&&t.children[vt]&&t.numberOfChildren===1&&t.children[vt].segments.length===0){let s=jy(t.children[vt],n,e);return new rn(t.segments,s.children)}return Object.entries(r).forEach(([s,i])=>{typeof i=="string"&&(i=[i]),i!==null&&(o[s]=RO(t.children[s],n,i))}),Object.entries(t.children).forEach(([s,i])=>{r[s]===void 0&&(o[s]=i)}),new rn(t.segments,o)}}function aee(t,n,e){let r=0,o=n,s={match:!1,pathIndex:0,commandIndex:0};for(;o<t.segments.length;){if(r>=e.length)return s;let i=t.segments[o],a=e[r];if(qy(a))break;let l=`${a}`,c=r<e.length-1?e[r+1]:null;if(o>0&&l===void 0)break;if(l&&c&&typeof c=="object"&&c.outlets===void 0){if(!fO(l,c,i))return s;r+=2}else{if(!fO(l,{},i))return s;r++}o++}return{match:!0,pathIndex:o,commandIndex:r}}function vE(t,n,e){let r=t.segments.slice(0,n),o=0;for(;o<e.length;){let s=e[o];if(qy(s)){let l=lee(s.outlets);return new rn(r,l)}if(o===0&&M2(e[0])){let l=t.segments[n];r.push(new yc(l.path,pO(e[0]))),o++;continue}let i=qy(s)?s.outlets[vt]:`${s}`,a=o<e.length-1?e[o+1]:null;i&&a&&M2(a)?(r.push(new yc(i,pO(a))),o+=2):(r.push(new yc(i,{})),o++)}return new rn(r,{})}function lee(t){let n={};return Object.entries(t).forEach(([e,r])=>{typeof r=="string"&&(r=[r]),r!==null&&(n[e]=vE(new rn([],{}),0,r))}),n}function pO(t){let n={};return Object.entries(t).forEach(([e,r])=>n[e]=`${r}`),n}function fO(t,n,e){return t==e.path&&ji(n,e.parameters)}var Hy="imperative",Fr=(function(t){return t[t.NavigationStart=0]="NavigationStart",t[t.NavigationEnd=1]="NavigationEnd",t[t.NavigationCancel=2]="NavigationCancel",t[t.NavigationError=3]="NavigationError",t[t.RoutesRecognized=4]="RoutesRecognized",t[t.ResolveStart=5]="ResolveStart",t[t.ResolveEnd=6]="ResolveEnd",t[t.GuardsCheckStart=7]="GuardsCheckStart",t[t.GuardsCheckEnd=8]="GuardsCheckEnd",t[t.RouteConfigLoadStart=9]="RouteConfigLoadStart",t[t.RouteConfigLoadEnd=10]="RouteConfigLoadEnd",t[t.ChildActivationStart=11]="ChildActivationStart",t[t.ChildActivationEnd=12]="ChildActivationEnd",t[t.ActivationStart=13]="ActivationStart",t[t.ActivationEnd=14]="ActivationEnd",t[t.Scroll=15]="Scroll",t[t.NavigationSkipped=16]="NavigationSkipped",t})(Fr||{}),vs=class{id;url;constructor(n,e){this.id=n,this.url=e}},Ip=class extends vs{type=Fr.NavigationStart;navigationTrigger;restoredState;constructor(n,e,r="imperative",o=null){super(n,e),this.navigationTrigger=r,this.restoredState=o}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}},za=class extends vs{urlAfterRedirects;type=Fr.NavigationEnd;constructor(n,e,r){super(n,e),this.urlAfterRedirects=r}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}},lo=(function(t){return t[t.Redirect=0]="Redirect",t[t.SupersededByNewNavigation=1]="SupersededByNewNavigation",t[t.NoDataFromResolver=2]="NoDataFromResolver",t[t.GuardRejected=3]="GuardRejected",t[t.Aborted=4]="Aborted",t})(lo||{}),Ky=(function(t){return t[t.IgnoredSameUrlNavigation=0]="IgnoredSameUrlNavigation",t[t.IgnoredByUrlHandlingStrategy=1]="IgnoredByUrlHandlingStrategy",t})(Ky||{}),Os=class extends vs{reason;code;type=Fr.NavigationCancel;constructor(n,e,r,o){super(n,e),this.reason=r,this.code=o}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}};function MO(t){return t instanceof Os&&(t.code===lo.Redirect||t.code===lo.SupersededByNewNavigation)}var Va=class extends vs{reason;code;type=Fr.NavigationSkipped;constructor(n,e,r,o){super(n,e),this.reason=r,this.code=o}},Sp=class extends vs{error;target;type=Fr.NavigationError;constructor(n,e,r,o){super(n,e),this.error=r,this.target=o}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}},Bd=class extends vs{urlAfterRedirects;state;type=Fr.RoutesRecognized;constructor(n,e,r,o){super(n,e),this.urlAfterRedirects=r,this.state=o}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}},F2=class extends vs{urlAfterRedirects;state;type=Fr.GuardsCheckStart;constructor(n,e,r,o){super(n,e),this.urlAfterRedirects=r,this.state=o}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}},$2=class extends vs{urlAfterRedirects;state;shouldActivate;type=Fr.GuardsCheckEnd;constructor(n,e,r,o,s){super(n,e),this.urlAfterRedirects=r,this.state=o,this.shouldActivate=s}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}},L2=class extends vs{urlAfterRedirects;state;type=Fr.ResolveStart;constructor(n,e,r,o){super(n,e),this.urlAfterRedirects=r,this.state=o}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}},P2=class extends vs{urlAfterRedirects;state;type=Fr.ResolveEnd;constructor(n,e,r,o){super(n,e),this.urlAfterRedirects=r,this.state=o}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}},B2=class{route;type=Fr.RouteConfigLoadStart;constructor(n){this.route=n}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}},z2=class{route;type=Fr.RouteConfigLoadEnd;constructor(n){this.route=n}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}},V2=class{snapshot;type=Fr.ChildActivationStart;constructor(n){this.snapshot=n}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}},U2=class{snapshot;type=Fr.ChildActivationEnd;constructor(n){this.snapshot=n}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}},G2=class{snapshot;type=Fr.ActivationStart;constructor(n){this.snapshot=n}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}},j2=class{snapshot;type=Fr.ActivationEnd;constructor(n){this.snapshot=n}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}};var zd=class{},Vd=class{url;navigationBehaviorOptions;constructor(n,e){this.url=n,this.navigationBehaviorOptions=e}};function cee(t){return!(t instanceof zd)&&!(t instanceof Vd)}var H2=class{rootInjector;outlet=null;route=null;children;attachRef=null;get injector(){return this.route?.snapshot._environmentInjector??this.rootInjector}constructor(n){this.rootInjector=n,this.children=new jd(this.rootInjector)}},jd=(()=>{class t{rootInjector;contexts=new Map;constructor(e){this.rootInjector=e}onChildOutletCreated(e,r){let o=this.getOrCreateContext(e);o.outlet=r,this.contexts.set(e,o)}onChildOutletDestroyed(e){let r=this.getContext(e);r&&(r.outlet=null,r.attachRef=null)}onOutletDeactivated(){let e=this.contexts;return this.contexts=new Map,e}onOutletReAttached(e){this.contexts=e}getOrCreateContext(e){let r=this.getContext(e);return r||(r=new H2(this.rootInjector),this.contexts.set(e,r)),r}getContext(e){return this.contexts.get(e)||null}static \u0275fac=function(r){return new(r||t)(At(Cr))};static \u0275prov=pt({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})(),W2=class{_root;constructor(n){this._root=n}get root(){return this._root.value}parent(n){let e=this.pathFromRoot(n);return e.length>1?e[e.length-2]:null}children(n){let e=bE(n,this._root);return e?e.children.map(r=>r.value):[]}firstChild(n){let e=bE(n,this._root);return e&&e.children.length>0?e.children[0].value:null}siblings(n){let e=wE(n,this._root);return e.length<2?[]:e[e.length-2].children.map(o=>o.value).filter(o=>o!==n)}pathFromRoot(n){return wE(n,this._root).map(e=>e.value)}};function bE(t,n){if(t===n.value)return n;for(let e of n.children){let r=bE(t,e);if(r)return r}return null}function wE(t,n){if(t===n.value)return[n];for(let e of n.children){let r=wE(t,e);if(r.length)return r.unshift(n),r}return[]}var xs=class{value;children;constructor(n,e){this.value=n,this.children=e}toString(){return`TreeNode(${this.value})`}};function Fd(t){let n={};return t&&t.children.forEach(e=>n[e.value.outlet]=e),n}var Xy=class extends W2{snapshot;constructor(n,e){super(n),this.snapshot=e,kE(this,n)}toString(){return this.snapshot.toString()}};function OO(t,n){let e=uee(t,n),r=new Kr([new yc("",{})]),o=new Kr({}),s=new Kr({}),i=new Kr({}),a=new Kr(""),l=new vc(r,o,i,a,s,vt,t,e.root);return l.snapshot=e.root,new Xy(new xs(l,[]),e)}function uee(t,n){let e={},r={},o={},i=new wp([],e,o,"",r,vt,t,null,{},n);return new Yy("",new xs(i,[]))}var vc=class{urlSubject;paramsSubject;queryParamsSubject;fragmentSubject;dataSubject;outlet;component;snapshot;_futureSnapshot;_routerState;_paramMap;_queryParamMap;title;url;params;queryParams;fragment;data;constructor(n,e,r,o,s,i,a,l){this.urlSubject=n,this.paramsSubject=e,this.queryParamsSubject=r,this.fragmentSubject=o,this.dataSubject=s,this.outlet=i,this.component=a,this._futureSnapshot=l,this.title=this.dataSubject?.pipe(Yn(c=>c[Jy]))??Gt(void 0),this.url=n,this.params=e,this.queryParams=r,this.fragment=o,this.data=s}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap??=this.params.pipe(Yn(n=>Cp(n))),this._paramMap}get queryParamMap(){return this._queryParamMap??=this.queryParams.pipe(Yn(n=>Cp(n))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}};function q2(t,n,e="emptyOnly"){let r,{routeConfig:o}=t;return n!==null&&(e==="always"||o?.path===""||!n.component&&!n.routeConfig?.loadComponent)?r={params:Ye(Ye({},n.params),t.params),data:Ye(Ye({},n.data),t.data),resolve:Ye(Ye(Ye(Ye({},t.data),n.data),o?.data),t._resolvedData)}:r={params:Ye({},t.params),data:Ye({},t.data),resolve:Ye(Ye({},t.data),t._resolvedData??{})},o&&$O(o)&&(r.resolve[Jy]=o.title),r}var wp=class{url;params;queryParams;fragment;data;outlet;component;routeConfig;_resolve;_resolvedData;_routerState;_paramMap;_queryParamMap;_environmentInjector;get title(){return this.data?.[Jy]}constructor(n,e,r,o,s,i,a,l,c,u){this.url=n,this.params=e,this.queryParams=r,this.fragment=o,this.data=s,this.outlet=i,this.component=a,this.routeConfig=l,this._resolve=c,this._environmentInjector=u}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap??=Cp(this.params),this._paramMap}get queryParamMap(){return this._queryParamMap??=Cp(this.queryParams),this._queryParamMap}toString(){let n=this.url.map(r=>r.toString()).join("/"),e=this.routeConfig?this.routeConfig.path:"";return`Route(url:'${n}', path:'${e}')`}},Yy=class extends W2{url;constructor(n,e){super(e),this.url=n,kE(this,e)}toString(){return FO(this._root)}};function kE(t,n){n.value._routerState=t,n.children.forEach(e=>kE(t,e))}function FO(t){let n=t.children.length>0?` { ${t.children.map(FO).join(", ")} } `:"";return`${t.value}${n}`}function hE(t){if(t.snapshot){let n=t.snapshot,e=t._futureSnapshot;t.snapshot=e,ji(n.queryParams,e.queryParams)||t.queryParamsSubject.next(e.queryParams),n.fragment!==e.fragment&&t.fragmentSubject.next(e.fragment),ji(n.params,e.params)||t.paramsSubject.next(e.params),PJ(n.url,e.url)||t.urlSubject.next(e.url),ji(n.data,e.data)||t.dataSubject.next(e.data)}else t.snapshot=t._futureSnapshot,t.dataSubject.next(t._futureSnapshot.data)}function CE(t,n){let e=ji(t.params,n.params)&&GJ(t.url,n.url),r=!t.parent!=!n.parent;return e&&!r&&(!t.parent||CE(t.parent,n.parent))}function $O(t){return typeof t.title=="string"||t.title===null}var LO=new nt(""),t1=(()=>{class t{activated=null;get activatedComponentRef(){return this.activated}_activatedRoute=null;name=vt;activateEvents=new Zr;deactivateEvents=new Zr;attachEvents=new Zr;detachEvents=new Zr;routerOutletData=WM();parentContexts=Ae(jd);location=Ae(xp);changeDetector=Ae(vp);inputBinder=Ae(Z2,{optional:!0});supportsBindingToComponentInputs=!0;ngOnChanges(e){if(e.name){let{firstChange:r,previousValue:o}=e.name;if(r)return;this.isTrackedInParentContexts(o)&&(this.deactivate(),this.parentContexts.onChildOutletDestroyed(o)),this.initializeOutletWithName()}}ngOnDestroy(){this.isTrackedInParentContexts(this.name)&&this.parentContexts.onChildOutletDestroyed(this.name),this.inputBinder?.unsubscribeFromRouteData(this)}isTrackedInParentContexts(e){return this.parentContexts.getContext(e)?.outlet===this}ngOnInit(){this.initializeOutletWithName()}initializeOutletWithName(){if(this.parentContexts.onChildOutletCreated(this.name,this),this.activated)return;let e=this.parentContexts.getContext(this.name);e?.route&&(e.attachRef?this.attach(e.attachRef,e.route):this.activateWith(e.route,e.injector))}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new it(4012,!1);return this.activated.instance}get activatedRoute(){if(!this.activated)throw new it(4012,!1);return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new it(4012,!1);this.location.detach();let e=this.activated;return this.activated=null,this._activatedRoute=null,this.detachEvents.emit(e.instance),e}attach(e,r){this.activated=e,this._activatedRoute=r,this.location.insert(e.hostView),this.inputBinder?.bindActivatedRouteToOutletComponent(this),this.attachEvents.emit(e.instance)}deactivate(){if(this.activated){let e=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(e)}}activateWith(e,r){if(this.isActivated)throw new it(4013,!1);this._activatedRoute=e;let o=this.location,i=e.snapshot.component,a=this.parentContexts.getOrCreateContext(this.name).children,l=new IE(e,a,o.injector,this.routerOutletData);this.activated=o.createComponent(i,{index:o.length,injector:l,environmentInjector:r}),this.changeDetector.markForCheck(),this.inputBinder?.bindActivatedRouteToOutletComponent(this),this.activateEvents.emit(this.activated.instance)}static \u0275fac=function(r){return new(r||t)};static \u0275dir=Fa({type:t,selectors:[["router-outlet"]],inputs:{name:"name",routerOutletData:[1,"routerOutletData"]},outputs:{activateEvents:"activate",deactivateEvents:"deactivate",attachEvents:"attach",detachEvents:"detach"},exportAs:["outlet"],features:[o2]})}return t})(),IE=class{route;childContexts;parent;outletData;constructor(n,e,r,o){this.route=n,this.childContexts=e,this.parent=r,this.outletData=o}get(n,e){return n===vc?this.route:n===jd?this.childContexts:n===LO?this.outletData:this.parent.get(n,e)}},Z2=new nt("");var AE=(()=>{class t{static \u0275fac=function(r){return new(r||t)};static \u0275cmp=Ho({type:t,selectors:[["ng-component"]],exportAs:["emptyRouterOutlet"],decls:1,vars:0,template:function(r,o){r&1&&Ms(0,"router-outlet")},dependencies:[t1],encapsulation:2})}return t})();function _E(t){let n=t.children&&t.children.map(_E),e=n?Gn(Ye({},t),{children:n}):Ye({},t);return!e.component&&!e.loadComponent&&(n||e.loadChildren)&&e.outlet&&e.outlet!==vt&&(e.component=AE),e}function pee(t,n,e){let r=Zy(t,n._root,e?e._root:void 0);return new Xy(r,n)}function Zy(t,n,e){if(e&&t.shouldReuseRoute(n.value,e.value.snapshot)){let r=e.value;r._futureSnapshot=n.value;let o=fee(t,n,e);return new xs(r,o)}else{if(t.shouldAttach(n.value)){let s=t.retrieve(n.value);if(s!==null){let i=s.route;return i.value._futureSnapshot=n.value,i.children=n.children.map(a=>Zy(t,a)),i}}let r=dee(n.value),o=n.children.map(s=>Zy(t,s));return new xs(r,o)}}function fee(t,n,e){return n.children.map(r=>{for(let o of e.children)if(t.shouldReuseRoute(r.value,o.value.snapshot))return Zy(t,r,o);return Zy(t,r)})}function dee(t){return new vc(new Kr(t.url),new Kr(t.params),new Kr(t.queryParams),new Kr(t.fragment),new Kr(t.data),t.outlet,t.component,t)}var Ud=class{redirectTo;navigationBehaviorOptions;constructor(n,e){this.redirectTo=n,this.navigationBehaviorOptions=e}},PO="ngNavigationCancelingError";function K2(t,n){let{redirectTo:e,navigationBehaviorOptions:r}=Pd(n)?{redirectTo:n,navigationBehaviorOptions:void 0}:n,o=BO(!1,lo.Redirect);return o.url=e,o.navigationBehaviorOptions=r,o}function BO(t,n){let e=new Error(`NavigationCancelingError: ${t||""}`);return e[PO]=!0,e.cancellationCode=n,e}function hee(t){return zO(t)&&Pd(t.url)}function zO(t){return!!t&&t[PO]}var SE=class{routeReuseStrategy;futureState;currState;forwardEvent;inputBindingEnabled;constructor(n,e,r,o,s){this.routeReuseStrategy=n,this.futureState=e,this.currState=r,this.forwardEvent=o,this.inputBindingEnabled=s}activate(n){let e=this.futureState._root,r=this.currState?this.currState._root:null;this.deactivateChildRoutes(e,r,n),hE(this.futureState.root),this.activateChildRoutes(e,r,n)}deactivateChildRoutes(n,e,r){let o=Fd(e);n.children.forEach(s=>{let i=s.value.outlet;this.deactivateRoutes(s,o[i],r),delete o[i]}),Object.values(o).forEach(s=>{this.deactivateRouteAndItsChildren(s,r)})}deactivateRoutes(n,e,r){let o=n.value,s=e?e.value:null;if(o===s)if(o.component){let i=r.getContext(o.outlet);i&&this.deactivateChildRoutes(n,e,i.children)}else this.deactivateChildRoutes(n,e,r);else s&&this.deactivateRouteAndItsChildren(e,r)}deactivateRouteAndItsChildren(n,e){n.value.component&&this.routeReuseStrategy.shouldDetach(n.value.snapshot)?this.detachAndStoreRouteSubtree(n,e):this.deactivateRouteAndOutlet(n,e)}detachAndStoreRouteSubtree(n,e){let r=e.getContext(n.value.outlet),o=r&&n.value.component?r.children:e,s=Fd(n);for(let i of Object.values(s))this.deactivateRouteAndItsChildren(i,o);if(r&&r.outlet){let i=r.outlet.detach(),a=r.children.onOutletDeactivated();this.routeReuseStrategy.store(n.value.snapshot,{componentRef:i,route:n,contexts:a})}}deactivateRouteAndOutlet(n,e){let r=e.getContext(n.value.outlet),o=r&&n.value.component?r.children:e,s=Fd(n);for(let i of Object.values(s))this.deactivateRouteAndItsChildren(i,o);r&&(r.outlet&&(r.outlet.deactivate(),r.children.onOutletDeactivated()),r.attachRef=null,r.route=null)}activateChildRoutes(n,e,r){let o=Fd(e);n.children.forEach(s=>{this.activateRoutes(s,o[s.value.outlet],r),this.forwardEvent(new j2(s.value.snapshot))}),n.children.length&&this.forwardEvent(new U2(n.value.snapshot))}activateRoutes(n,e,r){let o=n.value,s=e?e.value:null;if(hE(o),o===s)if(o.component){let i=r.getOrCreateContext(o.outlet);this.activateChildRoutes(n,e,i.children)}else this.activateChildRoutes(n,e,r);else if(o.component){let i=r.getOrCreateContext(o.outlet);if(this.routeReuseStrategy.shouldAttach(o.snapshot)){let a=this.routeReuseStrategy.retrieve(o.snapshot);this.routeReuseStrategy.store(o.snapshot,null),i.children.onOutletReAttached(a.contexts),i.attachRef=a.componentRef,i.route=a.route.value,i.outlet&&i.outlet.attach(a.componentRef,a.route.value),hE(a.route.value),this.activateChildRoutes(n,null,i.children)}else i.attachRef=null,i.route=o,i.outlet&&i.outlet.activateWith(o,i.injector),this.activateChildRoutes(n,null,i.children)}else this.activateChildRoutes(n,null,r)}},X2=class{path;route;constructor(n){this.path=n,this.route=this.path[this.path.length-1]}},Ld=class{component;route;constructor(n,e){this.component=n,this.route=e}};function mee(t,n,e){let r=t._root,o=n?n._root:null;return Gy(r,o,e,[r.value])}function gee(t){let n=t.routeConfig?t.routeConfig.canActivateChild:null;return!n||n.length===0?null:{node:t,guards:n}}function Hd(t,n){let e=Symbol(),r=n.get(t,e);return r===e?typeof t=="function"&&!cS(t)?t:n.get(t):r}function Gy(t,n,e,r,o={canDeactivateChecks:[],canActivateChecks:[]}){let s=Fd(n);return t.children.forEach(i=>{yee(i,s[i.value.outlet],e,r.concat([i.value]),o),delete s[i.value.outlet]}),Object.entries(s).forEach(([i,a])=>Wy(a,e.getContext(i),o)),o}function yee(t,n,e,r,o={canDeactivateChecks:[],canActivateChecks:[]}){let s=t.value,i=n?n.value:null,a=e?e.getContext(t.value.outlet):null;if(i&&s.routeConfig===i.routeConfig){let l=xee(i,s,s.routeConfig.runGuardsAndResolvers);l?o.canActivateChecks.push(new X2(r)):(s.data=i.data,s._resolvedData=i._resolvedData),s.component?Gy(t,n,a?a.children:null,r,o):Gy(t,n,e,r,o),l&&a&&a.outlet&&a.outlet.isActivated&&o.canDeactivateChecks.push(new Ld(a.outlet.component,i))}else i&&Wy(n,a,o),o.canActivateChecks.push(new X2(r)),s.component?Gy(t,null,a?a.children:null,r,o):Gy(t,null,e,r,o);return o}function xee(t,n,e){if(typeof e=="function")return io(n._environmentInjector,()=>e(t,n));switch(e){case"pathParamsChange":return!bp(t.url,n.url);case"pathParamsOrQueryParamsChange":return!bp(t.url,n.url)||!ji(t.queryParams,n.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!CE(t,n)||!ji(t.queryParams,n.queryParams);default:return!CE(t,n)}}function Wy(t,n,e){let r=Fd(t),o=t.value;Object.entries(r).forEach(([s,i])=>{o.component?n?Wy(i,n.children.getContext(s),e):Wy(i,null,e):Wy(i,n,e)}),o.component?n&&n.outlet&&n.outlet.isActivated?e.canDeactivateChecks.push(new Ld(n.outlet.component,o)):e.canDeactivateChecks.push(new Ld(null,o)):e.canDeactivateChecks.push(new Ld(null,o))}function n1(t){return typeof t=="function"}function vee(t){return typeof t=="boolean"}function bee(t){return t&&n1(t.canLoad)}function wee(t){return t&&n1(t.canActivate)}function Cee(t){return t&&n1(t.canActivateChild)}function Iee(t){return t&&n1(t.canDeactivate)}function See(t){return t&&n1(t.canMatch)}function VO(t){return t instanceof tp||t?.name==="EmptyError"}var D2=Symbol("INITIAL_VALUE");function Gd(){return Ta(t=>UI(t.map(n=>n.pipe(Ia(1),jI(D2)))).pipe(Yn(n=>{for(let e of n)if(e!==!0){if(e===D2)return D2;if(e===!1||Tee(e))return e}return!0}),Ca(n=>n!==D2),Ia(1)))}function Tee(t){return Pd(t)||t instanceof Ud}function UO(t){return t.aborted?Gt(void 0).pipe(Ia(1)):new tn(n=>{let e=()=>{n.next(),n.complete()};return t.addEventListener("abort",e),()=>t.removeEventListener("abort",e)})}function GO(t){return ny(UO(t))}function Eee(t){return To(n=>{let{targetSnapshot:e,currentSnapshot:r,guards:{canActivateChecks:o,canDeactivateChecks:s}}=n;return s.length===0&&o.length===0?Gt(Gn(Ye({},n),{guardsResult:!0})):Nee(s,e,r).pipe(To(i=>i&&vee(i)?Dee(e,o,t):Gt(i)),Yn(i=>Gn(Ye({},n),{guardsResult:i})))})}function Nee(t,n,e){return Rr(t).pipe(To(r=>Mee(r.component,r.route,e,n)),Sa(r=>r!==!0,!0))}function Dee(t,n,e){return Rr(n).pipe(h0(r=>ed(Aee(r.route.parent,e),kee(r.route,e),Ree(t,r.path),_ee(t,r.route))),Sa(r=>r!==!0,!0))}function kee(t,n){return t!==null&&n&&n(new G2(t)),Gt(!0)}function Aee(t,n){return t!==null&&n&&n(new V2(t)),Gt(!0)}function _ee(t,n){let e=n.routeConfig?n.routeConfig.canActivate:null;if(!e||e.length===0)return Gt(!0);let r=e.map(o=>ey(()=>{let s=n._environmentInjector,i=Hd(o,s),a=wee(i)?i.canActivate(n,t):io(s,()=>i(n,t));return Tp(a).pipe(Sa())}));return Gt(r).pipe(Gd())}function Ree(t,n){let e=n[n.length-1],o=n.slice(0,n.length-1).reverse().map(s=>gee(s)).filter(s=>s!==null).map(s=>ey(()=>{let i=s.guards.map(a=>{let l=s.node._environmentInjector,c=Hd(a,l),u=Cee(c)?c.canActivateChild(e,t):io(l,()=>c(e,t));return Tp(u).pipe(Sa())});return Gt(i).pipe(Gd())}));return Gt(o).pipe(Gd())}function Mee(t,n,e,r){let o=n&&n.routeConfig?n.routeConfig.canDeactivate:null;if(!o||o.length===0)return Gt(!0);let s=o.map(i=>{let a=n._environmentInjector,l=Hd(i,a),c=Iee(l)?l.canDeactivate(t,n,e,r):io(a,()=>l(t,n,e,r));return Tp(c).pipe(Sa())});return Gt(s).pipe(Gd())}function Oee(t,n,e,r,o){let s=n.canLoad;if(s===void 0||s.length===0)return Gt(!0);let i=s.map(a=>{let l=Hd(a,t),c=bee(l)?l.canLoad(n,e):io(t,()=>l(n,e)),u=Tp(c);return o?u.pipe(GO(o)):u});return Gt(i).pipe(Gd(),jO(r))}function jO(t){return PI(Fi(n=>{if(typeof n!="boolean")throw K2(t,n)}),Yn(n=>n===!0))}function Fee(t,n,e,r,o){let s=n.canMatch;if(!s||s.length===0)return Gt(!0);let i=s.map(a=>{let l=Hd(a,t),c=See(l)?l.canMatch(n,e):io(t,()=>l(n,e));return Tp(c).pipe(GO(o))});return Gt(i).pipe(Gd(),jO(r))}var Ba=class t extends Error{segmentGroup;constructor(n){super(),this.segmentGroup=n||null,Object.setPrototypeOf(this,t.prototype)}},Qy=class t extends Error{urlTree;constructor(n){super(),this.urlTree=n,Object.setPrototypeOf(this,t.prototype)}};function $ee(t){throw new it(4e3,!1)}function Lee(t){throw BO(!1,lo.GuardRejected)}var TE=class{urlSerializer;urlTree;constructor(n,e){this.urlSerializer=n,this.urlTree=e}lineralizeSegments(n,e){return te(this,null,function*(){let r=[],o=e.root;for(;;){if(r=r.concat(o.segments),o.numberOfChildren===0)return r;if(o.numberOfChildren>1||!o.children[vt])throw $ee(`${n.redirectTo}`);o=o.children[vt]}})}applyRedirectCommands(n,e,r,o,s){return te(this,null,function*(){let i=yield Pee(e,o,s);if(i instanceof ui)throw new Qy(i);let a=this.applyRedirectCreateUrlTree(i,this.urlSerializer.parse(i),n,r);if(i[0]==="/")throw new Qy(a);return a})}applyRedirectCreateUrlTree(n,e,r,o){let s=this.createSegmentGroup(n,e.root,r,o);return new ui(s,this.createQueryParams(e.queryParams,this.urlTree.queryParams),e.fragment)}createQueryParams(n,e){let r={};return Object.entries(n).forEach(([o,s])=>{if(typeof s=="string"&&s[0]===":"){let a=s.substring(1);r[o]=e[a]}else r[o]=s}),r}createSegmentGroup(n,e,r,o){let s=this.createSegments(n,e.segments,r,o),i={};return Object.entries(e.children).forEach(([a,l])=>{i[a]=this.createSegmentGroup(n,l,r,o)}),new rn(s,i)}createSegments(n,e,r,o){return e.map(s=>s.path[0]===":"?this.findPosParam(n,s,o):this.findOrReturn(s,r))}findPosParam(n,e,r){let o=r[e.path.substring(1)];if(!o)throw new it(4001,!1);return o}findOrReturn(n,e){let r=0;for(let o of e){if(o.path===n.path)return e.splice(r),o;r++}return n}};function Pee(t,n,e){if(typeof t=="string")return Promise.resolve(t);let r=t,{queryParams:o,fragment:s,routeConfig:i,url:a,outlet:l,params:c,data:u,title:p,paramMap:f,queryParamMap:d}=n;return R2(Tp(io(e,()=>r({params:c,data:u,queryParams:o,fragment:s,routeConfig:i,url:a,outlet:l,title:p,paramMap:f,queryParamMap:d}))))}function Bee(t,n){return t.providers&&!t._injector&&(t._injector=_y(t.providers,n,`Route: ${t.path}`)),t._injector??n}function ci(t){return t.outlet||vt}function zee(t,n){let e=t.filter(r=>ci(r)===n);return e.push(...t.filter(r=>ci(r)!==n)),e}var EE={matched:!1,consumedSegments:[],remainingSegments:[],parameters:{},positionalParamSegments:{}};function Vee(t,n,e,r,o,s){let i=HO(t,n,e);return i.matched?(r=Bee(n,r),Fee(r,n,e,o,s).pipe(Yn(a=>a===!0?i:Ye({},EE)))):Gt(i)}function HO(t,n,e){if(n.path==="")return n.pathMatch==="full"&&(t.hasChildren()||e.length>0)?Ye({},EE):{matched:!0,consumedSegments:[],remainingSegments:e,parameters:{},positionalParamSegments:{}};let o=(n.matcher||yO)(e,t,n);if(!o)return Ye({},EE);let s={};Object.entries(o.posParams??{}).forEach(([a,l])=>{s[a]=l.path});let i=o.consumed.length>0?Ye(Ye({},s),o.consumed[o.consumed.length-1].parameters):s;return{matched:!0,consumedSegments:o.consumed,remainingSegments:e.slice(o.consumed.length),parameters:i,positionalParamSegments:o.posParams??{}}}function dO(t,n,e,r){return e.length>0&&jee(t,e,r)?{segmentGroup:new rn(n,Gee(r,new rn(e,t.children))),slicedSegments:[]}:e.length===0&&Hee(t,e,r)?{segmentGroup:new rn(t.segments,Uee(t,e,r,t.children)),slicedSegments:e}:{segmentGroup:new rn(t.segments,t.children),slicedSegments:e}}function Uee(t,n,e,r){let o={};for(let s of e)if(Q2(t,n,s)&&!r[ci(s)]){let i=new rn([],{});o[ci(s)]=i}return Ye(Ye({},r),o)}function Gee(t,n){let e={};e[vt]=n;for(let r of t)if(r.path===""&&ci(r)!==vt){let o=new rn([],{});e[ci(r)]=o}return e}function jee(t,n,e){return e.some(r=>Q2(t,n,r)&&ci(r)!==vt)}function Hee(t,n,e){return e.some(r=>Q2(t,n,r))}function Q2(t,n,e){return(t.hasChildren()||n.length>0)&&e.pathMatch==="full"?!1:e.path===""}function Wee(t,n,e){return n.length===0&&!t.children[e]}var NE=class{};function qee(t,n,e,r,o,s,i="emptyOnly",a){return te(this,null,function*(){return new DE(t,n,e,r,o,i,s,a).recognize()})}var Kee=31,DE=class{injector;configLoader;rootComponentType;config;urlTree;paramsInheritanceStrategy;urlSerializer;abortSignal;applyRedirects;absoluteRedirectCount=0;allowRedirects=!0;constructor(n,e,r,o,s,i,a,l){this.injector=n,this.configLoader=e,this.rootComponentType=r,this.config=o,this.urlTree=s,this.paramsInheritanceStrategy=i,this.urlSerializer=a,this.abortSignal=l,this.applyRedirects=new TE(this.urlSerializer,this.urlTree)}noMatchError(n){return new it(4002,`'${n.segmentGroup}'`)}recognize(){return te(this,null,function*(){let n=dO(this.urlTree.root,[],[],this.config).segmentGroup,{children:e,rootSnapshot:r}=yield this.match(n),o=new xs(r,e),s=new Yy("",o),i=DO(r,[],this.urlTree.queryParams,this.urlTree.fragment);return i.queryParams=this.urlTree.queryParams,s.url=this.urlSerializer.serialize(i),{state:s,tree:i}})}match(n){return te(this,null,function*(){let e=new wp([],Object.freeze({}),Object.freeze(Ye({},this.urlTree.queryParams)),this.urlTree.fragment,Object.freeze({}),vt,this.rootComponentType,null,{},this.injector);try{return{children:yield this.processSegmentGroup(this.injector,this.config,n,vt,e),rootSnapshot:e}}catch(r){if(r instanceof Qy)return this.urlTree=r.urlTree,this.match(r.urlTree.root);throw r instanceof Ba?this.noMatchError(r):r}})}processSegmentGroup(n,e,r,o,s){return te(this,null,function*(){if(r.segments.length===0&&r.hasChildren())return this.processChildren(n,e,r,s);let i=yield this.processSegment(n,e,r,r.segments,o,!0,s);return i instanceof xs?[i]:[]})}processChildren(n,e,r,o){return te(this,null,function*(){let s=[];for(let l of Object.keys(r.children))l==="primary"?s.unshift(l):s.push(l);let i=[];for(let l of s){let c=r.children[l],u=zee(e,l),p=yield this.processSegmentGroup(n,u,c,l,o);i.push(...p)}let a=WO(i);return Xee(a),a})}processSegment(n,e,r,o,s,i,a){return te(this,null,function*(){for(let l of e)try{return yield this.processSegmentAgainstRoute(l._injector??n,e,l,r,o,s,i,a)}catch(c){if(c instanceof Ba||VO(c))continue;throw c}if(Wee(r,o,s))return new NE;throw new Ba(r)})}processSegmentAgainstRoute(n,e,r,o,s,i,a,l){return te(this,null,function*(){if(ci(r)!==i&&(i===vt||!Q2(o,s,r)))throw new Ba(o);if(r.redirectTo===void 0)return this.matchSegmentAgainstRoute(n,o,r,s,i,l);if(this.allowRedirects&&a)return this.expandSegmentAgainstRouteUsingRedirect(n,o,e,r,s,i,l);throw new Ba(o)})}expandSegmentAgainstRouteUsingRedirect(n,e,r,o,s,i,a){return te(this,null,function*(){let{matched:l,parameters:c,consumedSegments:u,positionalParamSegments:p,remainingSegments:f}=HO(e,o,s);if(!l)throw new Ba(e);typeof o.redirectTo=="string"&&o.redirectTo[0]==="/"&&(this.absoluteRedirectCount++,this.absoluteRedirectCount>Kee&&(this.allowRedirects=!1));let d=new wp(s,c,Object.freeze(Ye({},this.urlTree.queryParams)),this.urlTree.fragment,hO(o),ci(o),o.component??o._loadedComponent??null,o,mO(o),n),h=q2(d,a,this.paramsInheritanceStrategy);if(d.params=Object.freeze(h.params),d.data=Object.freeze(h.data),this.abortSignal.aborted)throw new Error(this.abortSignal.reason);let g=yield this.applyRedirects.applyRedirectCommands(u,o.redirectTo,p,d,n),m=yield this.applyRedirects.lineralizeSegments(o,g);return this.processSegment(n,r,e,m.concat(f),i,!1,a)})}matchSegmentAgainstRoute(n,e,r,o,s,i){return te(this,null,function*(){if(this.abortSignal.aborted)throw new Error(this.abortSignal.reason);let a=yield R2(Vee(e,r,o,n,this.urlSerializer,this.abortSignal));if(r.path==="**"&&(e.children={}),!a?.matched)throw new Ba(e);n=r._injector??n;let{routes:l}=yield this.getChildConfig(n,r,o),c=r._loadedInjector??n,{parameters:u,consumedSegments:p,remainingSegments:f}=a,d=new wp(p,u,Object.freeze(Ye({},this.urlTree.queryParams)),this.urlTree.fragment,hO(r),ci(r),r.component??r._loadedComponent??null,r,mO(r),n),h=q2(d,i,this.paramsInheritanceStrategy);d.params=Object.freeze(h.params),d.data=Object.freeze(h.data);let{segmentGroup:g,slicedSegments:m}=dO(e,p,f,l);if(m.length===0&&g.hasChildren()){let C=yield this.processChildren(c,l,g,d);return new xs(d,C)}if(l.length===0&&m.length===0)return new xs(d,[]);let y=ci(r)===s,x=yield this.processSegment(c,l,g,m,y?vt:s,!0,d);return new xs(d,x instanceof xs?[x]:[])})}getChildConfig(n,e,r){return te(this,null,function*(){if(e.children)return{routes:e.children,injector:n};if(e.loadChildren){if(e._loadedRoutes!==void 0){let s=e._loadedNgModuleFactory;return s&&!e._loadedInjector&&(e._loadedInjector=s.create(n).injector),{routes:e._loadedRoutes,injector:e._loadedInjector}}if(this.abortSignal.aborted)throw new Error(this.abortSignal.reason);if(yield R2(Oee(n,e,r,this.urlSerializer,this.abortSignal))){let s=yield this.configLoader.loadChildren(n,e);return e._loadedRoutes=s.routes,e._loadedInjector=s.injector,e._loadedNgModuleFactory=s.factory,s}throw Lee(e)}return{routes:[],injector:n}})}};function Xee(t){t.sort((n,e)=>n.value.outlet===vt?-1:e.value.outlet===vt?1:n.value.outlet.localeCompare(e.value.outlet))}function Yee(t){let n=t.value.routeConfig;return n&&n.path===""}function WO(t){let n=[],e=new Set;for(let r of t){if(!Yee(r)){n.push(r);continue}let o=n.find(s=>r.value.routeConfig===s.value.routeConfig);o!==void 0?(o.children.push(...r.children),e.add(o)):n.push(r)}for(let r of e){let o=WO(r.children);n.push(new xs(r.value,o))}return n.filter(r=>!e.has(r))}function hO(t){return t.data||{}}function mO(t){return t.resolve||{}}function Zee(t,n,e,r,o,s,i){return To(a=>te(null,null,function*(){let{state:l,tree:c}=yield qee(t,n,e,r,a.extractedUrl,o,s,i);return Gn(Ye({},a),{targetSnapshot:l,urlAfterRedirects:c})}))}function Qee(t){return To(n=>{let{targetSnapshot:e,guards:{canActivateChecks:r}}=n;if(!r.length)return Gt(n);let o=new Set(r.map(a=>a.route)),s=new Set;for(let a of o)if(!s.has(a))for(let l of qO(a))s.add(l);let i=0;return Rr(s).pipe(h0(a=>o.has(a)?Jee(a,e,t):(a.data=q2(a,a.parent,t).resolve,Gt(void 0))),Fi(()=>i++),m0(1),To(a=>i===s.size?Gt(n):Xr))})}function qO(t){let n=t.children.map(e=>qO(e)).flat();return[t,...n]}function Jee(t,n,e){let r=t.routeConfig,o=t._resolve;return r?.title!==void 0&&!$O(r)&&(o[Jy]=r.title),ey(()=>(t.data=q2(t,t.parent,e).resolve,ete(o,t,n).pipe(Yn(s=>(t._resolvedData=s,t.data=Ye(Ye({},t.data),s),null)))))}function ete(t,n,e){let r=gE(t);if(r.length===0)return Gt({});let o={};return Rr(r).pipe(To(s=>tte(t[s],n,e).pipe(Sa(),Fi(i=>{if(i instanceof Ud)throw K2(new xc,i);o[s]=i}))),m0(1),Yn(()=>o),ty(s=>VO(s)?Xr:VI(s)))}function tte(t,n,e){let r=n._environmentInjector,o=Hd(t,r),s=o.resolve?o.resolve(n,e):io(r,()=>o(n,e));return Tp(s)}function gO(t){return Ta(n=>{let e=t(n);return e?Rr(e).pipe(Yn(()=>n)):Gt(n)})}var RE=(()=>{class t{buildTitle(e){let r,o=e.root;for(;o!==void 0;)r=this.getResolvedTitleForRoute(o)??r,o=o.children.find(s=>s.outlet===vt);return r}getResolvedTitleForRoute(e){return e.data[Jy]}static \u0275fac=function(r){return new(r||t)};static \u0275prov=pt({token:t,factory:()=>Ae(KO),providedIn:"root"})}return t})(),KO=(()=>{class t extends RE{title;constructor(e){super(),this.title=e}updateTitle(e){let r=this.buildTitle(e);r!==void 0&&this.title.setTitle(r)}static \u0275fac=function(r){return new(r||t)(At(aO))};static \u0275prov=pt({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})(),r1=new nt("",{factory:()=>({})}),o1=new nt(""),XO=(()=>{class t{componentLoaders=new WeakMap;childrenLoaders=new WeakMap;onLoadStartListener;onLoadEndListener;compiler=Ae(ZT);loadComponent(e,r){return te(this,null,function*(){if(this.componentLoaders.get(r))return this.componentLoaders.get(r);if(r._loadedComponent)return Promise.resolve(r._loadedComponent);this.onLoadStartListener&&this.onLoadStartListener(r);let o=te(this,null,function*(){try{let s=yield vO(io(e,()=>r.loadComponent())),i=yield QO(ZO(s));return this.onLoadEndListener&&this.onLoadEndListener(r),r._loadedComponent=i,i}finally{this.componentLoaders.delete(r)}});return this.componentLoaders.set(r,o),o})}loadChildren(e,r){if(this.childrenLoaders.get(r))return this.childrenLoaders.get(r);if(r._loadedRoutes)return Promise.resolve({routes:r._loadedRoutes,injector:r._loadedInjector});this.onLoadStartListener&&this.onLoadStartListener(r);let o=te(this,null,function*(){try{let s=yield YO(r,this.compiler,e,this.onLoadEndListener);return r._loadedRoutes=s.routes,r._loadedInjector=s.injector,r._loadedNgModuleFactory=s.factory,s}finally{this.childrenLoaders.delete(r)}});return this.childrenLoaders.set(r,o),o}static \u0275fac=function(r){return new(r||t)};static \u0275prov=pt({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();function YO(t,n,e,r){return te(this,null,function*(){let o=yield vO(io(e,()=>t.loadChildren())),s=yield QO(ZO(o)),i;s instanceof h2||Array.isArray(s)?i=s:i=yield n.compileModuleAsync(s),r&&r(t);let a,l,c=!1,u;return Array.isArray(i)?(l=i,c=!0):(a=i.create(e).injector,u=i,l=a.get(o1,[],{optional:!0,self:!0}).flat()),{routes:l.map(_E),injector:a,factory:u}})}function nte(t){return t&&typeof t=="object"&&"default"in t}function ZO(t){return nte(t)?t.default:t}function QO(t){return te(this,null,function*(){return t})}var J2=(()=>{class t{static \u0275fac=function(r){return new(r||t)};static \u0275prov=pt({token:t,factory:()=>Ae(rte),providedIn:"root"})}return t})(),rte=(()=>{class t{shouldProcessUrl(e){return!0}extract(e){return e}merge(e,r){return e}static \u0275fac=function(r){return new(r||t)};static \u0275prov=pt({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})(),JO=new nt("");var ote=()=>{},eF=new nt(""),tF=(()=>{class t{currentNavigation=hc(null,{equal:()=>!1});currentTransition=null;lastSuccessfulNavigation=hc(null);events=new qr;transitionAbortWithErrorSubject=new qr;configLoader=Ae(XO);environmentInjector=Ae(Cr);destroyRef=Ae(fc);urlSerializer=Ae(e1);rootContexts=Ae(jd);location=Ae(Md);inputBindingEnabled=Ae(Z2,{optional:!0})!==null;titleStrategy=Ae(RE);options=Ae(r1,{optional:!0})||{};paramsInheritanceStrategy=this.options.paramsInheritanceStrategy||"emptyOnly";urlHandlingStrategy=Ae(J2);createViewTransition=Ae(JO,{optional:!0});navigationErrorHandler=Ae(eF,{optional:!0});navigationId=0;get hasRequestedNavigation(){return this.navigationId!==0}transitions;afterPreactivation=()=>Gt(void 0);rootComponentType=null;destroyed=!1;constructor(){let e=o=>this.events.next(new B2(o)),r=o=>this.events.next(new z2(o));this.configLoader.onLoadEndListener=r,this.configLoader.onLoadStartListener=e,this.destroyRef.onDestroy(()=>{this.destroyed=!0})}complete(){this.transitions?.complete()}handleNavigationRequest(e){let r=++this.navigationId;_a(()=>{this.transitions?.next(Gn(Ye({},e),{extractedUrl:this.urlHandlingStrategy.extract(e.rawUrl),targetSnapshot:null,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null,id:r}))})}setupNavigations(e){return this.transitions=new Kr(null),this.transitions.pipe(Ca(r=>r!==null),Ta(r=>{let o=!1,s=new AbortController,i=()=>!o&&this.currentTransition?.id===r.id;return Gt(r).pipe(Ta(a=>{if(this.navigationId>r.id)return this.cancelNavigationTransition(r,"",lo.SupersededByNewNavigation),Xr;this.currentTransition=r;let l=this.lastSuccessfulNavigation();this.currentNavigation.set({id:a.id,initialUrl:a.rawUrl,extractedUrl:a.extractedUrl,targetBrowserUrl:typeof a.extras.browserUrl=="string"?this.urlSerializer.parse(a.extras.browserUrl):a.extras.browserUrl,trigger:a.source,extras:a.extras,previousNavigation:l?Gn(Ye({},l),{previousNavigation:null}):null,abort:()=>s.abort()});let c=!e.navigated||this.isUpdatingInternalState()||this.isUpdatedBrowserUrl(),u=a.extras.onSameUrlNavigation??e.onSameUrlNavigation;if(!c&&u!=="reload")return this.events.next(new Va(a.id,this.urlSerializer.serialize(a.rawUrl),"",Ky.IgnoredSameUrlNavigation)),a.resolve(!1),Xr;if(this.urlHandlingStrategy.shouldProcessUrl(a.rawUrl))return Gt(a).pipe(Ta(p=>(this.events.next(new Ip(p.id,this.urlSerializer.serialize(p.extractedUrl),p.source,p.restoredState)),p.id!==this.navigationId?Xr:Promise.resolve(p))),Zee(this.environmentInjector,this.configLoader,this.rootComponentType,e.config,this.urlSerializer,this.paramsInheritanceStrategy,s.signal),Fi(p=>{r.targetSnapshot=p.targetSnapshot,r.urlAfterRedirects=p.urlAfterRedirects,this.currentNavigation.update(d=>(d.finalUrl=p.urlAfterRedirects,d));let f=new Bd(p.id,this.urlSerializer.serialize(p.extractedUrl),this.urlSerializer.serialize(p.urlAfterRedirects),p.targetSnapshot);this.events.next(f)}));if(c&&this.urlHandlingStrategy.shouldProcessUrl(a.currentRawUrl)){let{id:p,extractedUrl:f,source:d,restoredState:h,extras:g}=a,m=new Ip(p,this.urlSerializer.serialize(f),d,h);this.events.next(m);let y=OO(this.rootComponentType,this.environmentInjector).snapshot;return this.currentTransition=r=Gn(Ye({},a),{targetSnapshot:y,urlAfterRedirects:f,extras:Gn(Ye({},g),{skipLocationChange:!1,replaceUrl:!1})}),this.currentNavigation.update(x=>(x.finalUrl=f,x)),Gt(r)}else return this.events.next(new Va(a.id,this.urlSerializer.serialize(a.extractedUrl),"",Ky.IgnoredByUrlHandlingStrategy)),a.resolve(!1),Xr}),Yn(a=>{let l=new F2(a.id,this.urlSerializer.serialize(a.extractedUrl),this.urlSerializer.serialize(a.urlAfterRedirects),a.targetSnapshot);return this.events.next(l),this.currentTransition=r=Gn(Ye({},a),{guards:mee(a.targetSnapshot,a.currentSnapshot,this.rootContexts)}),r}),Eee(a=>this.events.next(a)),Ta(a=>{if(r.guardsResult=a.guardsResult,a.guardsResult&&typeof a.guardsResult!="boolean")throw K2(this.urlSerializer,a.guardsResult);let l=new $2(a.id,this.urlSerializer.serialize(a.extractedUrl),this.urlSerializer.serialize(a.urlAfterRedirects),a.targetSnapshot,!!a.guardsResult);if(this.events.next(l),!i())return Xr;if(!a.guardsResult)return this.cancelNavigationTransition(a,"",lo.GuardRejected),Xr;if(a.guards.canActivateChecks.length===0)return Gt(a);let c=new L2(a.id,this.urlSerializer.serialize(a.extractedUrl),this.urlSerializer.serialize(a.urlAfterRedirects),a.targetSnapshot);if(this.events.next(c),!i())return Xr;let u=!1;return Gt(a).pipe(Qee(this.paramsInheritanceStrategy),Fi({next:()=>{u=!0;let p=new P2(a.id,this.urlSerializer.serialize(a.extractedUrl),this.urlSerializer.serialize(a.urlAfterRedirects),a.targetSnapshot);this.events.next(p)},complete:()=>{u||this.cancelNavigationTransition(a,"",lo.NoDataFromResolver)}}))}),gO(a=>{let l=u=>{let p=[];if(u.routeConfig?._loadedComponent)u.component=u.routeConfig?._loadedComponent;else if(u.routeConfig?.loadComponent){let f=u._environmentInjector;p.push(this.configLoader.loadComponent(f,u.routeConfig).then(d=>{u.component=d}))}for(let f of u.children)p.push(...l(f));return p},c=l(a.targetSnapshot.root);return c.length===0?Gt(a):Rr(Promise.all(c).then(()=>a))}),gO(()=>this.afterPreactivation()),Ta(()=>{let{currentSnapshot:a,targetSnapshot:l}=r,c=this.createViewTransition?.(this.environmentInjector,a.root,l.root);return c?Rr(c).pipe(Yn(()=>r)):Gt(r)}),Ia(1),Yn(a=>{let l=pee(e.routeReuseStrategy,a.targetSnapshot,a.currentRouterState);this.currentTransition=r=a=Gn(Ye({},a),{targetRouterState:l}),this.currentNavigation.update(c=>(c.targetRouterState=l,c)),this.events.next(new zd),i()&&(new SE(e.routeReuseStrategy,r.targetRouterState,r.currentRouterState,c=>this.events.next(c),this.inputBindingEnabled).activate(this.rootContexts),i()&&(o=!0,this.currentNavigation.update(c=>(c.abort=ote,c)),this.lastSuccessfulNavigation.set(_a(this.currentNavigation)),this.events.next(new za(a.id,this.urlSerializer.serialize(a.extractedUrl),this.urlSerializer.serialize(a.urlAfterRedirects))),this.titleStrategy?.updateTitle(a.targetRouterState.snapshot),a.resolve(!0)))}),ny(UO(s.signal).pipe(Ca(()=>!o&&!r.targetRouterState),Fi(()=>{this.cancelNavigationTransition(r,s.signal.reason+"",lo.Aborted)}))),Fi({complete:()=>{o=!0}}),ny(this.transitionAbortWithErrorSubject.pipe(Fi(a=>{throw a}))),GI(()=>{s.abort(),o||this.cancelNavigationTransition(r,"",lo.SupersededByNewNavigation),this.currentTransition?.id===r.id&&(this.currentNavigation.set(null),this.currentTransition=null)}),ty(a=>{if(o=!0,this.destroyed)return r.resolve(!1),Xr;if(zO(a))this.events.next(new Os(r.id,this.urlSerializer.serialize(r.extractedUrl),a.message,a.cancellationCode)),hee(a)?this.events.next(new Vd(a.url,a.navigationBehaviorOptions)):r.resolve(!1);else{let l=new Sp(r.id,this.urlSerializer.serialize(r.extractedUrl),a,r.targetSnapshot??void 0);try{let c=io(this.environmentInjector,()=>this.navigationErrorHandler?.(l));if(c instanceof Ud){let{message:u,cancellationCode:p}=K2(this.urlSerializer,c);this.events.next(new Os(r.id,this.urlSerializer.serialize(r.extractedUrl),u,p)),this.events.next(new Vd(c.redirectTo,c.navigationBehaviorOptions))}else throw this.events.next(l),a}catch(c){this.options.resolveNavigationPromiseOnError?r.resolve(!1):r.reject(c)}}return Xr}))}))}cancelNavigationTransition(e,r,o){let s=new Os(e.id,this.urlSerializer.serialize(e.extractedUrl),r,o);this.events.next(s),e.resolve(!1)}isUpdatingInternalState(){return this.currentTransition?.extractedUrl.toString()!==this.currentTransition?.currentUrlTree.toString()}isUpdatedBrowserUrl(){let e=this.urlHandlingStrategy.extract(this.urlSerializer.parse(this.location.path(!0))),r=_a(this.currentNavigation),o=r?.targetBrowserUrl??r?.extractedUrl;return e.toString()!==o?.toString()&&!r?.extras.skipLocationChange}static \u0275fac=function(r){return new(r||t)};static \u0275prov=pt({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();function ste(t){return t!==Hy}var nF=new nt("");var rF=(()=>{class t{static \u0275fac=function(r){return new(r||t)};static \u0275prov=pt({token:t,factory:()=>Ae(ite),providedIn:"root"})}return t})(),Y2=class{shouldDetach(n){return!1}store(n,e){}shouldAttach(n){return!1}retrieve(n){return null}shouldReuseRoute(n,e){return n.routeConfig===e.routeConfig}shouldDestroyInjector(n){return!0}},ite=(()=>{class t extends Y2{static \u0275fac=(()=>{let e;return function(o){return(e||(e=i2(t)))(o||t)}})();static \u0275prov=pt({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})(),ME=(()=>{class t{urlSerializer=Ae(e1);options=Ae(r1,{optional:!0})||{};canceledNavigationResolution=this.options.canceledNavigationResolution||"replace";location=Ae(Md);urlHandlingStrategy=Ae(J2);urlUpdateStrategy=this.options.urlUpdateStrategy||"deferred";currentUrlTree=new ui;getCurrentUrlTree(){return this.currentUrlTree}rawUrlTree=this.currentUrlTree;getRawUrlTree(){return this.rawUrlTree}createBrowserPath({finalUrl:e,initialUrl:r,targetBrowserUrl:o}){let s=e!==void 0?this.urlHandlingStrategy.merge(e,r):r,i=o??s;return i instanceof ui?this.urlSerializer.serialize(i):i}commitTransition({targetRouterState:e,finalUrl:r,initialUrl:o}){r&&e?(this.currentUrlTree=r,this.rawUrlTree=this.urlHandlingStrategy.merge(r,o),this.routerState=e):this.rawUrlTree=o}routerState=OO(null,Ae(Cr));getRouterState(){return this.routerState}_stateMemento=this.createStateMemento();get stateMemento(){return this._stateMemento}updateStateMemento(){this._stateMemento=this.createStateMemento()}createStateMemento(){return{rawUrlTree:this.rawUrlTree,currentUrlTree:this.currentUrlTree,routerState:this.routerState}}restoredState(){return this.location.getState()}static \u0275fac=function(r){return new(r||t)};static \u0275prov=pt({token:t,factory:()=>Ae(ate),providedIn:"root"})}return t})(),ate=(()=>{class t extends ME{currentPageId=0;lastSuccessfulId=-1;get browserPageId(){return this.canceledNavigationResolution!=="computed"?this.currentPageId:this.restoredState()?.\u0275routerPageId??this.currentPageId}registerNonRouterCurrentEntryChangeListener(e){return this.location.subscribe(r=>{r.type==="popstate"&&setTimeout(()=>{e(r.url,r.state,"popstate")})})}handleRouterEvent(e,r){e instanceof Ip?this.updateStateMemento():e instanceof Va?this.commitTransition(r):e instanceof Bd?this.urlUpdateStrategy==="eager"&&(r.extras.skipLocationChange||this.setBrowserUrl(this.createBrowserPath(r),r)):e instanceof zd?(this.commitTransition(r),this.urlUpdateStrategy==="deferred"&&!r.extras.skipLocationChange&&this.setBrowserUrl(this.createBrowserPath(r),r)):e instanceof Os&&!MO(e)?this.restoreHistory(r):e instanceof Sp?this.restoreHistory(r,!0):e instanceof za&&(this.lastSuccessfulId=e.id,this.currentPageId=this.browserPageId)}setBrowserUrl(e,{extras:r,id:o}){let{replaceUrl:s,state:i}=r;if(this.location.isCurrentPathEqualTo(e)||s){let a=this.browserPageId,l=Ye(Ye({},i),this.generateNgRouterState(o,a));this.location.replaceState(e,"",l)}else{let a=Ye(Ye({},i),this.generateNgRouterState(o,this.browserPageId+1));this.location.go(e,"",a)}}restoreHistory(e,r=!1){if(this.canceledNavigationResolution==="computed"){let o=this.browserPageId,s=this.currentPageId-o;s!==0?this.location.historyGo(s):this.getCurrentUrlTree()===e.finalUrl&&s===0&&(this.resetInternalState(e),this.resetUrlToCurrentUrlTree())}else this.canceledNavigationResolution==="replace"&&(r&&this.resetInternalState(e),this.resetUrlToCurrentUrlTree())}resetInternalState({finalUrl:e}){this.routerState=this.stateMemento.routerState,this.currentUrlTree=this.stateMemento.currentUrlTree,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,e??this.rawUrlTree)}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.getRawUrlTree()),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}generateNgRouterState(e,r){return this.canceledNavigationResolution==="computed"?{navigationId:e,\u0275routerPageId:r}:{navigationId:e}}static \u0275fac=(()=>{let e;return function(o){return(e||(e=i2(t)))(o||t)}})();static \u0275prov=pt({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();function OE(t,n){t.events.pipe(Ca(e=>e instanceof za||e instanceof Os||e instanceof Sp||e instanceof Va),Yn(e=>e instanceof za||e instanceof Va?0:(e instanceof Os?e.code===lo.Redirect||e.code===lo.SupersededByNewNavigation:!1)?2:1),Ca(e=>e!==2),Ia(1)).subscribe(()=>{n()})}var oF={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},sF={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"},ev=(()=>{class t{get currentUrlTree(){return this.stateManager.getCurrentUrlTree()}get rawUrlTree(){return this.stateManager.getRawUrlTree()}disposed=!1;nonRouterCurrentEntryChangeSubscription;console=Ae(KT);stateManager=Ae(ME);options=Ae(r1,{optional:!0})||{};pendingTasks=Ae(dc);urlUpdateStrategy=this.options.urlUpdateStrategy||"deferred";navigationTransitions=Ae(tF);urlSerializer=Ae(e1);location=Ae(Md);urlHandlingStrategy=Ae(J2);injector=Ae(Cr);_events=new qr;get events(){return this._events}get routerState(){return this.stateManager.getRouterState()}navigated=!1;routeReuseStrategy=Ae(rF);injectorCleanup=Ae(nF,{optional:!0});onSameUrlNavigation=this.options.onSameUrlNavigation||"ignore";config=Ae(o1,{optional:!0})?.flat()??[];componentInputBindingEnabled=!!Ae(Z2,{optional:!0});currentNavigation=this.navigationTransitions.currentNavigation.asReadonly();constructor(){this.resetConfig(this.config),this.navigationTransitions.setupNavigations(this).subscribe({error:e=>{}}),this.subscribeToNavigationEvents()}eventsSubscription=new Wr;subscribeToNavigationEvents(){let e=this.navigationTransitions.events.subscribe(r=>{try{let o=this.navigationTransitions.currentTransition,s=_a(this.navigationTransitions.currentNavigation);if(o!==null&&s!==null){if(this.stateManager.handleRouterEvent(r,s),r instanceof Os&&r.code!==lo.Redirect&&r.code!==lo.SupersededByNewNavigation)this.navigated=!0;else if(r instanceof za)this.navigated=!0,this.injectorCleanup?.(this.routeReuseStrategy,this.routerState,this.config);else if(r instanceof Vd){let i=r.navigationBehaviorOptions,a=this.urlHandlingStrategy.merge(r.url,o.currentRawUrl),l=Ye({scroll:o.extras.scroll,browserUrl:o.extras.browserUrl,info:o.extras.info,skipLocationChange:o.extras.skipLocationChange,replaceUrl:o.extras.replaceUrl||this.urlUpdateStrategy==="eager"||ste(o.source)},i);this.scheduleNavigation(a,Hy,null,l,{resolve:o.resolve,reject:o.reject,promise:o.promise})}}cee(r)&&this._events.next(r)}catch(o){this.navigationTransitions.transitionAbortWithErrorSubject.next(o)}});this.eventsSubscription.add(e)}resetRootComponentType(e){this.routerState.root.component=e,this.navigationTransitions.rootComponentType=e}initialNavigation(){this.setUpLocationChangeListener(),this.navigationTransitions.hasRequestedNavigation||this.navigateToSyncWithBrowser(this.location.path(!0),Hy,this.stateManager.restoredState())}setUpLocationChangeListener(){this.nonRouterCurrentEntryChangeSubscription??=this.stateManager.registerNonRouterCurrentEntryChangeListener((e,r,o)=>{this.navigateToSyncWithBrowser(e,o,r)})}navigateToSyncWithBrowser(e,r,o){let s={replaceUrl:!0},i=o?.navigationId?o:null;if(o){let l=Ye({},o);delete l.navigationId,delete l.\u0275routerPageId,Object.keys(l).length!==0&&(s.state=l)}let a=this.parseUrl(e);this.scheduleNavigation(a,r,i,s).catch(l=>{this.disposed||this.injector.get(Vi)(l)})}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return _a(this.navigationTransitions.currentNavigation)}get lastSuccessfulNavigation(){return this.navigationTransitions.lastSuccessfulNavigation}resetConfig(e){this.config=e.map(_E),this.navigated=!1}ngOnDestroy(){this.dispose()}dispose(){this._events.unsubscribe(),this.navigationTransitions.complete(),this.nonRouterCurrentEntryChangeSubscription?.unsubscribe(),this.nonRouterCurrentEntryChangeSubscription=void 0,this.disposed=!0,this.eventsSubscription.unsubscribe()}createUrlTree(e,r={}){let{relativeTo:o,queryParams:s,fragment:i,queryParamsHandling:a,preserveFragment:l}=r,c=l?this.currentUrlTree.fragment:i,u=null;switch(a??this.options.defaultQueryParamsHandling){case"merge":u=Ye(Ye({},this.currentUrlTree.queryParams),s);break;case"preserve":u=this.currentUrlTree.queryParams;break;default:u=s||null}u!==null&&(u=this.removeEmptyProps(u));let p;try{let f=o?o.snapshot:this.routerState.snapshot.root;p=kO(f)}catch(f){(typeof e[0]!="string"||e[0][0]!=="/")&&(e=[]),p=this.currentUrlTree.root}return AO(p,e,u,c??null,this.urlSerializer)}navigateByUrl(e,r={skipLocationChange:!1}){let o=Pd(e)?e:this.parseUrl(e),s=this.urlHandlingStrategy.merge(o,this.rawUrlTree);return this.scheduleNavigation(s,Hy,null,r)}navigate(e,r={skipLocationChange:!1}){return lte(e),this.navigateByUrl(this.createUrlTree(e,r),r)}serializeUrl(e){return this.urlSerializer.serialize(e)}parseUrl(e){try{return this.urlSerializer.parse(e)}catch(r){return this.console.warn(ly(4018,!1)),this.urlSerializer.parse("/")}}isActive(e,r){let o;if(r===!0?o=Ye({},oF):r===!1?o=Ye({},sF):o=r,Pd(e))return lO(this.currentUrlTree,e,o);let s=this.parseUrl(e);return lO(this.currentUrlTree,s,o)}removeEmptyProps(e){return Object.entries(e).reduce((r,[o,s])=>(s!=null&&(r[o]=s),r),{})}scheduleNavigation(e,r,o,s,i){if(this.disposed)return Promise.resolve(!1);let a,l,c;i?(a=i.resolve,l=i.reject,c=i.promise):c=new Promise((p,f)=>{a=p,l=f});let u=this.pendingTasks.add();return OE(this,()=>{queueMicrotask(()=>this.pendingTasks.remove(u))}),this.navigationTransitions.handleNavigationRequest({source:r,restoredState:o,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,rawUrl:e,extras:s,resolve:a,reject:l,promise:c,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),c.catch(Promise.reject.bind(Promise))}static \u0275fac=function(r){return new(r||t)};static \u0275prov=pt({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();function lte(t){for(let n=0;n<t.length;n++)if(t[n]==null)throw new it(4008,!1)}var pte=new nt("");function FE(t,...n){return sd([{provide:o1,multi:!0,useValue:t},[],{provide:vc,useFactory:fte},{provide:m2,multi:!0,useFactory:dte},n.map(e=>e.\u0275providers)])}function fte(){return Ae(ev).routerState.root}function dte(){let t=Ae(Li);return n=>{let e=t.get(Td);if(n!==e.components[0])return;let r=t.get(ev),o=t.get(hte);t.get(mte)===1&&r.initialNavigation(),t.get(gte,null,{optional:!0})?.setUpPreloading(),t.get(pte,null,{optional:!0})?.init(),r.resetRootComponentType(e.componentTypes[0]),o.closed||(o.next(),o.complete(),o.unsubscribe())}}var hte=new nt("",{factory:()=>new qr}),mte=new nt("",{factory:()=>1});var gte=new nt("");var iF=[];var aF={providers:[XS(),FE(iF)]};var xte=new nt("cdk-dir-doc",{providedIn:"root",factory:()=>Ae(lr)}),vte=/^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;function lF(t){let n=t?.toLowerCase()||"";return n==="auto"&&typeof navigator<"u"&&navigator?.language?vte.test(navigator.language)?"rtl":"ltr":n==="rtl"?"rtl":"ltr"}var $E=(()=>{class t{get value(){return this.valueSignal()}valueSignal=hc("ltr");change=new Zr;constructor(){let e=Ae(xte,{optional:!0});if(e){let r=e.body?e.body.dir:null,o=e.documentElement?e.documentElement.dir:null;this.valueSignal.set(lF(r||o||"ltr"))}}ngOnDestroy(){this.change.complete()}static \u0275fac=function(r){return new(r||t)};static \u0275prov=pt({token:t,factory:t.\u0275fac,providedIn:"root"})}return t})();var LE=(()=>{class t{static \u0275fac=function(r){return new(r||t)};static \u0275mod=Gi({type:t});static \u0275inj=ri({})}return t})();var bte=["*"];var wte=new nt("MAT_CARD_CONFIG"),tv=(()=>{class t{appearance;constructor(){let e=Ae(wte,{optional:!0});this.appearance=e?.appearance||"raised"}static \u0275fac=function(r){return new(r||t)};static \u0275cmp=Ho({type:t,selectors:[["mat-card"]],hostAttrs:[1,"mat-mdc-card","mdc-card"],hostVars:8,hostBindings:function(r,o){r&2&&y2("mat-mdc-card-outlined",o.appearance==="outlined")("mdc-card--outlined",o.appearance==="outlined")("mat-mdc-card-filled",o.appearance==="filled")("mdc-card--filled",o.appearance==="filled")},inputs:{appearance:"appearance"},exportAs:["matCard"],ngContentSelectors:bte,decls:1,vars:0,template:function(r,o){r&1&&(Ad(),_d(0))},styles:[`.mat-mdc-card{display:flex;flex-direction:column;box-sizing:border-box;position:relative;border-style:solid;border-width:0;background-color:var(--mat-card-elevated-container-color, var(--mat-sys-surface-container-low));border-color:var(--mat-card-elevated-container-color, var(--mat-sys-surface-container-low));border-radius:var(--mat-card-elevated-container-shape, var(--mat-sys-corner-medium));box-shadow:var(--mat-card-elevated-container-elevation, var(--mat-sys-level1))}.mat-mdc-card::after{position:absolute;top:0;left:0;width:100%;height:100%;border:solid 1px rgba(0,0,0,0);content:"";display:block;pointer-events:none;box-sizing:border-box;border-radius:var(--mat-card-elevated-container-shape, var(--mat-sys-corner-medium))}.mat-mdc-card-outlined{background-color:var(--mat-card-outlined-container-color, var(--mat-sys-surface));border-radius:var(--mat-card-outlined-container-shape, var(--mat-sys-corner-medium));border-width:var(--mat-card-outlined-outline-width, 1px);border-color:var(--mat-card-outlined-outline-color, var(--mat-sys-outline-variant));box-shadow:var(--mat-card-outlined-container-elevation, var(--mat-sys-level0))}.mat-mdc-card-outlined::after{border:none}.mat-mdc-card-filled{background-color:var(--mat-card-filled-container-color, var(--mat-sys-surface-container-highest));border-radius:var(--mat-card-filled-container-shape, var(--mat-sys-corner-medium));box-shadow:var(--mat-card-filled-container-elevation, var(--mat-sys-level0))}.mdc-card__media{position:relative;box-sizing:border-box;background-repeat:no-repeat;background-position:center;background-size:cover}.mdc-card__media::before{display:block;content:""}.mdc-card__media:first-child{border-top-left-radius:inherit;border-top-right-radius:inherit}.mdc-card__media:last-child{border-bottom-left-radius:inherit;border-bottom-right-radius:inherit}.mat-mdc-card-actions{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;min-height:52px;padding:8px}.mat-mdc-card-title{font-family:var(--mat-card-title-text-font, var(--mat-sys-title-large-font));line-height:var(--mat-card-title-text-line-height, var(--mat-sys-title-large-line-height));font-size:var(--mat-card-title-text-size, var(--mat-sys-title-large-size));letter-spacing:var(--mat-card-title-text-tracking, var(--mat-sys-title-large-tracking));font-weight:var(--mat-card-title-text-weight, var(--mat-sys-title-large-weight))}.mat-mdc-card-subtitle{color:var(--mat-card-subtitle-text-color, var(--mat-sys-on-surface));font-family:var(--mat-card-subtitle-text-font, var(--mat-sys-title-medium-font));line-height:var(--mat-card-subtitle-text-line-height, var(--mat-sys-title-medium-line-height));font-size:var(--mat-card-subtitle-text-size, var(--mat-sys-title-medium-size));letter-spacing:var(--mat-card-subtitle-text-tracking, var(--mat-sys-title-medium-tracking));font-weight:var(--mat-card-subtitle-text-weight, var(--mat-sys-title-medium-weight))}.mat-mdc-card-title,.mat-mdc-card-subtitle{display:block;margin:0}.mat-mdc-card-avatar~.mat-mdc-card-header-text .mat-mdc-card-title,.mat-mdc-card-avatar~.mat-mdc-card-header-text .mat-mdc-card-subtitle{padding:16px 16px 0}.mat-mdc-card-header{display:flex;padding:16px 16px 0}.mat-mdc-card-content{display:block;padding:0 16px}.mat-mdc-card-content:first-child{padding-top:16px}.mat-mdc-card-content:last-child{padding-bottom:16px}.mat-mdc-card-title-group{display:flex;justify-content:space-between;width:100%}.mat-mdc-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0;margin-bottom:16px;object-fit:cover}.mat-mdc-card-avatar~.mat-mdc-card-header-text .mat-mdc-card-subtitle,.mat-mdc-card-avatar~.mat-mdc-card-header-text .mat-mdc-card-title{line-height:normal}.mat-mdc-card-sm-image{width:80px;height:80px}.mat-mdc-card-md-image{width:112px;height:112px}.mat-mdc-card-lg-image{width:152px;height:152px}.mat-mdc-card-xl-image{width:240px;height:240px}.mat-mdc-card-subtitle~.mat-mdc-card-title,.mat-mdc-card-title~.mat-mdc-card-subtitle,.mat-mdc-card-header .mat-mdc-card-header-text .mat-mdc-card-title,.mat-mdc-card-header .mat-mdc-card-header-text .mat-mdc-card-subtitle,.mat-mdc-card-title-group .mat-mdc-card-title,.mat-mdc-card-title-group .mat-mdc-card-subtitle{padding-top:0}.mat-mdc-card-content>:last-child:not(.mat-mdc-card-footer){margin-bottom:0}.mat-mdc-card-actions-align-end{justify-content:flex-end}
`],encapsulation:2,changeDetection:0})}return t})(),nv=(()=>{class t{static \u0275fac=function(r){return new(r||t)};static \u0275dir=Fa({type:t,selectors:[["mat-card-title"],["","mat-card-title",""],["","matCardTitle",""]],hostAttrs:[1,"mat-mdc-card-title"]})}return t})();var rv=(()=>{class t{static \u0275fac=function(r){return new(r||t)};static \u0275dir=Fa({type:t,selectors:[["mat-card-content"]],hostAttrs:[1,"mat-mdc-card-content"]})}return t})();var ov=(()=>{class t{static \u0275fac=function(r){return new(r||t)};static \u0275mod=Gi({type:t});static \u0275inj=ri({imports:[LE]})}return t})();var Hi=wa(pF()),mF=wa(dF()),pr=wa(PE());var Cte=["video"],Ite=["canvas"],sv=class t{constructor(n){this.cdr=n}cameraGranted=!1;videoRef;canvasRef;video;canvas;ctx;faceMesh;mpCamera;ngAfterViewInit(){this.video=this.videoRef.nativeElement,this.canvas=this.canvasRef.nativeElement;let n=this.canvas.getContext("2d");if(!n)throw new Error("No se pudo obtener el contexto del canvas");this.ctx=n}requestCamera(){return te(this,null,function*(){this.cameraGranted=!0,this.cdr.detectChanges(),this.faceMesh=new pr.FaceMesh({locateFile:n=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${n}`}),this.faceMesh.setOptions({maxNumFaces:1,refineLandmarks:!0,minDetectionConfidence:.5,minTrackingConfidence:.5}),this.faceMesh.onResults(this.onResults.bind(this)),this.mpCamera=new mF.Camera(this.video,{onFrame:()=>te(this,null,function*(){yield this.faceMesh.send({image:this.video})}),width:640,height:480}),yield this.mpCamera.start()})}onResults(n){if(this.ctx.save(),this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height),this.ctx.drawImage(n.image,0,0,this.canvas.width,this.canvas.height),n.multiFaceLandmarks)for(let e of n.multiFaceLandmarks)(0,Hi.drawConnectors)(this.ctx,e,pr.FACEMESH_TESSELATION,{color:"#C0C0C070",lineWidth:1}),(0,Hi.drawConnectors)(this.ctx,e,pr.FACEMESH_RIGHT_EYE,{color:"#FF3030"}),(0,Hi.drawConnectors)(this.ctx,e,pr.FACEMESH_RIGHT_EYEBROW,{color:"#FF3030"}),(0,Hi.drawConnectors)(this.ctx,e,pr.FACEMESH_RIGHT_IRIS,{color:"#FF3030"}),(0,Hi.drawConnectors)(this.ctx,e,pr.FACEMESH_LEFT_EYE,{color:"#30FF30"}),(0,Hi.drawConnectors)(this.ctx,e,pr.FACEMESH_LEFT_EYEBROW,{color:"#30FF30"}),(0,Hi.drawConnectors)(this.ctx,e,pr.FACEMESH_LEFT_IRIS,{color:"#30FF30"}),(0,Hi.drawConnectors)(this.ctx,e,pr.FACEMESH_FACE_OVAL,{color:"#E0E0E0"}),(0,Hi.drawConnectors)(this.ctx,e,pr.FACEMESH_LIPS,{color:"#E0E0E0"});this.ctx.restore()}static \u0275fac=function(e){return new(e||t)(Oa(vp))};static \u0275cmp=Ho({type:t,selectors:[["app-cam"]],viewQuery:function(e,r){if(e&1&&Rd(Cte,5)(Ite,5),e&2){let o;$a(o=La())&&(r.videoRef=o.first),$a(o=La())&&(r.canvasRef=o.first)}},decls:12,vars:0,consts:[["video",""],["canvas",""],[1,"permission-card"],["mat-raised-button","","color","primary",3,"click"],[2,"display","none"],["width","640","height","480"]],template:function(e,r){if(e&1){let o=My();ko(0,"mat-card",2)(1,"mat-card-title"),li(2,"Media Pipe"),Qr(),ko(3,"mat-card-content")(4,"p"),li(5,"Se requiere acceso a la c\xE1mara."),Qr(),ko(6,"button",3),kd("click",function(){return fd(o),dd(r.requestCamera())}),li(7," Activar C\xE1mara "),Qr()(),Ms(8,"video",4,0)(10,"canvas",5,1),Qr()}},dependencies:[ov,tv,rv,nv,Od],styles:[".permission-container[_ngcontent-%COMP%]{display:flex;justify-content:center;align-items:center;height:80vh;width:100%;height:100%}.permission-card[_ngcontent-%COMP%]{text-align:center;padding:2rem}"]})};var Ep=class{constructor(n,e){this.backend=n,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(n){return this.data.has(n)||this.dataMover.moveData(this.backend,n),this.data.get(n)}set(n,e){this.dataIdsCount++,this.data.set(n,e)}has(n){return this.data.has(n)}delete(n){return this.dataIdsCount--,this.data.delete(n)}numDataIds(){return this.dataIdsCount}},Ua=class{refCount(n){return qo("refCount")}incRef(n){return qo("incRef")}timerAvailable(){return!0}time(n){return qo("time")}read(n){return qo("read")}readSync(n){return qo("readSync")}readToGPU(n,e){return qo("readToGPU")}numDataIds(){return qo("numDataIds")}disposeData(n,e){return qo("disposeData")}write(n,e,r){return qo("write")}move(n,e,r,o,s){return qo("move")}createTensorFromGPUData(n,e,r){return qo("createTensorFromGPUData")}memory(){return qo("memory")}floatPrecision(){return qo("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return qo("dispose")}};function qo(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function gF(t){let n=t.length,e=0;for(;n>0;)e=Math.random()*n|0,n--,iv(t,n,e)}function Ste(t,n){if(t.length!==n.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${t.length}Second array length was ${n.length}`);let e=t.length,r=0;for(;e>0;)r=Math.random()*e|0,e--,iv(t,e,r),iv(n,e,r)}function Wd(t,n,e){return Math.max(t,Math.min(n,e))}function Tte(t){return t%2===0?t:t+1}function iv(t,n,e){let r=t[n];t[n]=t[e],t[e]=r}function Ete(t){let n=0;for(let e=0;e<t.length;e++)n+=t[e];return n}function Nte(t,n){let e=Math.random();return n*e+(1-e)*t}function Dte(t,n){let e=0;for(let r=0;r<t.length;r++){let o=Number(t[r])-Number(n[r]);e+=o*o}return e}function $(t,n){if(!t)throw new Error(typeof n=="string"?n:n())}function Pn(t,n,e=""){$(Ko(t,n),()=>e+` Shapes ${t} and ${n} must match`)}function bs(t){$(t!=null,()=>"The input to the tensor constructor must be a non-null value.")}function mt(t){if(t.length===0)return 1;let n=t[0];for(let e=1;e<t.length;e++)n*=t[e];return n}function kte(t){return t.length===0}function BE(t,n){if(t===n)return!0;if(t==null||n==null||t.length!==n.length)return!1;for(let e=0;e<t.length;e++)if(t[e]!==null&&n[e]!==null&&t[e]!==n[e])return!1;return!0}function Ko(t,n){if(t===n)return!0;if(t==null||n==null||t.length!==n.length)return!1;for(let e=0;e<t.length;e++)if(t[e]!==n[e])return!1;return!0}function Ga(t){return t%1===0}function Ate(t){if(Math.tanh!=null)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;{let n=Math.exp(2*t);return(n-1)/(n+1)}}function _te(t){let n=Math.ceil(Math.sqrt(t));return[n,Math.ceil(t/n)]}function Rte(t){let n=new Uint32Array(t);for(let e=0;e<t;++e)n[e]=e;return gF(n),n}function Dp(t,n){return n<=t.length?t:t+" ".repeat(n-t.length)}function Mte(t,n=o=>0,e,r){return new Promise((o,s)=>{let i=0,a=()=>{if(t()){o();return}i++;let l=n(i);if(e!=null&&i>=e){s();return}r!=null?r(a,l):setTimeout(a,l)};a()})}function Ote(t,n){let e=1,r=-1;for(let s=0;s<t.length;++s)if(t[s]>=0)e*=t[s];else if(t[s]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);r=s}else if(t[s]<0)throw Error(`Shapes can not be < 0. Found ${t[s]} at dim ${s}`);if(r===-1){if(n>0&&n!==e)throw Error(`Size(${n}) must match the product of shape ${t}`);return t}if(e===0)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(n%e!==0)throw Error(`The implicit shape can't be a fractional number. Got ${n} / ${e}`);let o=t.slice();return o[r]=n/e,o}function Zn(t,n){let e=n.length;return t=t==null?n.map((r,o)=>o):[].concat(t),$(t.every(r=>r>=-e&&r<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${t}`),$(t.every(r=>Ga(r)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(r=>r<0?e+r:r)}function zE(t,n){let e=[],r=[],o=n!=null&&Array.isArray(n)&&n.length===0,s=n==null||o?null:Zn(n,t).sort(),i=0;for(let a=0;a<t.length;++a){if(s!=null){if(s[i]===a&&t[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${t[a]}' is not 1`);(s[i]==null||s[i]>a)&&t[a]===1&&(e.push(t[a]),r.push(a)),s[i]<=a&&i++}t[a]!==1&&(e.push(t[a]),r.push(a))}return{newShape:e,keptDims:r}}function VE(t,n){return av(t,n)}function av(t,n){let e=null;if(t==null||t==="float32")e=new Float32Array(n);else if(t==="int32")e=new Int32Array(n);else if(t==="bool")e=new Uint8Array(n);else if(t==="string")e=new Array(n);else throw new Error(`Unknown data type ${t}`);return e}function UE(t,n){for(let e=0;e<t.length;e++){let r=t[e];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${n} being uploaded contains ${r}.`)}}function GE(t){return t==="bool"||t==="complex64"||t==="float32"||t==="int32"||t==="string"}function Fte(t,n){return!(n==="complex64"||n==="float32"&&t!=="complex64"||n==="int32"&&t!=="float32"&&t!=="complex64"||n==="bool"&&t==="bool")}function qd(t){if(t==="float32"||t==="int32")return 4;if(t==="complex64")return 8;if(t==="bool")return 1;throw new Error(`Unknown dtype ${t}`)}function jE(t){if(t==null)return 0;let n=0;return t.forEach(e=>n+=e.length),n}function Kd(t){return typeof t=="string"||t instanceof String}function yF(t){return typeof t=="boolean"}function xF(t){return typeof t=="number"}function bc(t){return Array.isArray(t)?bc(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":xF(t)?"float32":Kd(t)?"string":yF(t)?"bool":"float32"}function Xd(t){return!!(t&&t.constructor&&t.call&&t.apply)}function Yd(t,n){for(let e=n;e<t;++e)if(t%e===0)return e;return t}function Wi(t){let n=t.length;if(n<2)return[];let e=new Array(n-1);e[n-2]=t[n-1];for(let r=n-3;r>=0;--r)e[r]=e[r+1]*t[r+1];return e}function vF(t,n,e,r=!1){let o=new Array;if(n.length===1){let s=n[0]*(r?2:1);for(let i=0;i<s;i++)o[i]=e[t+i]}else{let s=n[0],i=n.slice(1),a=i.reduce((l,c)=>l*c)*(r?2:1);for(let l=0;l<s;l++)o[l]=vF(t+l*a,i,e,r)}return o}function Np(t,n,e=!1){if(t.length===0)return n[0];let r=t.reduce((o,s)=>o*s)*(e?2:1);if(r===0)return[];if(r!==n.length)throw new Error(`[${t}] does not match the input size ${n.length}${e?" for a complex tensor":""}.`);return vF(0,t,n,e)}function $te(t,n){if(Array.isArray(t))return t;if(n==="float32")return t instanceof Float32Array?t:new Float32Array(t);if(n==="int32")return t instanceof Int32Array?t:new Int32Array(t);if(n==="bool"||n==="string")return Uint8Array.from(new Int32Array(t));throw new Error(`Unknown dtype ${n}`)}function s1(t,n){let e=Zd(t,n);for(let r=0;r<e.length;r++)e[r]=1;return e}function Zd(t,n){if(n==null||n==="float32"||n==="complex64")return new Float32Array(t);if(n==="int32")return new Int32Array(t);if(n==="bool")return new Uint8Array(t);throw new Error(`Unknown data type ${n}`)}function Lte(t,n){let e=t.reduce((r,o)=>r*o,1);if(n==null||n==="float32")return Np(t,new Float32Array(e));if(n==="int32")return Np(t,new Int32Array(e));if(n==="bool")return Np(t,new Uint8Array(e));throw new Error(`Unknown data type ${n}`)}function Sn(t){t.forEach(n=>{$(Number.isInteger(n)&&n>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function Pte(t,n,e){if(n===0)return 0;if(n===1)return t[0];let r=t[t.length-1];for(let o=0;o<t.length-1;++o)r+=e[o]*t[o];return r}function Bte(t,n,e){if(n===0)return[];if(n===1)return[t];let r=new Array(n);for(let o=0;o<r.length-1;++o)r[o]=Math.floor(t/e[o]),t-=r[o]*e[o];return r[r.length-1]=t,r}function kp(t){return t&&t.then&&typeof t.then=="function"}var bF="tfjsflags",i1=class{constructor(n){this.global=n,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Vte,this.populateURLFlags()}setPlatform(n,e){this.platform!=null&&(Z().getBool("IS_TEST")||Z().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${n}.`)),this.platformName=n,this.platform=e}registerFlag(n,e,r){if(this.flagRegistry[n]={evaluationFn:e,setHook:r},this.urlFlags[n]!=null){let o=this.urlFlags[n];Z().getBool("IS_TEST")||Z().getBool("PROD")||console.warn(`Setting feature override from URL ${n}: ${o}.`),this.set(n,o)}}getAsync(n){return te(this,null,function*(){return n in this.flags?this.flags[n]:(this.flags[n]=yield this.evaluateFlag(n),this.flags[n])})}get(n){if(n in this.flags)return this.flags[n];let e=this.evaluateFlag(n);if(kp(e))throw new Error(`Flag ${n} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[n]=e,this.flags[n]}getNumber(n){return this.get(n)}getBool(n){return this.get(n)}getString(n){return this.get(n)}getFlags(){return this.flags}get features(){return this.flags}set(n,e){if(this.flagRegistry[n]==null)throw new Error(`Cannot set flag ${n} as it has not been registered.`);this.flags[n]=e,this.flagRegistry[n].setHook!=null&&this.flagRegistry[n].setHook(e)}evaluateFlag(n){if(this.flagRegistry[n]==null)throw new Error(`Cannot evaluate flag '${n}': no evaluation function found.`);return this.flagRegistry[n].evaluationFn()}setFlags(n){this.flags=Object.assign({},n)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;let n=this.getQueryParams(this.global.location.search);bF in n&&n[bF].split(",").forEach(r=>{let[o,s]=r.split(":");this.urlFlags[o]=Gte(o,s)})}};function Vte(t){let n={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...r)=>(Ute(n,r[0],r[1]),r.join("="))),n}function Ute(t,n,e){t[decodeURIComponent(n)]=decodeURIComponent(e||"")}function Gte(t,n){let e=n.toLowerCase();return e==="true"||e==="false"?e==="true":`${+e}`===e?+e:n}function Z(){return HE}var HE=null;function wF(t){HE=t}var WE;function qE(){if(WE==null){let t;if(typeof window<"u")t=window;else if(typeof global<"u")t=global;else if(typeof process<"u")t=process;else if(typeof self<"u")t=self;else throw new Error("Could not find a global object");WE=t}return WE}function jte(){let t=qE();return t._tfGlobals==null&&(t._tfGlobals=new Map),t._tfGlobals}function a1(t,n){let e=jte();if(e.has(t))return e.get(t);{let r=n();return e.set(t,r),e.get(t)}}var ja="Acos",Ha="Acosh";var wc="AddN";var Cc="ArgMax",Ic="ArgMin",Wa="Asin",qa="Asinh",Ka="Atan",Xa="Atanh",Ya="Atan2",Sc="AvgPool",Qd="AvgPoolGrad",Tc="AvgPool3D",Jd="AvgPool3DGrad",Ec="BatchMatMul",Nc="BatchToSpaceND",eh="Bincount",Ap="BitwiseAnd",CF="BroadcastTo",th="BroadcastArgs",qi="Cast",Za="Ceil",Qa="ClipByValue",nh="Complex",Dc="ComplexAbs",kc="Concat",Ac="Conv2D",rh="Conv2DBackpropFilter",_c="Conv2DBackpropInput",Rc="Conv3D",oh="Conv3DBackpropFilterV2",sh="Conv3DBackpropInputV2";var Ja="Cosh",ih="Cumprod",Mc="Cumsum",ah="CropAndResize",lh="DenseBincount",ch="DepthToSpace",Oc="DepthwiseConv2dNative",uh="DepthwiseConv2dNativeBackpropFilter",ph="DepthwiseConv2dNativeBackpropInput",fh="Diag",Fc="Dilation2D",l1="Dilation2DBackpropInput",c1="Dilation2DBackpropFilter",u1="Draw",el="RealDiv",dh="Einsum";var hh="EluGrad";var _p="Equal";var $c="ExpandDims",tl="Expm1";var mh="Fill",gh="FlipLeftRight",nl="Floor",rl="FloorDiv",Lc="FusedBatchNorm",Pc="GatherV2",yh="GatherNd",Rp="Greater",ol="GreaterEqual",Ki="Identity",xh="IFFT",vh="Imag",sl="IsFinite",il="IsInf",al="IsNan",Bc="LeakyRelu",Mp="Less",Op="LessEqual",bh="LinSpace";var ll="Log1p",Fp="LogicalAnd",$p="LogicalNot",Lp="LogicalOr";var IF="LogSoftmax";var wh="LRNGrad";var cl="Maximum",zc="MaxPool",Ch="MaxPoolGrad",Vc="MaxPool3D",Ih="MaxPool3DGrad",Sh="MaxPoolWithArgmax",Uc="Mean";var ul="Minimum",Gc="MirrorPad";var Th="Multinomial",pl="Multiply";var Pp="NotEqual",Eh="NonMaxSuppressionV3",Nh="NonMaxSuppressionV4",Dh="NonMaxSuppressionV5",jc="OnesLike",Hc="OneHot",Wc="Pack",qc="PadV2";var Kc="Prelu",Xc="Prod",kh="RaggedGather",Ah="RaggedRange",_h="RaggedTensorToTensor",Rh="Range",Mh="Real",fl="Reciprocal",dl="Relu",Yc="Reshape",Zc="ResizeNearestNeighbor",Oh="ResizeNearestNeighborGrad",Qc="ResizeBilinear",Fh="ResizeBilinearGrad",hl="Relu6",Jc="Reverse",ml="Round",gl="Rsqrt",$h="ScatterNd",Lh="TensorScatterUpdate",Ph="SearchSorted",eu="Select",yl="Selu",tu="Slice";var xl="Sinh",vl="Sign",bl="Sigmoid",wl="Softplus",Cl="Sqrt";var nu="SpaceToBatchND",ru="SplitV",ou="Softmax",Bh="SparseFillEmptyRows",zh="SparseReshape",Vh="SparseSegmentMean",Uh="SparseSegmentSum",Gh="SparseToDense",Il="SquaredDifference",jh="Square",Bp="StaticRegexReplace",Hh="StridedSlice",Wh="StringNGrams",qh="StringSplit",Kh="StringToHashBucketFast";var Sl="Tanh",Xi="Tile",Xh="TopK",Yh="Transform",Yi="Transpose",Zh="Unique",su="Unpack",iu="UnsortedSegmentSum";var au="ZerosLike",Tl="Step",p1="FromPixels",Qh="RotateWithOffset",zp="_FusedMatMul",Vp="FusedConv2D",Up="FusedDepthwiseConv2D";function Zi(...t){Z().getBool("IS_TEST")||Z().getBool("PROD")||console.warn(...t)}function Hte(...t){Z().getBool("IS_TEST")||Z().getBool("PROD")||console.log(...t)}var lv=a1("kernelRegistry",()=>new Map),KE=a1("gradRegistry",()=>new Map);function Jh(t,n){let e=EF(t,n);return lv.get(e)}function XE(t){return KE.get(t)}function YE(t){let n=lv.entries(),e=[];for(;;){let{done:r,value:o}=n.next();if(r)break;let[s,i]=o,[a]=s.split("_");a===t&&e.push(i)}return e}function cv(t){let{kernelName:n,backendName:e}=t,r=EF(n,e);lv.has(r)&&Zi(`The kernel '${n}' for backend '${e}' is already registered`),lv.set(r,t)}function TF(t){let{kernelName:n}=t;KE.has(n)&&Z().getBool("DEBUG")&&Zi(`Overriding the gradient for '${n}'`),KE.set(n,t)}function EF(t,n){return`${n}_${t}`}var b={};Xt(b,{arraysEqual:()=>Ko,arraysEqualWithNull:()=>BE,assert:()=>$,assertNonNegativeIntegerDimensions:()=>Sn,assertNonNull:()=>bs,assertShapesMatch:()=>Pn,bytesFromStringArray:()=>jE,bytesPerElement:()=>qd,checkConversionForErrors:()=>UE,clamp:()=>Wd,computeStrides:()=>Wi,convertBackendValuesAndArrayBuffer:()=>$te,createScalarValue:()=>Qte,createShuffledIndices:()=>Rte,decodeString:()=>om,distSquared:()=>Dte,encodeString:()=>rm,fetch:()=>ene,fingerPrint64:()=>Zte,flatten:()=>cu,getArrayFromDType:()=>av,getTypedArrayFromDType:()=>VE,hasEncodingLoss:()=>Fte,hexToLong:()=>f1,indexToLoc:()=>Bte,inferDtype:()=>bc,inferFromImplicitShape:()=>Ote,isBoolean:()=>yF,isFunction:()=>Xd,isInt:()=>Ga,isNumber:()=>xF,isPromise:()=>kp,isScalarShape:()=>kte,isString:()=>Kd,isTypedArray:()=>Jr,isValidDtype:()=>GE,locToIndex:()=>Pte,makeOnesTypedArray:()=>s1,makeZerosNestedTypedArray:()=>Lte,makeZerosTypedArray:()=>Zd,nearestDivisor:()=>Yd,nearestLargerEven:()=>Tte,now:()=>qp,parseAxisParam:()=>Zn,randUniform:()=>Nte,repeatedTry:()=>Mte,rightPad:()=>Dp,shuffle:()=>gF,shuffleCombo:()=>Ste,sizeFromShape:()=>mt,sizeToSquarishShape:()=>_te,squeezeShape:()=>zE,sum:()=>Ete,swap:()=>iv,tanh:()=>Ate,toNestedArray:()=>Np,toTypedArray:()=>nm});function uv(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}var eN=wa(LF());var Wp=eN.default||eN;function f1(t){return Wp.fromString(t,!0,16)}var BF=f1("c3a5c85c97cb3127"),Hp=f1("b492b66fbe98f273"),co=f1("9ae16a3b2f90404f");function JE(t){return t.xor(t.shru(47))}function zF(t,n,e){let r=t.slice(n,n+e);return Wp.fromBytes(Array.from(r),!0,!0)}function Tn(t,n){return zF(t,n,8)}function PF(t,n){return zF(t,n,4)}function Ir(t,n){return n===0?t:t.shru(n).or(t.shl(64-n))}function lu(t,n,e=f1("9ddfea08eb382d69")){let r=t.xor(n).mul(e);r=r.xor(r.shru(47));let o=n.xor(r).mul(e);return o=o.xor(o.shru(47)),o=o.mul(e),o}function qte(t,n,e,r,o,s){o=o.add(t),s=Ir(s.add(o).add(r),21);let i=o;return o=o.add(n),o=o.add(e),s=s.add(Ir(o,44)),[o.add(r),s.add(i)]}function fv(t,n,e,r){return qte(Tn(t,n),Tn(t,n+8),Tn(t,n+16),Tn(t,n+24),e,r)}function Kte(t,n=t.length){if(n>=8){let e=co.add(n*2),r=Tn(t,0).add(co),o=Tn(t,n-8),s=Ir(o,37).mul(e).add(r),i=Ir(r,25).add(o).mul(e);return lu(s,i,e)}if(n>=4){let e=co.add(n*2),r=PF(t,0);return lu(r.shl(3).add(n),PF(t,n-4),e)}if(n>0){let e=t[0],r=t[n>>1],o=t[n-1],s=e+(r<<8),i=n+(o<<2);return JE(co.mul(s).xor(BF.mul(i))).mul(co)}return co}function Xte(t,n=t.length){let e=co.add(n*2),r=Tn(t,0).mul(Hp),o=Tn(t,8),s=Tn(t,n-8).mul(e),i=Tn(t,n-16).mul(co);return lu(Ir(r.add(o),43).add(Ir(s,30)).add(i),r.add(Ir(o.add(co),18)).add(s),e)}function Yte(t,n=t.length){let e=co.add(n*2),r=Tn(t,0).mul(co),o=Tn(t,8),s=Tn(t,n-8).mul(e),i=Tn(t,n-16).mul(co),a=Ir(r.add(o),43).add(Ir(s,30)).add(i),l=lu(a,r.add(Ir(o.add(co),18)).add(s),e),c=Tn(t,16).mul(e),u=Tn(t,24),p=a.add(Tn(t,n-32)).mul(e),f=l.add(Tn(t,n-24)).mul(e);return lu(Ir(c.add(u),43).add(Ir(p,30)).add(f),c.add(Ir(u.add(r),18)).add(p),e)}function Zte(t,n=t.length){let e=Wp.fromNumber(81,!0);if(n<=32)return n<=16?Kte(t,n):Xte(t,n);if(n<=64)return Yte(t,n);let r=e,o=e.mul(Hp).add(113),s=JE(o.mul(co).add(113)).mul(co),i=[Wp.UZERO,Wp.UZERO],a=[Wp.UZERO,Wp.UZERO];r=r.mul(co).add(Tn(t,0));let l=0,c=(n-1>>6)*64,u=c+(n-1&63)-63;do r=Ir(r.add(o).add(i[0]).add(Tn(t,l+8)),37).mul(Hp),o=Ir(o.add(i[1]).add(Tn(t,l+48)),42).mul(Hp),r=r.xor(a[1]),o=o.add(i[0]).add(Tn(t,l+40)),s=Ir(s.add(a[0]),33).mul(Hp),i=fv(t,l,i[1].mul(Hp),r.add(a[0])),a=fv(t,l+32,s.add(a[1]),o.add(Tn(t,l+16))),[s,r]=[r,s],l+=64;while(l!==c);let p=Hp.add(s.and(255).shl(1));return l=u,a[0]=a[0].add(n-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),r=Ir(r.add(o).add(i[0]).add(Tn(t,l+8)),37).mul(p),o=Ir(o.add(i[1]).add(Tn(t,l+48)),42).mul(p),r=r.xor(a[1].mul(9)),o=o.add(i[0].mul(9).add(Tn(t,l+40))),s=Ir(s.add(a[0]),33).mul(p),i=fv(t,l,i[1].mul(p),r.add(a[0])),a=fv(t,l+32,s.add(a[1]),o.add(Tn(t,l+16))),[s,r]=[r,s],lu(lu(i[0],a[0],p).add(JE(o).mul(BF)).add(s),lu(i[1],a[1],p).add(r),p)}function Qte(t,n){return n==="string"?rm(t):nm([t],n)}function Jte(t,n){return t instanceof Float32Array&&n==="float32"||t instanceof Int32Array&&n==="int32"||t instanceof Uint8Array&&n==="bool"}function nm(t,n){if(n==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=cu(t)),Z().getBool("DEBUG")&&UE(t,n),Jte(t,n))return t;if(n==null||n==="float32"||n==="complex64")return new Float32Array(t);if(n==="int32")return new Int32Array(t);if(n==="bool"){let e=new Uint8Array(t.length);for(let r=0;r<e.length;++r)Math.round(t[r])!==0&&(e[r]=1);return e}else throw new Error(`Unknown data type ${n}`)}function qp(){return Z().platform.now()}function ene(t,n){return Z().platform.fetch(t,n)}function rm(t,n="utf-8"){return n=n||"utf-8",Z().platform.encode(t,n)}function om(t,n="utf-8"){return n=n||"utf-8",Z().platform.decode(t,n)}function Jr(t){return Z().platform.isTypedArray!=null?Z().platform.isTypedArray(t):uv(t)}function cu(t,n=[],e=!1){if(n==null&&(n=[]),typeof t=="boolean"||typeof t=="number"||typeof t=="string"||kp(t)||t==null||Jr(t)&&e)n.push(t);else if(Array.isArray(t)||Jr(t))for(let r=0;r<t.length;++r)cu(t[r],n,e);else{let r=-1;for(let o of Object.keys(t))/^([1-9]+[0-9]*|0)$/.test(o)&&(r=Math.max(r,Number(o)));for(let o=0;o<=r;o++)cu(t[o],n,e)}return n}var dv=class{constructor(n,e){this.backendTimer=n,this.logger=e,e==null&&(this.logger=new tN)}profileKernel(n,e,r){let o,s=()=>{o=r()},i,a=qp();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(s);else{s();for(let c of o)c.dataSync();i=Promise.resolve({kernelMs:qp()-a})}if(Z().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<o.length;c++){let u=o[c];u.data().then(p=>{tne(p,u.dtype,n)})}return{kernelName:n,outputs:o,inputs:e,timeMs:i.then(c=>c.kernelMs),extraInfo:i.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(n){let{kernelName:e,outputs:r,timeMs:o,inputs:s,extraInfo:i}=n;r.forEach(a=>{Promise.all([a.data(),o,i]).then(l=>{this.logger.logKernelProfile(e,a,l[0],l[1],s,l[2])})})}};function tne(t,n,e){if(n!=="float32")return!1;for(let r=0;r<t.length;r++){let o=t[r];if(isNaN(o)||!isFinite(o))return console.warn(`Found ${o} in the result of '${e}'`),!0}return!1}var tN=class{logKernelProfile(n,e,r,o,s,i){let a=typeof o=="number"?Dp(`${o}ms`,9):o.error,l=Dp(n,25),c=e.rank,u=e.size,p=Dp(e.shape.toString(),14),f="";for(let d in s){let h=s[d];if(h!=null){let g=h.shape||e.shape,m=g.length;f+=`${d}: ${m}D ${m>0?g:""} `}}console.log(`%c${l}	%c${a}	%c${c}D ${p}	%c${u}	%c${f}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function VF(t,n,e){let r={},o={};for(let l=0;l<n.length;l++)r[n[l].id]=!0;for(let l=0;l<t.length;l++){let c=t[l],u=c.inputs;for(let p in u){let f=u[p],d=!1;for(let h=0;h<n.length;h++)if(r[f.id]){c.outputs.forEach(g=>r[g.id]=!0),d=!0,o[c.id]=!0;break}if(d)break}}let s={};s[e.id]=!0;let i={};for(let l=t.length-1;l>=0;l--){let c=t[l],u=c.inputs;for(let p=0;p<c.outputs.length;p++)if(s[c.outputs[p].id]){for(let f in u)s[u[f].id]=!0,i[c.id]=!0;break}}let a=[];for(let l=0;l<t.length;l++){let c=t[l];if(o[c.id]&&i[c.id]){let u={};for(let f in c.inputs){let d=c.inputs[f];r[d.id]&&(u[f]=d)}let p=Object.assign({},c);p.inputs=u,p.outputs=c.outputs,a.push(p)}}return a}function UF(t,n,e,r){for(let o=n.length-1;o>=0;o--){let s=n[o],i=[];if(s.outputs.forEach(l=>{let c=t[l.id];c!=null?i.push(c):i.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let a=s.gradient(i);for(let l in s.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);let c=e(()=>a[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);let u=s.inputs[l];if(!Ko(c.shape,u.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${u.shape}'`);if(t[u.id]==null)t[u.id]=c;else{let p=t[u.id];t[u.id]=r(p,c),p.dispose()}}}}var GF=20,d1=3,nN=7;function jF(t,n,e,r){let o=Wi(n),s=nne(t,n,e,o),i=n.length,a=hv(t,n,e,o,s),l=["Tensor"];return r&&(l.push(`  dtype: ${e}`),l.push(`  rank: ${i}`),l.push(`  shape: [${n}]`),l.push("  values:")),l.push(a.map(c=>"    "+c).join(`
`)),l.join(`
`)}function nne(t,n,e,r){let o=mt(n),s=r[r.length-1],i=new Array(s).fill(0),a=n.length,l=e==="complex64"?m1(t):t;if(a>1)for(let c=0;c<o/s;c++){let u=c*s;for(let p=0;p<s;p++)i[p]=Math.max(i[p],h1(l[u+p],0,e).length)}return i}function h1(t,n,e){let r;return Array.isArray(t)?r=`${parseFloat(t[0].toFixed(nN))} + ${parseFloat(t[1].toFixed(nN))}j`:Kd(t)?r=`'${t}'`:e==="bool"?r=HF(t):r=parseFloat(t.toFixed(nN)).toString(),Dp(r,n)}function HF(t){return t===0?"false":"true"}function hv(t,n,e,r,o,s=!0){let i=e==="complex64"?2:1,a=n[0],l=n.length;if(l===0){if(e==="complex64"){let g=m1(t);return[h1(g[0],0,e)]}return e==="bool"?[HF(t[0])]:[t[0].toString()]}if(l===1){if(a>GF){let m=d1*i,y=Array.from(t.slice(0,m)),x=Array.from(t.slice((a-d1)*i,a*i));return e==="complex64"&&(y=m1(y),x=m1(x)),["["+y.map((C,I)=>h1(C,o[I],e)).join(", ")+", ..., "+x.map((C,I)=>h1(C,o[a-d1+I],e)).join(", ")+"]"]}return["["+(e==="complex64"?m1(t):Array.from(t)).map((m,y)=>h1(m,o[y],e)).join(", ")+"]"]}let c=n.slice(1),u=r.slice(1),p=r[0]*i,f=[];if(a>GF){for(let g=0;g<d1;g++){let m=g*p,y=m+p;f.push(...hv(t.slice(m,y),c,e,u,o,!1))}f.push("...");for(let g=a-d1;g<a;g++){let m=g*p,y=m+p;f.push(...hv(t.slice(m,y),c,e,u,o,g===a-1))}}else for(let g=0;g<a;g++){let m=g*p,y=m+p;f.push(...hv(t.slice(m,y),c,e,u,o,g===a-1))}let d=l===2?",":"";f[0]="["+(a>0?f[0]+d:"");for(let g=1;g<f.length-1;g++)f[g]=" "+f[g]+d;let h=`,
`;for(let g=2;g<l;g++)h+=`
`;return f[f.length-1]=" "+f[f.length-1]+"]"+(s?"":h),f}function m1(t){let n=[];for(let e=0;e<t.length;e+=2)n.push([t[e],t[e+1]]);return n}var $t=class{constructor(n,e,r){if(this.dtype=e,this.shape=n.slice(),this.size=mt(n),r!=null){let o=r.length;$(o===this.size,()=>`Length of values '${o}' does not match the size inferred by the shape '${this.size}'.`)}if(e==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||av(e,this.size),this.strides=Wi(n)}set(n,...e){e.length===0&&(e=[0]),$(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);let r=this.locToIndex(e);this.values[r]=n}get(...n){n.length===0&&(n=[0]);let e=0;for(let o of n){if(o<0||o>=this.shape[e]){let s=`Requested out of range element at ${n}.   Buffer shape=${this.shape}`;throw new Error(s)}e++}let r=n[n.length-1];for(let o=0;o<n.length-1;++o)r+=this.strides[o]*n[o];return this.values[r]}locToIndex(n){if(this.rank===0)return 0;if(this.rank===1)return n[0];let e=n[n.length-1];for(let r=0;r<n.length-1;++r)e+=this.strides[r]*n[r];return e}indexToLoc(n){if(this.rank===0)return[];if(this.rank===1)return[n];let e=new Array(this.shape.length);for(let r=0;r<e.length-1;++r)e[r]=Math.floor(n/this.strides[r]),n-=e[r]*this.strides[r];return e[e.length-1]=n,e}get rank(){return this.shape.length}toTensor(){return fi().makeTensor(this.values,this.shape,this.dtype)}},fi=null,sm=null,rne=null;function WF(t){fi=t}function qF(t){sm=t}function KF(t){rne=t}var ot=class{constructor(n,e,r,o){this.kept=!1,this.isDisposedInternal=!1,this.shape=n.slice(),this.dtype=e||"float32",this.size=mt(n),this.strides=Wi(n),this.dataId=r,this.id=o,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){return te(this,null,function*(){let n=yield this.data();return sm.buffer(this.shape,this.dtype,n)})}bufferSync(){return sm.buffer(this.shape,this.dtype,this.dataSync())}array(){return te(this,null,function*(){let n=yield this.data();return Np(this.shape,n,this.dtype==="complex64")})}arraySync(){return Np(this.shape,this.dataSync(),this.dtype==="complex64")}data(){return te(this,null,function*(){this.throwIfDisposed();let n=fi().read(this.dataId);if(this.dtype==="string"){let e=yield n;try{return e.map(r=>om(r))}catch(r){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return n})}dataToGPU(n){return this.throwIfDisposed(),fi().readToGPU(this.dataId,n)}dataSync(){this.throwIfDisposed();let n=fi().readSync(this.dataId);if(this.dtype==="string")try{return n.map(e=>om(e))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return n}bytes(){return te(this,null,function*(){this.throwIfDisposed();let n=yield fi().read(this.dataId);return this.dtype==="string"?n:new Uint8Array(n.buffer)})}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),fi().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(n=!1){return sm.print(this,n)}clone(){return this.throwIfDisposed(),sm.clone(this)}toString(n=!1){let e=this.dataSync();return jF(e,this.shape,this.dtype,n)}cast(n){return this.throwIfDisposed(),sm.cast(this,n)}variable(n=!0,e,r){return this.throwIfDisposed(),fi().makeVariable(this,n,e,r)}};Object.defineProperty(ot,Symbol.hasInstance,{value:t=>!!t&&t.data!=null&&t.dataSync!=null&&t.throwIfDisposed!=null});function j(){return a1("Tensor",()=>ot)}j();var El=class extends ot{constructor(n,e,r,o){super(n.shape,n.dtype,n.dataId,o),this.trainable=e,this.name=r}assign(n){if(n.dtype!==this.dtype)throw new Error(`dtype of the new value (${n.dtype}) and previous value (${this.dtype}) must match`);if(!Ko(n.shape,this.shape))throw new Error(`shape of the new value (${n.shape}) and previous value (${this.shape}) must match`);fi().disposeTensor(this),this.dataId=n.dataId,fi().incRef(this,null)}dispose(){fi().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(El,Symbol.hasInstance,{value:t=>t instanceof ot&&t.assign!=null&&t.assign instanceof Function});var XF=(function(t){return t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64",t})(XF||{}),YF=(function(t){return t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64",t})(YF||{}),ZF=(function(t){return t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64",t})(ZF||{}),QF=(function(t){return t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64",t})(QF||{}),one={float32:ZF,int32:XF,bool:YF,complex64:QF};function Wn(t,n){if(t==="string"||n==="string"){if(t==="string"&&n==="string")return"string";throw new Error(`Can not upcast ${t} with ${n}`)}return one[t][n]}function Kp(t){return Wn(t,"int32")}function mv(t){return t!=null&&typeof t=="object"&&"texture"in t&&t.texture instanceof WebGLTexture}function gv(t){return typeof GPUBuffer<"u"&&t!=null&&typeof t=="object"&&"buffer"in t&&t.buffer instanceof GPUBuffer}function xt(t,n){if(t.dtype===n.dtype)return[t,n];let e=Wn(t.dtype,n.dtype);return[t.cast(e),n.cast(e)]}function JF(t,n){$(t.dtype===n.dtype,()=>`The dtypes of the first(${t.dtype}) and second(${n.dtype}) input must match`)}function yv(t){let n=[];return e$(t,n,new Set),n}function e$(t,n,e){if(t==null)return;if(t instanceof ot){n.push(t);return}if(!sne(t))return;let r=t;for(let o in r){let s=r[o];e.has(s)||(e.add(s),e$(s,n,e))}}function sne(t){return Array.isArray(t)||typeof t=="object"}function rN(t){return t.kernelName!=null}var xv=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(n=>n.name)))}}}dispose(){for(let n in this.registeredVariables)this.registeredVariables[n].dispose()}},ane=(()=>{class t{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new xv}ready(){return te(this,null,function*(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let e=this.getSortedBackends();for(let r=0;r<e.length;r++){let o=e[r];if(yield this.initializeBackend(o).success){yield this.setBackend(o);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")})}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:e,asyncInit:r}=this.initializeBackendsAndReturnBest();if(r)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){let{asyncInit:r}=this.initializeBackend(e);if(r)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,r,o=1){return e in this.registryFactory?(Zi(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:r,priority:o},!0)}setBackend(e){return te(this,null,function*(){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;let{success:r,asyncInit:o}=this.initializeBackend(e);if(!(o?yield r:r))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new dv(this.backendInstance),!0})}setupRegisteredKernels(){YE(this.backendName).forEach(r=>{r.setupFunc!=null&&r.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){YE(e).forEach(o=>{o.disposeFunc!=null&&o.disposeFunc(this.registry[e])})}initializeBackend(e){let r=this.registryFactory[e];if(r==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{let o=r.factory();if(o&&!(o instanceof Ua)&&typeof o.then=="function"){let s=++this.pendingBackendInitId,i=o.then(a=>s<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,Zi(`Initialization of backend ${e} failed`),Zi(a.stack||a.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[e]=o,{success:!0,asyncInit:!1}}catch(o){return Zi(`Initialization of backend ${e} failed`),Zi(o.stack||o.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,r)=>this.registryFactory[r].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let r=0;r<e.length;r++){let o=e[r],{success:s,asyncInit:i}=this.initializeBackend(o);if(i||s)return{name:o,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,r){let o=this.state.tensorInfo.get(r),s=o.backend,i=this.readSync(r),a=s.refCount(r);s.disposeData(r,!0),o.backend=e,e.move(r,i,o.shape,o.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,r){let o=null;if(r==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");r=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof r!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");o=e}let s;return this.scopedRun(()=>this.startScope(o),()=>this.endScope(s),()=>(s=r(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,r,o){e();try{let s=o();return r(),s}catch(s){throw r(),s}}nextTensorId(){return t.nextTensorId++}nextVariableId(){return t.nextVariableId++}clone(e){let r=R.runKernel(Ki,{x:e}),o={x:e},s=a=>({x:()=>{let l="float32",c={x:a},u={dtype:l};return R.runKernel(qi,c,u)}}),i=[];return this.addTapeNode(this.state.activeScope.name,o,[r],s,i,{}),r}runKernel(e,r,o){if(this.backendName==null&&this.backend,!(Jh(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:r,attrs:o})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,r,o){let s=this.backend.numDataIds(),i=0;o.forEach(c=>{i+=c.dtype==="complex64"?3:1});let a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],l=s-r-i-a;if(l>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${e}'`)}runKernelFunc(e){let r,o=[],s=this.isTapeOn(),i=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let l;this.backendName==null&&this.backend;let c,u=rN(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(rN(e)){let{kernelName:g,inputs:m,attrs:y}=e;this.backendName==null&&this.backend;let x=Jh(g,this.backendName);$(x!=null,()=>`Cannot find registered kernel '${g}' for backend '${this.backendName}'`),l=()=>{let C=this.backend.numDataIds();c=x.kernelFunc({inputs:m,attrs:y,backend:this.backend});let I=Array.isArray(c)?c:[c];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(g,C,I);let D=I.map(O=>O.rank!=null?O:this.makeTensorFromTensorInfo(O));if(s){let O=this.getTensorsForGradient(g,m,D);o=this.saveTensorsForBackwardMode(O)}return D}}else{let{forwardFunc:g}=e,m=y=>{s&&(o=y.map(x=>this.keep(this.clone(x))))};l=()=>{let y=this.backend.numDataIds();c=this.tidy(()=>g(this.backend,m));let x=Array.isArray(c)?c:[c];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,y,x),x}}let{inputs:p,attrs:f}=e,d=rN(e)?null:e.backwardsFunc,h;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?r=l():(h=this.profiler.profileKernel(u,p,()=>l()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(h),r=h.outputs)}),s&&this.addTapeNode(u,p,r,d,o,f),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(p).map(g=>p[g]!=null?p[g].shape:null),outputShapes:r.map(g=>g.shape),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(c)?r:r[0]}saveTensorsForBackwardMode(e){return e.map(o=>this.keep(this.clone(o)))}getTensorsForGradient(e,r,o){let s=XE(e);if(s!=null){let i=s.inputsToSave||[],a=s.outputsToSave||[],l;s.saveAllInputs?($(Array.isArray(r),()=>"saveAllInputs is true, expected inputs to be an array."),l=Object.keys(r).map(u=>r[u])):l=i.map(u=>r[u]);let c=o.filter((u,p)=>a[p]);return l.concat(c)}return[]}makeTensor(e,r,o,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");o=o||"float32",s=s||this.backend;let i=e;o==="string"&&Kd(e[0])&&(i=e.map(c=>rm(c)));let a=s.write(i,r,o),l=new ot(r,o,a,this.nextTensorId());if(this.trackTensor(l,s),o==="string"){let c=this.state.tensorInfo.get(a),u=jE(i);this.state.numBytes+=u-c.bytes,c.bytes=u}return l}makeTensorFromDataId(e,r,o,s){o=o||"float32";let i={dataId:e,shape:r,dtype:o};return this.makeTensorFromTensorInfo(i,s)}makeTensorFromTensorInfo(e,r){let{dataId:o,shape:s,dtype:i}=e,a=new ot(s,i,o,this.nextTensorId());return this.trackTensor(a,r),a}makeVariable(e,r=!0,o,s){o=o||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));let i=new El(e,r,o,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,r){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let o=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(o=e.size*qd(e.dtype)),this.state.numBytes+=o,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:r||this.backend,dtype:e.dtype,shape:e.shape,bytes:o})),e instanceof El||this.track(e)}incRef(e,r){this.trackTensor(e,r),this.backend.incRef(e.dataId)}removeDataId(e,r){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===r&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let r=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=r.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){let o=e.size*qd(e.dtype);this.state.numBytes-=o}r.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,r.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let r=this.state.registeredVariables[e];this.disposeVariable(r)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}profile(e){return te(this,null,function*(){this.state.profiling=!0;let r=this.state.numBytes,o=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=yield e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-r,this.state.activeProfile.newTensors=this.state.numTensors-o;for(let s of this.state.activeProfile.kernels)s.kernelTimeMs=yield s.kernelTimeMs,s.extraInfo=yield s.extraInfo;return this.state.activeProfile})}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,r,o,s,i,a){let l={id:this.state.nextTapeNodeId++,kernelName:e,inputs:r,outputs:o,saved:i},c=XE(e);c!=null&&(s=c.gradFunc),s!=null&&(l.gradient=u=>(u=u.map((p,f)=>{if(p==null){let d=o[f],h=Zd(d.size,d.dtype);return this.makeTensor(h,d.shape,d.dtype)}return p}),s(u.length>1?u:u[0],i,a))),this.state.activeTape.push(l)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let r={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(r.name=e),this.state.scopeStack.push(r),this.state.activeScope=r}endScope(e){let r=yv(e),o=new Set(r.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){let a=this.state.activeScope.track[i];!a.kept&&!o.has(a.id)&&a.dispose()}let s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],r.forEach(i=>{!i.kept&&i.scopeId===s.id&&this.track(i)})}gradients(e,r,o,s=!1){if($(r.length>0,()=>"gradients() received an empty list of xs."),o!=null&&o.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${o.dtype}'`);let i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));$(i instanceof ot,()=>"The result y returned by f() must be a tensor.");let a=VF(this.state.activeTape,r,i);if(!s&&a.length===0&&r.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let l={};l[i.id]=o??lne(i.shape),UF(l,a,u=>this.tidy(u),cne);let c=r.map(u=>l[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(let p of u.saved)p.dispose()}),this.state.activeTape=null),{value:i,grads:c}})}customGrad(e){return $(Xd(e),()=>"The f passed in customGrad(f) must be a function."),(...r)=>{$(r.every(l=>l instanceof ot),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let o,s={};r.forEach((l,c)=>{s[c]=l});let i=(l,c)=>(o=e(...r,c),$(o.value instanceof ot,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),$(Xd(o.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),o.value),a=(l,c)=>{let u=o.gradFunc(l,c),p=Array.isArray(u)?u:[u];$(p.length===r.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),$(p.every(d=>d instanceof ot),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let f={};return p.forEach((d,h)=>{f[h]=()=>d}),f};return this.runKernelFunc({forwardFunc:i,backwardsFunc:a,inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,r){return this.state.tensorInfo.get(e).backend.readToGPU(e,r)}time(e){return te(this,null,function*(){let r=qp(),o=yield this.backend.time(e);return o.wallMs=qp()-r,o})}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new xv;for(let e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return t.nextTensorId=0,t.nextVariableId=0,t})();function lne(t){let n=s1(mt(t),"float32");return R.makeTensor(n,t,"float32")}function oN(){let t=qE();if(t._tfengine==null){let n=new i1(t);t._tfengine=new ane(n)}return wF(t._tfengine.ENV),WF(()=>t._tfengine),t._tfengine}var R=oN();function cne(t,n){let e={a:t,b:n};return R.runKernel("Add",e)}var pu={};Xt(pu,{isBrowser:()=>iN,isMobile:()=>fne,mockIsMobile:()=>pne});function une(){return typeof navigator<"u"&&navigator!=null}var sN;function pne(t){sN=t}function fne(t){if(sN!==void 0)return sN;if(t||une()){if(t||(t=navigator),t.product==="ReactNative")return!0;let n=t.userAgent||t.vendor||(typeof window<"u"?window.opera:"");if(!n){let e=t;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(n)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(n.substr(0,4))}return!1}function iN(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var Ao=Z();Ao.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Ao.registerFlag("IS_BROWSER",()=>iN());Ao.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Ao.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Ao.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Ao.registerFlag("PROD",()=>!1);Ao.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Ao.getBool("DEBUG"));Ao.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Ao.registerFlag("IS_TEST",()=>!1);Ao.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Ao.getBool("DEBUG"));Ao.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Ao.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Ao.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function _o(t,n){let e=t;if(Jr(t))return n==="string"?[]:[t.length];if(mv(t)){let o=t.channels||"RGBA";return[t.height,t.width*o.length]}else if(gv(t))return[t.buffer.size/(n==null?4:qd(n))];if(!Array.isArray(t))return[];let r=[];for(;Array.isArray(e)||Jr(e)&&n!=="string";)r.push(e.length),e=e[0];return Array.isArray(t)&&Z().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&n$(t,r,[]),r}function n$(t,n,e){if(e=e||[],!Array.isArray(t)&&!Jr(t)){$(n.length===0,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${n[0]} elements`);return}$(n.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${t.length} elements`),$(t.length===n[0],()=>`Element arr[${e.join("][")}] should have ${n[0]} elements, but has ${t.length} elements`);let r=n.slice(1);for(let o=0;o<t.length;++o)n$(t[o],r,e.concat(o))}function t$(t,n,e,r){if(t!=="string_or_numeric"){if(t==null)throw new Error("Expected dtype cannot be null.");if(t!=="numeric"&&t!==n||t==="numeric"&&n==="string")throw new Error(`Argument '${e}' passed to '${r}' must be ${t} tensor, but got ${n} tensor`)}}function T(t,n,e,r="numeric"){if(t instanceof j())return t$(r,t.dtype,n,e),t;let o=bc(t);if(o!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(o=r),t$(r,o,n,e),t==null||!Jr(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string"){let l=t==null?"null":t.constructor.name;throw new Error(`Argument '${n}' passed to '${e}' must be a Tensor or TensorLike, but got '${l}'`)}let s=_o(t,o);!Jr(t)&&!Array.isArray(t)&&(t=[t]);let a=o!=="string"?nm(t,o):cu(t,[],!0);return R.makeTensor(a,s,o)}function Xp(t,n,e,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${n} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((s,i)=>T(s,`${n}[${i}]`,e,r))}var aN="__op";function A(t){let n=Object.keys(t);if(n.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${n.length} keys.`);let e=n[0],r=t[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e=e+aN;let o=(...s)=>{R.startScope(e);try{let i=r(...s);return kp(i)&&console.error("Cannot return a Promise inside of tidy."),R.endScope(i),i}catch(i){throw R.endScope(null),i}};return Object.defineProperty(o,"name",{value:e,configurable:!0}),o}function dne(t,n){let e=T(t,"real","complex"),r=T(n,"imag","complex");Pn(e.shape,r.shape,`real and imag shapes, ${e.shape} and ${r.shape}, must match in call to tf.complex().`);let o={real:e,imag:r};return R.runKernel(nh,o)}var Ro=A({complex_:dne});function uo(t,n,e,r){if(r==null)r=bc(t);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(gv(t)||mv(t)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return R.backend.createTensorFromGPUData(t,n||e,r)}if(!Jr(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(n!=null){Sn(n);let o=mt(n),s=mt(e);$(o===s,()=>`Based on the provided shape, [${n}], the tensor should have ${o} values but has ${s}`);for(let i=0;i<e.length;++i){let a=e[i],l=i===e.length-1?a!==mt(n.slice(i)):!0;$(e[i]===n[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${n}). `)}}return!Jr(t)&&!Array.isArray(t)&&(t=[t]),n=n||e,t=r!=="string"?nm(t,r):cu(t,[],!0),R.makeTensor(t,n,r)}function fr(t,n,e){let r=_o(t,e);return uo(t,n,r,e)}var Nl={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};var $r=class t{static join(n){return new t(n).slice()}constructor(n){if(this.shards=[],this.previousShardIndex=0,n==null||(n instanceof Array||(n=[n]),n=n.map(r=>Jr(r)?r.buffer:r),n.length===0))return;this.bufferUniformSize=n[0].byteLength;let e=0;for(let r=0;r<n.length;r++){let o=n[r];r!==n.length-1&&o.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let s=e+o.byteLength;this.shards.push({buffer:o,start:e,end:s}),e=s}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(n=0,e=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(n=isNaN(Number(n))?0:n,e=isNaN(Number(e))?0:e,n=Math.max(0,n),e=Math.min(this.byteLength,e),e<=n)return new ArrayBuffer(0);let r=this.findShardForByte(n);if(r===-1)throw new Error(`Could not find start shard for byte ${n}`);let o=e-n,s=new ArrayBuffer(o),i=new Uint8Array(s),a=0;for(let l=r;l<this.shards.length;l++){let c=this.shards[l],p=n+a-c.start,f=a,h=Math.min(e,c.end)-c.start,g=new Uint8Array(c.buffer,p,h-p);if(i.set(g,f),a+=g.length,e<c.end)break}return s}findShardForByte(n){if(this.shards.length===0||n<0||n>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(n/this.bufferUniformSize),this.previousShardIndex;function e(o){return n<o.start?-1:n>=o.end?1:0}if(e(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;let r=hne(this.shards,e);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}};function hne(t,n){let e=0,r=t.length;for(;e<=r;){let o=Math.floor((r-e)/2)+e,s=n(t[o]);if(s===0)return o;s<0?r=o:e=o+1}return-1}function mne(t){Z().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(t+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}KF(mne);function Ps(){return R}function g1(){return R.memory()}function X(t,n){return R.tidy(t,n)}function Ve(t){yv(t).forEach(e=>e.dispose())}function mn(t){return R.keep(t)}function lN(t){return R.setBackend(t)}function r$(){return R.backendName}function vv(t,n,e=1){return R.registerBackend(t,n,e)}function bv(){return R.backend}var fu=4;function i$(t,n){return te(this,null,function*(){let e=[],r=[],o=Array.isArray(t)?t.map(i=>i.name):Object.keys(t);for(let i=0;i<o.length;++i){let a=o[i],l=Array.isArray(t)?t[i].tensor:t[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);let c={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){let u=new Promise(p=>te(null,null,function*(){let f=yield l.bytes(),d=f.reduce((m,y)=>m+y.length,0)+fu*f.length,h=new Uint8Array(d),g=0;for(let m=0;m<f.length;m++){let y=f[m],x=new Uint8Array(new Uint32Array([y.length]).buffer);h.set(x,g),g+=fu,h.set(y,g),g+=y.length}p(h)}));r.push(u)}else r.push(l.data());n!=null&&(c.group=n),e.push(c)}let s=yield Promise.all(r);return{data:xne(s),specs:e}})}function wv(t,n){let e=new $r(t),r={},o=0;for(let s of n){let i=gne(s,(a,l)=>e.slice(o+a,o+l));r[s.name]=a$(s,e.slice(o,o+i)),o+=i}return r}function gne(t,n){let e=mt(t.shape),r;if("quantization"in t){let o=t.quantization;r=Nl[o.dtype]}else if(t.dtype==="string"){let o=0;for(let s=0;s<e;s++)o+=fu+new Uint32Array(n(o,o+fu))[0];return o}else r=Nl[t.dtype];return e*r}function yne(t,n){return te(this,null,function*(){let e=mt(t.shape),r;if("quantization"in t){let o=t.quantization;r=Nl[o.dtype]}else if(t.dtype==="string"){let o=0;for(let s=0;s<e;s++)o+=fu+new Uint32Array(yield n(o,o+fu))[0];return o}else r=Nl[t.dtype];return e*r})}function a$(t,n){let e=t.name,r=t.dtype,o=t.shape,s=mt(o),i,a=0;if("quantization"in t){let l=t.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${t.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(r!=="float32")throw new Error(`Weight ${t.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${r}.`)}else throw new Error(`Weight ${t.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let c=Nl[l.dtype],u=l.dtype==="uint8"?new Uint8Array(n):new Uint16Array(n);if(r==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){i=new Float32Array(u.length);for(let p=0;p<u.length;p++){let f=u[p];i[p]=f*l.scale+l.min}}else if(l.dtype==="float16")i=Cne()(u);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(r==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);i=new Int32Array(u.length);for(let p=0;p<u.length;p++){let f=u[p];i[p]=Math.round(f*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${e}': ${r}`);a+=s*c}else if(r==="string"){let l=mt(t.shape);i=[];for(let c=0;c<l;c++){let u=new Uint32Array(n.slice(a,a+fu))[0];a+=fu;let p=new Uint8Array(n.slice(a,a+u));i.push(p),a+=u}}else{let l=Nl[r];if(r==="float32")i=new Float32Array(n);else if(r==="int32")i=new Int32Array(n);else if(r==="bool")i=new Uint8Array(n);else if(r==="complex64"){i=new Float32Array(n);let c=new Float32Array(i.length/2),u=new Float32Array(i.length/2);for(let h=0;h<c.length;h++)c[h]=i[h*2],u[h]=i[h*2+1];let p=fr(c,o,"float32"),f=fr(u,o,"float32"),d=Ro(p,f);return p.dispose(),f.dispose(),d}else throw new Error(`Unsupported dtype in weight '${e}': ${r}`);a+=s*l}return fr(i,o,r)}function o$(t,n,e){return te(this,null,function*(){let r=new Uint8Array(n);for(;r.byteLength<e;){let{done:o,value:s}=yield t.read();if(o&&s==null){let a=e-r.byteLength;throw new Error(`Reader is done but ${a} bytes are still expected`)}let i=new Uint8Array(r.length+s.byteLength);i.set(r,0),i.set(new Uint8Array(s),r.length),r=i}return r.buffer})}function Cv(t,n){return te(this,null,function*(){let e={},r=t.getReader(),o=new ArrayBuffer(0);for(let s of n){let i=yield yne(s,(c,u)=>te(null,null,function*(){return o=yield o$(r,o,u),o.slice(c,u)}));o=yield o$(r,o,i);let a=o.slice(0,i);o=o.slice(i);let l=a$(s,a);if(e[s.name]=l,r$()==="webgpu"){let c=bv();"uploadToGPU"in c&&mt(l.shape)>=Z().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&c.uploadToGPU(l.dataId)}}return e})}function xne(t){if(t===null)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let n=0,e=[];t.forEach(s=>{if(n+=s.byteLength,e.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let r=new Uint8Array(n),o=0;return e.forEach(s=>{r.set(new Uint8Array(s.buffer),o),o+=s.byteLength}),r.buffer}var cN=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function s$(t){return cN?Buffer.byteLength(t,"utf8"):new Blob([t]).size}function l$(t){if(cN)return Buffer.from(t).toString("base64");let n=new Uint8Array(t),e="";for(let r=0,o=n.length;r<o;r++)e+=String.fromCharCode(n[r]);return btoa(e)}function c$(t){if(cN){let r=Buffer.from(t,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}let n=atob(t),e=new Uint8Array(n.length);for(let r=0;r<n.length;++r)e.set([n.charCodeAt(r)],r);return e.buffer}function u$(t){return $r.join(t)}function uN(t){for(t=t.trim();t.endsWith("/");)t=t.slice(0,t.length-1);let e=t.split("/");return e[e.length-1]}function Iv(t,n){let e={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:n};return t.signature!=null&&(e.signature=t.signature),t.userDefinedMetadata!=null&&(e.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(e.modelInitializer=t.modelInitializer),t.initializerSignature!=null&&(e.initializerSignature=t.initializerSignature),t.trainingConfig!=null&&(e.trainingConfig=t.trainingConfig),e}function pN(t,n,e){let r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(t.trainingConfig!=null&&(r.trainingConfig=t.trainingConfig),t.weightsManifest!=null){if(!n)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!e)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=n,r.weightData=e}return t.signature!=null&&(r.signature=t.signature),t.userDefinedMetadata!=null&&(r.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(r.modelInitializer=t.modelInitializer),t.initializerSignature!=null&&(r.initializerSignature=t.initializerSignature),r}function im(t,n){return te(this,null,function*(){let e,r;return t.weightsManifest!=null&&([e,r]=yield n(t.weightsManifest)),pN(t,e,r)})}function Qi(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:t.modelTopology==null?0:s$(JSON.stringify(t.modelTopology)),weightSpecsBytes:t.weightSpecs==null?0:s$(JSON.stringify(t.weightSpecs)),weightDataBytes:t.weightData==null?0:new $r(t.weightData).byteLength}}function y1(t){let n=[];for(let e of t)n.push(...e.weights);return n}function vne(){let t=e=>{let r=e<<13,o=0;for(;(r&8388608)===0;)o-=8388608,r<<=1;return r&=-8388609,o+=947912704,r|o},n=new Uint32Array(2048);n[0]=0;for(let e=1;e<1024;e++)n[e]=t(e);for(let e=1024;e<2048;e++)n[e]=939524096+(e-1024<<13);return n}function bne(){let t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let n=1;n<31;n++)t[n]=n<<23;for(let n=33;n<63;n++)t[n]=2147483648+(n-32<<23);return t}function wne(){let t=new Uint32Array(64);for(let n=0;n<64;n++)t[n]=1024;return t[0]=t[32]=0,t}function Cne(){let t=vne(),n=bne(),e=wne();return r=>{let o=new ArrayBuffer(4*r.length),s=new Uint32Array(o);for(let i=0;i<r.length;i++){let a=r[i],l=t[e[a>>10]+(a&1023)]+n[a>>10];s[i]=l}return new Float32Array(o)}}var dr=class t{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return t.instance==null&&(t.instance=new t),t.instance}static registerSaveRouter(n){t.getInstance().saveRouters.push(n)}static registerLoadRouter(n){t.getInstance().loadRouters.push(n)}static getSaveHandlers(n){return t.getHandlers(n,"save")}static getLoadHandlers(n,e){return t.getHandlers(n,"load",e)}static getHandlers(n,e,r){let o=[];return(e==="load"?t.getInstance().loadRouters:t.getInstance().saveRouters).forEach(i=>{let a=i(n,r);a!==null&&o.push(a)}),o}},p$=t=>dr.registerSaveRouter(t),f$=t=>dr.registerLoadRouter(t),d$=t=>dr.getSaveHandlers(t),h$=(t,n)=>dr.getLoadHandlers(t,n);var fN="tensorflowjs",dN=1,Yp="models_store",du="model_info_store";function m$(){if(!Z().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let t=typeof window>"u"?self:window,n=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(n==null)throw new Error("The current browser does not appear to support IndexedDB.");return n}function hN(t){let n=t.result;n.createObjectStore(Yp,{keyPath:"modelPath"}),n.createObjectStore(du,{keyPath:"modelPath"})}var Zp=(()=>{class t{constructor(e){if(this.indexedDB=m$(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}save(e){return te(this,null,function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)})}load(){return te(this,null,function*(){return this.databaseAction(this.modelPath)})}databaseAction(e,r){return new Promise((o,s)=>{let i=this.indexedDB.open(fN,dN);i.onupgradeneeded=()=>hN(i),i.onsuccess=()=>{let a=i.result;if(r==null){let l=a.transaction(Yp,"readonly"),u=l.objectStore(Yp).get(this.modelPath);u.onsuccess=()=>{if(u.result==null)return a.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));o(u.result.modelArtifacts)},u.onerror=p=>(a.close(),s(u.error)),l.oncomplete=()=>a.close()}else{r.weightData=$r.join(r.weightData);let l=Qi(r),c=a.transaction(du,"readwrite"),u=c.objectStore(du),p;try{p=u.put({modelPath:this.modelPath,modelArtifactsInfo:l})}catch(d){return s(d)}let f;p.onsuccess=()=>{f=a.transaction(Yp,"readwrite");let d=f.objectStore(Yp),h;try{h=d.put({modelPath:this.modelPath,modelArtifacts:r,modelArtifactsInfo:l})}catch(g){return s(g)}h.onsuccess=()=>o({modelArtifactsInfo:l}),h.onerror=g=>{u=c.objectStore(du);let m=u.delete(this.modelPath);m.onsuccess=()=>(a.close(),s(h.error)),m.onerror=y=>(a.close(),s(h.error))}},p.onerror=d=>(a.close(),s(p.error)),c.oncomplete=()=>{f==null?a.close():f.oncomplete=()=>a.close()}}},i.onerror=a=>s(i.error)})}}return t.URL_SCHEME="indexeddb://",t})();var g$=t=>Z().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Zp.URL_SCHEME)?Ine(t.slice(Zp.URL_SCHEME.length)):null;dr.registerSaveRouter(g$);dr.registerLoadRouter(g$);function Ine(t){return new Zp(t)}function Sne(t){return t.startsWith(Zp.URL_SCHEME)?t.slice(Zp.URL_SCHEME.length):t}var Sv=class{constructor(){this.indexedDB=m$()}listModels(){return te(this,null,function*(){return new Promise((n,e)=>{let r=this.indexedDB.open(fN,dN);r.onupgradeneeded=()=>hN(r),r.onsuccess=()=>{let o=r.result,s=o.transaction(du,"readonly"),a=s.objectStore(du).getAll();a.onsuccess=()=>{let l={};for(let c of a.result)l[c.modelPath]=c.modelArtifactsInfo;n(l)},a.onerror=l=>(o.close(),e(a.error)),s.oncomplete=()=>o.close()},r.onerror=o=>e(r.error)})})}removeModel(n){return te(this,null,function*(){return n=Sne(n),new Promise((e,r)=>{let o=this.indexedDB.open(fN,dN);o.onupgradeneeded=()=>hN(o),o.onsuccess=()=>{let s=o.result,i=s.transaction(du,"readwrite"),a=i.objectStore(du),l=a.get(n),c;l.onsuccess=()=>{if(l.result==null)return s.close(),r(new Error(`Cannot find model with path '${n}' in IndexedDB.`));{let u=a.delete(n),p=()=>{c=s.transaction(Yp,"readwrite");let d=c.objectStore(Yp).delete(n);d.onsuccess=()=>e(l.result.modelArtifactsInfo),d.onerror=h=>r(l.error)};u.onsuccess=p,u.onerror=f=>(p(),s.close(),r(l.error))}},l.onerror=u=>(s.close(),r(l.error)),i.oncomplete=()=>{c==null?s.close():c.oncomplete=()=>s.close()}},o.onerror=s=>r(o.error)})})}};var Dl="/",am="tensorflowjs_models",y$="info",Tne="model_topology",Ene="weight_specs",Nne="weight_data",Dne="model_metadata";function x$(t){return{info:[am,t,y$].join(Dl),topology:[am,t,Tne].join(Dl),weightSpecs:[am,t,Ene].join(Dl),weightData:[am,t,Nne].join(Dl),modelMetadata:[am,t,Dne].join(Dl)}}function v$(t){for(let n of Object.values(t))window.localStorage.removeItem(n)}function kne(t){let n=t.split(Dl);if(n.length<3)throw new Error(`Invalid key format: ${t}`);return n.slice(1,n.length-1).join(Dl)}function Ane(t){return t.startsWith(Qp.URL_SCHEME)?t.slice(Qp.URL_SCHEME.length):t}var Qp=(()=>{class t{constructor(e){if(!Z().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=x$(this.modelPath)}save(e){return te(this,null,function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let r=JSON.stringify(e.modelTopology),o=JSON.stringify(e.weightSpecs),s=Qi(e),i=$r.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,r),this.LS.setItem(this.keys.weightSpecs,o),this.LS.setItem(this.keys.weightData,l$(i));let a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:s}}catch(a){throw v$(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}})}load(){return te(this,null,function*(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let r={},o=JSON.parse(this.LS.getItem(this.keys.topology));if(o==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);r.modelTopology=o;let s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);r.weightSpecs=s;let i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){let l=JSON.parse(i);r.format=l.format,r.generatedBy=l.generatedBy,r.convertedBy=l.convertedBy,l.signature!=null&&(r.signature=l.signature),l.userDefinedMetadata!=null&&(r.userDefinedMetadata=l.userDefinedMetadata),l.modelInitializer!=null&&(r.modelInitializer=l.modelInitializer),l.initializerSignature!=null&&(r.initializerSignature=l.initializerSignature),l.trainingConfig!=null&&(r.trainingConfig=l.trainingConfig)}let a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return r.weightData=c$(a),r})}}return t.URL_SCHEME="localstorage://",t})();var b$=t=>Z().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(Qp.URL_SCHEME)?_ne(t.slice(Qp.URL_SCHEME.length)):null;dr.registerSaveRouter(b$);dr.registerLoadRouter(b$);function _ne(t){return new Qp(t)}var Tv=class{constructor(){$(Z().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),$(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){return te(this,null,function*(){let n={},e=am+Dl,r=Dl+y$;for(let o=0;o<this.LS.length;++o){let s=this.LS.key(o);if(s.startsWith(e)&&s.endsWith(r)){let i=kne(s);n[i]=JSON.parse(this.LS.getItem(s))}}return n})}removeModel(n){return te(this,null,function*(){n=Ane(n);let e=x$(n);if(this.LS.getItem(e.info)==null)throw new Error(`Cannot find model at path '${n}'`);let r=JSON.parse(this.LS.getItem(e.info));return v$(e),r})}};var lm="://",di=class t{constructor(){this.managers={}}static getInstance(){return t.instance==null&&(t.instance=new t),t.instance}static registerManager(n,e){$(n!=null,()=>"scheme must not be undefined or null."),n.endsWith(lm)&&(n=n.slice(0,n.indexOf(lm))),$(n.length>0,()=>"scheme must not be an empty string.");let r=t.getInstance();$(r.managers[n]==null,()=>`A model store manager is already registered for scheme '${n}'.`),r.managers[n]=e}static getManager(n){let e=t.getInstance().managers[n];if(e==null)throw new Error(`Cannot find model manager for scheme '${n}'`);return e}static getSchemes(){return Object.keys(t.getInstance().managers)}};function Ev(t){if(t.indexOf(lm)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${di.getSchemes().join(",")}`);return{scheme:t.split(lm)[0],path:t.split(lm)[1]}}function w$(t,n,e=!1){return te(this,null,function*(){$(t!==n,()=>`Old path and new path are the same: '${t}'`);let r=dr.getLoadHandlers(t);$(r.length>0,()=>`Copying failed because no load handler is found for source URL ${t}.`),$(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${t}.`);let o=r[0],s=dr.getSaveHandlers(n);$(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${n}.`),$(s.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${n}.`);let i=s[0],a=Ev(t).scheme,l=Ev(t).path,c=a===Ev(t).scheme,u=yield o.load();e&&c&&(yield di.getManager(a).removeModel(l));let p=yield i.save(u);return e&&!c&&(yield di.getManager(a).removeModel(l)),p.modelArtifactsInfo})}function C$(){return te(this,null,function*(){let t=di.getSchemes(),n={};for(let e of t){let r=yield di.getManager(e).listModels();for(let o in r){let s=e+lm+o;n[s]=r[o]}}return n})}function I$(t){return te(this,null,function*(){let n=Ev(t);return di.getManager(n.scheme).removeModel(n.path)})}function S$(t,n){return te(this,null,function*(){return w$(t,n,!1)})}function T$(t,n){return te(this,null,function*(){return w$(t,n,!0)})}var mN=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(n,e){return fetch(n,e)}now(){return performance.now()}encode(n,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(n)}decode(n,e){return new TextDecoder(e).decode(n)}setTimeoutCustom(n,e){if(typeof window>"u"||!Z().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(n,e);return}this.functionRefs.push(n),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();let o=this.functionRefs[r.data.index];o(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(n){return uv(n)}};if(Z().get("IS_BROWSER")){Z().setPlatform("browser",new mN);try{di.registerManager(Qp.URL_SCHEME,new Tv)}catch(t){}try{di.registerManager(Zp.URL_SCHEME,new Sv)}catch(t){}}var Mne={importFetch:()=>N$()},gN;var yN=class{constructor(){this.util=D$(),this.textEncoder=new this.util.TextEncoder}fetch(n,e){return Z().global.fetch!=null?Z().global.fetch(n,e):(gN==null&&(gN=Mne.importFetch()),gN(n,e))}now(){let n=process.hrtime();return n[0]*1e3+n[1]/1e6}encode(n,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(n)}decode(n,e){return n.length===0?"":new this.util.TextDecoder(e).decode(n)}isTypedArray(n){return this.util.types.isFloat32Array(n)||this.util.types.isInt32Array(n)||this.util.types.isUint8Array(n)||this.util.types.isUint8ClampedArray(n)}};Z().get("IS_NODE")&&!Z().get("IS_BROWSER")&&Z().setPlatform("node",new yN);function Be(t,n="float32",e){return n=n||"float32",Sn(t),new $t(t,n,e)}function One(t,n){let e=T(t,"x","cast");if(!GE(n))throw new Error(`Failed to cast to unknown dtype ${n}`);if(n==="string"&&e.dtype!=="string"||n!=="string"&&e.dtype==="string")throw new Error("Only strings can be casted to strings");let r={x:e},o={dtype:n};return R.runKernel(qi,r,o)}var fe=A({cast_:One});function Fne(t){let e={x:T(t,"x","clone","string_or_numeric")};return R.runKernel(Ki,e)}var po=A({clone_:Fne});function Nv(t,n=!1){console.log(t.toString(n))}oN();var $ne={buffer:Be,cast:fe,clone:po,print:Nv};qF($ne);function Lne(t,n){let e=T(t,"a","add"),r=T(n,"b","add");[e,r]=xt(e,r);let o={a:e,b:r};return R.runKernel("Add",o)}var le=A({add_:Lne});function Pne(t,n){let e=T(t,"a","floorDiv"),r=T(n,"b","floorDiv");[e,r]=xt(e,r);let o={a:e,b:r};return R.runKernel(rl,o)}var um=A({floorDiv_:Pne});function Bne(t,n){let e=T(t,"a","div"),r=T(n,"b","div");if([e,r]=xt(e,r),e.dtype==="int32"&&r.dtype==="int32")return um(e,r);let o={a:e,b:r},s={};return R.runKernel(el,o,s)}var ve=A({div_:Bne});function zne(t,n){let e=T(t,"a","mul"),r=T(n,"b","mul");[e,r]=xt(e,r);let o={a:e,b:r};return R.runKernel(pl,o)}var z=A({mul_:zne});function Vne(t){let n=T(t,"x","abs");if(n.dtype==="complex64"){let e={x:n};return R.runKernel(Dc,e)}else{let e={x:n};return R.runKernel("Abs",e)}}var hn=A({abs_:Vne});function Une(t){let e={x:T(t,"x","acos")};return R.runKernel(ja,e)}var Dv=A({acos_:Une});function Gne(t){let e={x:T(t,"x","acosh")};return R.runKernel(Ha,e)}var kv=A({acosh_:Gne});function jne(t){$(Array.isArray(t),()=>"The argument passed to tf.addN() must be a list of tensors"),$(t.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`);let n=t.map((o,s)=>T(o,`tensors${s}`,"addN")),e=n[0];n.forEach(o=>{if(o.dtype!==e.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),n.forEach(o=>{if(!Ko(o.shape,e.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let r=n;return R.runKernel(wc,r)}var k$=A({addN_:jne});function Hne(t,n=null,e=!1){let o={x:T(t,"x","all","bool")},s={axis:n,keepDims:e};return R.runKernel("All",o,s)}var fm=A({all_:Hne});function Wne(t,n=null,e=!1){let o={x:T(t,"x","any","bool")},s={axis:n,keepDims:e};return R.runKernel("Any",o,s)}var ef=A({any_:Wne});function qne(t,n=0){let r={x:T(t,"x","argMax")},o={axis:n};return R.runKernel(Cc,r,o)}var Ji=A({argMax_:qne});function Kne(t,n=0){let r={x:T(t,"x","argMin")},o={axis:n};return R.runKernel(Ic,r,o)}var Rv=A({argMin_:Kne});function Xne(t){let e={x:T(t,"x","asin")};return R.runKernel(Wa,e)}var Mv=A({asin_:Xne});function Yne(t){let e={x:T(t,"x","asinh")};return R.runKernel(qa,e)}var Ov=A({asinh_:Yne});function Zne(t){let e={x:T(t,"x","atan")};return R.runKernel(Ka,e)}var Fv=A({atan_:Zne});function Qne(t,n){let e=T(t,"a","atan2"),r=T(n,"b","atan2");[e,r]=xt(e,r);let o={a:e,b:r};return R.runKernel(Ya,o)}var $v=A({atan2_:Qne});function Jne(t){let e={x:T(t,"x","atanh")};return R.runKernel(Xa,e)}var Lv=A({atanh_:Jne});function ere(t,n,e,r,o="NHWC",s){let i=t[3],a=[...n,i],l=_$(o);return tf(t,a,e,s,r,null,null,l)}function vN(t,n,e,r,o,s,i="channelsLast"){let[a,l]=x1(n),c;if(i==="channelsLast")c=[a,l,t[3],t[3]];else if(i==="channelsFirst")c=[a,l,t[1],t[1]];else throw new Error(`Unknown dataFormat ${i}`);return tf(t,c,e,r,o,s,!1,i)}function tre(t,n,e,r,o,s,i="NDHWC"){let[a,l,c]=xN(n),u,p;if(i==="NDHWC")p="channelsLast",u=[a,l,c,t[4],t[4]];else if(i==="NCDHW")p="channelsFirst",u=[a,l,c,t[1],t[1]];else throw new Error(`Unknown dataFormat ${i}`);return A$(t,u,e,r,o,!1,p,s)}function tf(t,n,e,r,o,s,i=!1,a="channelsLast"){let[l,c,u,p]=[-1,-1,-1,-1];if(a==="channelsLast")[l,c,u,p]=t;else if(a==="channelsFirst")[l,p,c,u]=t;else throw new Error(`Unknown dataFormat ${a}`);let[f,d,,h]=n,[g,m]=x1(e),[y,x]=x1(r),C=dm(f,y),I=dm(d,x),{padInfo:D,outHeight:O,outWidth:L}=ore(o,c,u,g,m,C,I,s,a),B=i?h*p:h,V;return a==="channelsFirst"?V=[l,B,O,L]:a==="channelsLast"&&(V=[l,O,L,B]),{batchSize:l,dataFormat:a,inHeight:c,inWidth:u,inChannels:p,outHeight:O,outWidth:L,outChannels:B,padInfo:D,strideHeight:g,strideWidth:m,filterHeight:f,filterWidth:d,effectiveFilterHeight:C,effectiveFilterWidth:I,dilationHeight:y,dilationWidth:x,inShape:t,outShape:V,filterShape:n}}function A$(t,n,e,r,o,s=!1,i="channelsLast",a){let[l,c,u,p,f]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[l,c,u,p,f]=t;else if(i==="channelsFirst")[l,f,c,u,p]=t;else throw new Error(`Unknown dataFormat ${i}`);let[d,h,g,,m]=n,[y,x,C]=xN(e),[I,D,O]=xN(r),L=dm(d,I),B=dm(h,D),V=dm(g,O),{padInfo:F,outDepth:G,outHeight:ee,outWidth:Q}=sre(o,c,u,p,y,x,C,L,B,V,a),oe=s?m*f:m,ae;return i==="channelsFirst"?ae=[l,oe,G,ee,Q]:i==="channelsLast"&&(ae=[l,G,ee,Q,oe]),{batchSize:l,dataFormat:i,inDepth:c,inHeight:u,inWidth:p,inChannels:f,outDepth:G,outHeight:ee,outWidth:Q,outChannels:oe,padInfo:F,strideDepth:y,strideHeight:x,strideWidth:C,filterDepth:d,filterHeight:h,filterWidth:g,effectiveFilterDepth:L,effectiveFilterHeight:B,effectiveFilterWidth:V,dilationDepth:I,dilationHeight:D,dilationWidth:O,inShape:t,outShape:ae,filterShape:n}}function nre(t,n,e,r,o){r==null&&(r=bN(t,n,e));let s=t[0],i=t[1],a=v1((s-n+2*r)/e+1,o),l=v1((i-n+2*r)/e+1,o);return[a,l]}function rre(t,n,e,r,o,s){o==null&&(o=bN(t,n[0],r[0]));let i=[0,0,0,e];for(let a=0;a<3;a++)t[a]+2*o>=n[a]&&(i[a]=v1((t[a]-n[a]+2*o)/r[a]+1,s));return i}function bN(t,n,e,r=1){let o=dm(n,r);return Math.floor((t[0]*(e-1)-e+o)/2)}function x1(t){return typeof t=="number"?[t,t,t]:t.length===2?[t[0],t[1],1]:t}function xN(t){return typeof t=="number"?[t,t,t]:t}function dm(t,n){return n<=1?t:t+(t-1)*(n-1)}function ore(t,n,e,r,o,s,i,a,l){let c,u,p;if(typeof t=="number"){c={top:t,bottom:t,left:t,right:t,type:t===0?"VALID":"NUMBER"};let d=nre([n,e],s,r,t,a);u=d[0],p=d[1]}else if(t==="same"){u=Math.ceil(n/r),p=Math.ceil(e/o);let f=Math.max(0,(u-1)*r+s-n),d=Math.max(0,(p-1)*o+i-e),h=Math.floor(f/2),g=f-h,m=Math.floor(d/2),y=d-m;c={top:h,bottom:g,left:m,right:y,type:"SAME"}}else if(t==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((n-s+1)/r),p=Math.ceil((e-i+1)/o);else if(typeof t=="object"){let f=l==="channelsLast"?t[1][0]:t[2][0],d=l==="channelsLast"?t[1][1]:t[2][1],h=l==="channelsLast"?t[2][0]:t[3][0],g=l==="channelsLast"?t[2][1]:t[3][1];c={top:f,bottom:d,left:h,right:g,type:f===0&&d===0&&h===0&&g===0?"VALID":"EXPLICIT"},u=v1((n-s+f+d)/r+1,a),p=v1((e-i+h+g)/o+1,a)}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:c,outHeight:u,outWidth:p}}function sre(t,n,e,r,o,s,i,a,l,c,u){let p,f,d,h;if(t==="valid"&&(t=0),typeof t=="number"){p={top:t,bottom:t,left:t,right:t,front:t,back:t,type:t===0?"VALID":"NUMBER"};let m=rre([n,e,r,1],[a,l,c],1,[o,s,i],t,u);f=m[0],d=m[1],h=m[2]}else if(t==="same"){f=Math.ceil(n/o),d=Math.ceil(e/s),h=Math.ceil(r/i);let g=(f-1)*o+a-n,m=(d-1)*s+l-e,y=(h-1)*i+c-r,x=Math.floor(g/2),C=g-x,I=Math.floor(m/2),D=m-I,O=Math.floor(y/2),L=y-O;p={top:I,bottom:D,left:O,right:L,front:x,back:C,type:"SAME"}}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:p,outDepth:f,outHeight:d,outWidth:h}}function v1(t,n){if(!n)return Math.trunc(t);switch(n){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${n}`)}}function ws(t){let[n,e,r]=x1(t);return n===1&&e===1&&r===1}function Sr(t,n){return ws(t)||ws(n)}function ea(t){return x1(t).every(n=>n>0)}function _$(t){if(t==="NHWC")return"channelsLast";if(t==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}function on(t,n,e){if(e!=null){if(typeof n=="string")throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${e} but got pad ${n}.`);if(typeof n=="number")$(Ga(n),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${e} but got pad ${n}.`);else if(typeof n=="object")n.forEach(r=>{r.forEach(o=>{$(Ga(o),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${e} but got pad ${o}.`)})});else throw Error(`Error in ${t}: Unknown padding parameter: ${n}`)}}function ire(t,n){let r={x:T(t,"x","reshape","string_or_numeric")},o={shape:n};return R.runKernel(Yc,r,o)}var U=A({reshape_:ire});function are(t,n,e,r,o){let s=T(t,"x","avgPool","float32"),i=1;$(Sr(e,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`);let a=s,l=!1;s.rank===3&&(l=!0,a=U(s,[1,s.shape[0],s.shape[1],s.shape[2]])),$(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),on("avgPool",r,o);let c={x:a},u={filterSize:n,strides:e,pad:r,dimRoundingMode:o},p=R.runKernel(Sc,c,u);return p=fe(p,s.dtype),l?U(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var hu=A({avgPool_:are});function lre(t,n,e,r,o,s="NDHWC"){let i=T(t,"x","avgPool3d","float32"),a=i,l=!1;i.rank===4&&(l=!0,a=U(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),$(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),$(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),$(typeof e=="number"&&e>0||Array.isArray(e)&&e[0]>0&&e[1]>0&&e[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${e}'`),on("avgPool3d",r,o);let c={x:a},u={filterSize:n,strides:e,pad:r,dimRoundingMode:o,dataFormat:s},p=R.runKernel(Tc,c,u);return p=fe(p,a.dtype),l?U(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var Pv=A({avgPool3d_:lre});function cre(t,n=0){$(t.length>=1,()=>"Pass at least one tensor to concat");let e=Xp(t,"tensors","concat","string_or_numeric");if(e[0].dtype==="complex64"&&e.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),e.length===1)return po(e[0]);let r=e,o={axis:n};return R.runKernel(kc,r,o)}var Et=A({concat_:cre});function ure(t,n,e=!1,r=!1){let o=T(t,"a","matMul"),s=T(n,"b","matMul");[o,s]=xt(o,s);let i={a:o,b:s},a={transposeA:e,transposeB:r};return R.runKernel(Ec,i,a)}var ct=A({matMul_:ure});function pre(t){let e={x:T(t,"x","sigmoid","float32")};return R.runKernel(bl,e)}var Tr=A({sigmoid_:pre});function fre(t,n,e){let r=T(t,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");let o={x:r},s={begin:n,size:e};return R.runKernel(tu,o,s)}var Ue=A({slice_:fre});function dre(t){let e={x:T(t,"x","tanh","float32")};return R.runKernel(Sl,e)}var hi=A({tanh_:dre});function hre(t,n,e,r,o,s){let i=T(t,"forgetBias","basicLSTMCell"),a=T(n,"lstmKernel","basicLSTMCell"),l=T(e,"lstmBias","basicLSTMCell"),c=T(r,"data","basicLSTMCell"),u=T(o,"c","basicLSTMCell"),p=T(s,"h","basicLSTMCell"),f=Et([c,p],1),d=ct(f,a),h=le(d,l),g=h.shape[0],m=h.shape[1]/4,y=[g,m],x=Ue(h,[0,0],y),C=Ue(h,[0,m],y),I=Ue(h,[0,m*2],y),D=Ue(h,[0,m*3],y),O=le(z(Tr(x),hi(C)),z(u,Tr(le(i,I)))),L=z(hi(O),Tr(D));return[O,L]}var R$=A({basicLSTMCell_:hre});function mre(t,n,e){let r=T(t,"x","batchToSpaceND"),o=n.reduce((a,l)=>a*l);$(r.rank>=1+n.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${n.length}`),$(e.length===n.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${n.length}`),$(r.shape[0]%o===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${n.join(" * ")} === ${o}`);let s={x:r},i={blockShape:n,crops:e};return R.runKernel(Nc,s,i)}var mu=A({batchToSpaceND_:mre});function M$(t){let n;return t.rank===0||t.rank===1?n=U(t,[1,1,1,t.size]):t.rank===2?n=U(t,[1,1,t.shape[0],t.shape[1]]):t.rank===3?n=U(t,[1,t.shape[0],t.shape[1],t.shape[2]]):n=t,n}function gre(t,n,e,r,o,s){s==null&&(s=.001);let i=T(t,"x","batchNorm"),a=T(n,"mean","batchNorm"),l=T(e,"variance","batchNorm"),c;o!=null&&(c=T(o,"scale","batchNorm"));let u;r!=null&&(u=T(r,"offset","batchNorm")),$(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),$(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),$(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let f={x:M$(i),scale:c,offset:u,mean:a,variance:l},d={varianceEpsilon:s},h=R.runKernel(Lc,f,d);return U(h,i.shape)}var ta=A({batchNorm_:gre});function yre(t,n,e,r,o,s){let i=T(t,"x","batchNorm"),a=T(n,"mean","batchNorm"),l=T(e,"variance","batchNorm"),c;o!=null&&(c=T(o,"scale","batchNorm"));let u;return r!=null&&(u=T(r,"offset","batchNorm")),$(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),$(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),$(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&$(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),u!=null&&$(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`),ta(i,a,l,u,c,s)}var Bv=A({batchNorm2d_:yre});function xre(t,n,e,r,o,s){let i=T(t,"x","batchNorm"),a=T(n,"mean","batchNorm"),l=T(e,"variance","batchNorm"),c;o!=null&&(c=T(o,"scale","batchNorm"));let u;return r!=null&&(u=T(r,"offset","batchNorm")),$(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),$(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),$(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&$(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),u!=null&&$(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`),ta(i,a,l,u,c,s)}var zv=A({batchNorm3d_:xre});function vre(t,n,e,r,o,s){let i=T(t,"x","batchNorm"),a=T(n,"mean","batchNorm"),l=T(e,"variance","batchNorm"),c;o!=null&&(c=T(o,"scale","batchNorm"));let u;return r!=null&&(u=T(r,"offset","batchNorm")),$(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),$(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),$(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&$(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),u!=null&&$(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`),ta(i,a,l,u,c,s)}var Vv=A({batchNorm4d_:vre});function bre(t,n,e){let r=T(t,"x","bincount"),o=T(n,"weights","bincount");$(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),$(e>=0,()=>`size must be non-negative, but got ${e}.`),$(o.size===r.size||o.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${o.shape}.`);let s={x:r,weights:o},i={size:e};return R.runKernel(eh,s,i)}var Uv=A({bincount_:bre});function wre(t,n){let e=T(t,"x","bitwiseAnd"),r=T(n,"y","bitwiseAnd");if(!Ko(e.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${e.shape}, y: ${r.shape}`);if(e.dtype!=="int32"||r.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${e.dtype} and type of y: ${r.dtype}`);let o={a:e,b:r};return R.runKernel(Ap,o)}var O$=A({bitwiseAnd_:wre});function Cre(t,n){let e=T(t,"s0","broadcastArgs","int32"),r=T(n,"s1","broadcastArgs","int32");if(e.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${e.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let o={s0:e,s1:r};return R.runKernel(th,o)}var F$=A({broadcastArgs_:Cre});function Ire(t,n){let e=T(t,"broadcastTo","x"),r=e.shape;if(Sn(n),n.length<e.rank)throw new Error(`broadcastTo(): shape.length=${n.length} < input.rank=${e.rank}.`);if(n.length>e.rank){let c=e.shape.slice();for(;c.length<n.length;)c.unshift(1);e=U(e,c)}let o=e.shape,s=Array.from(n);for(let c=n.length-1;c>=0;c--)if(o[c]===n[c])s[c]=1;else if(e.shape[c]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${n}].`);if(s.map((c,u)=>c>1?u:-1).filter(c=>c>=0).length===0)return po(e);let a={x:e},l={reps:s};return R.runKernel(Xi,a,l)}var na=A({broadcastTo_:Ire});function Sre(t){let e={x:T(t,"x","ceil","float32")};return R.runKernel(Za,e)}var Gv=A({ceil_:Sre});function Bs(t,n,e){Sn(t),e=e||bc(n);let r={shape:t,value:n,dtype:e};return R.runKernel(mh,{},r)}function Tre(t,n,e){let r=T(t,"x","clipByValue");if($(n<=e,()=>`Error in clip: min (${n}) must be less than or equal to max (${e}).`),n===e)return Bs(r.shape,n,r.dtype);let o={x:r},s={clipValueMin:n,clipValueMax:e};return R.runKernel(Qa,o,s)}var Qn=A({clipByValue_:Tre});function Ere(t){return Et(t,0)}var jv=A({concat1d_:Ere});function Nre(t,n){return Et(t,n)}var Hv=A({concat2d_:Nre});function Dre(t,n){return Et(t,n)}var Wv=A({concat3d_:Dre});function kre(t,n){return Et(t,n)}var qv=A({concat4d_:kre});function Are(t,n,e,r,o="NHWC",s=[1,1],i){let a=T(t,"x","conv2d","float32"),l=T(n,"filter","conv2d","float32"),c=a,u=!1;a.rank===3&&(u=!0,c=U(a,[1,a.shape[0],a.shape[1],a.shape[2]])),$(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),$(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),on("conv2d",r,i);let p=o==="NHWC"?c.shape[3]:c.shape[1];$(p===l.shape[2],()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${l.shape[2]}.`),$(Sr(e,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),$(ea(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),$(ea(e),()=>"Error in conv2D: Strides should be larger than 0.");let f={x:c,filter:l},d={strides:e,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i},h=R.runKernel(Ac,f,d);return u?U(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var Mo=A({conv2d_:Are});function _re(t,n,e,r,o="NWC",s=1,i){let a=T(t,"x","conv1d"),l=T(n,"filter","conv1d"),c=a,u=!1;a.rank===2&&(u=!0,c=U(a,[1,a.shape[0],a.shape[1]])),$(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),$(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),on("conv1d",r,i),$(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),$(Sr(e,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${s}'`),$(ea(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),$(ea(e),()=>"Error in conv1D: Stride should be larger than 0."),$(o==="NWC",()=>`Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`);let p=U(l,[1,l.shape[0],l.shape[1],l.shape[2]]),f=U(c,[c.shape[0],1,c.shape[1],c.shape[2]]),m=Mo(f,p,[1,e],r,"NHWC",[1,s],i);return u?U(m,[m.shape[2],m.shape[3]]):U(m,[m.shape[0],m.shape[2],m.shape[3]])}var hm=A({conv1d_:_re});function Rre(t,n,e,r,o,s="NHWC",i){$(t.length===n.rank,()=>`Length of inShape (${t.length}) and rank of dy (${n.rank}) must match`);let a=t,l=n,c=!1;n.rank===3&&(c=!0,l=U(n,[1,n.shape[0],n.shape[1],n.shape[2]]),a=[1,t[0],t[1],t[2]]),$(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),$(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),$(e.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);let u=s==="NHWC"?a[3]:a[1],p=s==="NHWC"?l.shape[3]:l.shape[1];$(u===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${e.shape[2]}.`),$(p===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${e.shape[3]}.`),on("conv2dDerInput",o,i);let f={dy:l,filter:e},d={strides:r,pad:o,dataFormat:s,dimRoundingMode:i,inputShape:a},h=R.runKernel(_c,f,d);return c?U(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var mm=A({conv2DBackpropInput_:Rre});function Mre(t,n,e,r,o,s){let i=T(t,"x","conv2dTranspose"),a=T(n,"filter","conv2dTranspose");return mm(e,i,a,r,o,"NHWC",s)}var gm=A({conv2dTranspose_:Mre});function Ore(t,n,e,r,o="NDHWC",s=[1,1,1]){let i=T(t,"x","conv3d"),a=T(n,"filter","conv3d"),l=i,c=!1;i.rank===4&&(c=!0,l=U(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),$(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),$(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),$(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),$(Sr(e,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),$(o==="NDHWC",()=>`Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`),$(ea(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),$(ea(e),()=>"Error in conv3D: Strides should be larger than 0.");let u={x:l,filter:a},p={strides:e,pad:r,dataFormat:o,dilations:s},f=R.runKernel(Rc,u,p);return c?U(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}var Kv=A({conv3d_:Ore});function Fre(t,n,e,r,o){$(t.length===n.rank,()=>`Length of inShape (${t.length}) and rank of dy (${n.rank}) must match`);let s=t,i=n,a=!1;n.rank===4&&(a=!0,i=U(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]),s=[1,t[0],t[1],t[2],t[3]]);let l=s[4],c=i.shape[4];$(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),$(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),$(e.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),$(l===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${e.shape[3]}.`),$(c===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${e.shape[4]}.`);let u={dy:i,filter:e},p={pad:o,strides:r,inputShape:s},f=R.runKernel(sh,u,p);return a?U(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}var Xv=A({conv3DBackpropInput_:Fre});function $re(t,n,e,r,o){let s=T(t,"x","conv3dTranspose"),i=T(n,"filter","conv3dTranspose");return Xv(e,s,i,r,o)}var Yv=A({conv3dTranspose_:$re});function Lre(t){let e={x:T(t,"x","cos","float32")};return R.runKernel("Cos",e)}var gu=A({cos_:Lre});function Pre(t){let e={x:T(t,"x","cosh","float32")};return R.runKernel(Ja,e)}var xm=A({cosh_:Pre});function Bre(t,n=0,e=!1,r=!1){let s={x:T(t,"x","cumprod")},i={axis:n,exclusive:e,reverse:r};return R.runKernel(ih,s,i)}var nf=A({cumprod_:Bre});function zre(t,n=0,e=!1,r=!1){let s={x:T(t,"x","cumsum")},i={axis:n,exclusive:e,reverse:r};return R.runKernel(Mc,s,i)}var vm=A({cumsum_:zre});function Vre(t,n,e,r=!1){let o=T(t,"x","denseBincount"),s=T(n,"weights","denseBincount");$(o.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${o.dtype}`),$(o.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${o.rank}.`),$(e>=0,()=>`size must be non-negative, but got ${e}.`),$(s.size===o.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${o.shape}, weights shape: ${s.shape}.`);let i={x:o,weights:s},a={size:e,binaryOutput:r};return R.runKernel(lh,i,a)}var b1=A({denseBincount_:Vre});function Ure(t,n,e="NHWC"){let r=T(t,"x","depthToSpace","float32"),o=e==="NHWC"?r.shape[1]:r.shape[2],s=e==="NHWC"?r.shape[2]:r.shape[3],i=e==="NHWC"?r.shape[3]:r.shape[1];$(n>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${n}`),$(o*n>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${n}  for depthToSpace with input shape
    ${r.shape}`),$(s*n>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${n} for depthToSpace with input shape
        ${r.shape}`),$(i%(n*n)===0,()=>`Dimension size must be evenly divisible by ${n*n} but is ${i} for depthToSpace with input shape ${r.shape}`);let a={x:r},l={blockSize:n,dataFormat:e};return R.runKernel(ch,a,l)}var Zv=A({depthToSpace_:Ure});function Gre(t,n,e,r,o="NHWC",s=[1,1],i){let a=T(t,"x","depthwiseConv2d","float32"),l=T(n,"filter","depthwiseConv2d","float32"),c=a,u=!1;a.rank===3&&(u=!0,c=U(a,[1,a.shape[0],a.shape[1],a.shape[2]])),$(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),$(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);let p=o==="NHWC"?c.shape[3]:c.shape[1];$(p===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${p}) must match the inChannels dimension in filter ${l.shape[2]}.`),on("depthwiseConv2d",r,i);let f={x:c,filter:l},d={strides:e,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i},h=R.runKernel(Oc,f,d);return u?U(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var ra=A({depthwiseConv2d_:Gre});function jre(t){let e={x:T(t,"x","diag")};return R.runKernel(fh,e)}var $$=A({diag_:jre});function Hre(t,n,e,r,o=[1,1],s="NHWC"){let i=T(t,"x","dilation2d"),a=T(n,"filter","dilation2d");$(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),$(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),$(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let l=i,c=!1;i.rank===3&&(l=U(i,[1,i.shape[0],i.shape[1],i.shape[2]]),c=!0),$(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);let u={x:l,filter:a},p={strides:e,pad:r,dilations:o},f=R.runKernel(Fc,u,p);return c?U(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Qv=A({dilation2d_:Hre});var Zo={};Xt(Zo,{assertAndGetBroadcastShape:()=>rt,getBroadcastDims:()=>L$,getReductionAxes:()=>Yt});function L$(t,n){let e=t.length,r=[];for(let o=0;o<e;o++){let s=e-1-o,i=t[s]||1;(n[n.length-1-o]||1)>1&&i===1&&r.unshift(s)}return r}function Yt(t,n){let e=[];for(let r=0;r<n.length;r++){let o=t[t.length-r-1],s=n.length-r-1,i=n[s];(o==null||o===1&&i>1)&&e.unshift(s)}return e}function rt(t,n){let e=Math.max(t.length,n.length),r=new Array(e);for(let o=0;o<e;o++){let s=t[t.length-o-1];s==null&&(s=1);let i=n[n.length-o-1];if(i==null&&(i=1),s===1)r[e-o-1]=i;else if(i===1)r[e-o-1]=s;else if(s!==i){let a=`Operands could not be broadcast together with shapes ${t} and ${n}.`;throw Error(a)}else r[e-o-1]=s}return r}function Wre(t,n){let e=T(t,"a","equal","string_or_numeric"),r=T(n,"b","equal","string_or_numeric");[e,r]=xt(e,r),rt(e.shape,r.shape);let o={a:e,b:r};return R.runKernel(_p,o)}var eo=A({equal_:Wre});function qre(t,n,e){let r=T(n,"a","where"),o=T(e,"b","where"),s=T(t,"condition","where","bool"),i=rt(rt(s.shape,r.shape),o.shape),a=na(s,i),l=na(r,i),c=na(o,i),u={condition:a,t:l,e:c};return R.runKernel(eu,u)}var sn=A({where_:qre});function Kre(t){let e={x:T(t,"x","zerosLike")};return R.runKernel(au,e)}var Ge=A({zerosLike_:Kre});function Xre(t,n){let e=T(t,"a","div"),r=T(n,"b","div");[e,r]=xt(e,r);let o=ve(e,r),s=Ge(o),i=eo(r,s);return sn(i,s,o)}var Jv=A({divNoNan_:Xre});function Yre(t,n){let e=T(t,"t1","dot"),r=T(n,"t2","dot");$((e.rank===1||e.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${r.rank}.`);let o=e.rank===1?e.size:e.shape[1],s=r.rank===1?r.size:r.shape[0];if($(o===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${o} and ${s}.`),e.rank===1&&r.rank===1){let i=U(e,[1,-1]),a=U(r,[-1,1]),l=ct(i,a);return U(l,[])}else if(e.rank===1&&r.rank===2){let i=U(e,[1,-1]),a=U(r,[r.shape[0],r.shape[1]]),l=ct(i,a);return U(l,[l.size])}else if(e.rank===2&&r.rank===1){let i=U(r,[-1,1]),a=ct(e,i);return U(a,[a.size])}else{let i=U(r,[r.shape[0],r.shape[1]]);return ct(e,i)}}var eb=A({dot_:Yre});function Zre(t,...n){let e=n.map((o,s)=>T(o,`tensors${s}`,"einsum")),r={equation:t};return R.runKernel(dh,e,r)}var yu=A({einsum_:Zre});function Qre(t){let e={x:T(t,"x","elu","float32")};return R.runKernel("Elu",e)}var oa=A({elu_:Qre});function Jre(t,n){let e=T(t,"x","ensureShape","string_or_numeric");if(!BE(e.shape,n))throw new Error(`EnsureShape: Shape of tensor ${e.shape} is not compatible with expected shape ${n}`);return t}var P$=A({ensureShape_:Jre});function eoe(t){let n=T(t,"x","erf");$(n.dtype==="int32"||n.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),n.dtype==="int32"&&(n=fe(n,"float32"));let e={x:n};return R.runKernel("Erf",e)}var wm=A({erf_:eoe});function wN(t,n){for(let e=0;e<t.length;++e)if(t[t.length-e-1]!==n-1-e)return!1;return!0}function B$(t,n,e){let r=t.length+n.length,o=[],s=0,i=0;for(let a=0;a<r;a++)e.indexOf(a)===-1?o.push(t[s++]):o.push(n[i++]);return o}function CN(t,n){let e=[],r=t.length;for(let s=0;s<r;s++)n.indexOf(s)===-1&&e.push(t[s]);let o=n.map(s=>t[s]);return[e,o]}function zs(t,n){let e=n.map(r=>1);return B$(t,e,n)}function toe(t,n,e){$(wN(n,e),()=>`${t} supports only inner-most axes for now. Got axes ${n} and rank-${e} input.`)}function IN(t,n){if(wN(t,n))return null;let e=[];for(let r=0;r<n;++r)t.indexOf(r)===-1&&e.push(r);return t.forEach(r=>e.push(r)),e}function w1(t){return t.map((n,e)=>[e,n]).sort((n,e)=>n[1]-e[1]).map(n=>n[0])}function noe(t,n){let e=[];for(let r=n-t;r<n;++r)e.push(r);return e}function roe(t,n=null,e=!1){let o={x:T(t,"x","max")},s={reductionIndices:n,keepDims:e};return R.runKernel("Max",o,s)}var hr=A({max_:roe});function ooe(t,n=null,e=!1){let o={x:T(t,"x","min")},s={axis:n,keepDims:e};return R.runKernel("Min",o,s)}var kl=A({min_:ooe});function soe(t,n){let e=T(t,"base","pow"),r=T(n,"exp","pow");[e,r]=xt(e,r);let o={a:e,b:r};return R.runKernel("Pow",o)}var Lr=A({pow_:soe});function Ee(t,n){if((Jr(t)&&n!=="string"||Array.isArray(t))&&n!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(n==="string"&&Jr(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return uo(t,[],[],n)}function ioe(t){let e={x:T(t,"x","sqrt","float32")};return R.runKernel(Cl,e)}var Wt=A({sqrt_:ioe});function aoe(t){let n=T(t,"x","square"),e={};return R.runKernel("Square",{x:n},e)}var lt=A({square_:aoe});function loe(t,n=null,e=!1){let r=T(t,"x","sum");r.dtype==="bool"&&(r=fe(r,"int32"));let o={x:r},s={axis:n,keepDims:e};return R.runKernel("Sum",o,s)}var Ne=A({sum_:loe});function coe(t,n="euclidean",e=null,r=!1){t=T(t,"x","norm");let o=z$(t,n,e),s=o.shape;if(r){let i=Zn(e,t.shape);s=zs(o.shape,i)}return U(o,s)}function z$(t,n,e=null){if(t.rank===0)return hn(t);if(t.rank!==1&&e===null)return z$(U(t,[-1]),n,e);if(t.rank===1||typeof e=="number"||Array.isArray(e)&&e.length===1){if(n===1)return Ne(hn(t),e);if(n===1/0)return hr(hn(t),e);if(n===-1/0)return kl(hn(t),e);if(n==="euclidean"||n===2)return Wt(Ne(Lr(hn(t),Ee(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${n}`)}if(Array.isArray(e)&&e.length===2){if(n===1)return hr(Ne(hn(t),e[0]),e[1]-1);if(n===1/0)return hr(Ne(hn(t),e[1]),e[0]);if(n===-1/0)return kl(Ne(hn(t),e[1]),e[0]);if(n==="fro"||n==="euclidean")return Wt(Ne(lt(t),e));throw new Error(`Error in norm: invalid ord value: ${n}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}var Al=A({norm_:coe});function uoe(t,n=null,e=!1){return Al(t,"euclidean",n,e)}var tb=A({euclideanNorm_:uoe});function poe(t){let e={x:T(t,"x","exp")};return R.runKernel("Exp",e)}var gn=A({exp_:poe});function foe(t,n=0){let e=T(t,"x","expandDims","string_or_numeric");$(n<=e.rank,()=>"Axis must be <= rank of the tensor");let r={input:e},o={dim:n};return R.runKernel($c,r,o)}var an=A({expandDims_:foe});function doe(t){let e={x:T(t,"x","expm1")};return R.runKernel(tl,e)}var nb=A({expm1_:doe});function hoe(t,n){let e=T(t,"x","tile","string_or_numeric");$(e.rank===n.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${n}.`);let r={x:e},o={reps:n};return R.runKernel(Xi,r,o)}var Er=A({tile_:hoe});function moe(t,n,e,r="float32"){n==null&&(n=t);let o=Be([t,n],r),s=t<=n?t:n;for(let a=0;a<s;++a)o.set(1,a,a);let i=U(o.toTensor(),[t,n]);if(e==null)return i;if(e.length===1)return Er(an(i,0),[e[0],1,1]);if(e.length===2)return Er(an(an(i,0),0),[e[0],e[1],1,1]);if(e.length===3)return Er(an(an(an(i,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}var of=A({eye_:moe});function goe(t){let e={x:T(t,"x","floor","float32")};return R.runKernel(nl,e)}var sa=A({floor_:goe});function yoe(t,n,e=0,r=0){let o=T(t,"x","gather"),s=T(n,"indices","gather","int32"),i={x:o,indices:s},a={axis:e,batchDims:r};return R.runKernel(Pc,i,a)}var ia=A({gather_:yoe});function xoe(t,n){let e=T(t,"a","greater","string_or_numeric"),r=T(n,"b","greater","string_or_numeric");[e,r]=xt(e,r),rt(e.shape,r.shape);let o={a:e,b:r};return R.runKernel(Rp,o)}var En=A({greater_:xoe});function voe(t,n){let e=T(t,"a","greaterEqual","string_or_numeric"),r=T(n,"b","greaterEqual","string_or_numeric");[e,r]=xt(e,r),rt(e.shape,r.shape);let o={a:e,b:r};return R.runKernel(ol,o)}var fo=A({greaterEqual_:voe});function boe(t){let e={input:T(t,"input","imag")};return R.runKernel(vh,e)}var xu=A({imag_:boe});function woe(t){let e={x:T(t,"x","isFinite")};return R.runKernel(sl,e)}var rb=A({isFinite_:woe});function Coe(t){let e={x:T(t,"x","isInf")};return R.runKernel(il,e)}var ob=A({isInf_:Coe});function Ioe(t){let e={x:T(t,"x","isNaN")};return R.runKernel(al,e)}var sb=A({isNaN_:Ioe});function Soe(t,n=.2){let r={x:T(t,"x","leakyRelu")},o={alpha:n};return R.runKernel(Bc,r,o)}var vu=A({leakyRelu_:Soe});function Toe(t,n){let e=T(t,"a","less","string_or_numeric"),r=T(n,"b","less","string_or_numeric");[e,r]=xt(e,r),rt(e.shape,r.shape);let o={a:e,b:r};return R.runKernel(Mp,o)}var _l=A({less_:Toe});function Eoe(t,n){let e=T(t,"a","lessEqual","string_or_numeric"),r=T(n,"b","lessEqual","string_or_numeric");[e,r]=xt(e,r),rt(e.shape,r.shape);let o={a:e,b:r};return R.runKernel(Op,o)}var Qo=A({lessEqual_:Eoe});function V$(t,n,e){if(e<=0)throw new Error("The number of values should be positive.");let r={start:t,stop:n,num:e};return R.runKernel(bh,{},r)}function Noe(t,n=5,e=1,r=1,o=.5){let s=T(t,"x","localResponseNormalization");$(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),$(Ga(n),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${n}.`);let i=s,a=!1;s.rank===3&&(a=!0,i=U(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let l={x:i},c={depthRadius:n,bias:e,alpha:r,beta:o},u=R.runKernel("LRN",l,c);return a?U(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var ib=A({localResponseNormalization_:Noe});function Doe(t){let e={x:T(t,"x","log","float32")};return R.runKernel("Log",e)}var mr=A({log_:Doe});function koe(t){let e={x:T(t,"x","log1p")};return R.runKernel(ll,e)}var bu=A({log1p_:koe});function TN(t,n){$(Xd(t),()=>"The f passed in variableGrads(f) must be a function"),$(n==null||Array.isArray(n)&&n.every(c=>c instanceof El),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let e=n!=null;if(!e){n=[];for(let c in R.registeredVariables)n.push(R.registeredVariables[c])}let r=e?n.filter(c=>!c.trainable):null,o=n.length;n=n.filter(c=>c.trainable),$(n.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`);let s=!0,{value:i,grads:a}=R.gradients(t,n,null,s);$(a.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),$(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let l={};return n.forEach((c,u)=>{a[u]!=null&&(l[c.name]=a[u])}),r?.forEach(c=>l[c.name]=null),{value:i,grads:l}}function Oo(t){return R.customGrad(t)}function Aoe(t){let e={x:T(t,"x","neg")};return R.runKernel("Neg",e)}var ft=A({neg_:Aoe});function _oe(t){let e={x:T(t,"x","softplus")};return R.runKernel(wl,e)}var mi=A({softplus_:_oe});function Roe(t){let n=T(t,"x","logSigmoid");return Oo(r=>({value:ft(mi(ft(r))),gradFunc:i=>z(i,Tr(ft(r)))}))(n)}var ab=A({logSigmoid_:Roe});function Moe(t,n){let e=T(t,"a","sub"),r=T(n,"b","sub");[e,r]=xt(e,r);let o={a:e,b:r};return R.runKernel("Sub",o)}var Ie=A({sub_:Moe});function Ooe(t,n=-1){let e=T(t,"logits","logSoftmax");if(n===-1&&(n=e.rank-1),n!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${n}`);return Oo((o,s)=>{let a=hr(o,n,!0),l=Ie(o,a),c=Ie(fe(l,"float32"),mr(Ne(gn(l),n,!0)));return s([c]),{value:c,gradFunc:(p,f)=>{let[d]=f,h=!0,g=gn(d);return Ie(p,z(Ne(p,n,h),g))}}})(e)}var Em=A({logSoftmax_:Ooe});function Foe(t,n=null,e=!1){let r=T(t,"x","logSumExp"),o=Zn(n,r.shape),s=hr(r,o,!0),i=Ie(r,s),a=gn(i),l=Ne(a,o),c=mr(l),u=le(U(s,c.shape),c);if(e){let p=zs(u.shape,o);return U(u,p)}return u}var wu=A({logSumExp_:Foe});function $oe(t,n){let e=T(t,"a","logicalAnd","bool"),r=T(n,"b","logicalAnd","bool");rt(e.shape,r.shape);let o={a:e,b:r};return R.runKernel(Fp,o)}var Pr=A({logicalAnd_:$oe});function Loe(t){let e={x:T(t,"x","logicalNot","bool")};return R.runKernel($p,e)}var Cu=A({logicalNot_:Loe});function Poe(t,n){let e=T(t,"a","logicalOr","bool"),r=T(n,"b","logicalOr","bool");rt(e.shape,r.shape);let o={a:e,b:r};return R.runKernel(Lp,o)}var Nm=A({logicalOr_:Poe});function Boe(t,n){let e=T(t,"a","logicalXor","bool"),r=T(n,"b","logicalXor","bool");return rt(e.shape,r.shape),Pr(Nm(t,n),Cu(Pr(t,n)))}var lb=A({logicalXor_:Boe});var cb=2147483648;function zoe(t,n,e="left"){let r=T(t,"sortedSequence","searchSorted"),o=T(n,"values","searchSorted"),s=r.shape[r.shape.length-1],i=o.shape[o.shape.length-1],a=U(r,[-1,s]),l=U(o,[-1,i]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(mt(l.shape)>=cb)throw new Error(`values tensor size must less than ${cb}`);if(a.shape[1]>=cb)throw new Error(`trailing dim_size must less than ${cb} for int32 output type, was ${a.shape[1]}`);let c={sortedSequence:a,values:l},u={side:e};return R.runKernel(Ph,c,u)}var N1=A({searchSorted_:zoe});function U$(t,n){return N1(t,n,"left")}function Voe(t,n,e,r,o){let s=T(t,"x","maxPool"),i=1,a=s,l=!1;s.rank===3&&(l=!0,a=U(s,[1,s.shape[0],s.shape[1],s.shape[2]])),$(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),$(Sr(e,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${i}'`),on("maxPool",r,o);let c={x:a},u={filterSize:n,strides:e,pad:r,dimRoundingMode:o},p=R.runKernel(zc,c,u);return l?U(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var Iu=A({maxPool_:Voe});function Uoe(t,n=[1,1,1],e,r,o,s="NDHWC"){let i=T(t,"x","maxPool3d"),a=i,l=!1;i.rank===4&&(l=!0,a=U(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),$(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),$(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),on("maxPool3d",r,o);let c={x:a},u={filterSize:n,strides:e,pad:r,dimRoundingMode:o,dataFormat:s},p=R.runKernel(Vc,c,u);return l?U(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var ub=A({maxPool3d_:Uoe});function Goe(t,n,e,r,o=!1){let i={x:T(t,"x","maxPoolWithArgmax")},a={filterSize:n,strides:e,pad:r,includeBatchInIndex:o},l=R.runKernel(Sh,i,a);return{result:l[0],indexes:l[1]}}var G$=A({maxPoolWithArgmax_:Goe});function joe(t,n){let e=T(t,"a","maximum"),r=T(n,"b","maximum");[e,r]=xt(e,r),e.dtype==="bool"&&(e=fe(e,"int32"),r=fe(r,"int32")),rt(e.shape,r.shape);let o={a:e,b:r};return R.runKernel(cl,o)}var Fo=A({maximum_:joe});function Hoe(t,n=null,e=!1){let o={x:T(t,"x","mean")},s={axis:n,keepDims:e};return R.runKernel(Uc,o,s)}var ln=A({mean_:Hoe});function cn(t,n="float32"){if(Sn(t),n==="complex64"){let r=cn(t,"float32"),o=cn(t,"float32");return Ro(r,o)}let e=Zd(mt(t),n);return R.makeTensor(e,t,n)}function jn(t,n="float32"){if(Sn(t),n==="complex64"){let r=jn(t,"float32"),o=cn(t,"float32");return Ro(r,o)}let e=s1(mt(t),n);return R.makeTensor(e,t,n)}function j$(t,n,{indexing:e="xy"}={}){if(e!=="xy"&&e!=="ij")throw new TypeError(`${e} is not a valid third argument to meshgrid`);if(t===void 0)return[];let r=T(t,"x","meshgrid",t instanceof ot?t.dtype:"float32");if(n===void 0)return[r];let o=T(n,"y","meshgrid",n instanceof ot?n.dtype:"float32"),s=mt(r.shape),i=mt(o.shape);return e==="xy"?(r=U(r,[1,-1]),o=U(o,[-1,1]),[ct(jn([i,1],r.dtype),r),ct(o,jn([1,s],o.dtype))]):(r=U(r,[-1,1]),o=U(o,[1,-1]),[ct(r,jn([1,i],r.dtype)),ct(jn([s,1],o.dtype),o)])}function Woe(t,n){let e=T(t,"a","minimum"),r=T(n,"b","minimum");[e,r]=xt(e,r),e.dtype==="bool"&&(e=fe(e,"int32"),r=fe(r,"int32")),rt(e.shape,r.shape);let o={a:e,b:r};return R.runKernel(ul,o)}var Is=A({minimum_:Woe});function qoe(t,n,e){$(e==="reflect"||e==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);let r=T(t,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");$(n.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${n.length}.`);let o=e==="reflect"?1:0;for(let a=0;a<r.rank;a++)$(n[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),$(n[a][0]>=0&&n[a][0]<=r.shape[a]-o&&n[a][1]>=0&&n[a][1]<=r.shape[a]-o,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-o} or less than 0 for input of shape ${r.shape}`);let s={paddings:n,mode:e},i={x:r};return R.runKernel(Gc,i,s)}var pb=A({mirrorPad_:qoe});function Koe(t,n){let e=T(t,"a","mod"),r=T(n,"b","mod");[e,r]=xt(e,r);let o={a:e,b:r};return R.runKernel("Mod",o)}var fb=A({mod_:Koe});function Xoe(t,n=null,e=!1){t=T(t,"x","moments");let r=Zn(n,t.shape),o=ln(t,r,e),s=o.shape;e||(s=zs(o.shape,r));let i=lt(Ie(fe(t,"float32"),U(o,s))),a=ln(i,r,e);return{mean:o,variance:a}}var sf=A({moments_:Xoe});function Yoe(t,n,e,r){let o=T(n,"data","multiRNNCell"),s=Xp(e,"c","multiRNNCell"),i=Xp(r,"h","multiRNNCell"),a=o,l=[];for(let p=0;p<t.length;p++){let f=t[p](a,s[p],i[p]);l.push(f[0]),l.push(f[1]),a=f[1]}let c=[],u=[];for(let p=0;p<l.length;p+=2)c.push(l[p]),u.push(l[p+1]);return[c,u]}var H$=A({multiRNNCell_:Yoe});function Zoe(t,n,e,r=!1){let o=T(t,"logits","multinomial"),s=o.size,i=o.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);e=e||Math.random();let l={logits:i===1?U(o,[1,-1]):o},c={numSamples:n,seed:e,normalized:r},u=R.runKernel(Th,l,c);return i===1?U(u,[u.size]):u}var W$=A({multinomial_:Zoe});function Qoe(t,n){let e=T(t,"a","notEqual","string_or_numeric"),r=T(n,"b","notEqual","string_or_numeric");[e,r]=xt(e,r),rt(e.shape,r.shape);let o={a:e,b:r};return R.runKernel(Pp,o)}var gi=A({notEqual_:Qoe});function Joe(t,n,e=1,r=0,o="int32"){if(n<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${n}`);let i={indices:T(t,"indices","oneHot","int32")},a={dtype:o,depth:n,onValue:e,offValue:r};return R.runKernel(Hc,i,a)}var af=A({oneHot_:Joe});function ese(t){let e={x:T(t,"x","onesLike")};return R.runKernel(jc,e)}var cr=A({onesLike_:ese});function tse(t,n){let e=T(t,"v1","outerProduct"),r=T(n,"v2","outerProduct");$(e.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${e.rank} and ${r.rank}.`);let o=U(e,[-1,1]),s=U(r,[1,-1]);return ct(o,s)}var q$=A({outerProduct_:tse});function nse(t,n,e=0){let r=T(t,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let o={paddings:n,constantValue:e},s={x:r};return R.runKernel(qc,s,o)}var ho=A({pad_:nse});function rse(t,n,e=0){return $(n.length===2,()=>"Invalid number of paddings. Must be length of 2."),ho(t,[n],e)}var K$=A({pad1d_:rse});function ose(t,n,e=0){return $(n.length===2&&n[0].length===2&&n[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ho(t,n,e)}var X$=A({pad2d_:ose});function sse(t,n,e=0){return $(n.length===3&&n[0].length===2&&n[1].length===2&&n[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ho(t,n,e)}var Y$=A({pad3d_:sse});function ise(t,n,e=0){return $(n.length===4&&n[0].length===2&&n[1].length===2&&n[2].length===2&&n[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ho(t,n,e)}var Z$=A({pad4d_:ise});function ase(t,n,e){let r=T(t,"x","spaceToBatchND");$(r.rank>=1+n.length,()=>`input rank ${r.rank} should be > than [blockShape] ${n.length}`),$(e.length===n.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${n.length}`),$(r.shape.reduce((i,a,l)=>l>0&&l<=n.length?i&&(a+e[l-1][0]+e[l-1][1])%n[l-1]===0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${n.toString()}`);let o={x:r},s={blockShape:n,paddings:e};return R.runKernel(nu,o,s)}var Su=A({spaceToBatchND_:ase});function lse(t,n,e,r,o,s,i){o==null&&(o=[1,1]),s==null&&(s=1),r===0&&(r="valid");let a=T(t,"x","maxPool"),l=a,c=!1;a.rank===3&&(c=!0,l=U(a,[1,a.shape[0],a.shape[1],a.shape[2]])),$(Sr(s,o),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${o}'`);let u=vN(l.shape,n,s,o,r),p=[u.dilationHeight,u.dilationWidth],f;r==="same"?f=use([u.filterHeight,u.filterWidth],p):f=[[0,0],[0,0]];let d=p[0]===1&&p[1]===1,[h,g]=cse([u.inHeight,u.inWidth],p,f),m=d?r:"valid",y=d?l:Su(l,p,h),C=(e==="avg"?()=>hu(y,n,s,m,i):()=>Iu(y,n,s,m,i))(),I=d?C:mu(C,p,g);return c?U(I,[I.shape[1],I.shape[2],I.shape[3]]):I}function cse(t,n,e){let r=e.map(u=>u[0]),o=e.map(u=>u[1]),s=t.concat(r,o),i=n.map((u,p)=>(u-s[p]%u)%u),a=o.map((u,p)=>u+i[p]),l=n.map((u,p)=>[r[p],a[p]]),c=n.map((u,p)=>[0,i[p]]);return[l,c]}function use(t,n){let r=t.map((i,a)=>i+(i-1)*(n[a]-1)).map(i=>i-1),o=r.map(i=>Math.floor(i/2)),s=r.map((i,a)=>i-o[a]);return r.map((i,a)=>[o[a],s[a]])}var db=A({pool_:lse});function pse(t,n){let e=T(t,"x","prelu"),r=T(n,"alpha","prelu"),o={x:e,alpha:r};return R.runKernel(Kc,o)}var Tu=A({prelu_:pse});function fse(t,n=null,e=!1){let r=T(t,"x","prod");r.dtype==="bool"&&(r=fe(r,"int32"));let o={x:r},s={axis:n,keepDims:e};return R.runKernel(Xc,o,s)}var hb=A({prod_:fse});function dse(t,n,e,r){let o=t.map((u,p)=>T(u,`tensors${p}`,"raggedGather","int32")),s=T(n,"paramsDenseValues","raggedGather"),i=T(e,"indices","raggedGather","int32"),a={paramsNestedSplits:o,paramsDenseValues:s,indices:i},l={outputRaggedRank:r},c=R.runKernel(kh,a,l);return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}var Q$=A({raggedGather_:dse});function hse(t,n,e){let r=T(t,"starts","raggedRange"),o=T(n,"limits","raggedRange",r.dtype),s=T(e,"deltas","raggedRange",r.dtype),i={starts:r,limits:o,deltas:s},a=R.runKernel(Ah,i);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}var J$=A({raggedRange_:hse});function mse(t,n,e,r,o){let s=T(t,"shape","raggedTensorToTensor","int32"),i=T(n,"values","raggedTensorToTensor"),a=T(e,"defaultValue","raggedTensorToTensor",i.dtype),l=r.map((p,f)=>T(p,`tensors${f}`,"raggedTensorToTensor","int32")),c={shape:s,values:i,defaultValue:a,rowPartitionTensors:l},u={rowPartitionTypes:o};return R.runKernel(_h,c,u)}var eL=A({raggedTensorToTensor_:mse});function gse(t,n,e){Sn(t);let r=mt(t),o=null;if(e==null||e==="float32")o=new Float32Array(r);else if(e==="int32")o=new Int32Array(r);else if(e==="bool")o=new Uint8Array(r);else throw new Error(`Unknown data type ${e}`);for(let s=0;s<r;s++)o[s]=n();return R.makeTensor(o,t,e)}var tL=A({rand_:gse});var xb=wa(D1());var cf=class{constructor(n,e,r,o,s){this.mean=n,this.stdDev=e,this.dtype=r,this.nextVal=NaN,this.truncated=o,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let i=s||Math.random();this.random=xb.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){let o=this.nextVal;return this.nextVal=NaN,o}let n,e,r=!1;for(;!r;){let o,s,i;do o=2*this.random()-1,s=2*this.random()-1,i=o*o+s*s;while(i>=1||i===0);let a=Math.sqrt(-2*Math.log(i)/i);n=this.mean+this.stdDev*o*a,e=this.mean+this.stdDev*s*a,(!this.truncated||this.isValidTruncated(n))&&(r=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(n)}convertValue(n){return this.dtype==null||this.dtype==="float32"?n:Math.round(n)}isValidTruncated(n){return n<=this.upper&&n>=this.lower}},gb=class{constructor(n,e,r,o){this.alpha=n,this.beta=1/e,this.dtype=r;let s=o||Math.random();this.randu=xb.alea(s.toString()),this.randn=new cf(0,1,r,!1,this.randu()),n<1?this.d=n+2/3:this.d=n-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let n,e,r,o,s,i;for(;;){do o=this.randn.nextValue(),i=1+this.c*o;while(i<=0);if(i*=i*i,n=o*o,e=1-.331*n*n,r=.5*n+this.d*(1-i+Math.log(i)),s=this.randu(),s<e||Math.log(s)<r)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(n){return this.dtype==="float32"?n:Math.round(n)}},yb=class{constructor(n=0,e=1,r,o){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=n,this.range=e-n,this.dtype=r,o==null&&(o=Math.random()),typeof o=="number"&&(o=o.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${n} - ${e} <= 1 and dtype is not float`);this.random=xb.alea(o)}convertValue(n){return this.canReturnFloat()?n:Math.round(n)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function Ise(t,n,e=1,r="float32",o){if(Sn(t),e==null&&(e=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);let s=new gb(n,e,r,o),i=Be(t,r);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var xL=A({randomGamma_:Ise});function Sse(t,n=0,e=1,r,o){if(Sn(t),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);let s=new cf(n,e,r,!1,o),i=Be(t,r);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var uf=A({randomNormal_:Sse});function Tse(t,n,e){if(n!=null&&n==="bool")throw new Error(`Unsupported data type ${n}`);return uf(t,0,1,n,e)}var vL=A({randomStandardNormal_:Tse});function Ese(t,n=0,e=1,r="float32",o){Sn(t);let s=Be(t,r),i=new yb(n,e,null,o);for(let a=0;a<s.values.length;a++)s.values[a]=i.nextValue();return s.toTensor()}var Jo=A({randomUniform_:Ese});function Nse(t,n,e,r){return Jo(t,n,e,"int32",r)}var bL=A({randomUniformInt_:Nse});function aa(t,n,e=1,r="float32"){if(e===0)throw new Error("Cannot have a step of zero");let o={start:t,stop:n,step:e,dtype:r};return R.runKernel(Rh,{},o)}function Dse(t){let e={input:T(t,"input","real")};return R.runKernel(Mh,e)}var Rl=A({real_:Dse});function kse(t){let e={x:T(t,"x","reciprocal")};return R.runKernel(fl,e)}var vb=A({reciprocal_:kse});function Ase(t){let e={x:T(t,"x","relu")};return R.runKernel(dl,e)}var Nr=A({relu_:Ase});function _se(t){let e={x:T(t,"x","relu6")};return R.runKernel(hl,e)}var km=A({relu6_:_se});function Rse(t,n){let r={x:T(t,"x","reverse")},o={dims:n};return R.runKernel(Jc,r,o)}var Jn=A({reverse_:Rse});function Mse(t){let n=T(t,"x","reverse");return $(n.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${n.rank}.`),Jn(n,0)}var wL=A({reverse1d_:Mse});function Ose(t,n){let e=T(t,"x","reverse");return $(e.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${e.rank}.`),Jn(e,n)}var CL=A({reverse2d_:Ose});function Fse(t,n){let e=T(t,"x","reverse");return $(e.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${e.rank}.`),Jn(e,n)}var IL=A({reverse3d_:Fse});function $se(t,n){let e=T(t,"x","reverse");return $(e.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${e.rank}.`),Jn(e,n)}var SL=A({reverse4d_:$se});function Lse(t){let e={x:T(t,"x","round")};return R.runKernel(ml,e)}var Am=A({round_:Lse});function Pse(t){let e={x:T(t,"x","rsqrt","float32")};return R.runKernel(gl,e)}var _m=A({rsqrt_:Pse});function Bse(t){let e={x:T(t,"x","selu")};return R.runKernel(yl,e)}var Rm=A({selu_:Bse});function zse(t,n,e,r,o,s=[1,1],i="NHWC"){let a=T(t,"x","separableConv2d"),l=T(n,"depthwiseFilter","separableConv2d"),c=T(e,"pointwiseFilter","separableConv2d"),u=a,p=!1;if(a.rank===3&&(p=!0,u=U(a,[1,a.shape[0],a.shape[1],a.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");$(u.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`),$(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),$(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),$(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),$(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);let f=l.shape[2],d=l.shape[3];$(c.shape[2]===f*d,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${f*d}, but got ${c.shape[2]}.`);let h=ra(u,l,r,o,i,s),m=Mo(h,c,1,"valid",i);return p?U(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var Mm=A({separableConv2d_:zse});function Vse(t,n){return te(this,null,function*(){let e=T(t,"x","setdiff1d"),r=T(n,"y","setdiff1d");$(e.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${e.dtype}) and y (${r.dtype}).`),$(e.rank===1,()=>`x should be 1D tensor, but got x (${e.shape}).`),$(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);let o=yield e.data(),s=yield r.data(),i=new Set(s),a=0;for(let u=0;u<o.length;u++)i.has(o[u])||a++;let l=new $t([a],e.dtype),c=new $t([a],"int32");for(let u=0,p=0;u<o.length;u++)i.has(o[u])||(l.values[p]=o[u],c.values[p]=u,p++);return[l.toTensor(),c.toTensor()]})}var TL=Vse;function Use(t){let e={x:T(t,"x","sign")};return R.runKernel(vl,e)}var bb=A({sign_:Use});function Gse(t){let e={x:T(t,"x","sin","float32")};return R.runKernel("Sin",e)}var Fm=A({sin_:Gse});function jse(t){let e={x:T(t,"x","sinh")};return R.runKernel(xl,e)}var $m=A({sinh_:jse});function Hse(t,n,e){let r=T(t,"x","slice1d");return $(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Ue(r,[n],[e])}var Lm=A({slice1d_:Hse});function Wse(t,n,e){let r=T(t,"x","slice2d");return $(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Ue(r,n,e)}var k1=A({slice2d_:Wse});function qse(t,n,e){let r=T(t,"x","slice3d");return $(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Ue(r,n,e)}var Pm=A({slice3d_:qse});function Kse(t,n,e){let r=T(t,"x","slice4d");return $(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Ue(r,n,e)}var pf=A({slice4d_:Kse});function Xse(t,n=-1){let e=T(t,"logits","softmax","float32");if(n===-1&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${n}`);let r={logits:e},o={dim:n};return R.runKernel(ou,r,o)}var Eu=A({softmax_:Xse});function Yse(t){$(t.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`);let n={input:t};return R.runKernel("FFT",n)}var Nu=A({fft_:Yse});function Zse(t){$(t.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`);let n={input:t};return R.runKernel(xh,n)}var Ml=A({ifft_:Zse});function Qse(t){let n=t.shape[t.shape.length-1],e=t.size/n,r;if(n<=2){let o=U(t,[e,n]);r=Ml(o)}else{let o=[e,2*(n-1)],s=U(Rl(t),[e,n]),i=U(xu(t),[e,n]),a=Jn(Ue(s,[0,1],[e,n-2]),1),l=z(Jn(Ue(i,[0,1],[e,n-2]),1),Ee(-1)),c=Et([s,a],1),u=Et([i,l],1),p=U(Ro(c,u),[o[0],o[1]]);r=Ml(p)}if(r=Rl(r),t.rank===3&&t.shape[0]!==0){let o=r,s=t.shape[0];r=U(r,[s,r.shape[0]/s,r.shape[1]]),o.dispose()}return r}var Bm=A({irfft_:Qse});function Jse(t,n,e=0){let o={x:T(t,"x","split")},s={numOrSizeSplits:n,axis:e};return R.runKernel(ru,o,s)}var er=A({split_:Jse});function eie(t,n){$(t.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let e=t.shape[t.shape.length-1],r=t.size/e,o;if(n!=null&&n<e){let h=t.shape.map(m=>0),g=t.shape.map(m=>m);g[t.shape.length-1]=n,o=Ue(t,h,g),e=n}else if(n!=null&&n>e){let h=t.shape.map(g=>g);h[t.shape.length-1]=n-e,o=Et([t,cn(h)],t.shape.length-1),e=n}else o=t;let s=Ge(o),i=U(Ro(o,s),[r,e]),a=Nu(i),l=Math.floor(e/2)+1,c=Rl(a),u=xu(a),p=er(c,[l,e-l],c.shape.length-1),f=er(u,[l,e-l],u.shape.length-1),d=o.shape.slice();return d[o.shape.length-1]=l,U(Ro(p[0],f[0]),d)}var Du=A({rfft_:eie});function tie(t,n){let e=T(t,"a","squaredDifference"),r=T(n,"b","squaredDifference");[e,r]=xt(e,r),rt(e.shape,r.shape);let o={a:e,b:r},s={};return R.runKernel(Il,o,s)}var zm=A({squaredDifference_:tie});function nie(t,n){let e=T(t,"x","squeeze","string_or_numeric");return U(e,zE(e.shape,n).newShape)}var Zt=A({squeeze_:nie});function rie(t,n=0){let e=Xp(t,"tensors","stack","string_or_numeric");$(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&$(n<=e[0].rank,()=>"Axis must be <= rank of the tensor");let r=e,o={axis:n};return R.runKernel(Wc,r,o)}var Nn=A({stack_:rie});function oie(t,n=0){let r={x:T(t,"x","step")},o={alpha:n};return R.runKernel(Tl,r,o)}var Vs=A({step_:oie});function sie(t,n,e,r,o=0,s=0,i=0,a=0,l=0){let u={x:T(t,"x","stridedSlice","string_or_numeric")},p={begin:n,end:e,strides:r,beginMask:o,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l};return R.runKernel(Hh,u,p)}var Cb=A({stridedSlice_:sie});function iie(t){let e={x:T(t,"x","tan","float32")};return R.runKernel("Tan",e)}var Ib=A({tan_:iie});function qt(t,n){bs(t);let e=_o(t,n);if(e.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return uo(t,null,e,n)}function es(t,n,e){if(bs(t),n!=null&&n.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let r=_o(t,e);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&n==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return uo(t,n,r,e)}function Sb(t,n,e){if(bs(t),n!=null&&n.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let r=_o(t,e);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&n==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return uo(t,n,r,e)}function EL(t,n,e){if(bs(t),n!=null&&n.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let r=_o(t,e);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&n==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return uo(t,n,r,e)}function NL(t,n,e){if(bs(t),n!=null&&n.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let r=_o(t,e);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&n==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return uo(t,n,r,e)}function DL(t,n,e){if(bs(t),n!=null&&n.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let r=_o(t,e);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&n==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return n=n||r,uo(t,n,r,e)}function kL(t,n,e){let r=n.rank>1?n.shape[n.rank-1]:1,o=n.rank>1?n.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${n.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${o}.`;if(e.rank<o)throw new Error(s+` update.rank < ${o}. `);if(t.length<r+(e.rank-o))throw new Error(s+` Output shape length < ${r+(e.rank-o)}`);if(e.rank!==o+t.length-r)throw new Error(s+` update.rank != ${o+t.length-r}`);for(let i=0;i<o;++i)if(e.shape[i]!==n.shape[i])throw new Error(s+` updates.shape[${i}] (${e.shape[i]}) != indices.shape[${i}] (${n.shape[i]}).`);for(let i=0;i<e.rank-o;++i)if(e.shape[i+o]!==t[i+r])throw new Error(s+` updates.shape[${i+o}] (${e.shape[i+o]}) != shape[${i+o}] (${t[i+o]})`)}function A1(t,n,e){if(n.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${n.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if(n.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${n.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(e.length===0){if(n.size===0)throw new Error(`Indices specified for empty output. indices shape: ${n.shape}`);if(t.size===0)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}kL(e,n,t)}function aie(t,n,e){let r=n.shape.length,o=r>1?n.shape[r-1]:1,s=e.length,i=1;for(let p=o;p<s;++p)i*=e[p];let a=o<1?1:o,l=mt(n.shape)/a,c=[...Wi(e.slice(0,o)),1],u=mt(e);return{sliceRank:o,numUpdates:l,sliceSize:i,strides:c,outputSize:u}}function lie(t,n,e){let r=T(t,"tensor","tensorScatterupdate"),o=T(n,"indices","tensorScatterupdate","int32"),s=T(e,"updates","tensorScatterupdate");if(A1(s,o,r.shape),r.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${s.dtype}.`);let i={tensor:r,indices:o,updates:s},a={};return R.runKernel(Lh,i,a)}var _L=A({tensorScatterUpdate_:lie});function cie(t,n=1,e=!0){let r=T(t,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let o=r.shape[r.shape.length-1];if(n<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${n}`);if(n>o)throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${n}`);let s={x:r},i={k:n,sorted:e},[a,l]=R.runKernel(Xh,s,i);return{values:a,indices:l}}var Tb=A({topk_:cie});function uie(t,n=0,e=1,r,o){if(Sn(t),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new cf(n,e,r,!0,o),i=Be(t,r);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var Um=A({truncatedNormal_:uie});function pie(t,n=0){let e=T(t,"x","unique","string_or_numeric");$(e.rank>0,()=>"The input tensor must be at least 1D");let r={x:e},o={axis:n},[s,i]=R.runKernel(Zh,r,o);return{values:s,indices:i}}var Eb=A({unique_:pie});function fie(t,n,e){let r=T(t,"x","unsortedSegmentSum"),o=T(n,"segmentIds","unsortedSegmentSum","int32");$(Ga(e),()=>"numSegments must be of dtype int");let s={x:r,segmentIds:o},i={numSegments:e};return R.runKernel(iu,s,i)}var Gm=A({unsortedSegmentSum_:fie});function die(t,n=0){let e=T(t,"x","unstack","string_or_numeric");$(n>=-e.shape.length&&n<e.shape.length,()=>`Axis = ${n} is not in [-${e.shape.length}, ${e.shape.length})`);let r={value:e},o={axis:n};return R.runKernel(su,r,o)}var tr=A({unstack_:die});function RL(t,n){return N1(t,n,"right")}function Nb(t,n=!0,e,r){return R.makeVariable(t,n,e,r)}function Db(t,n){let e=[];for(let s=0;s<n.length;s++)n[s]&&e.push(s);let r=Be(t,"int32"),o=Be([e.length,t.length],"int32");for(let s=0;s<e.length;s++){let i=r.indexToLoc(e[s]),a=s*t.length;o.values.set(i,a)}return o.toTensor()}function hie(t){return te(this,null,function*(){let n=T(t,"condition","whereAsync","bool"),e=yield n.data(),r=Db(n.shape,e);return t!==n&&n.dispose(),r})}var kb=hie;function mie(t,n,e){return te(this,null,function*(){let r=T(t,"tensor","boolMask"),o=T(n,"mask","boolMask","bool"),s=e??0,i=o.rank,a=r.shape;$(i>0,()=>"mask cannot be scalar"),Pn(a.slice(s,s+i),o.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let g=s;g<s+i;g++)l*=a[g];let c=a.slice(0,s).concat([l],a.slice(s+i)),u=U(r,c),p=U(o,[-1]),f=yield kb(p),d=Zt(f,[1]),h=ia(u,d,s);return t!==r&&r.dispose(),n!==o&&o.dispose(),d.dispose(),u.dispose(),p.dispose(),f.dispose(),h})}var gie=mie;function yie(t,n,e){let r=T(t,"x","transpose");if(n==null&&(n=r.shape.map((i,a)=>a).reverse()),$(r.rank===n.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${n}.`),n.forEach(i=>{$(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${n}`)}),r.rank<=1)return r.clone();let o={x:r},s={perm:n};return r.dtype==="complex64"?X(()=>{let i=Rl(r),a=xu(r);return i=R.runKernel(Yi,{x:i},s),a=R.runKernel(Yi,{x:a},s),e&&(a=ft(a)),Ro(i,a)}):R.runKernel(Yi,o,s)}var ut=A({transpose_:yie});function xie(t,n,e,r,o=!0){let s=T(t,"v","movingAverage"),i=T(n,"x","movingAverage"),a=T(e,"decay","movingAverage");JF(s,i),$(Ko(s.shape,i.shape),()=>"Shape mismatch in v and x");let l=Ee(1),c=Ie(l,a),u=z(Ie(i,s),c);if(o){$(r!=null,()=>"When using zeroDebias: true, step is required.");let p=T(r,"step","movingAverage");u=ve(u,Ie(l,Lr(a,p)))}return le(s,u)}var vie=A({movingAverage_:xie});function bie(t,n,e){Sn(e);let r=T(t,"indices","scatterND","int32"),o=T(n,"updates","scatterND");A1(o,r,e);let s={indices:r,updates:o},i={shape:e};return R.runKernel($h,s,i)}var wie=A({scatterND_:bie});function ML(t,n,e,r){if(t.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);let o=t.rank>0?t.shape[0]:1,s=t.rank>1?t.shape[1]:1;if(e.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${e.length}, should be: ${s}.`);let i=n.size;if(!(n.rank===0||n.rank===1&&i===o))throw new Error(`sparseValues has incorrect shape ${n.shape}, should be [] or [${o}]`);if(n.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function Iie(t,n,e,r=0){Sn(e);let o=T(t,"sparseIndices","sparseToDense","int32"),s=T(n,"sparseValues","sparseToDense","string_or_numeric"),i=T(r,"defaultValue","sparseToDense",s.dtype);ML(o,s,e,i);let a={sparseIndices:o,sparseValues:s,defaultValue:i},l={outputShape:e};return R.runKernel(Gh,a,l)}var Sie=A({sparseToDense_:Iie});function Tie(t,n){let e=T(n,"indices","gatherND","int32"),o={params:T(t,"x","gatherND","string_or_numeric"),indices:e};return R.runKernel(yh,o)}var Eie=A({gatherND_:Tie});function OL(t,n){if(n==null)return t.shape.slice();if(Ko(t.shape,n))return n;if(t.shape.length===n.length){let e=[];for(let r=0;r<t.shape.length;r++)n[r]==null&&t.shape[r]!=null?e.push(t.shape[r]):e.push(n[r]);return e}return n}function Nie(t,n,e,r){let o=T(t,"x","dropout");if($(o.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${o.dtype} tensor instead.`),$(n>=0&&n<1,()=>`rate must be a float in the range [0, 1), but got ${n}.`),n===0)return t instanceof ot?o.clone():o;let s=OL(o,e),i=1-n,a=ve(sa(le(Jo(s,0,1,"float32",r),i)),i);return z(o,a)}var RN=A({dropout_:Nie});function MN(t){return Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2))))}function _1(t,n,e){let r=1-t%2,o=new Float32Array(t);for(let s=0;s<t;++s){let i=2*Math.PI*s/(t+r-1);o[s]=n-e*Math.cos(i)}return qt(o,"float32")}function Die(t,n,e=1){return te(this,null,function*(){let r=T(t,"predictions","inTopK"),o=T(n,"targets","inTopK");$(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),$(r.rank-1===o.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${o.rank}`),Pn(r.shape.slice(0,r.shape.length-1),o.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=r.shape[r.shape.length-1];$(e>0&&e<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${e}`);let i=yield r.data(),a=yield o.data(),[l,c]=[i.length/s,s],u=VE("bool",l);for(let p=0;p<l;p++){let f=p*c,d=i.subarray(f,f+c),h=[];for(let g=0;g<d.length;g++)h.push({value:d[g],index:g});h.sort((g,m)=>m.value-g.value),u[p]=0;for(let g=0;g<e;g++)if(h[g].index===a[p]){u[p]=1;break}}return t!==r&&r.dispose(),n!==o&&o.dispose(),fr(u,o.shape,"bool")})}var kie=Die;var ku={};Xt(ku,{conv2d:()=>FL,depthwiseConv2d:()=>$L,matMul:()=>LL});function Aie(t,n,e,r,o,s="NHWC",i){let a=t;t.rank===3&&(a=U(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=n;l.rank===3&&(l=U(n,[1,n.shape[0],n.shape[1],n.shape[2]])),$(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),$(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),$(e.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);let c=s==="NHWC"?a.shape[3]:a.shape[1],u=s==="NHWC"?l.shape[3]:l.shape[1];$(c===e[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${e[2]}.`),$(u===e[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${e[3]}).`),on("conv2dDerFilter",o,i);let p={x:a,dy:l},f={strides:r,pad:o,dataFormat:s,dimRoundingMode:i,filterShape:e};return R.runKernel(rh,p,f)}var jm=A({conv2DBackpropFilter_:Aie});function ff(t,n,e){if(e==null||e==="linear")return t;if(e==="relu")return z(t,Vs(n));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function df(t,n){let e=n,r=Yt(t.shape,n.shape);return r.length>0&&(e=Ne(e,r)),U(e,t.shape)}function hf(t,n,e,r){if(n==="linear")return t;if(n==="relu")return Nr(t);if(n==="elu")return oa(t);if(n==="relu6")return km(t);if(n==="prelu")return Tu(t,e);if(n==="leakyrelu")return vu(t,r);if(n==="sigmoid")return Tr(t);throw new Error(`Unknown fused activation ${n}.`)}var mf=(t,n)=>!(t>0)||n==="linear";function _ie({x:t,filter:n,strides:e,pad:r,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(l=l||"linear",mf(R.state.gradientDepth,l)===!1){$(o==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${o} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let O=Mo(t,n,e,r,o,s,i);return a!=null&&(O=le(O,a)),hf(O,l,c,u)}let p=T(t,"x","conv2d","float32"),f=T(n,"filter","conv2d","float32"),d=p,h=!1;p.rank===3&&(h=!0,d=U(p,[1,p.shape[0],p.shape[1],p.shape[2]])),$(d.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${d.rank}.`),$(f.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${f.rank}.`),on("fused conv2d",r,i);let g=o==="NHWC"?d.shape[3]:d.shape[1];$(f.shape[2]===g,()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${f.shape[2]}.`),$(Sr(e,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`);let m=tf(d.shape,f.shape,e,s,r,i),y;a!=null&&(y=T(a,"bias","fused conv2d"),[y]=xt(y,p),o==="NHWC"?rt(m.outShape,y.shape):($(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),$(y.shape.length===0||y.shape[0]===m.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${m.outChannels})`)));let x;if(c!=null){let O=c.shape;if($(O.length<=1||O.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${O.length}.`),O.length===1)$(O[0]===1||O[0]===m.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${O}) is not compatible with the number of output channels (${m.outChannels}).`);else if(O.length===3)try{rt(O,m.outShape)}catch(L){let B=`Error in fused conv2d: PReLU activation weights (${O}) is not compatible with the output shape of the conv2d (${m.outShape}).`;throw Error(B)}x=T(c,"prelu weights","fused conv2d")}let C=(O,L)=>{$(o==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${o} but only NHWC is currently supported.`);let[B,V,F,G]=L,ee=ff(O,F,l);$(ws(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let Q=mm(V.shape,ee,B,e,r),oe=jm(V,ee,B.shape,e,r),ae=[Q,oe];if(G!=null){let J=df(G,ee);ae.push(J)}return ae},I={x:d,filter:f,bias:y,preluActivationWeights:x},D={strides:e,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:u};return a==null?Oo((L,B,V)=>{let F=R.runKernel(Vp,I,D);return V([B,L,F]),h&&(F=U(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:C}})(d,f):Oo((L,B,V,F)=>{let G=R.runKernel(Vp,I,D);return F([B,L,G,V]),h&&(G=U(G,[G.shape[1],G.shape[2],G.shape[3]])),{value:G,gradFunc:C}})(d,f,y)}var FL=A({fusedConv2d_:_ie});function Rie(t,n,e,r,o,s=[1,1],i){let a=t;t.rank===3&&(a=U(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=n;l.rank===3&&(l=U(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let c={x:a,dy:l},u={strides:r,pad:o,dimRoundingMode:i,dilations:s,filterShape:e};return R.runKernel(uh,c,u)}var Ab=A({depthwiseConv2dNativeBackpropFilter_:Rie});function Mie(t,n,e,r,o,s=[1,1],i){let a=n,l=!1;n.rank===3&&(l=!0,a=U(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let c={dy:a,filter:e},u={strides:r,pad:o,dimRoundingMode:i,dilations:s,inputShape:t},p=R.runKernel(ph,c,u);return l?U(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var _b=A({depthwiseConv2dNativeBackpropInput_:Mie});function Oie({x:t,filter:n,strides:e,pad:r,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(mf(R.state.gradientDepth,l)===!1){let D=ra(t,n,e,r,o,s,i);return a!=null&&(D=le(D,a)),hf(D,l,c,u)}let p=T(t,"x","depthwiseConv2d","float32"),f=T(n,"filter","depthwiseConv2d","float32"),d=p,h=!1;p.rank===3&&(h=!0,d=U(p,[1,p.shape[0],p.shape[1],p.shape[2]])),$(d.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`),$(f.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${f.rank}.`),$(d.shape[3]===f.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${d.shape[3]}) must match the inChannels dimension in filter ${f.shape[2]}.`),s==null&&(s=[1,1]),$(Sr(e,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),on("fused depthwiseConv2d",r,i);let g=tf(d.shape,f.shape,e,s,r,i,!0),m;a!=null&&(m=T(a,"bias","fused conv2d"),[m]=xt(m,p),rt(g.outShape,m.shape));let y;c!=null&&(y=T(c,"prelu weights","fused depthwiseConv2d"));let x=(D,O)=>{$(ws(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[L,B,V,F]=O,G=ff(D,V,l),ee=_b(B.shape,G,L,e,r,s,i),Q=Ab(B,G,L.shape,e,r,s,i);if(F!=null){let oe=df(m,G);return[ee,Q,oe]}return[ee,Q]},C={x:d,filter:f,bias:m,preluActivationWeights:y},I={strides:e,pad:r,dataFormat:o,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:u};return a==null?Oo((O,L,B)=>{let V=R.runKernel(Up,C,I);return B([L,O,V]),h&&(V=U(V,[V.shape[1],V.shape[2],V.shape[3]])),{value:V,gradFunc:x}})(d,f):Oo((O,L,B,V)=>{let F=R.runKernel(Up,C,I);return V([L,O,F,B]),h&&(F=U(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:x}})(d,f,m)}var $L=A({fusedDepthwiseConv2d_:Oie});function Fie({a:t,b:n,transposeA:e=!1,transposeB:r=!1,bias:o,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:a=.2}){if(mf(R.state.gradientDepth,s)===!1){let G=ct(t,n,e,r);return o!=null&&(G=le(G,o)),hf(G,s,i,a)}let l=T(t,"a","fused matMul"),c=T(n,"b","fused matMul");[l,c]=xt(l,c);let u=e?l.shape[l.rank-2]:l.shape[l.rank-1],p=r?c.shape[c.rank-1]:c.shape[c.rank-2],f=e?l.shape[l.rank-1]:l.shape[l.rank-2],d=r?c.shape[c.rank-2]:c.shape[c.rank-1],h=l.shape.slice(0,-2),g=c.shape.slice(0,-2),m=mt(h),y=mt(g);$(u===p,()=>`Error in fused matMul: inner shapes (${u}) and (${p}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${e} and transposeB=${r} must match.`);let C=rt(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([f,d]),I=e?U(l,[m,u,f]):U(l,[m,f,u]),D=r?U(c,[y,d,p]):U(c,[y,p,d]),O;o!=null&&(O=T(o,"bias","fused matMul"),[O]=xt(O,l),rt(C,O.shape));let L;i!=null&&(L=T(i,"prelu weights","fused matMul"));let B=(G,ee)=>{let[Q,oe,ae,J]=ee,re=ff(U(G,ae.shape),ae,s),se,pe;if(!e&&!r?(se=ct(re,oe,!1,!0),pe=ct(Q,re,!0,!1)):!e&&r?(se=ct(re,oe,!1,!1),pe=ct(re,Q,!0,!1)):e&&!r?(se=ct(oe,re,!1,!0),pe=ct(Q,re,!1,!1)):(se=ct(oe,re,!0,!0),pe=ct(re,Q,!0,!0)),o!=null){let xe=df(J,re);return[se,pe,xe]}else return[se,pe]},V={a:I,b:D,bias:O,preluActivationWeights:L},F={transposeA:e,transposeB:r,activation:s,leakyreluAlpha:a};return o==null?Oo((ee,Q,oe)=>{let ae=R.runKernel(zp,V,F);return oe([ee,Q,ae]),{value:U(ae,C),gradFunc:B}})(I,D):Oo((ee,Q,oe,ae)=>{let J=R.runKernel(zp,V,F);return ae([ee,Q,J,oe]),{value:U(J,C),gradFunc:B}})(I,D,O)}var LL=A({fusedMatMul_:Fie});function $ie(t){return _1(t,.54,.46)}var PL=A({hammingWindow_:$ie});function Lie(t){return _1(t,.5,.5)}var Rb=A({hannWindow_:Lie});function Pie(t,n,e,r=!1,o=0){let s=0,i=[];for(;s+n<=t.size;)i.push(Ue(t,s,n)),s+=e;if(r)for(;s<t.size;){let a=s+n-t.size,l=Et([Ue(t,s,n-a),Bs([a],o)]);i.push(l),s+=e}return i.length===0?es([],[0,n]):U(Et(i),[i.length,n])}var Mb=A({frame_:Pie});function Bie(t,n,e,r,o=Rb){r==null&&(r=MN(n));let s=Mb(t,n,e),i=z(s,o(n));return Du(i,r)}var BL=A({stft_:Bie});function zie(t,n,e,r,o="bilinear",s=0){let i=T(t,"image","cropAndResize"),a=T(n,"boxes","cropAndResize","float32"),l=T(e,"boxInd","cropAndResize","int32"),c=a.shape[0];$(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),$(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`),$(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`),$(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),$(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),$(o==="bilinear"||o==="nearest",()=>`method must be bilinear or nearest, but was ${o}`);let u={image:i,boxes:a,boxInd:l},p={method:o,extrapolationValue:s,cropSize:r};return R.runKernel(ah,u,p)}var zL=A({cropAndResize_:zie});function Vie(t){let n=T(t,"image","flipLeftRight","float32");$(n.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${n.rank}.`);let e={image:n};return R.runKernel(gh,e,{})}var VL=A({flipLeftRight_:Vie});function Uie(t){let n=T(t,"image","grayscaleToRGB"),e=n.rank-1,r=n.shape[e];$(n.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${n.rank}.`),$(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);let o=new Array(n.rank);return o.fill(1,0,e),o[e]=3,Er(n,o)}var UL=A({grayscaleToRGB_:Uie});function Gie(t){let n=T(t,"image","RGBToGrayscale"),e=n.rank-1,r=n.shape[e];$(n.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${n.rank}.`),$(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);let o=n.dtype,s=fe(n,"float32"),i=qt([.2989,.587,.114]),a;switch(n.rank){case 2:a=yu("ij,j->i",s,i);break;case 3:a=yu("ijk,k->ij",s,i);break;case 4:a=yu("ijkl,l->ijk",s,i);break;case 5:a=yu("ijklm,m->ijkl",s,i);break;case 6:a=yu("ijklmn,n->ijklm",s,i);break;default:throw new Error("Not a valid tensor rank.")}return a=an(a,-1),fe(a,o)}var GL=A({rgbToGrayscale_:Gie});function jie(t,n,e=0,r=.5){let o=T(t,"image","rotateWithOffset","float32");$(o.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${o.rank}.`);let s={image:o},i={radians:n,fillValue:e,center:r};return R.runKernel(Qh,s,i)}var jL=A({rotateWithOffset_:jie});function Us(t,n,e,r,o,s){r==null&&(r=.5),o==null&&(o=Number.NEGATIVE_INFINITY),s==null&&(s=0);let i=t.shape[0];return e=Math.min(e,i),$(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),$(t.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),$(t.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),$(n.rank===1,()=>"scores must be a 1D tensor"),$(n.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${n.shape[0]}`),$(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:e,iouThreshold:r,scoreThreshold:o,softNmsSigma:s}}function Hie(t,n,e,r=.5,o=Number.NEGATIVE_INFINITY){let s=T(t,"boxes","nonMaxSuppression","float32"),i=T(n,"scores","nonMaxSuppression","float32"),a=Us(s,i,e,r,o);e=a.maxOutputSize,r=a.iouThreshold,o=a.scoreThreshold;let l={maxOutputSize:e,iouThreshold:r,scoreThreshold:o};return R.runKernel(Eh,{boxes:s,scores:i},l)}var HL=A({nonMaxSuppression_:Hie});function WL(t,n,e){let r=Wie(t,n,e),o=r<0?-(r+1):r;t.splice(o,0,n)}function Wie(t,n,e){return Kie(t,n,e||qie)}function qie(t,n){return t>n?1:t<n?-1:0}function Kie(t,n,e){let r=0,o=t.length,s=0,i=!1;for(;r<o;){s=r+(o-r>>>1);let a=e(n,t[s]);a>0?r=s+1:(o=s,i=!a)}return i?r:-r-1}function Ob(t,n,e,r,o){return ON(t,n,e,r,o,0)}function Fb(t,n,e,r,o,s){return ON(t,n,e,r,o,0,!1,s,!0)}function $b(t,n,e,r,o,s){return ON(t,n,e,r,o,s,!0)}function ON(t,n,e,r,o,s,i=!1,a=!1,l=!1){let c=[];for(let m=0;m<n.length;m++)n[m]>o&&c.push({score:n[m],boxIndex:m,suppressBeginIndex:0});c.sort(qL);let u=s>0?-.5/s:0,p=[],f=[];for(;p.length<e&&c.length>0;){let m=c.pop(),{score:y,boxIndex:x,suppressBeginIndex:C}=m;if(y<o)break;let I=!1;for(let D=p.length-1;D>=C;--D){let O=Xie(t,x,p[D]);if(O>=r){I=!0;break}if(m.score=m.score*Yie(r,u,O),m.score<=o)break}m.suppressBeginIndex=p.length,I||(m.score===y?(p.push(x),f.push(m.score)):m.score>o&&WL(c,m,qL))}let d=p.length,h=e-d;a&&h>0&&(p.push(...new Array(h).fill(0)),f.push(...new Array(h).fill(0)));let g={selectedIndices:p};return i&&(g.selectedScores=f),l&&(g.validOutputs=d),g}function Xie(t,n,e){let r=t.subarray(n*4,n*4+4),o=t.subarray(e*4,e*4+4),s=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),c=Math.min(o[0],o[2]),u=Math.min(o[1],o[3]),p=Math.max(o[0],o[2]),f=Math.max(o[1],o[3]),d=(a-s)*(l-i),h=(p-c)*(f-u);if(d<=0||h<=0)return 0;let g=Math.max(s,c),m=Math.max(i,u),y=Math.min(a,p),x=Math.min(l,f),C=Math.max(y-g,0)*Math.max(x-m,0);return C/(d+h-C)}function Yie(t,n,e){let r=Math.exp(n*e*e);return e<=t?r:0}function qL(t,n){return t.score-n.score||t.score===n.score&&n.boxIndex-t.boxIndex}function Zie(s,i,a){return te(this,arguments,function*(t,n,e,r=.5,o=Number.NEGATIVE_INFINITY){let l=T(t,"boxes","nonMaxSuppressionAsync"),c=T(n,"scores","nonMaxSuppressionAsync"),u=Us(l,c,e,r,o);e=u.maxOutputSize,r=u.iouThreshold,o=u.scoreThreshold;let p=yield Promise.all([l.data(),c.data()]),f=p[0],d=p[1],{selectedIndices:h}=Ob(f,d,e,r,o);return l!==t&&l.dispose(),c!==n&&c.dispose(),qt(h,"int32")})}var KL=Zie;function Qie(t,n,e,r=.5,o=Number.NEGATIVE_INFINITY,s=0){let i=T(t,"boxes","nonMaxSuppression"),a=T(n,"scores","nonMaxSuppression"),l=Us(i,a,e,r,o,s);e=l.maxOutputSize,r=l.iouThreshold,o=l.scoreThreshold,s=l.softNmsSigma;let c={boxes:i,scores:a},u={maxOutputSize:e,iouThreshold:r,scoreThreshold:o,softNmsSigma:s},p=R.runKernel(Dh,c,u);return{selectedIndices:p[0],selectedScores:p[1]}}var XL=A({nonMaxSuppressionWithScore_:Qie});function Jie(i,a,l){return te(this,arguments,function*(t,n,e,r=.5,o=Number.NEGATIVE_INFINITY,s=0){let c=T(t,"boxes","nonMaxSuppressionAsync"),u=T(n,"scores","nonMaxSuppressionAsync"),p=Us(c,u,e,r,o,s);e=p.maxOutputSize,r=p.iouThreshold,o=p.scoreThreshold,s=p.softNmsSigma;let f=yield Promise.all([c.data(),u.data()]),d=f[0],h=f[1],{selectedIndices:g,selectedScores:m}=$b(d,h,e,r,o,s);return c!==t&&c.dispose(),u!==n&&u.dispose(),{selectedIndices:qt(g,"int32"),selectedScores:qt(m)}})}var YL=Jie;function eae(t,n,e,r=.5,o=Number.NEGATIVE_INFINITY,s=!1){let i=T(t,"boxes","nonMaxSuppression"),a=T(n,"scores","nonMaxSuppression"),l=Us(i,a,e,r,o,null),c=l.maxOutputSize,u=l.iouThreshold,p=l.scoreThreshold,f={boxes:i,scores:a},d={maxOutputSize:c,iouThreshold:u,scoreThreshold:p,padToMaxOutputSize:s},h=R.runKernel(Nh,f,d);return{selectedIndices:h[0],validOutputs:h[1]}}var ZL=A({nonMaxSuppressionPadded_:eae});function tae(i,a,l){return te(this,arguments,function*(t,n,e,r=.5,o=Number.NEGATIVE_INFINITY,s=!1){let c=T(t,"boxes","nonMaxSuppressionAsync"),u=T(n,"scores","nonMaxSuppressionAsync"),p=Us(c,u,e,r,o,null),f=p.maxOutputSize,d=p.iouThreshold,h=p.scoreThreshold,[g,m]=yield Promise.all([c.data(),u.data()]),{selectedIndices:y,validOutputs:x}=Fb(g,m,f,d,h,s);return c!==t&&c.dispose(),u!==n&&u.dispose(),{selectedIndices:qt(y,"int32"),validOutputs:Ee(x,"int32")}})}var QL=tae;function nae(t,n,e=!1,r=!1){let o=T(t,"images","resizeBilinear");$(o.rank===3||o.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`),$(n.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${n}.`),$(r===!1||e===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=o,i=!1;o.rank===3&&(i=!0,s=U(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=n,a={images:s},l={alignCorners:e,halfPixelCenters:r,size:n},c=R.runKernel(Qc,a,l);return i?U(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var Lb=A({resizeBilinear_:nae});function rae(t,n,e=!1,r=!1){let o=T(t,"images","resizeNearestNeighbor");$(o.rank===3||o.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`),$(n.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${n}.`),$(o.dtype==="float32"||o.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),$(r===!1||e===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=o,i=!1;o.rank===3&&(i=!0,s=U(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=n,a={images:s},l={alignCorners:e,halfPixelCenters:r,size:n},c=R.runKernel(Zc,a,l);return i?U(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var Pb=A({resizeNearestNeighbor_:rae});function oae(t,n="binary",e=!1,r=.5){let o=T(t,"image","threshold"),s=.2989,i=.587,a=.114,l=o.shape[0]*o.shape[1],c=z(qt([r]),255),u,p,f,d;if($(o.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${o.rank}.`),$(o.shape[2]===3||o.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${o.shape[2]}.`),$(o.dtype==="int32"||o.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${o.dtype}.`),$(n==="otsu"||n==="binary",()=>`Method must be binary or otsu, but was ${n}`),o.shape[2]===3){[u,p,f]=er(o,[1,1,1],-1);let m=z(u,s),y=z(p,i),x=z(f,a);d=le(le(m,y),x)}else d=t;if(n==="otsu"){let m=Uv(fe(Am(d),"int32"),fr([]),256);c=sae(m,l)}let h=e?Qo(d,c):En(d,c);return fe(z(h,255),"int32")}function sae(t,n){let e=qt([-1]),r=qt([0]),o=qt([0]),s,i,a,l,c,u;for(let p=0;p<t.size-1;p++){s=Ue(t,0,p+1),i=Ue(t,p+1),c=ve(Ne(s),n),u=ve(Ne(i),n);let f=Ne(z(s,aa(0,s.size)));a=ve(f,Ne(s));let d=Bs(i.shape,s.size),h=le(aa(0,i.size),d),g=z(i,h);l=ve(Ne(g),Ne(i));let m=Ie(a,l),y=Ie(a,l),x=z(c,u);o=z(z(x,m),y);let C=En(o,r);r=sn(C,o,r),e=sn(C,qt([p]),e)}return e}var JL=A({threshold_:oae});function iae(t,n,e="nearest",r="constant",o=0,s){let i=T(t,"image","transform","float32"),a=T(n,"transforms","transform","float32");$(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),$(a.rank===2&&(a.shape[0]===i.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),$(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let l={image:i,transforms:a},c={interpolation:e,fillMode:r,fillValue:o,outputShape:s};return R.runKernel(Yh,l,c)}var eP=A({transform_:iae});function aae(t,n,e){let r=T(t,"a","bandPart");$(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);let o=r.shape,[s,i]=r.shape.slice(-2),a,l;typeof n=="number"?($(n%1===0,()=>`bandPart(): numLower must be an integer, got ${n}.`),$(n<=s,()=>`bandPart(): numLower (${n}) must not be greater than the number of rows (${s}).`),a=T(n<0?s:n,"numLower","bandPart")):($(n.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=sn(_l(n,0),s,Is(n,s))),typeof e=="number"?($(e%1===0,()=>`bandPart(): numUpper must be an integer, got ${e}.`),$(e<=i,()=>`bandPart(): numUpper (${e}) must not be greater than the number of columns (${i}).`),l=T(e<0?i:e,"numUpper","bandPart")):($(e.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=sn(_l(e,0),i,Is(e,i)));let c=U(aa(0,s,1,"int32"),[-1,1]),u=aa(0,i,1,"int32"),p=Ie(c,u),f=Pr(Qo(p,a),fo(p,ft(l))),d=cn([s,i],r.dtype);return U(Nn(tr(U(r,[-1,s,i])).map(h=>sn(f,h,d))),o)}var tP=A({bandPart_:aae});function lae(t){let n;if(Array.isArray(t)){n=!1,$(t!=null&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let o=t[0].shape[0];for(let s=1;s<t.length;++s)$(t[s].shape[0]===o,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[s].shape[0]} vs. ${o})`)}else n=!0,t=er(t,t.shape[0],0).map(o=>Zt(o,[0]));$(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);let e=[],r=t;for(let o=0;o<t.length;++o)e.push(R.tidy(()=>{let s=r[o];if(o>0)for(let i=0;i<o;++i){let a=z(Ne(z(e[i],s)),e[i]);s=Ie(s,a)}return ve(s,Al(s,"euclidean"))}));return n?Nn(e,0):e}var nP=A({gramSchmidt_:lae});function cae(t,n=!1){if($(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),t.rank===2)return rP(t,n);{let e=t.shape.slice(0,t.shape.length-2).reduce((l,c)=>l*c),r=tr(U(t,[e,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),o=[],s=[];r.forEach(l=>{let[c,u]=rP(l,n);o.push(c),s.push(u)});let i=U(Nn(o,0),t.shape),a=U(Nn(s,0),t.shape);return[i,a]}}function rP(t,n=!1){return R.tidy(()=>{$(t.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);let e=t.shape[0],r=t.shape[1],o=of(e),s=po(t),i=es([[1]],[1,1]),a=po(i),l=e>=r?r:e;for(let c=0;c<l;++c){let u=s,p=a,f=o;[a,s,o]=R.tidy(()=>{let d=Ue(s,[c,c],[e-c,1]),h=Al(d),g=Ue(s,[c,c],[1,1]),m=sn(En(g,0),es([[-1]]),es([[1]])),y=Ie(g,z(m,h)),x=ve(d,y);x.shape[0]===1?a=po(i):a=Et([i,Ue(x,[1,0],[x.shape[0]-1,x.shape[1]])],0);let C=ft(ve(ct(m,y),h)),I=Ue(s,[c,0],[e-c,r]),D=z(C,a),O=ut(a);if(c===0)s=Ie(I,ct(D,ct(O,I)));else{let V=Ie(I,ct(D,ct(O,I)));s=Et([Ue(s,[0,0],[c,r]),V],0)}let L=ut(D),B=Ue(o,[0,c],[e,o.shape[1]-c]);if(c===0)o=Ie(B,ct(ct(B,a),L));else{let V=Ie(B,ct(ct(B,a),L));o=Et([Ue(o,[0,0],[e,c]),V],1)}return[a,s,o]}),Ve([u,p,f])}return!n&&e>r&&(o=Ue(o,[0,0],[e,r]),s=Ue(s,[0,0],[r,r])),[o,s]})}var oP=A({qr_:cae});var qn=(function(t){return t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",t})(qn||{});function uae(t,n,e=qn.SUM_BY_NONZERO_WEIGHTS){let r=T(t,"losses","computeWeightedLoss"),o=null;n!=null&&(o=T(n,"weights","computeWeightedLoss"));let s=o==null?r:z(r,o);if(e===qn.NONE)return s;if(e===qn.SUM)return Ne(s);if(e===qn.MEAN){if(o==null)return ln(s);{let i=r.size/o.size,a=ve(Ne(s),Ne(o));return i>1?ve(a,Ee(i)):a}}if(e===qn.SUM_BY_NONZERO_WEIGHTS){if(o==null)return ve(Ne(s),Ee(r.size));{let i=z(o,jn(r.shape)),a=fe(Ne(gi(i,Ee(0))),"float32");return ve(Ne(s),a)}}throw Error(`Unknown reduction: ${e}`)}var Br=A({computeWeightedLoss_:uae});function pae(t,n,e,r=qn.SUM_BY_NONZERO_WEIGHTS){let o=T(t,"labels","absoluteDifference"),s=T(n,"predictions","absoluteDifference"),i=null;e!=null&&(i=T(e,"weights","absoluteDifference")),Pn(o.shape,s.shape,"Error in absoluteDifference: ");let a=hn(Ie(o,s));return Br(a,i,r)}var sP=A({absoluteDifference_:pae});function fae(t,n,e,r,o=qn.SUM_BY_NONZERO_WEIGHTS){let s=T(t,"labels","cosineDistance"),i=T(n,"predictions","cosineDistance"),a=null;r!=null&&(a=T(r,"weights","cosineDistance")),Pn(s.shape,i.shape,"Error in cosineDistance: ");let l=Ee(1),c=Ie(l,Ne(z(s,i),e,!0));return Br(c,a,o)}var iP=A({cosineDistance_:fae});function dae(t,n,e,r=qn.SUM_BY_NONZERO_WEIGHTS){let o=T(t,"labels","hingeLoss"),s=T(n,"predictions","hingeLoss"),i=null;e!=null&&(i=T(e,"weights","hingeLoss")),Pn(o.shape,s.shape,"Error in hingeLoss: ");let a=Ee(1);o=Ie(z(Ee(2),o),a);let l=Nr(Ie(a,z(o,s)));return Br(l,i,r)}var aP=A({hingeLoss_:dae});function hae(t,n,e,r=1,o=qn.SUM_BY_NONZERO_WEIGHTS){let s=T(t,"labels","huberLoss"),i=T(n,"predictions","huberLoss"),a=null;e!=null&&(a=T(e,"weights","huberLoss")),Pn(s.shape,i.shape,"Error in huberLoss: ");let l=Ee(r),c=hn(Ie(i,s)),u=Is(c,l),p=Ie(c,u),f=le(z(Ee(.5),lt(u)),z(l,p));return Br(f,a,o)}var lP=A({huberLoss_:hae});function mae(t,n,e,r=1e-7,o=qn.SUM_BY_NONZERO_WEIGHTS){let s=T(t,"labels","logLoss"),i=T(n,"predictions","logLoss"),a=null;e!=null&&(a=T(e,"weights","logLoss")),Pn(s.shape,i.shape,"Error in logLoss: ");let l=Ee(1),c=Ee(r),u=ft(z(s,mr(le(i,c)))),p=z(Ie(l,s),mr(le(Ie(l,i),c))),f=Ie(u,p);return Br(f,a,o)}var cP=A({logLoss_:mae});function gae(t,n,e,r=qn.SUM_BY_NONZERO_WEIGHTS){let o=T(t,"labels","meanSquaredError"),s=T(n,"predictions","meanSquaredError"),i=null;e!=null&&(i=T(e,"weights","meanSquaredError")),Pn(o.shape,s.shape,"Error in meanSquaredError: ");let a=zm(o,s);return Br(a,i,r)}var uP=A({meanSquaredError_:gae});function yae(t,n){let e=T(t,"labels","sigmoidCrossEntropyWithLogits"),r=T(n,"logits","sigmoidCrossEntropyWithLogits");Pn(e.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let o=Nr(r),s=z(r,e),i=bu(gn(ft(hn(r))));return le(Ie(o,s),i)}function xae(t,n,e,r=0,o=qn.SUM_BY_NONZERO_WEIGHTS){let s=T(t,"multiClassLabels","sigmoidCrossEntropy"),i=T(n,"logits","sigmoidCrossEntropy"),a=null;if(e!=null&&(a=T(e,"weights","sigmoidCrossEntropy")),Pn(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){let c=Ee(r),u=Ee(1),p=Ee(.5);s=le(z(s,Ie(u,c)),z(p,c))}let l=yae(s,i);return Br(l,a,o)}var pP=A({sigmoidCrossEntropy_:xae});function vae(t,n,e=-1){if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${n.rank} and dim was ${e}`);return Oo((o,s,i)=>{let l=wu(s,[e],!0),c=Ie(fe(s,"float32"),l);i([o,c]);let u=ft(z(c,o));return{value:Ne(u,[e]),gradFunc:(d,h)=>{let[g,m]=h,y=zs(d.shape,[e]);return[z(U(d,y),Ie(fe(g,"float32"),gn(m))),z(U(d,y),Ie(gn(m),fe(g,"float32")))]}}})(t,n)}function bae(t,n,e,r=0,o=qn.SUM_BY_NONZERO_WEIGHTS){let s=T(t,"onehotLabels","softmaxCrossEntropy"),i=T(n,"logits","softmaxCrossEntropy"),a=null;if(e!=null&&(a=T(e,"weights","softmaxCrossEntropy")),Pn(s.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){let c=Ee(r),u=Ee(1),p=Ee(s.shape[1]);s=le(z(s,Ie(u,c)),ve(c,p))}let l=vae(s,i);return Br(l,a,o)}var fP=A({softmaxCrossEntropy_:bae});function wae(t,n,e,r){let o=T(t,"indices","sparseFillEmptyRows","int32"),s=T(n,"values","sparseFillEmptyRows"),i=T(e,"denseShape","sparseFillEmptyRows","int32"),a=T(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(o.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${o.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);let l={indices:o,values:s,denseShape:i,defaultValue:a},c=R.runKernel(Bh,l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}var dP=A({sparseFillEmptyRows_:wae});function Cae(t,n,e){let r=T(t,"inputIndices","sparseReshape","int32"),o=T(n,"inputShape","sparseReshape","int32"),s=T(e,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(o.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${o.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:r,inputShape:o,newShape:s},a=R.runKernel(zh,i);return{outputIndices:a[0],outputShape:a[1]}}var hP=A({sparseReshape_:Cae});function Iae(t,n,e){let r=T(t,"data","sparseSegmentMean"),o=T(n,"indices","sparseSegmentMean","int32"),s=T(e,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);let i={data:r,indices:o,segmentIds:s};return R.runKernel(Vh,i)}var mP=A({sparseSegmentMean_:Iae});function Sae(t,n,e){let r=T(t,"data","sparseSegmentSum"),o=T(n,"indices","sparseSegmentSum","int32"),s=T(e,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);let i={data:r,indices:o,segmentIds:s};return R.runKernel(Uh,i)}var gP=A({sparseSegmentSum_:Sae});function Tae(t,n,e,r,o,s,i,a){let l=T(t,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);let c=T(n,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let u={separator:e,nGramWidths:r,leftPad:o,rightPad:s,padWidth:i,preserveShortSequences:a},p={data:l,dataSplits:c},f=R.runKernel(Wh,p,u);return{nGrams:f[0],nGramsSplits:f[1]}}var yP=A({stringNGrams_:Tae});function Eae(t,n,e=!0){let r=T(t,"input","stringSplit","string"),o=T(n,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(o.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${o.shape}`);let s={skipEmpty:e},i={input:r,delimiter:o},a=R.runKernel(qh,i,s);return{indices:a[0],values:a[1],shape:a[2]}}var xP=A({stringSplit_:Eae});function Nae(t,n){let e=T(t,"input","stringToHashBucketFast","string"),r={numBuckets:n};if(n<=0)throw new Error("Number of buckets must be at least 1");let o={input:e};return R.runKernel(Kh,o,r)}var vP=A({stringToHashBucketFast_:Nae});function Dae(t,n,e,r=!0){let o=T(t,"input","staticRegexReplace","string"),s={pattern:n,rewrite:e,replaceGlobal:r};return R.runKernel(Bp,{x:o},s)}var bP=A({staticRegexReplace_:Dae});var kae={fft:Nu,ifft:Ml,rfft:Du,irfft:Bm},Aae={hammingWindow:PL,hannWindow:Rb,frame:Mb,stft:BL},nr={flipLeftRight:VL,grayscaleToRGB:UL,resizeNearestNeighbor:Pb,resizeBilinear:Lb,rgbToGrayscale:GL,rotateWithOffset:jL,cropAndResize:zL,nonMaxSuppression:HL,nonMaxSuppressionAsync:KL,nonMaxSuppressionWithScore:XL,nonMaxSuppressionWithScoreAsync:YL,nonMaxSuppressionPadded:ZL,nonMaxSuppressionPaddedAsync:QL,threshold:JL,transform:eP},FN={bandPart:tP,gramSchmidt:nP,qr:oP},_ae={absoluteDifference:sP,computeWeightedLoss:Br,cosineDistance:iP,hingeLoss:aP,huberLoss:lP,logLoss:cP,meanSquaredError:uP,sigmoidCrossEntropy:pP,softmaxCrossEntropy:fP},Rae={sparseFillEmptyRows:dP,sparseReshape:hP,sparseSegmentMean:mP,sparseSegmentSum:gP},Mae={stringNGrams:yP,stringSplit:xP,stringToHashBucketFast:vP,staticRegexReplace:bP};var de={};Xt(de,{Serializable:()=>R1,SerializationMap:()=>Bb,getRegisteredName:()=>Fae,registerClass:()=>LN});var Oae=new Map,$N=new Map,R1=class{getClassName(){return this.constructor.className}static fromConfig(n,e){return new n(e)}},Bb=class t{constructor(){this.classNameMap={}}static getMap(){return t.instance==null&&(t.instance=new t),t.instance}static register(n){t.getMap().classNameMap[n.className]=[n,n.fromConfig]}};function LN(t,n,e){$(t.className!=null,()=>"Class being registered does not have the static className property defined."),$(typeof t.className=="string",()=>"className is required to be a string, but got type "+typeof t.className),$(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof n>"u"&&(n="Custom"),typeof e>"u"&&(e=t.className);let r=e,o=n+">"+r;return Bb.register(t),Oae.set(o,t),$N.set(t,o),t}function Fae(t){return $N.has(t)?$N.get(t):t.className}var zr=class extends R1{minimize(n,e=!1,r){let{value:o,grads:s}=this.computeGradients(n,r);if(r!=null){let i=r.map(a=>({name:a.name,tensor:s[a.name]}));this.applyGradients(i)}else this.applyGradients(s);return Ve(s),e?o:(o.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(n,e){return TN(n,e)}dispose(){this.iterations_!=null&&Ve(this.iterations_)}saveIterations(){return te(this,null,function*(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Ee(this.iterations_,"int32")}})}getWeights(){return te(this,null,function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})}setWeights(n){return te(this,null,function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)})}extractIterations(n){return te(this,null,function*(){return this.iterations_=(yield n[0].tensor.data())[0],n.slice(1)})}};Object.defineProperty(zr,Symbol.hasInstance,{value:t=>t.minimize!=null&&t.computeGradients!=null&&t.applyGradients!=null});var Hm=class extends zr{static get className(){return"Adadelta"}constructor(n,e,r=null){super(),this.learningRate=n,this.rho=e,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=R.backend.epsilon())}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,o)=>{let s=R.registeredVariables[r],i=!1;this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${r}/accum_grad`,variable:X(()=>Ge(s).variable(i))}),this.accumulatedUpdates[o]==null&&(this.accumulatedUpdates[o]={originalName:`${r}/accum_var`,variable:X(()=>Ge(s).variable(i))});let a=Array.isArray(n)?n[o].tensor:n[r];if(a==null)return;let l=this.accumulatedGrads[o].variable,c=this.accumulatedUpdates[o].variable;X(()=>{let u=le(z(l,this.rho),z(lt(a),1-this.rho)),p=z(ve(Wt(le(c,this.epsilon)),Wt(le(l,this.epsilon))),a),f=le(z(c,this.rho),z(lt(p),1-this.rho));l.assign(u),c.assign(f);let d=le(z(p,-this.learningRate),s);s.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Ve(this.accumulatedGrads.map(n=>n.variable)),Ve(this.accumulatedUpdates.map(n=>n.variable)))}getWeights(){return te(this,null,function*(){let n=[...this.accumulatedGrads,...this.accumulatedUpdates];return[yield this.saveIterations()].concat(n.map(e=>({name:e.originalName,tensor:e.variable})))})}setWeights(n){return te(this,null,function*(){n=yield this.extractIterations(n);let e=n.length/2,r=!1;this.accumulatedGrads=n.slice(0,e).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.accumulatedUpdates=n.slice(e,e*2).map(o=>({originalName:o.name,variable:o.tensor.variable(r)}))})}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(n,e){return new n(e.learningRate,e.rho,e.epsilon)}};var Wm=class extends zr{static get className(){return"Adagrad"}constructor(n,e=.1){super(),this.learningRate=n,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,o)=>{let s=R.registeredVariables[r];this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${r}/accumulator`,variable:X(()=>Bs(s.shape,this.initialAccumulatorValue).variable(!1))});let i=Array.isArray(n)?n[o].tensor:n[r];if(i==null)return;let a=this.accumulatedGrads[o].variable;X(()=>{let l=le(a,lt(i));a.assign(l);let c=le(z(ve(i,Wt(le(l,R.backend.epsilon()))),-this.learningRate),s);s.assign(c)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Ve(this.accumulatedGrads.map(n=>n.variable))}getWeights(){return te(this,null,function*(){return[yield this.saveIterations()].concat(this.accumulatedGrads.map(n=>({name:n.originalName,tensor:n.variable})))})}setWeights(n){return te(this,null,function*(){n=yield this.extractIterations(n);let e=!1;this.accumulatedGrads=n.map(r=>({originalName:r.name,variable:r.tensor.variable(e)}))})}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(n,e){return new n(e.learningRate,e.initialAccumulatorValue)}};var qm=class extends zr{static get className(){return"Adam"}constructor(n,e,r,o=null){super(),this.learningRate=n,this.beta1=e,this.beta2=r,this.epsilon=o,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],X(()=>{this.accBeta1=Ee(e).variable(),this.accBeta2=Ee(r).variable()}),o==null&&(this.epsilon=R.backend.epsilon())}applyGradients(n){let e=Array.isArray(n)?n.map(r=>r.name):Object.keys(n);X(()=>{let r=Ie(1,this.accBeta1),o=Ie(1,this.accBeta2);e.forEach((s,i)=>{let a=R.registeredVariables[s],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:X(()=>Ge(a).variable(l))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${s}/v`,variable:X(()=>Ge(a).variable(l))});let c=Array.isArray(n)?n[i].tensor:n[s];if(c==null)return;let u=this.accumulatedFirstMoment[i].variable,p=this.accumulatedSecondMoment[i].variable,f=le(z(u,this.beta1),z(c,1-this.beta1)),d=le(z(p,this.beta2),z(lt(c),1-this.beta2)),h=ve(f,r),g=ve(d,o);u.assign(f),p.assign(d);let m=le(z(ve(h,le(Wt(g),this.epsilon)),-this.learningRate),a);a.assign(m)}),this.accBeta1.assign(z(this.accBeta1,this.beta1)),this.accBeta2.assign(z(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Ve(this.accumulatedFirstMoment.map(n=>n.variable)),this.accumulatedSecondMoment!=null&&Ve(this.accumulatedSecondMoment.map(n=>n.variable))}getWeights(){return te(this,null,function*(){let n=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[yield this.saveIterations()].concat(n.map(e=>({name:e.originalName,tensor:e.variable})))})}setWeights(n){return te(this,null,function*(){n=yield this.extractIterations(n),X(()=>{this.accBeta1.assign(Lr(this.beta1,this.iterations_+1)),this.accBeta2.assign(Lr(this.beta2,this.iterations_+1))});let e=n.length/2,r=!1;this.accumulatedFirstMoment=n.slice(0,e).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.accumulatedSecondMoment=n.slice(e,e*2).map(o=>({originalName:o.name,variable:o.tensor.variable(r)}))})}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(n,e){return new n(e.learningRate,e.beta1,e.beta2,e.epsilon)}};var Km=class extends zr{static get className(){return"Adamax"}constructor(n,e,r,o=null,s=0){super(),this.learningRate=n,this.beta1=e,this.beta2=r,this.epsilon=o,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],X(()=>{this.iteration=Ee(0).variable(),this.accBeta1=Ee(e).variable()}),o==null&&(this.epsilon=R.backend.epsilon())}applyGradients(n){let e=Array.isArray(n)?n.map(r=>r.name):Object.keys(n);X(()=>{let r=Ie(1,this.accBeta1),o=ve(-this.learningRate,le(z(this.iteration,this.decay),1));e.forEach((s,i)=>{let a=R.registeredVariables[s],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:Ge(a).variable(l)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${s}/v`,variable:Ge(a).variable(l)});let c=Array.isArray(n)?n[i].tensor:n[s];if(c==null)return;let u=this.accumulatedFirstMoment[i].variable,p=this.accumulatedWeightedInfNorm[i].variable,f=le(z(u,this.beta1),z(c,1-this.beta1)),d=z(p,this.beta2),h=hn(c),g=Fo(d,h);u.assign(f),p.assign(g);let m=le(z(ve(o,r),ve(f,le(g,this.epsilon))),a);a.assign(m)}),this.iteration.assign(le(this.iteration,1)),this.accBeta1.assign(z(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Ve(this.accumulatedFirstMoment.map(n=>n.variable)),this.accumulatedWeightedInfNorm!=null&&Ve(this.accumulatedWeightedInfNorm.map(n=>n.variable))}getWeights(){return te(this,null,function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})}setWeights(n){return te(this,null,function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(n,e){return new n(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}};var Au=class extends zr{static get className(){return"SGD"}constructor(n){super(),this.learningRate=n,this.setLearningRate(n)}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,o)=>{let s=Array.isArray(n)?n[o].tensor:n[r];if(s==null)return;let i=R.registeredVariables[r];X(()=>{let a=le(z(this.c,s),i);i.assign(a)})}),this.incrementIterations()}setLearningRate(n){this.learningRate=n,this.c!=null&&this.c.dispose(),this.c=mn(Ee(-n))}dispose(){this.c.dispose()}getWeights(){return te(this,null,function*(){return[yield this.saveIterations()]})}setWeights(n){return te(this,null,function*(){if(n=yield this.extractIterations(n),n.length!==0)throw new Error("SGD optimizer does not have settable weights.")})}getConfig(){return{learningRate:this.learningRate}}static fromConfig(n,e){return new n(e.learningRate)}};var Xm=class extends Au{static get className(){return"Momentum"}constructor(n,e,r=!1){super(n),this.learningRate=n,this.momentum=e,this.useNesterov=r,this.accumulations=[],this.m=Ee(this.momentum)}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,o)=>{let s=R.registeredVariables[r];this.accumulations[o]==null&&(this.accumulations[o]={originalName:`${r}/momentum`,variable:X(()=>Ge(s).variable(!1))});let i=this.accumulations[o].variable,a=Array.isArray(n)?n[o].tensor:n[r];a!=null&&X(()=>{let l,c=le(z(this.m,i),a);this.useNesterov?l=le(z(this.c,le(a,z(c,this.m))),s):l=le(z(this.c,c),s),i.assign(c),s.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Ve(this.accumulations.map(n=>n.variable))}setMomentum(n){this.momentum=n}getWeights(){return te(this,null,function*(){return[yield this.saveIterations()].concat(this.accumulations.map(n=>({name:n.originalName,tensor:n.variable})))})}setWeights(n){return te(this,null,function*(){n=yield this.extractIterations(n);let e=!1;this.accumulations=n.map(r=>({originalName:r.name,variable:r.tensor.variable(e)}))})}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(n,e){return new n(e.learningRate,e.momentum,e.useNesterov)}};var Ym=class extends zr{static get className(){return"RMSProp"}constructor(n,e=.9,r=0,o=null,s=!1){if(super(),this.learningRate=n,this.decay=e,this.momentum=r,this.epsilon=o,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,o==null&&(this.epsilon=R.backend.epsilon()),n==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(n){(Array.isArray(n)?n.map(r=>r.name):Object.keys(n)).forEach((r,o)=>{let s=R.registeredVariables[r],i=!1;this.accumulatedMeanSquares[o]==null&&(this.accumulatedMeanSquares[o]={originalName:`${r}/rms`,variable:X(()=>Ge(s).variable(i))}),this.accumulatedMoments[o]==null&&(this.accumulatedMoments[o]={originalName:`${r}/momentum`,variable:X(()=>Ge(s).variable(i))}),this.accumulatedMeanGrads[o]==null&&this.centered&&(this.accumulatedMeanGrads[o]={originalName:`${r}/mg`,variable:X(()=>Ge(s).variable(i))});let a=Array.isArray(n)?n[o].tensor:n[r];if(a==null)return;let l=this.accumulatedMeanSquares[o].variable,c=this.accumulatedMoments[o].variable;X(()=>{let u=le(z(l,this.decay),z(lt(a),1-this.decay));if(this.centered){let p=this.accumulatedMeanGrads[o].variable,f=le(z(p,this.decay),z(a,1-this.decay)),d=ve(z(a,this.learningRate),Wt(Ie(u,le(lt(f),this.epsilon)))),h=le(z(c,this.momentum),d);l.assign(u),p.assign(f),c.assign(h);let g=Ie(s,h);s.assign(g)}else{let p=le(z(l,this.decay),z(lt(a),1-this.decay)),f=le(z(c,this.momentum),ve(z(a,this.learningRate),Wt(le(p,this.epsilon))));l.assign(p),c.assign(f);let d=Ie(s,f);s.assign(d)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Ve(this.accumulatedMeanSquares.map(n=>n.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Ve(this.accumulatedMeanGrads.map(n=>n.variable)),this.accumulatedMoments!=null&&Ve(this.accumulatedMoments.map(n=>n.variable))}getWeights(){return te(this,null,function*(){let n=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&n.push(...this.accumulatedMeanGrads),[yield this.saveIterations()].concat(n.map(e=>({name:e.originalName,tensor:e.variable})))})}setWeights(n){return te(this,null,function*(){n=yield this.extractIterations(n);let e=this.centered?n.length/3:n.length/2,r=!1;this.accumulatedMeanSquares=n.slice(0,e).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.accumulatedMoments=n.slice(e,e*2).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=n.slice(e*2,e*3).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})))})}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(n,e){return new n(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}};var $ae=[Hm,Wm,qm,Km,Xm,Ym,Au];function wP(){for(let t of $ae)LN(t)}var yi={};Xt(yi,{CompositeArrayBuffer:()=>$r,browserFiles:()=>IP,browserHTTPRequest:()=>DP,concatenateArrayBuffers:()=>u$,copyModel:()=>S$,decodeWeights:()=>wv,decodeWeightsStream:()=>Cv,encodeWeights:()=>i$,fromMemory:()=>kP,fromMemorySync:()=>jN,getLoadHandlers:()=>h$,getModelArtifactsForJSON:()=>im,getModelArtifactsForJSONSync:()=>pN,getModelArtifactsInfoForJSON:()=>Qi,getSaveHandlers:()=>d$,getWeightSpecs:()=>y1,http:()=>Vb,isHTTPScheme:()=>zb,listModels:()=>C$,loadWeights:()=>TP,moveModel:()=>T$,registerLoadRouter:()=>f$,registerSaveRouter:()=>p$,removeModel:()=>I$,weightsLoaderFactory:()=>UN,withSaveHandler:()=>AP,withSaveHandlerSync:()=>_P});var Lae="model",Pae=".json",Bae=".weights.bin";function CP(t){return new Promise(n=>setTimeout(n)).then(t)}var PN=(()=>{class t{constructor(e){if(!Z().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(t.URL_SCHEME)&&(e=e.slice(t.URL_SCHEME.length)),(e==null||e.length===0)&&(e=Lae),this.modelJsonFileName=e+Pae,this.weightDataFileName=e+Bae}save(e){return te(this,null,function*(){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let r=$r.join(e.weightData),o=window.URL.createObjectURL(new Blob([r],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let s=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],i=Iv(e,s),a=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),l=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(l.download=this.modelJsonFileName,l.href=a,yield CP(()=>l.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){let c=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;c.download=this.weightDataFileName,c.href=o,yield CP(()=>c.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Qi(e)}}})}}return t.URL_SCHEME="downloads://",t})();var BN=class{constructor(n){if(n==null||n.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${n}`);this.jsonFile=n[0],this.weightsFiles=n.slice(1)}load(){return te(this,null,function*(){return new Promise((n,e)=>{let r=new FileReader;r.onload=o=>{let s=JSON.parse(o.target.result),i=s.modelTopology;if(i==null){e(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){e(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){n({modelTopology:i});return}let l=im(s,c=>this.loadWeights(c));n(l)},r.onerror=o=>e(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})})}loadWeights(n){let e=[],r=[];for(let i of n)e.push(...i.weights),r.push(...i.paths);let o=this.checkManifestAndWeightFiles(n),s=r.map(i=>this.loadWeightsFile(i,o[i]));return Promise.all(s).then(i=>[e,i])}loadWeightsFile(n,e){return new Promise((r,o)=>{let s=new FileReader;s.onload=i=>{let a=i.target.result;r(a)},s.onerror=i=>o(`Failed to weights data from file of path '${n}'.`),s.readAsArrayBuffer(e)})}checkManifestAndWeightFiles(n){let e=[],r=this.weightsFiles.map(s=>uN(s.name)),o={};for(let s of n)s.paths.forEach(i=>{let a=uN(i);if(e.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(e.push(a),r.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);o[i]=this.weightsFiles[r.indexOf(a)]});if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return o}},zae=t=>Z().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(PN.URL_SCHEME)?Vae(t.slice(PN.URL_SCHEME.length)):null;dr.registerSaveRouter(zae);function Vae(t="model"){return new PN(t)}function IP(t){return new BN(t)}function zN(t,n,e,r){i(t),e=e??0,r=r??1,a(e,r);let o=0,s=l=>(l.then(c=>{let u=e+ ++o/t.length*(r-e);return n(u),c}),l);function i(l){$(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function a(l,c){$(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),$(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),$(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}return Promise.all(t.map(s))}function VN(t,n){return te(this,null,function*(){n==null&&(n={});let e=n.fetchFunc==null?Z().platform.fetch:n.fetchFunc,r=t.map(p=>e(p,n.requestInit,{isBinary:!0})),a=(n.onProgress==null?yield Promise.all(r):yield zN(r,n.onProgress,0,.5)).map(p=>p.arrayBuffer());return n.onProgress==null?yield Promise.all(a):yield zN(a,n.onProgress,.5,1)})}function SP(t,n){var e;let r=n.fetchFunc==null?Z().platform.fetch:n.fetchFunc,o=0,s;return(e=n.onProgress)===null||e===void 0||e.call(n,0),new ReadableStream({pull:i=>te(null,null,function*(){for(var a;o<t.length;){s||(s=(yield r(t[o],n.requestInit,{isBinary:!0})).body.getReader());let{done:l,value:c}=yield s.read();if(l){o++,s=void 0,(a=n.onProgress)===null||a===void 0||a.call(n,o/t.length);continue}i.enqueue(c);return}i.close()})})}function TP(t,n="",e,r){return te(this,null,function*(){return UN(i=>VN(i,{requestInit:r}))(t,n,e)})}function UN(t){return(n,e="",r)=>te(null,null,function*(){let o=n.map(()=>!1),s={},i=r!=null?r.map(()=>!1):[],a=[];if(n.forEach((d,h)=>{let g=0;d.weights.forEach(m=>{let y="quantization"in m?m.quantization.dtype:m.dtype,x=Nl[y]*mt(m.shape),C=()=>{o[h]=!0,s[h]==null&&(s[h]=[]),s[h].push({manifestEntry:m,groupOffset:g,sizeBytes:x})};r!=null?r.forEach((I,D)=>{I===m.name&&(C(),i[D]=!0)}):C(),a.push(m.name),g+=x})}),!i.every(d=>d)){let d=r.filter((h,g)=>!i[g]);throw new Error(`Could not find weights in manifest with names: ${d.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}let l=o.reduce((d,h,g)=>(h&&d.push(g),d),[]),c=[];l.forEach(d=>{n[d].paths.forEach(h=>{let g=e+(e.endsWith("/")?"":"/")+h;c.push(g)})});let u=yield t(c),p={},f=0;return l.forEach(d=>{let h=n[d].paths.length,g=new $r(u.slice(f,f+h));s[d].forEach(y=>{let x=g.slice(y.groupOffset,y.groupOffset+y.sizeBytes),C=wv(x,[y.manifestEntry]);for(let I in C)p[I]=C[I]}),f+=h}),p})}var Uae="application/octet-stream",Gae="application/json",EP=(()=>{class t{constructor(e,r){if(this.DEFAULT_METHOD="POST",r==null&&(r={}),this.weightPathPrefix=r.weightPathPrefix,this.weightUrlConverter=r.weightUrlConverter,r.fetchFunc!=null?($(typeof r.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=r.fetchFunc):this.fetch=Z().platform.fetch,$(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&$(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,r.requestInit!=null&&r.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=r.requestInit||{},this.loadOptions=r}save(e){return te(this,null,function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let r=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);r.body=new FormData;let o=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],s=Iv(e,o);if(r.body.append("model.json",new Blob([JSON.stringify(s)],{type:Gae}),"model.json"),e.weightData!=null){let a=$r.join(e.weightData);r.body.append("model.weights.bin",new Blob([a],{type:Uae}),"model.weights.bin")}let i=yield this.fetch(this.path,r);if(i.ok)return{modelArtifactsInfo:Qi(e),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)})}loadModelJSON(){return te(this,null,function*(){let e=yield this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let r;try{r=yield e.json()}catch(i){let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}let o=r.modelTopology,s=r.weightsManifest;if(o==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return r})}load(){return te(this,null,function*(){if(this.loadOptions.streamWeights)return this.loadStream();let e=yield this.loadModelJSON();return im(e,r=>this.loadWeights(r))})}loadStream(){return te(this,null,function*(){let e=yield this.loadModelJSON(),r=yield this.getWeightUrls(e.weightsManifest),o=y1(e.weightsManifest),s=()=>SP(r,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:o,getWeightStream:s})})}getWeightUrls(e){return te(this,null,function*(){let r=Array.isArray(this.path)?this.path[1]:this.path,[o,s]=jae(r),i=this.weightPathPrefix||o,a=[],l=[];for(let c of e)for(let u of c.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(u)):a.push(i+u+s);return this.weightUrlConverter&&a.push(...yield Promise.all(l)),a})}loadWeights(e){return te(this,null,function*(){let r=yield this.getWeightUrls(e),o=y1(e),s=yield VN(r,this.loadOptions);return[o,s]})}}return t.URL_SCHEME_REGEX=/^https?:\/\//,t})();function jae(t){let n=t.lastIndexOf("/"),e=t.lastIndexOf("?"),r=t.substring(0,n),o=e>n?t.substring(e):"";return[r+"/",o]}function zb(t){return t.match(EP.URL_SCHEME_REGEX)!=null}var NP=(t,n)=>{if(typeof fetch>"u"&&(n==null||n.fetchFunc==null))return null;{let e=!0;if(Array.isArray(t)?e=t.every(r=>zb(r)):e=zb(t),e)return Vb(t,n)}return null};dr.registerSaveRouter(NP);dr.registerLoadRouter(NP);function Vb(t,n){return new EP(t,n)}function DP(t,n){return Vb(t,n)}var M1=class{constructor(n){this.modelArtifacts=n}load(){return this.modelArtifacts}},Ub=class{constructor(n){this.saveHandler=n}save(n){return this.saveHandler(n)}},GN=class{constructor(n){n.load&&(this.load=()=>Promise.resolve(n.load())),n.save&&(this.save=e=>Promise.resolve(n.save(e)))}};function kP(t,n,e,r){let o=arguments;return new GN(jN(...o))}function jN(t,n,e,r){return arguments.length===1?t.modelTopology!=null||t.weightSpecs!=null?new M1(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new M1({modelTopology:t})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new M1({modelTopology:t,weightSpecs:n,weightData:e,trainingConfig:r}))}function AP(t){return new Ub(t)}function _P(t){return new Ub(t)}var Ol={};Xt(Ol,{draw:()=>Qae,fromPixels:()=>Jae,fromPixelsAsync:()=>Xae,toPixels:()=>Zae});var gf,RP=!1;function MP(t,n=3){if(n>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(t==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let e=!1,r=!1,o=!1,s=!1,i=!1,a=!1;if(t.data instanceof Uint8Array)e=!0;else if(typeof ImageData<"u"&&t instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&t instanceof HTMLVideoElement)o=!0;else if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement)s=!0;else if(t.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&t instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);if(Jh(p1,R.backendName)!=null){let h={pixels:t},g={numChannels:n};return R.runKernel(p1,h,g)}let[c,u]=o?[t.videoWidth,t.videoHeight]:[t.width,t.height],p;if(i)p=t.getContext("2d").getImageData(0,0,c,u).data;else if(r||e)p=t.data;else if(s||o||a){if(gf==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")gf=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else gf=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});gf.canvas.width=c,gf.canvas.height=u,gf.drawImage(t,0,0,c,u),p=gf.getImageData(0,0,c,u).data}let f;if(n===4)f=new Int32Array(p);else{let h=c*u;f=new Int32Array(h*n);for(let g=0;g<h;g++)for(let m=0;m<n;++m)f[g*n+m]=p[g*4+m]}return Sb(f,[u,c,n],"int32")}function Hae(t){return t!=null&&t.data instanceof Uint8Array}function Wae(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function qae(t){return t!=null&&t.width!==0&&t.height!==0}function Kae(t){return Wae()&&!(t instanceof ImageBitmap)&&qae(t)&&!Hae(t)}function Xae(t,n=3){return te(this,null,function*(){let e=null;if(Z().getBool("WRAP_TO_IMAGEBITMAP")&&Kae(t)){let r;try{r=yield createImageBitmap(t,{premultiplyAlpha:"none"})}catch(o){r=null}r!=null&&r.width===t.width&&r.height===t.height?e=r:e=t}else e=t;return MP(e,n)})}function OP(t){if(t.rank!==2&&t.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);let n=t.rank===2?1:t.shape[2];if(n>4||n===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${n}`);if(t.dtype!=="float32"&&t.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`)}function Yae(t){let n=t?.alpha||1;if(n>1||n<0)throw new Error(`Alpha value ${n} is suppoed to be in range [0 - 1].`)}function Zae(t,n){return te(this,null,function*(){let e=T(t,"img","toPixels");if(!(t instanceof ot)){let c=e;e=fe(c,"int32"),c.dispose()}OP(e);let[r,o]=e.shape.slice(0,2),s=e.rank===2?1:e.shape[2],i=yield e.data(),a=e.dtype==="float32"?255:1,l=new Uint8ClampedArray(o*r*4);for(let c=0;c<r*o;++c){let u=[0,0,0,255];for(let f=0;f<s;f++){let d=i[c*s+f];if(e.dtype==="float32"){if(d<0||d>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${d}.`)}else if(e.dtype==="int32"&&(d<0||d>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${d}.`);s===1?(u[0]=d*a,u[1]=d*a,u[2]=d*a):u[f]=d*a}let p=c*4;l[p+0]=Math.round(u[0]),l[p+1]=Math.round(u[1]),l[p+2]=Math.round(u[2]),l[p+3]=Math.round(u[3])}if(n!=null){RP||Jh(u1,R.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),RP=!0),n.width=o,n.height=r;let c=n.getContext("2d"),u=new ImageData(l,o,r);c.putImageData(u,0,0)}return e!==t&&e.dispose(),l})}function Qae(t,n,e){let r=T(t,"img","draw");if(!(t instanceof ot)){let i=r;r=fe(i,"int32"),i.dispose()}OP(r),Yae(e?.imageOptions);let o={image:r},s={canvas:n,options:e};R.runKernel(u1,o,s)}var Jae=A({fromPixels_:MP});function ele(t,n){let e=t.shape.length,r=n.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(n.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.shape[r-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${n.shape[r-1]} vs. ${e}`);if(mt(t.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);let o=n.shape,s=o[o.length-1],i=1;for(let p=0;p<o.length-1;++p)i*=o[p];let a=t.shape,l=o.slice();l.pop();let c=1;for(let p=s;p<e;++p)c*=a[p],l.push(a[p]);let u=[...Wi(t.shape).map(p=>p/c),1].slice(0,s);return[l,i,c,u]}var gr={};Xt(gr,{assertParamsValid:()=>nle,computeFlatOffset:()=>ale,computeOutShape:()=>ole,getNormalizedAxes:()=>sle,isSliceContinous:()=>ile,maskToAxes:()=>rle,parseSliceParams:()=>WN,sliceInfo:()=>lle,startForAxis:()=>UP,startIndicesWithElidedDims:()=>BP,stopForAxis:()=>GP,stopIndicesWithElidedDims:()=>zP,stridesForAxis:()=>VP,stridesWithElidedDims:()=>$P});var HN=-2,tle=-1;function nle(t,n,e){let r=t.shape.length;$(r===n.length,()=>`Error in slice${r}D: Length of begin ${n} must match the rank of the array (${r}).`),$(r===e.length,()=>`Error in slice${r}D: Length of size ${e} must match the rank of the array (${r}).`);for(let o=0;o<r;++o)$(n[o]+e[o]<=t.shape[o],()=>`Error in slice${r}D: begin[${o}] + size[${o}] (${n[o]+e[o]}) would overflow input.shape[${o}] (${t.shape[o]})`)}function rle(t){let n=[],e=0;for(;t>0;)t&1&&n.push(e),t/=2,e++;return n}function ole(t,n,e){let r=[];for(let o=0;o<t.length;o++)r[o]=Math.ceil((n[o]-t[o])/e[o]);return r}function $P(t,n,e,r){let o=[...t];for(let s=o.length;s<r.length;s++)o.push(1);for(let s=0;s<e;s++)s===0?o[n]=1:(o.splice(n,0,1),o.pop());return o}function LP(t,n,e){return e<=t?e:e-(n-1)}function PP(t,n){let e=[];for(let r=0;r<t;r++)e.push(n+r);return e}function sle(t,n,e,r,o,s,i,a,l){let c=t.length,u=new Array(c),p=new Array(c),f=new Array(c);if(n.length&&e>0){let d=n[0],h=e+1;u=BP(i,d,h,r,t),p=zP(a,d,h,o,t),f=$P(s,d,h,t)}else for(let d=0;d<c;d++)u[d]=UP(i,r,s,t,d,l),p[d]=GP(a,o,s,t,d,l),f[d]=VP(s,d,l);return{begin:u,end:p,strides:f}}function BP(t,n,e,r,o){let s=[...o],i=PP(e,n);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=0;else{let l=LP(n,e,a),c=r[l];t&1<<l&&(c=0),s[a]=c}return s}function zP(t,n,e,r,o){let s=[...o],i=PP(e,n);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=Number.MAX_SAFE_INTEGER;else{let l=LP(n,e,a),c=r[l];t&1<<l&&(c=Number.MAX_SAFE_INTEGER),s[a]=c}for(let a=0;a<s.length;a++){let l=o[a];s[a]<0&&(s[a]+=l),s[a]=Wd(0,s[a],o[a])}return s}function VP(t,n,e){let r=t[n];return(e&1<<n||r==null)&&(r=1),r}function UP(t,n,e,r,o,s){let i=n[o],a=e[o]||1;(t&1<<o||s&1<<o||i==null)&&(a>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let l=r[o];return i<0&&(i+=l),i=Wd(0,i,l-1),i}function GP(t,n,e,r,o,s){let i=n[o],a=e[o]||1;(t&1<<o||s&1<<o||i==null)&&(a>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let l=r[o];return i<0&&(i+=l),a>0?i=Wd(0,i,l):i=Wd(-1,i,l-1),i}function ile(t,n,e){let r=e.length;for(let o=0;o<e.length;o++)if(e[o]>1){r=o;break}for(let o=r+1;o<e.length;o++)if(n[o]>0||e[o]!==t[o])return!1;return!0}function ale(t,n){let e=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)e+=t[r]*n[r];return e}function WN(t,n,e){let r,o=t.shape.length;typeof n=="number"?r=[n,...new Array(o-1).fill(0)]:n.length<o?r=n.concat(new Array(o-n.length).fill(0)):r=n.slice(),r.forEach(i=>{$(i!==-1,()=>"slice() does not support negative begin indexing.")});let s;return e==null?s=new Array(o).fill(-1):typeof e=="number"?s=[e,...new Array(o-1).fill(-1)]:e.length<o?s=e.concat(new Array(o-e.length).fill(-1)):s=e,s=s.map((i,a)=>i>=0?i:($(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),t.shape[a]-r[a])),[r,s]}function lle(t,n,e,r,o,s,i,a,l){let c;if(r==null?(c=new Array(n.length),c.fill(1)):c=r,i!=null&&(i&i-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let u=!1,p={dims:c.length,numAddAxisAfterEllipsis:0,begin:n.slice(),end:e.slice(),strides:c.slice(),beginMask:o,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l};for(let C=0;C<p.dims;C++)u&&(1<<C&a)!==0&&p.numAddAxisAfterEllipsis++,1<<C&i&&(u=!0);u||(p.ellipsisMask|=1<<p.dims,p.dims++);let f={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};cle(p,f);let d=!0,h=!0,g=!0,m=[],y=[];for(let C=0;C<t.length;++C){if(f.strides[C]===0)throw Error(`strides[${C}] must be non-zero`);let I=!!(f.shrinkAxisMask&1<<C),D=t[C];if(D===-1){m.push(I?1:-1);continue}let O=[f.beginMask&1<<C,f.endMask&1<<C],L=[f.strides[C]>0?0:-1,f.strides[C]>0?D:D-1];if(I&&f.strides[C]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&f.strides[C]===1;let B=!!(f.beginMask&1<<C&&f.endMask&1<<C);if(f.beginValid&&f.endValid){if(I){let ee=f.begin[C]<0?D+f.begin[C]:f.begin[C];if(f.begin[C]=ee,f.end[C]=f.begin[C]+1,ee<0||ee>=D)throw Error(`slice index ${f.begin[C]} of dimension ${C} out of bounds.`)}else f.begin[C]=FP(f.begin[C],0,f.strides[C],D,O,L),f.end[C]=FP(f.end[C],1,f.strides[C],D,O,L);let G=f.strides[C]===1&&f.begin[C]===0&&f.end[C]===D;d=d&&G,h=h&&(C===0&&f.strides[C]===1||G)}else d=d&&f.strides[C]===1&&B,h=h&&(C===0&&f.strides[C]===1||B);let V,F=!1;if(f.beginValid&&f.endValid?(V=f.end[C]-f.begin[C],F=!0):I?(V=1,F=!0):B&&D>=0&&(f.strides[C]<0?V=-D:V=D,F=!0),F){let G;V===0||V<0!=f.strides[C]<0?G=0:G=Math.trunc(V/f.strides[C])+(V%f.strides[C]!==0?1:0),m.push(G)}else m.push(-1)}for(let C=0;C<f.finalShapeGatherIndices.length;++C){let I=f.finalShapeGatherIndices[C];I>=0?y.push(m[I]):I===HN&&y.push(1)}return{finalShapeSparse:y.filter((C,I)=>f.finalShapeGatherIndices[I]!==HN),finalShape:y,isIdentity:d,sliceDim0:h,isSimpleSlice:g,begin:f.begin,end:f.end,strides:f.strides}}function cle(t,n){n.beginMask=0,n.endMask=0,n.shrinkAxisMask=0;let e=0;n.beginValid=t.begin!=null,n.endValid=t.end!=null,n.begin=new Array(n.dims),n.end=new Array(n.dims),n.strides=new Array(n.dims),n.finalShapeGatherIndices=[],n.finalShapeGatherIndicesSparse=[],n.inputShapeGatherIndicesSparse=new Array(n.dims);for(let r=0;r<t.dims;r++)if(1<<r&t.ellipsisMask){let o=Math.min(n.dims-(t.dims-r)+1+t.numAddAxisAfterEllipsis,n.dims);for(;e<o;e++)n.begin[e]=0,n.end[e]=0,n.strides[e]=1,n.beginMask|=1<<e,n.endMask|=1<<e,n.finalShapeGatherIndices.push(e),n.finalShapeGatherIndicesSparse.push(-1),n.inputShapeGatherIndicesSparse[e]=r}else if(1<<r&t.newAxisMask)n.finalShapeGatherIndices.push(HN),n.finalShapeGatherIndicesSparse.push(-1);else{if(e===n.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${n.dims} dims, ${n.begin.length}.`);t.begin!=null&&(n.begin[e]=t.begin[r]),t.end!=null&&(n.end[e]=t.end[r]),n.strides[e]=t.strides[r],t.beginMask&1<<r&&(n.beginMask|=1<<e),t.endMask&1<<r&&(n.endMask|=1<<e),t.shrinkAxisMask&1<<r?(n.finalShapeGatherIndices.push(tle),n.finalShapeGatherIndicesSparse.push(-1),n.shrinkAxisMask|=1<<e):(n.finalShapeGatherIndices.push(e),n.finalShapeGatherIndicesSparse.push(r)),n.inputShapeGatherIndicesSparse[e]=r,e++}}function FP(t,n,e,r,o,s){if(o[n])return e>0?s[n]:s[n+1&1];{let i=t<0?r+t:t;return i<s[0]?s[0]:i>s[1]?s[1]:i}}var Gb=class{static sgd(n){return new Au(n)}static momentum(n,e,r=!1){return new Xm(n,e,r)}static rmsprop(n,e=.9,r=0,o=null,s=!1){return new Ym(n,e,r,o,s)}static adam(n=.001,e=.9,r=.999,o=null){return new qm(n,e,r,o)}static adadelta(n=.001,e=.95,r=null){return new Hm(n,e,r)}static adamax(n=.002,e=.9,r=.999,o=null,s=0){return new Km(n,e,r,o,s)}static adagrad(n,e=.1){return new Wm(n,e)}};var yf=Gb;var ule=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:t=>t();function O1(){return new Promise(t=>ule(()=>t()))}var _={};Xt(_,{ERF_A1:()=>Tle,ERF_A2:()=>Ele,ERF_A3:()=>Nle,ERF_A4:()=>Dle,ERF_A5:()=>kle,ERF_P:()=>Sle,PARALLELIZE_THRESHOLD:()=>jb,RowPartitionType:()=>Fl,SELU_SCALE:()=>KN,SELU_SCALEALPHA:()=>qN,applyActivation:()=>hf,assertAndGetBroadcastShape:()=>rt,assertAxesAreInnerMostDims:()=>toe,assertParamsConsistent:()=>ple,assignToTypedArray:()=>Fle,axesAreInnerMostDims:()=>wN,calculateShapes:()=>aie,checkEinsumDimSizes:()=>Vle,checkPadOnDimRoundingMode:()=>on,combineLocations:()=>B$,combineRaggedTensorToTensorShapes:()=>dle,complexWithEvenIndex:()=>Rle,complexWithOddIndex:()=>Mle,computeConv2DInfo:()=>tf,computeConv3DInfo:()=>A$,computeDefaultPad:()=>bN,computeDilation2DInfo:()=>ere,computeOptimalWindowSize:()=>yle,computeOutAndReduceShapes:()=>CN,computeOutShape:()=>fle,computePool2DInfo:()=>vN,computePool3DInfo:()=>tre,convertConv2DDataFormat:()=>_$,decodeEinsumEquation:()=>Ble,eitherStridesOrDilationsAreOne:()=>Sr,expandShapeToKeepDim:()=>zs,exponent:()=>Lle,exponents:()=>$le,fromStringArrayToUint8:()=>lce,fromUint8ToStringArray:()=>ace,getAxesPermutation:()=>IN,getBroadcastDims:()=>L$,getComplexWithIndex:()=>Ole,getEinsumComputePath:()=>Ule,getEinsumPermutation:()=>zle,getFusedBiasGradient:()=>df,getFusedDyActivation:()=>ff,getImageCenter:()=>xle,getInnerMostAxes:()=>noe,getPermuted:()=>ble,getRaggedRank:()=>mle,getReductionAxes:()=>Yt,getReshaped:()=>vle,getReshapedPermuted:()=>wle,getRowPartitionTypesHelper:()=>hle,getSliceBeginCoords:()=>Cle,getSliceSize:()=>Ile,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>Wle,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>qle,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>Kle,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>Zle,getSparseReshapeInputOutputMismatchErrorMessage:()=>Jle,getSparseReshapeInputOutputMultipleErrorMessage:()=>Qle,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>Xle,getSparseReshapeNegativeOutputDimErrorMessage:()=>Yle,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>rce,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>ece,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>tce,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>nce,getUndoAxesPermutation:()=>w1,isIdentityPermutation:()=>Gle,log:()=>Hte,mergeRealAndImagArrays:()=>Ale,prepareAndValidate:()=>ele,prepareSplitSize:()=>Hle,segment_util:()=>YN,shouldFuse:()=>mf,slice_util:()=>gr,splitRealAndImagArrays:()=>_le,stridesOrDilationsArePositive:()=>ea,tupleValuesAreOne:()=>ws,upcastType:()=>Wn,validateDefaultValueShape:()=>gle,validateInput:()=>A1,validateUpdateShape:()=>kL,warn:()=>Zi});function ple(t,n){let e=t[0].length;t.forEach((o,s)=>{$(o.length===e,()=>`Error in concat${e}D: rank of tensors[${s}] must be the same as the rank of the rest (${e})`)}),$(n>=0&&n<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);let r=t[0];t.forEach((o,s)=>{for(let i=0;i<e;i++)$(i===n||o[i]===r[i],()=>`Error in concat${e}D: Shape of tensors[${s}] (${o}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`)})}function fle(t,n){let e=t[0].slice();for(let r=1;r<t.length;r++)e[n]+=t[r][n];return e}var Fl=(function(t){return t[t.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",t[t.VALUE_ROWIDS=1]="VALUE_ROWIDS",t[t.ROW_LENGTHS=2]="ROW_LENGTHS",t[t.ROW_SPLITS=3]="ROW_SPLITS",t[t.ROW_LIMITS=4]="ROW_LIMITS",t[t.ROW_STARTS=5]="ROW_STARTS",t})(Fl||{});function dle(t,n,e){let r=new Array;if(e==null&&n==null)return r;if(n==null)for(;r.length<t+e.length;)r.push(-1);else r=n.slice();if(e==null)return r;if(t+e.length!==r.length)throw new Error(`rt input.shape and shape=${n} are incompatible: rt input.rank = ${t+e.length}, but shape.rank = ${r.length}`);for(let o=1;o<e.length;++o){let s=e[o],i=r[r.length-e.length+o],a=r[i];if(s>=0)if(a>=0){if(a!==s)throw new Error(`rt input.shape and shape=${n} are incompatible: rt input.shape[${o+t}] = ${s} but shape[${o+t}] = ${a}`)}else r[i]=s}return r}function hle(t){let n={FIRST_DIM_SIZE:Fl.FIRST_DIM_SIZE,VALUE_ROWIDS:Fl.VALUE_ROWIDS,ROW_LENGTHS:Fl.ROW_LENGTHS,ROW_SPLITS:Fl.ROW_SPLITS,ROW_LIMITS:Fl.ROW_LIMITS,ROW_STARTS:Fl.ROW_STARTS},e=[];for(let r of t)if(r in n)e.push(n[r]);else break;return e}function mle(t){return t.length===0?0:t[0]===Fl.FIRST_DIM_SIZE?t.length-1:t.length}function gle(t,n){if(t==null||n==null)return;let e=t.length,r=n.length;if(e>=r)throw new Error(`defaultValue.shape=${t} and ragged tensor flatValues.shape=${n}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${r})`);for(let o=0;o<Math.min(e,r-1);++o){let s=t[o],i=n[o+1];if(s>=0&&i>=0&&s!==1&&s!==i)throw new Error(`defaultValue.shape=${t}, and ragged tensor input flatValues.shape=${n} are incompatible: defaultValue.shape[${o-t.length}] = ${s} but ragged tensor input.flatValues.shape[${o-t.length}] = ${i}`)}}var jb=30;function yle(t){return t<=jb?t:Yd(t,Math.floor(Math.sqrt(t)))}function xle(t,n,e){let r=e*(typeof t=="number"?t:t[0]),o=n*(typeof t=="number"?t:t[1]);return[r,o]}function vle(t,n,e,r=!0){let o=[];if(r)o=o.concat(n.slice(0)),o.push(t[0]/e),o=o.concat(t.slice(1));else{o=o.concat(t[0]);let s=n.length;for(let i=0;i<s;++i)o=o.concat([t[i+1]/n[i],n[i]]);o=o.concat(t.slice(s+1))}return o}function ble(t,n,e=!0){let r=[];if(e){r.push(n);for(let o=n+1;o<t;++o)o<=2*n?(r.push(o),r.push(o-(n+1))):r.push(o)}else{let o=[],s=[];for(let i=1;i<t;++i)i>=n*2+1||i%2===1?s.push(i):o.push(i);r.push(...o),r.push(0),r.push(...s)}return r}function wle(t,n,e,r=!0){let o=[];r?o.push(t[0]/e):o.push(t[0]*e);for(let s=1;s<t.length;++s)s<=n.length?r?o.push(n[s-1]*t[s]):o.push(t[s]/n[s-1]):o.push(t[s]);return o}function Cle(t,n){let e=[0];for(let r=0;r<n;++r)e.push(t[r][0]);return e}function Ile(t,n,e){let r=t.slice(0,1);for(let o=0;o<e;++o)r.push(t[o+1]-n[o][0]-n[o][1]);return r}var qN=1.7580993408473768,KN=1.0507009873554805;var Sle=.3275911,Tle=.254829592,Ele=-.284496736,Nle=1.421413741,Dle=-1.453152027,kle=1.061405429;function Ale(t,n){if(t.length!==n.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${n.length}.`);let e=new Float32Array(t.length*2);for(let r=0;r<e.length;r+=2)e[r]=t[r/2],e[r+1]=n[r/2];return e}function _le(t){let n=new Float32Array(t.length/2),e=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)n[r/2]=t[r],e[r/2]=t[r+1];return{real:n,imag:e}}function Rle(t){let n=Math.ceil(t.length/4),e=new Float32Array(n),r=new Float32Array(n);for(let o=0;o<t.length;o+=4)e[Math.floor(o/4)]=t[o],r[Math.floor(o/4)]=t[o+1];return{real:e,imag:r}}function Mle(t){let n=Math.floor(t.length/4),e=new Float32Array(n),r=new Float32Array(n);for(let o=2;o<t.length;o+=4)e[Math.floor(o/4)]=t[o],r[Math.floor(o/4)]=t[o+1];return{real:e,imag:r}}function Ole(t,n){let e=t[n*2],r=t[n*2+1];return{real:e,imag:r}}function Fle(t,n,e,r){t[r*2]=n,t[r*2+1]=e}function $le(t,n){let e=new Float32Array(t/2),r=new Float32Array(t/2);for(let o=0;o<Math.ceil(t/2);o++){let s=(n?2:-2)*Math.PI*(o/t);e[o]=Math.cos(s),r[o]=Math.sin(s)}return{real:e,imag:r}}function Lle(t,n,e){let r=(e?2:-2)*Math.PI*(t/n),o=Math.cos(r),s=Math.sin(r);return{real:o,imag:s}}var XN="->",Ple=/->/g,jP=",",HP="...";function Ble(t,n){t=t.replace(/\s/g,"");let e=(t.length-t.replace(Ple,"").length)/XN.length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error(`Equation must contain exactly one arrow ("${XN}").`);let[r,o]=t.split(XN);$(r.indexOf(HP)===-1,()=>`The ellipsis notation ("${HP}") is not supported yet.`);let s=r.split(jP),i=s.length;if(n!==i)throw new Error(`Expected ${i} input tensors, received ${n}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let a=[];for(let f=0;f<o.length;++f){let d=o[f];if(!s.some(h=>h.indexOf(d)!==-1))throw new Error(`Output subscripts contain the label ${d} not present in the input subscripts.`);a.indexOf(d)===-1&&a.push(d)}for(let f=0;f<r.length;++f){let d=r[f];a.indexOf(d)===-1&&d!==jP&&a.push(d)}let l=new Array(s.length);for(let f=0;f<i;++f){if(new Set(s[f].split("")).size!==s[f].length)throw new Error(`Found duplicate axes in input component ${s[f]}. Support for duplicate axes in input is not implemented yet.`);l[f]=[];for(let d=0;d<s[f].length;++d)l[f].push(a.indexOf(s[f][d]))}let c=a.length,u=o.length,p=[];for(let f=u;f<c;++f)p.push(f);return{allDims:a,summedDims:p,idDims:l}}function zle(t,n){let e=new Array(t);e.fill(-1);for(let o=0;o<n.length;++o)e[n[o]]=o;let r=[];for(let o=0;o<t;++o)e[o]===-1&&r.push(o);return e=e.filter(o=>o!==-1),{permutationIndices:e,expandDims:r}}function Vle(t,n,e){let r=new Array(t);for(let o=0;o<e.length;++o){let s=e[o].shape;for(let i=0;i<n[o].length;++i)r[n[o][i]]===void 0?r[n[o][i]]=s[i]:$(r[n[o][i]]===s[i],()=>`Expected dimension ${r[n[o][i]]} at axis ${i} of input shaped ${JSON.stringify(s)}, but got dimension ${s[i]}`)}}function Ule(t,n){let e=t,r=[],o=0;t.length===0&&e.push(-1),o=t.length+1;for(let i=0;i<o;++i)r.push([]);let s=[];for(let i=0;i<e.length;++i){let a=e[i],l=jle(n,a);for(let c of l)s.indexOf(c)===-1&&(r[i].push(c),s.push(c))}return{path:e,steps:r}}function Gle(t){return t.every((n,e)=>n===e)}function jle(t,n){let e=[];for(let r=0;r<t.length;++r)(t[r].length===0||t[r].indexOf(n)!==-1||n===-1)&&e.push(r);return e}function Hle(t,n,e=0){let r=[];if(typeof n=="number")$(t.shape[e]%n===0,()=>"Number of splits must evenly divide the axis."),r=new Array(n).fill(t.shape[e]/n);else{let o=n.reduce((i,a)=>(a===-1&&(i+=1),i),0);$(o<=1,()=>"There should be only one negative value in split array.");let s=n.indexOf(-1);if(s!==-1){let i=n.reduce((a,l)=>l>0?a+l:a);n[s]=t.shape[e]-i}$(t.shape[e]===n.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),r=n}return r}function Wle(t){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${t}`}function qle(t,n){return`indices(${t}, 0) is invalid: ${n} < 0`}function Kle(t,n,e){return`indices(${t}, 0) is invalid: ${n} >= ${e}`}function Xle(t,n){return`only one output dimension may be -1, not both ${t} and ${n}`}function Yle(t,n){return`size ${t} must be non-negative, not ${n}`}function Zle(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Qle(t,n){let e=mt(t),r=mt(n);return`Input to reshape is a SparseTensor with ${e}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${t} outputShape= ${n}`}function Jle(t,n){let e=mt(t),r=mt(n);return`Input to reshape is a tensor with ${e} dense values, but the requested shape has ${r}. inputShape=${t} outputShape=${n}`}function ece(){return"segment ids must be >= 0"}function tce(){return"segment ids are not increasing"}function nce(t,n){return`Segment id ${t} out of range [0, ${n}), possibly because segmentIds input is not sorted.`}function rce(t,n,e){return`Bad: indices[${t}] == ${n} out of range [0, ${e})`}var YN={};Xt(YN,{collectGatherOpShapeInfo:()=>ice,computeOutShape:()=>sce,segOpComputeOptimalWindowSize:()=>oce});function oce(t,n){let e=!1,r;for(t<=jb?(r=t,e=!0):r=Yd(t,Math.floor(Math.sqrt(t)));!e;)r>n||r===t?e=!0:r=Yd(t,r+1);return r}function sce(t,n,e){let r=[],o=t.length;for(let s=0;s<o;s++)s!==n?r.push(t[s]):r.push(e);return r}function ice(t,n,e,r){let o=n.shape.length,s=t.shape.length;if(r!==0&&(r<-o||r>o))throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${r}`);if(r<0&&(r+=o),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${s}).`);if(e<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${e}).`);for(let p=0;p<r;++p)if(t.shape[p]!==n.shape[p])throw new Error(`x.shape[${p}]: ${t.shape[p]} should be equal to indices.shape[${p}]: ${n.shape[p]}.`);let i=t.shape[e],a=[],l=1,c=1,u=1;for(let p=0;p<r;++p)a.push(t.shape[p]),l*=t.shape[p];for(let p=r;p<e;p++)a.push(t.shape[p]),c*=t.shape[p];for(let p=r;p<o;p++)a.push(n.shape[p]);for(let p=e+1;p<s;p++)a.push(t.shape[p]),u*=t.shape[p];return{batchSize:l,sliceSize:u,outerSize:c,dimSize:i,outputShape:a}}function ace(t){try{return t.map(n=>om(n))}catch(n){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${n}`)}}function lce(t){return t.map(n=>rm(n))}var Vr={};Xt(Vr,{nonMaxSuppressionV3Impl:()=>Ob,nonMaxSuppressionV4Impl:()=>Fb,nonMaxSuppressionV5Impl:()=>$b,whereImpl:()=>Db});wP();var Hb={kernelName:"Abs",inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>z(t,Vs(fe(e,"float32"),-1))}}};var WP={kernelName:ja,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>{let r=lt(fe(e,"float32")),o=Wt(Ie(Ee(1),r));return ft(ve(t,o))}}}};var qP={kernelName:Ha,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>{let r=Wt(Ie(lt(fe(e,"float32")),1));return ve(t,r)}}}};var KP={kernelName:"Add",inputsToSave:["a","b"],gradFunc:(t,n)=>{let[e,r]=n,o=rt(e.shape,r.shape);return{a:()=>{let a=t,l=Yt(e.shape,o);return l.length>0&&(a=Ne(a,l)),U(a,e.shape)},b:()=>{let a=t,l=Yt(r.shape,o);return l.length>0&&(a=Ne(a,l)),U(a,r.shape)}}}};var XP={kernelName:wc,saveAllInputs:!0,gradFunc:(t,n)=>{let e={};return n.forEach((r,o)=>{e[o]=()=>t.clone()}),e}};var YP={kernelName:Cc,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>Ge(e)}}};var ZP={kernelName:Ic,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>Ge(e)}}};var QP={kernelName:Wa,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>ve(t,Wt(Ie(Ee(1),lt(fe(e,"float32")))))}}};var JP={kernelName:qa,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>{let r=Wt(le(Ee(1),lt(fe(e,"float32"))));return ve(t,r)}}}};var e6={kernelName:Ya,inputsToSave:["a","b"],gradFunc:(t,n)=>{let[e,r]=n,o=rt(e.shape,r.shape);return{a:()=>{let a=le(lt(e),lt(r)),l=z(t,ve(r,a)),c=Yt(e.shape,o);return c.length>0&&(l=Ne(l,c)),U(l,e.shape)},b:()=>{let a=le(lt(e),lt(r)),l=ft(z(t,ve(e,a))),c=Yt(r.shape,o);return c.length>0&&(l=Ne(l,c)),U(l,r.shape)}}}};var t6={kernelName:Ka,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>ve(t,le(lt(fe(e,"float32")),1))}}};var n6={kernelName:Xa,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>ve(t,Ie(Ee(1),lt(fe(e,"float32"))))}}};function cce(t,n,e,r,o,s){let i=T(t,"dy","avgPool3dGrad"),a=T(n,"input","avgPool3dGrad"),l=i,c=a,u=!1;a.rank===4&&(u=!0,l=U(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),c=U(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),$(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),$(c.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),on("avgPool3dGrad",o,s);let p={dy:l,input:c},f={filterSize:e,strides:r,pad:o,dimRoundingMode:s},d=R.runKernel(Jd,p,f);return u?U(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var r6=A({avgPool3dGrad_:cce});var o6={kernelName:Tc,inputsToSave:["x"],gradFunc:(t,n,e)=>{let[r]=n,{filterSize:o,strides:s,pad:i,dimRoundingMode:a}=e;return{x:()=>r6(t,r,o,s,i,a)}}};function uce(t,n,e,r,o){let s=T(t,"dy","avgPoolGrad"),i=T(n,"input","avgPoolGrad");$(i.rank===s.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`);let a=i,l=s,c=!1;i.rank===3&&(c=!0,a=U(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=U(s,[1,s.shape[0],s.shape[1],s.shape[2]])),$(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),$(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);let u={dy:l,input:a},p={filterSize:e,strides:r,pad:o},f=R.runKernel(Qd,u,p);return c?U(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var s6=A({avgPoolGrad_:uce});var i6={kernelName:Sc,inputsToSave:["x"],gradFunc:(t,n,e)=>{let[r]=n,{filterSize:o,strides:s,pad:i}=e;return{x:()=>s6(t,r,o,s,i)}}};var a6={kernelName:Ec,inputsToSave:["a","b"],gradFunc:(t,n,e)=>{let[r,o]=n,{transposeA:s,transposeB:i}=e;return!s&&!i?{a:()=>ct(t,o,!1,!0),b:()=>ct(r,t,!0,!1)}:!s&&i?{a:()=>ct(t,o,!1,!1),b:()=>ct(t,r,!0,!1)}:s&&!i?{a:()=>ct(o,t,!1,!0),b:()=>ct(r,t,!1,!1)}:{a:()=>ct(o,t,!0,!0),b:()=>ct(t,r,!0,!0)}}};var l6={kernelName:Nc,gradFunc:(t,n,e)=>{let{blockShape:r,crops:o}=e;return{x:()=>Su(t,r,o)}}};var c6={kernelName:CF,gradFunc:(t,n,e)=>{let r=e,o=r.inputShape,s=r.shape,i=Array.from(s);for(let l=o.length-1;l>=0;l--)if(o[l]===s[l])i[l]=1;else if(o[l]!==1)throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${s}].`);let a=[];for(let l=0;l<i.length;l++)i[l]>1&&a.push(l);return{x:()=>Ne(t,a,!0)}}};var u6={kernelName:qi,gradFunc:t=>({x:()=>t.clone()})};var p6={kernelName:Za,gradFunc:t=>({x:()=>Ge(t)})};var f6={kernelName:Qa,inputsToSave:["x"],gradFunc:(t,n,e)=>{let[r]=n,{clipValueMin:o,clipValueMax:s}=e;return{x:()=>sn(Pr(fo(r,o),Qo(r,s)),t,Ge(t))}}};var d6={kernelName:Dc,inputsToSave:["x"],gradFunc:Hb.gradFunc};var h6={kernelName:kc,saveAllInputs:!0,gradFunc:(t,n,e)=>{let r=n.map(l=>l.shape),{axis:o}=e,s=Zn(o,n[0].shape)[0],i=r.map(l=>l[s]);return er(t,i,s).map(l=>()=>l)}};var m6={kernelName:Ac,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{let[r,o]=n,{dilations:s,strides:i,pad:a,dataFormat:l}=e;return $(ws(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>mm(r.shape,t,o,i,a,l),filter:()=>jm(r,t,o.shape,i,a,l)}}};var g6={kernelName:_c,inputsToSave:["dy","filter"],gradFunc:(t,n,e)=>{let[r,o]=n,{strides:s,pad:i,dataFormat:a,dimRoundingMode:l}=e;return{dy:()=>Mo(t,o,s,i,a,1,l),filter:()=>jm(t,r,o.shape,s,i,a,l)}}};function pce(t,n,e,r,o){let s=t;t.rank===4&&(s=U(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let i=n;i.rank===4&&(i=U(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]])),$(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),$(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),$(e.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),$(s.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${e[3]}.`),$(i.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${e[4]}).`);let a={x:s,dy:i},l={strides:r,pad:o,filterShape:e};return R.runKernel(oh,a,l)}var y6=A({conv3DBackpropFilter_:pce});var x6={kernelName:Rc,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{let{dilations:r,strides:o,pad:s}=e;$(ws(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);let[i,a]=n;return{x:()=>Xv(i.shape,t,a,o,s),filter:()=>y6(i,t,a.shape,o,s)}}};var v6={kernelName:"Cos",inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>z(ft(Fm(fe(e,"float32"))),t)}}};var b6={kernelName:Ja,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>z($m(fe(e,"float32")),t)}}};var w6={kernelName:Mc,inputsToSave:["x"],gradFunc:(t,n,e)=>{let[r]=n,{axis:o,exclusive:s,reverse:i}=e;return{x:()=>{let a=IN([o],r.rank),l=vm(t,o,s,!i);return a!=null&&(l=ut(l,a)),l}}}};var C6={kernelName:Oc,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{let{dilations:r,strides:o,pad:s,dimRoundingMode:i}=e,a=r??[1,1];$(ws(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);let[l,c]=n;return $(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),$(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),$(l.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),$(Sr(o,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${o} and dilations '${a}'.`),on("depthwiseConv2d",s,i),{x:()=>_b(l.shape,t,c,o,s,a,i),filter:()=>Ab(l,t,c.shape,o,s,a,i)}}};var I6={kernelName:Fc,inputsToSave:["x","filter"],gradFunc:(t,n,e)=>{let[r,o]=n,s={x:r,filter:o,dy:t},i={x:r,filter:o,dy:t};return{x:()=>R.runKernel(l1,s,e),filter:()=>R.runKernel(c1,i,e)}}};var S6={kernelName:"Elu",outputsToSave:[!0],gradFunc:(t,n)=>{let[e]=n,r={dy:t,y:e};return{x:()=>R.runKernel(hh,r)}}};var T6={kernelName:"Erf",inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n,r=z(gn(ft(lt(e))),2/Math.sqrt(Math.PI));return{x:()=>z(t,r)}}};var E6={kernelName:"Exp",outputsToSave:[!0],gradFunc:(t,n)=>{let[e]=n;return{x:()=>z(t,e)}}};var N6={kernelName:$c,inputsToSave:["input"],gradFunc:(t,n)=>{let[e]=n;return{input:()=>U(t,e.shape)}}};var D6={kernelName:tl,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>z(t,gn(e))}}};var k6={kernelName:nl,gradFunc:t=>({x:()=>Ge(t)})};var A6={kernelName:rl,inputsToSave:["a","b"],gradFunc:(t,n)=>{let[e,r]=n,o=rt(e.shape,r.shape);return{a:()=>{let a=ve(t,fe(r,"float32")),l=Yt(e.shape,o);return l.length>0?U(Ne(a,l),e.shape):a},b:()=>{let a=z(t,fe(e,"float32")),l=Yt(r.shape,o);l.length>0&&(a=U(Ne(a,l),r.shape));let c=lt(r);return ft(ve(a,fe(c,"float32")))}}}};var _6={kernelName:Lc,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,n,e)=>{let{varianceEpsilon:r}=e,[o,s,i,a]=n,l=a??Ee(1),c=Yt(s.shape,o.shape),u=[];if(s.rank===1){for(let I=0;I<o.shape.length-1;++I)u.push(o.shape[I]);u.push(1)}let p=Ie(o,s),f=z(t,l),d=_m(le(i,Ee(r))),h=z(z(z(d,d),d),Ee(-.5));return{x:()=>s.rank===1?U(z(z(t,Er(U(d,[1,1,1,s.shape[0]]),u)),l),o.shape):U(z(z(t,d),l),o.shape),mean:()=>{let I=z(z(d,Ee(-1)),f);return s.rank===1&&(I=Ne(I,c)),U(I,s.shape)},variance:()=>{let I=z(z(h,p),f);return s.rank===1&&(I=Ne(I,c)),U(I,s.shape)},scale:()=>{let I=z(p,d),D=z(t,I);return s.rank===1&&(D=Ne(D,c)),U(D,s.shape)},offset:()=>{let I=t;return s.rank===1&&(I=Ne(I,c)),U(I,s.shape)}}}};var O6={kernelName:Pc,inputsToSave:["x","indices"],gradFunc:(t,n,e)=>{let[r,o]=n,{axis:s,batchDims:i}=e,a=Zn(s,r.shape)[0],l=(c,u,p)=>()=>{let f=c.shape,d=u.size,h=f.slice(0,a),g=h.length,m=f.slice(s,f.length).slice(1),y=m.length,x=R6(0,g),C=R6(g+1,g+1+y),I=M6([h,[d],m]),D=U(p,I),O=U(u,[d]),L=M6([[g],x,C]),B=ut(D,L),V=Gm(B,O,c.shape[a]),F=w1(L);return V=ut(V,F),V};if(i===1){let c=r.shape[0],u=r.split(c,0);return{x:()=>Nn(u.map((d,h)=>l(d,o.slice(h,1),t.slice(h,1))())).reshape(r.shape),indices:()=>o}}else return{x:l(r,o,t),indices:()=>o}}};function R6(t,n){let e=[];for(let r=t;r<n;++r)e.push(r);return e}function M6(t){let n=[];for(let e=0;e<t.length;++e)for(let r=0;r<t[e].length;++r)n.push(t[e][r]);return n}var F6={kernelName:ol,inputsToSave:["a","b"],gradFunc:(t,n)=>{let[e,r]=n;return{a:()=>Ge(e),b:()=>Ge(r)}}};var $6={kernelName:Ki,gradFunc:t=>({x:()=>fe(t,"float32")})};var L6={kernelName:sl,gradFunc:t=>({x:()=>Ge(t)})};var P6={kernelName:il,gradFunc:t=>({x:()=>Ge(t)})};var B6={kernelName:al,gradFunc:t=>({x:()=>Ge(t)})};var z6={kernelName:Bc,inputsToSave:["x"],gradFunc:(t,n,e)=>{let[r]=n,{alpha:o}=e,s=En(r,0);return{x:()=>sn(s,t,z(t,o))}}};var V6={kernelName:ll,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>ve(t,le(e,1))}}};var U6={kernelName:"Log",inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>ve(t,fe(e,"float32"))}}};var G6={kernelName:IF,inputsToSave:[],outputsToSave:[!0],gradFunc:(t,n,e)=>{let[r]=n,{axis:o}=e;return{logits:()=>{let i=gn(r);return Ie(t,z(Ne(t,o,!0),i))}}}};function fce(t,n,e,r=5,o=1,s=1,i=.5){let a={x:t,y:n,dy:e},l={depthRadius:r,bias:o,alpha:s,beta:i};return R.runKernel(wh,a,l)}var j6=A({localResponseNormalizationBackprop_:fce});var H6={kernelName:"LRN",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{let[r,o]=n,{depthRadius:s,bias:i,alpha:a,beta:l}=e;return{x:()=>j6(r,o,t,s,i,a,l)}}};function Wb(t,n,e,r){return n.rank<e.rank&&(n=U(n,zs(n.shape,r))),t.rank<e.rank&&(t=U(t,zs(t.shape,r))),{x:()=>z(t,fe(eo(e,n),t.dtype))}}var ZN={kernelName:"Max",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{let r=e,{reductionIndices:o}=r,s=n[0],i=n[1],a=Zn(o,s.shape),l=Wb(t,i,s,a);return{x:()=>l.x()}}};var W6={kernelName:cl,inputsToSave:["a","b"],gradFunc:(t,n)=>{let[e,r]=n;return{a:()=>z(t,fe(fo(e,r),"float32")),b:()=>z(t,fe(_l(e,r),"float32"))}}};function dce(t,n,e,r,o,s,i){let a=T(t,"dy","maxPool3dGrad"),l=T(n,"input","maxPool3dGrad"),c=T(e,"output","maxPool3dGrad"),u=a,p=l,f=c,d=!1;l.rank===4&&(d=!0,u=U(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),p=U(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),f=U(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),$(u.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),$(p.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),$(f.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${f.rank}.`),on("maxPool3dGrad",s,i);let h={dy:u,input:p,output:f},g={filterSize:r,strides:o,pad:s,dimRoundingMode:i},m=R.runKernel(Ih,h,g);return d?U(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var q6=A({maxPool3dGrad_:dce});var K6={kernelName:Vc,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{let[r,o]=n,{filterSize:s,strides:i,pad:a,dimRoundingMode:l}=e;return{x:()=>q6(t,r,o,s,i,a,l)}}};function hce(t,n,e,r,o,s,i){let a=T(t,"dy","maxPoolGrad"),l=T(n,"input","maxPoolGrad"),c=T(e,"output","maxPoolGrad");$(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),$(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),$(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),on("maxPoolGrad",s,i);let u={dy:a,input:l,output:c},p={filterSize:r,strides:o,pad:s,dimRoundingMode:i};return R.runKernel(Ch,u,p)}var X6=A({maxPoolGrad_:hce});var Y6={kernelName:zc,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{let[r,o]=n,{filterSize:s,strides:i,pad:a}=e;return{x:()=>X6(t,r,o,s,i,a)}}};var Z6={kernelName:Uc,inputsToSave:["x"],gradFunc:(t,n,e)=>{let[r]=n,{axis:o}=e,s=Zn(o,r.shape),a=CN(r.shape,s)[1],l=mt(a);return{x:()=>{let u=r.shape.slice();s.forEach(d=>{u[d]=1});let p=U(t,u);return ve(z(p,jn(r.shape,"float32")),l)}}}};var Q6={kernelName:"Min",inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,n,e)=>{let r=e,{axis:o}=r,[s,i]=n,a=Zn(o,s.shape),l=Wb(t,i,s,a);return{x:()=>l.x()}}};var J6={kernelName:ul,inputsToSave:["a","b"],gradFunc:(t,n)=>{let[e,r]=n;return{a:()=>z(t,fe(Qo(e,r),"float32")),b:()=>z(t,fe(En(e,r),"float32"))}}};var e5={kernelName:Gc,inputsToSave:["x"],gradFunc:(t,n,e)=>{let r=n[0],{paddings:o}=e,s=o.map(i=>i[0]);return{x:()=>Ue(t,s,r.shape)}}};var t5={kernelName:"Mod",inputsToSave:["a","b"],gradFunc:(t,n)=>{let[e,r]=n,o=rt(e.shape,r.shape);return{a:()=>{let a=Yt(e.shape,o);return a.length>0?U(Ne(t,a),e.shape):t},b:()=>{let a=z(t,ft(sa(ve(e,r)))),l=Yt(r.shape,o);return l.length>0?U(Ne(a,l),r.shape):a}}}};var n5={kernelName:pl,inputsToSave:["a","b"],gradFunc:(t,n)=>{let[e,r]=n,o=rt(e.shape,r.shape);return{a:()=>{let a=z(t,fe(r,"float32")),l=Yt(e.shape,o);return l.length>0?U(Ne(a,l),e.shape):a},b:()=>{let a=z(t,fe(e,"float32")),l=Yt(r.shape,o);return l.length>0?U(Ne(a,l),r.shape):a}}}};var r5={kernelName:"Neg",gradFunc:t=>({x:()=>ft(t)})};var o5={kernelName:Hc,inputsToSave:["indices"],gradFunc:(t,n)=>{let e=n[0];return{indices:()=>cn(e.shape,"float32")}}};var s5={kernelName:jc,gradFunc:t=>({x:()=>Ge(t)})};var i5={kernelName:Wc,saveAllInputs:!0,gradFunc:(t,n,e)=>{let{axis:r}=e;return tr(t,r).map(s=>()=>s)}};var QN={kernelName:qc,inputsToSave:["x"],gradFunc:(t,n,e)=>{let r=n[0],{paddings:o}=e,s=o.map(i=>i[0]);return{x:()=>Ue(t,s,r.shape)}}};var a5={kernelName:"Pow",inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,n)=>{let[e,r,o]=n,s=e,i=r,a=rt(s.shape,i.shape);return{a:()=>{let u=fe(i,"float32"),p=z(t,z(u,Lr(s,Ie(u,Ee(1))))),f=Yt(s.shape,a);return f.length>0&&(p=Ne(p,f)),U(p,s.shape)},b:()=>{let u=En(s,0),p=sn(u,mr(s),Ge(s)),f=z(t,z(o,p)),d=Yt(i.shape,a);return d.length>0&&(f=Ne(f,d)),U(f,i.shape)}}}};var l5={kernelName:Kc,inputsToSave:["x","alpha"],gradFunc:(t,n)=>{let[e,r]=n,o=En(e,0);return{x:()=>sn(o,t,z(t,r)),alpha:()=>{let s=sn(o,Ge(t),z(t,e)),i=Yt(r.shape,t.shape);return i.length>0&&(s=Ne(s,i)),U(s,r.shape)}}}};function mce(t,n,e){let r=t.shape.slice();r[e]=1;let o=U(n,r),s=nf(t,e,!0,!1),i=nf(t,e,!0,!0),a=z(s,i);return z(o,a)}function gce(t,n,e){let r=t.shape.length,o=r-e.length,s=_.getAxesPermutation(e,r),i=t;s!=null&&(i=ut(t,s));let a=i.shape.slice(),c=a.splice(r-e.length,e.length).reduce((f,d)=>f*d,1);a.push(c);let u=i.reshape(a),p=mce(u,n,o);if(p=p.reshape(i.shape),s!=null){let f=_.getUndoAxesPermutation(s);p=ut(p,f)}return p}var c5={kernelName:Xc,inputsToSave:["x"],gradFunc:(t,n,e)=>{let[r]=n,{axis:o}=e,s=[];return o==null?s=r.shape.map((i,a)=>a):typeof o=="number"?s=[o]:s=o,{x:()=>gce(r,t,s)}}};var u5={kernelName:el,inputsToSave:["a","b"],gradFunc:(t,n)=>{let[e,r]=n,o=rt(e.shape,r.shape);return{a:()=>{let a=ve(t,fe(r,"float32")),l=Yt(e.shape,o);return l.length>0?U(Ne(a,l),e.shape):a},b:()=>{let a=z(t,fe(e,"float32")),l=Yt(r.shape,o);l.length>0&&(a=U(Ne(a,l),r.shape));let c=lt(r);return ft(ve(a,fe(c,"float32")))}}}};var p5={kernelName:fl,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>ve(t,ft(lt(e)))}}};var f5={kernelName:hl,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n,r=z(Qo(e,6),Vs(e));return{x:()=>z(t,fe(r,"float32"))}}};var d5={kernelName:dl,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>z(t,fe(Vs(e),"float32"))}}};var h5={kernelName:Yc,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>U(t,e.shape)}}};var m5={kernelName:Qc,inputsToSave:["images"],gradFunc:(t,n,e)=>{let[r]=n,o={dy:t,images:r};return{images:()=>R.runKernel(Fh,o,e)}}};var g5={kernelName:Zc,inputsToSave:["images"],gradFunc:(t,n,e)=>{let[r]=n,o={dy:t,images:r};return{images:()=>R.runKernel(Oh,o,e)}}};var y5={kernelName:Jc,gradFunc:(t,n,e)=>{let{dims:r}=e,o=Zn(r,t.shape);return{x:()=>Jn(t,o)}}};var x5={kernelName:ml,gradFunc:t=>({x:()=>Ge(t)})};var v5={kernelName:gl,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>ft(ve(t,z(Lr(e,1.5),2)))}}};var b5={kernelName:eu,inputsToSave:["condition"],gradFunc:(t,n)=>{let[e]=n;return{condition:()=>fe(Ge(e),"float32"),t:()=>z(t,fe(e,t.dtype)),e:()=>z(t,fe(Cu(e),t.dtype))}}};var w5={kernelName:yl,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>{let r=En(e,Ee(0)),o=Ee(qN),s=Ee(KN),i=z(t,s),a=z(z(t,o),gn(fe(e,"float32")));return sn(r,i,a)}}}};var C5={kernelName:bl,outputsToSave:[!0],gradFunc:(t,n)=>{let[e]=n;return{x:()=>z(t,z(e,Ie(Ee(1),e)))}}};var I5={kernelName:vl,gradFunc:t=>({x:()=>Ge(t)})};var S5={kernelName:"Sin",inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>z(gu(fe(e,"float32")),t)}}};var T5={kernelName:xl,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>z(xm(fe(e,"float32")),t)}}};var E5={kernelName:tu,inputsToSave:["x"],gradFunc:(t,n,e)=>{let[r]=n,{begin:o,size:s}=e,i=r.shape,[a,l]=WN(r,o,s),c=[];for(let u=0;u<t.rank;u++)c.push([a[u],i[u]-a[u]-l[u]]);return{x:()=>ho(t,c)}}};var N5={kernelName:ou,outputsToSave:[!0],gradFunc:(t,n,e)=>{let[r]=n,{dim:o}=e,s=!0,i=z(t,r);return{logits:()=>Ie(i,z(Ne(i,[o],s),r))}}};var D5={kernelName:wl,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>z(t,Tr(e))}}};var JN={kernelName:nu,gradFunc:(t,n,e)=>{let{blockShape:r,paddings:o}=e;return{x:()=>mu(t,r,o)}}};var eD={kernelName:ru,gradFunc:(t,n,e)=>{let{axis:r}=e;return{x:()=>Et(t,r)}}};var k5={kernelName:Cl,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>ve(t,z(Wt(fe(e,"float32")),2))}}};var A5={kernelName:jh,inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>z(t,z(fe(e,"float32"),2))}}};var _5={kernelName:Il,inputsToSave:["a","b"],gradFunc:(t,n)=>{let[e,r]=n,o=Ee(2);return{a:()=>z(t,z(o,Ie(e,r))),b:()=>z(t,z(o,Ie(r,e)))}}};var R5={kernelName:Tl,gradFunc:t=>({x:()=>Ge(t)})};var M5={kernelName:"Sub",inputsToSave:["a","b"],gradFunc:(t,n)=>{let[e,r]=n,o=rt(e.shape,r.shape);return{a:()=>{let a=t,l=Yt(e.shape,o);return l.length>0&&(a=Ne(a,l)),U(a,e.shape)},b:()=>{let a=t,l=Yt(r.shape,o);return l.length>0&&(a=Ne(a,l)),U(ft(a),r.shape)}}}};var O5={kernelName:"Sum",inputsToSave:["x"],gradFunc:(t,n,e)=>{let[r]=n,o=r.shape.slice(),{axis:s}=e;Zn(s,r.shape).forEach(c=>{o[c]=1});let a=U(t,o),l=z(a,jn(r.shape,"float32"));return{x:()=>l}}};var F5={kernelName:"Tan",inputsToSave:["x"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>ve(t,lt(gu(e)))}}};var $5={kernelName:Sl,outputsToSave:[!0],gradFunc:(t,n)=>{let[e]=n;return{x:()=>z(Ie(Ee(1),lt(e)),t)}}};var L5={kernelName:Xi,inputsToSave:["x"],gradFunc:(t,n,e)=>{let[r]=n,{reps:o}=e;return{x:()=>{let i=Ge(r);if(r.rank===1)for(let a=0;a<o[0];++a)i=le(i,Ue(t,[a*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let a=0;a<o[0];++a)for(let l=0;l<o[1];++l)i=le(i,Ue(t,[a*r.shape[0],l*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let a=0;a<o[0];++a)for(let l=0;l<o[1];++l)for(let c=0;c<o[2];++c)i=le(i,Ue(t,[a*r.shape[0],l*r.shape[1],c*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let a=0;a<o[0];++a)for(let l=0;l<o[1];++l)for(let c=0;c<o[2];++c)for(let u=0;u<o[3];++u)i=le(i,Ue(t,[a*r.shape[0],l*r.shape[1],c*r.shape[2],u*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return i}}}};var P5={kernelName:Yi,gradFunc:(t,n,e)=>{let r=e,{perm:o}=r,s=w1(o);return{x:()=>ut(t,s)}}};var B5={kernelName:su,gradFunc:(t,n,e)=>{let r=e,{axis:o}=r;return{value:()=>Nn(t,o)}}};var z5={kernelName:iu,inputsToSave:["segmentIds"],gradFunc:(t,n)=>{let[e]=n;return{x:()=>yce(t,e)}}};function yce(t,n){let e=Fo(n,Ge(n)),r=ia(t,e),o=fo(n,Ee(0,"int32")),s=r.rank-o.rank;for(let a=0;a<s;++a)o=an(o,a+1);o=Pr(o,jn(r.shape,"bool"));let i=Ge(r);return sn(o,r,i)}var V5={kernelName:au,gradFunc:t=>({x:()=>Ge(t)})};var xce=[Hb,WP,qP,KP,XP,YP,ZP,QP,JP,e6,t6,n6,o6,i6,a6,l6,c6,u6,p6,f6,d6,h6,g6,m6,x6,v6,b6,w6,C6,I6,u5,S6,T6,E6,N6,D6,A6,k6,_6,O6,F6,$6,L6,P6,B6,z6,V6,U6,G6,H6,ZN,ZN,W6,K6,Y6,Z6,Q6,J6,e5,t5,n5,r5,o5,s5,i5,QN,QN,a5,l5,c5,p5,f5,d5,h5,m5,g5,y5,x5,v5,b5,w5,C5,I5,S5,T5,E5,N5,D5,JN,JN,eD,eD,k5,_5,A5,R5,M5,O5,F5,$5,L5,P5,B5,z5,V5];for(let t of xce)TF(t);j().prototype.abs=function(){return this.throwIfDisposed(),hn(this)};j().prototype.acos=function(){return this.throwIfDisposed(),Dv(this)};j().prototype.acosh=function(){return this.throwIfDisposed(),kv(this)};j().prototype.add=function(t){return this.throwIfDisposed(),le(this,t)};j().prototype.all=function(t,n){return this.throwIfDisposed(),fm(this,t,n)};j().prototype.any=function(t,n){return this.throwIfDisposed(),ef(this,t,n)};j().prototype.argMax=function(t){return this.throwIfDisposed(),Ji(this,t)};j().prototype.argMin=function(t){return this.throwIfDisposed(),Rv(this,t)};j().prototype.asScalar=function(){return this.throwIfDisposed(),$(this.size===1,()=>"The array must have only 1 element."),U(this,[])};j().prototype.asType=function(t){return this.throwIfDisposed(),fe(this,t)};j().prototype.as1D=function(){return this.throwIfDisposed(),U(this,[this.size])};j().prototype.as2D=function(t,n){return this.throwIfDisposed(),U(this,[t,n])};j().prototype.as3D=function(t,n,e){return this.throwIfDisposed(),U(this,[t,n,e])};j().prototype.as4D=function(t,n,e,r){return this.throwIfDisposed(),U(this,[t,n,e,r])};j().prototype.as5D=function(t,n,e,r,o){return this.throwIfDisposed(),U(this,[t,n,e,r,o])};j().prototype.asin=function(){return this.throwIfDisposed(),Mv(this)};j().prototype.asinh=function(){return this.throwIfDisposed(),Ov(this)};j().prototype.atan=function(){return this.throwIfDisposed(),Fv(this)};j().prototype.atan2=function(t){return this.throwIfDisposed(),$v(this,t)};j().prototype.atanh=function(){return this.throwIfDisposed(),Lv(this)};j().prototype.avgPool=function(t,n,e,r){return this.throwIfDisposed(),hu(this,t,n,e,r)};j().prototype.batchToSpaceND=function(t,n){return this.throwIfDisposed(),mu(this,t,n)};j().prototype.batchNorm=function(t,n,e,r,o){return this.throwIfDisposed(),ta(this,t,n,e,r,o)};j().prototype.broadcastTo=function(t){return this.throwIfDisposed(),na(this,t)};j().prototype.cast=function(t){return this.throwIfDisposed(),fe(this,t)};j().prototype.ceil=function(){return this.throwIfDisposed(),Gv(this)};j().prototype.clipByValue=function(t,n){return this.throwIfDisposed(),Qn(this,t,n)};j().prototype.concat=function(t,n){return this.throwIfDisposed(),t instanceof ot&&(t=[t]),Et([this,...t],n)};j().prototype.conv1d=function(t,n,e,r,o,s){return this.throwIfDisposed(),hm(this,t,n,e,r,o,s)};j().prototype.conv2dTranspose=function(t,n,e,r,o){return this.throwIfDisposed(),gm(this,t,n,e,r,o)};j().prototype.conv2d=function(t,n,e,r,o,s){return this.throwIfDisposed(),Mo(this,t,n,e,r,o,s)};j().prototype.cos=function(){return this.throwIfDisposed(),gu(this)};j().prototype.cosh=function(){return this.throwIfDisposed(),xm(this)};j().prototype.cumprod=function(t,n,e){return this.throwIfDisposed(),nf(this,t,n,e)};j().prototype.cumsum=function(t,n,e){return this.throwIfDisposed(),vm(this,t,n,e)};j().prototype.depthToSpace=function(t,n){return this.throwIfDisposed(),Zv(this,t,n)};j().prototype.depthwiseConv2d=function(t,n,e,r,o,s){return this.throwIfDisposed(),ra(this,t,n,e,r,o,s)};j().prototype.dilation2d=function(t,n,e,r,o){return this.throwIfDisposed(),Qv(this,t,n,e,r,o)};j().prototype.divNoNan=function(t){return this.throwIfDisposed(),Jv(this,t)};j().prototype.div=function(t){return this.throwIfDisposed(),ve(this,t)};j().prototype.dot=function(t){return this.throwIfDisposed(),eb(this,t)};j().prototype.elu=function(){return this.throwIfDisposed(),oa(this)};j().prototype.equal=function(t){return this.throwIfDisposed(),eo(this,t)};j().prototype.erf=function(){return this.throwIfDisposed(),wm(this)};j().prototype.euclideanNorm=function(t,n){return this.throwIfDisposed(),tb(this,t,n)};j().prototype.exp=function(){return this.throwIfDisposed(),gn(this)};j().prototype.expandDims=function(t){return this.throwIfDisposed(),an(this,t)};j().prototype.expm1=function(){return this.throwIfDisposed(),nb(this)};j().prototype.fft=function(){return this.throwIfDisposed(),Nu(this)};j().prototype.flatten=function(){return this.throwIfDisposed(),U(this,[this.size])};j().prototype.floor=function(){return this.throwIfDisposed(),sa(this)};j().prototype.floorDiv=function(t){return this.throwIfDisposed(),um(this,t)};j().prototype.gather=function(t,n,e){return this.throwIfDisposed(),ia(this,t,n,e)};j().prototype.greaterEqual=function(t){return this.throwIfDisposed(),fo(this,t)};j().prototype.greater=function(t){return this.throwIfDisposed(),En(this,t)};j().prototype.ifft=function(){return this.throwIfDisposed(),Ml(this)};j().prototype.irfft=function(){return this.throwIfDisposed(),Bm(this)};j().prototype.isFinite=function(){return this.throwIfDisposed(),rb(this)};j().prototype.isInf=function(){return this.throwIfDisposed(),ob(this)};j().prototype.isNaN=function(){return this.throwIfDisposed(),sb(this)};j().prototype.leakyRelu=function(t){return this.throwIfDisposed(),vu(this,t)};j().prototype.lessEqual=function(t){return this.throwIfDisposed(),Qo(this,t)};j().prototype.less=function(t){return this.throwIfDisposed(),_l(this,t)};j().prototype.localResponseNormalization=function(t,n,e,r){return this.throwIfDisposed(),ib(this,t,n,e,r)};j().prototype.logSigmoid=function(){return this.throwIfDisposed(),ab(this)};j().prototype.logSoftmax=function(t){return this.throwIfDisposed(),Em(this,t)};j().prototype.logSumExp=function(t,n){return this.throwIfDisposed(),wu(this,t,n)};j().prototype.log=function(){return this.throwIfDisposed(),mr(this)};j().prototype.log1p=function(){return this.throwIfDisposed(),bu(this)};j().prototype.logicalAnd=function(t){return this.throwIfDisposed(),Pr(this,t)};j().prototype.logicalNot=function(){return this.throwIfDisposed(),Cu(this)};j().prototype.logicalOr=function(t){return this.throwIfDisposed(),Nm(this,t)};j().prototype.logicalXor=function(t){return this.throwIfDisposed(),lb(this,t)};j().prototype.matMul=function(t,n,e){return this.throwIfDisposed(),ct(this,t,n,e)};j().prototype.maxPool=function(t,n,e,r){return this.throwIfDisposed(),Iu(this,t,n,e,r)};j().prototype.max=function(t,n){return this.throwIfDisposed(),hr(this,t,n)};j().prototype.maximum=function(t){return this.throwIfDisposed(),Fo(this,t)};j().prototype.mean=function(t,n){return this.throwIfDisposed(),ln(this,t,n)};j().prototype.min=function(t,n){return this.throwIfDisposed(),kl(this,t,n)};j().prototype.minimum=function(t){return this.throwIfDisposed(),Is(this,t)};j().prototype.mirrorPad=function(t,n){return this.throwIfDisposed(),pb(this,t,n)};j().prototype.mod=function(t){return this.throwIfDisposed(),fb(this,t)};j().prototype.mul=function(t){return this.throwIfDisposed(),z(this,t)};j().prototype.neg=function(){return this.throwIfDisposed(),ft(this)};j().prototype.norm=function(t,n,e){return this.throwIfDisposed(),Al(this,t,n,e)};j().prototype.notEqual=function(t){return this.throwIfDisposed(),gi(this,t)};j().prototype.oneHot=function(t,n=1,e=0){return this.throwIfDisposed(),af(this,t,n,e)};j().prototype.onesLike=function(){return this.throwIfDisposed(),cr(this)};j().prototype.pad=function(t,n){return this.throwIfDisposed(),ho(this,t,n)};j().prototype.pool=function(t,n,e,r,o,s){return this.throwIfDisposed(),db(this,t,n,e,r,o,s)};j().prototype.pow=function(t){return this.throwIfDisposed(),Lr(this,t)};j().prototype.prelu=function(t){return this.throwIfDisposed(),Tu(this,t)};j().prototype.prod=function(t,n){return this.throwIfDisposed(),hb(this,t,n)};j().prototype.reciprocal=function(){return this.throwIfDisposed(),vb(this)};j().prototype.relu=function(){return this.throwIfDisposed(),Nr(this)};j().prototype.relu6=function(){return this.throwIfDisposed(),km(this)};j().prototype.reshapeAs=function(t){return this.throwIfDisposed(),U(this,t.shape)};j().prototype.reshape=function(t){return this.throwIfDisposed(),U(this,t)};j().prototype.resizeBilinear=function(t,n,e){return this.throwIfDisposed(),Lb(this,t,n,e)};j().prototype.resizeNearestNeighbor=function(t,n,e){return this.throwIfDisposed(),Pb(this,t,n,e)};j().prototype.reverse=function(t){return this.throwIfDisposed(),Jn(this,t)};j().prototype.rfft=function(){return this.throwIfDisposed(),Du(this)};j().prototype.round=function(){return this.throwIfDisposed(),Am(this)};j().prototype.rsqrt=function(){return this.throwIfDisposed(),_m(this)};j().prototype.selu=function(){return this.throwIfDisposed(),Rm(this)};j().prototype.separableConv2d=function(t,n,e,r,o,s){return this.throwIfDisposed(),Mm(this,t,n,e,r,o,s)};j().prototype.sigmoid=function(){return this.throwIfDisposed(),Tr(this)};j().prototype.sign=function(){return this.throwIfDisposed(),bb(this)};j().prototype.sin=function(){return this.throwIfDisposed(),Fm(this)};j().prototype.sinh=function(){return this.throwIfDisposed(),$m(this)};j().prototype.slice=function(t,n){return this.throwIfDisposed(),Ue(this,t,n)};j().prototype.softmax=function(t){return this.throwIfDisposed(),Eu(this,t)};j().prototype.softplus=function(){return this.throwIfDisposed(),mi(this)};j().prototype.spaceToBatchND=function(t,n){return this.throwIfDisposed(),Su(this,t,n)};j().prototype.split=function(t,n){return this.throwIfDisposed(),er(this,t,n)};j().prototype.sqrt=function(){return this.throwIfDisposed(),Wt(this)};j().prototype.square=function(){return this.throwIfDisposed(),lt(this)};j().prototype.squaredDifference=function(t){return this.throwIfDisposed(),zm(this,t)};j().prototype.squeeze=function(t){return this.throwIfDisposed(),Zt(this,t)};j().prototype.stack=function(t,n){this.throwIfDisposed();let e=t instanceof ot?[this,t]:[this,...t];return Nn(e,n)};j().prototype.step=function(t){return this.throwIfDisposed(),Vs(this,t)};j().prototype.stridedSlice=function(t,n,e,r,o,s,i,a){return this.throwIfDisposed(),Cb(this,t,n,e,r,o,s,i,a)};j().prototype.sub=function(t){return this.throwIfDisposed(),Ie(this,t)};j().prototype.sum=function(t,n){return this.throwIfDisposed(),Ne(this,t,n)};j().prototype.tan=function(){return this.throwIfDisposed(),Ib(this)};j().prototype.tanh=function(){return this.throwIfDisposed(),hi(this)};j().prototype.tile=function(t){return this.throwIfDisposed(),Er(this,t)};j().prototype.toBool=function(){return this.throwIfDisposed(),fe(this,"bool")};j().prototype.toFloat=function(){return this.throwIfDisposed(),fe(this,"float32")};j().prototype.toInt=function(){return this.throwIfDisposed(),fe(this,"int32")};j().prototype.topk=function(t,n){return this.throwIfDisposed(),Tb(this,t,n)};j().prototype.transpose=function(t){return this.throwIfDisposed(),ut(this,t)};j().prototype.unique=function(t){return this.throwIfDisposed(),Eb(this,t)};j().prototype.unsortedSegmentSum=function(t,n){return this.throwIfDisposed(),Gm(this,t,n)};j().prototype.unstack=function(t){return this.throwIfDisposed(),tr(this,t)};j().prototype.where=function(t,n){return this.throwIfDisposed(),sn(t,this,n)};j().prototype.zerosLike=function(){return this.throwIfDisposed(),Ge(this)};var Ss=class t extends Error{constructor(n){super(n),Object.setPrototypeOf(this,t.prototype)}},mo=class t extends Error{constructor(n){super(n),Object.setPrototypeOf(this,t.prototype)}},Y=class t extends Error{constructor(n){super(n),Object.setPrototypeOf(this,t.prototype)}},Ze=class t extends Error{constructor(n){super(n),Object.setPrototypeOf(this,t.prototype)}},qb=class t extends Error{constructor(n){super(n),Object.setPrototypeOf(this,t.prototype)}};var F1=class{constructor(n){this.maxEntries=n||100,this.cache=new Map}get(n){let e;return this.cache.has(n)&&(e=this.cache.get(n),this.cache.delete(n),this.cache.set(n,e)),e}put(n,e){if(this.cache.has(n))this.cache.delete(n);else if(this.cache.size>=this.maxEntries){let r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(n,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(n){if(n<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${n}.`);if(this.maxEntries>n)for(let e=0;e<this.maxEntries-n;e++){let r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=n}};function js(t,n){if(Array.isArray(t)){let e=[];for(let r=0;r<n;r++)e=e.concat(t);return e}else{let e=new Array(n);return e.fill(t),e}}function Ts(t,n){if(!t)throw new qb(n)}function nD(t,n){let e=0;for(let r of t)r===n&&e++;return e}function yr(t){return t.length===1?t[0]:t}function Lt(t){return Array.isArray(t)?t:[t]}function Hs(t){let e=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return e[0]!=="_"?e:"private"+e}function $l(t){return t.length<=1||t.indexOf("_")===-1?t:t.replace(/[_]+(\w|$)/g,(n,e)=>e.toUpperCase())}var Gs={};function Zm(t){if(t==null)return null;let n={};return n.className=t.getClassName(),n.config=t.getConfig(),n}function tD(t){if(!(t==null||typeof t!="object"))if(Array.isArray(t))t.forEach(n=>tD(n));else{let n=Object.keys(t);for(let e of n){let r=t[e];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?t[e]=r.value:tD(r))}}}function la(t,n={},e={},r="object",o=!1){if(typeof t=="string"){let s=t,i;if(s in e)i=e[s];else if(s in Gs)i=Gs[s];else if(i=n[s],i==null)throw new Y(`Unknown ${r}: ${t}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{let s=t;if(s.className==null||s.config==null)throw new Y(`${r}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);let i=s.className,a,l;if(i in e?[a,l]=e[i]:i in Gs?[a,l]=Gs.className:i in n&&([a,l]=n[i]),a==null)throw new Y(`Unknown ${r}: ${i}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){let c={};for(let d of Object.keys(Gs))c[d]=Gs[d];for(let d of Object.keys(e))c[d]=e[d];let u=s.config;u.customObjects=c;let p=Object.assign({},Gs);for(let d of Object.keys(e))Gs[d]=e[d];tD(s.config);let f=l(a,s.config,e,o);return Gs=Object.assign({},p),f}else{let c=Object.assign({},Gs);for(let p of Object.keys(e))Gs[p]=e[p];let u=new a(s.config);return Gs=Object.assign({},c),u}}}function vce(t,n){return t<n?-1:t>n?1:0}function $1(t,n){return-1*vce(t,n)}function Ws(t){if(t==null)return t;let n=[];for(let e of t)n.indexOf(e)===-1&&n.push(e);return n}function U5(t){if(t==null)throw new Y(`Invalid value in obj: ${JSON.stringify(t)}`);for(let n in t)if(t.hasOwnProperty(n))return!1;return!0}function ca(t,n,e){if(e!=null&&t.indexOf(e)<0)throw new Y(`${e} is not a valid ${n}.  Valid values are ${t} or null/undefined.`)}function Kb(t,n,e=0,r=1/0){return Ts(e>=0),Ts(r>=e),Array.isArray(t)&&t.length>=e&&t.length<=r&&t.every(o=>typeof o===n)}function Bn(t,n){Array.isArray(t)?(b.assert(t.length>0,()=>`${n} is unexpectedly an empty array.`),t.forEach((e,r)=>Bn(e,`element ${r+1} of ${n}`))):b.assert(Number.isInteger(t)&&t>0,()=>`Expected ${n} to be a positive integer, but got ${G5(t)}.`)}function G5(t){return t===null?"null":Array.isArray(t)?"["+t.map(n=>G5(n)).join(",")+"]":typeof t=="string"?`"${t}"`:`${t}`}function j5(t,n,e){let r=e!=null?e():b.now(),o;return(...i)=>{let a=e!=null?e():b.now();return a-r<n||(r=a,o=t(...i)),o}}function Xb(t){return t==="relu"?"relu":t==="linear"?"linear":t==="elu"?"elu":null}var bce=0;function Zb(){return bce++}var Yb={};function _u(t=""){return t in Yb||(Yb[t]=0),Yb[t]+=1,t+Yb[t].toString()}var H5=["channelsFirst","channelsLast"],W5=["nearest","bilinear"],q5=["valid","same","causal"],K5=["max","avg"],X5=["sum","mul","concat","ave"];var Qm=new Map;function wn(t){ca(H5,"DataFormat",t)}function Z5(t){ca(W5,"InterpolationFormat",t)}function go(t){ca(q5,"PaddingMode",t)}function rD(t){ca(K5,"PoolMode",t)}var L1=[],Y5="/";function vi(t,n){L1.push(t);try{let e=n();return L1.pop(),e}catch(e){throw L1.pop(),e}}function wce(){return L1.length===0?"":L1.join(Y5)+Y5}function Qb(t){if(!Q5(t))throw new Error("Not a valid tensor name: '"+t+"'");return wce()+t}function Jb(t){if(!Q5(t))throw new Error("Not a valid tensor name: '"+t+"'");Qm.has(t)||Qm.set(t,0);let n=Qm.get(t);if(Qm.set(t,Qm.get(t)+1),n>0){let e=`${t}_${n}`;return Qm.set(e,1),e}else return t}var Cce=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function Q5(t){return!!t.match(Cce)}function J5(t){return t===parseInt(t.toString(),10)}function qs(t,n,e){n==null&&(n=0),e==null&&(e=t.length);let r=1;for(let o=n;o<e;++o)r*=t[o];return r}function xf(t){if(t.length===0)return Number.NaN;let n=Number.POSITIVE_INFINITY;for(let e=0;e<t.length;e++){let r=t[e];r<n&&(n=r)}return n}function bi(t){if(t.length===0)return Number.NaN;let n=Number.NEGATIVE_INFINITY;for(let e=0;e<t.length;e++){let r=t[e];r>n&&(n=r)}return n}function yo(t,n){if(n<t)throw new Y(`end (${n}) < begin (${t}) is forbidden.`);let e=[];for(let r=t;r<n;++r)e.push(r);return e}var oD;function Kn(){return oD==null&&(oD=bv().epsilon()),oD}function xo(){return"channelsLast"}function to(t,n){return fe(t,n)}function Pl(t,n=-1){let e=t.shape.slice();return n<0&&(n=e.length+n+1),e.splice(n,0,1),U(t,e)}function e8(t,n){return X(()=>{if(t.shape.length!==2)throw new Y(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);let e=Pl(t,1);return tw(e,[1,n,1])})}function t8(t){let n=[qs(t.shape)];return U(t,n)}function n8(t){if(t.rank<=1)throw new Y(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);let n=[t.shape[0],qs(t.shape,1)];return U(t,n)}function Ll(t,n,e){return X(()=>{switch(t.rank){case 1:return Lm(t,n,e);case 2:return k1(t,[n,0],[e,t.shape[1]]);case 3:return Pm(t,[n,0,0],[e,t.shape[1],t.shape[2]]);case 4:return pf(t,[n,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3]]);case 5:return Ue(t,[n,0,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return Ue(t,[n,0,0,0,0,0],[e,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new Y(`sliceAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}})}function sD(t,n,e){return X(()=>{switch(t.rank){case 1:return Lm(t,n,e);case 2:return k1(t,[0,n],[t.shape[0],e]);case 3:return Pm(t,[0,0,n],[t.shape[0],t.shape[1],e]);case 4:return pf(t,[0,0,0,n],[t.shape[0],t.shape[1],t.shape[2],e]);default:throw new Y(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function P1(t,n,e,r){return X(()=>{switch(t.rank){case 1:return Lm(t,n,e);case 2:switch(r){case 1:return Ll(t,n,e);case 2:return sD(t,n,e);default:throw new Y(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Ll(t,n,e);case 2:return Pm(t,[0,n,0],[t.shape[0],e,t.shape[2]]);case 3:return sD(t,n,e);default:throw new Y(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Ll(t,n,e);case 2:return pf(t,[0,n,0,0],[t.shape[0],e,t.shape[2],t.shape[3]]);case 3:return pf(t,[0,0,n,0],[t.shape[0],t.shape[1],e,t.shape[3]]);case 4:return sD(t,n,e);default:throw new Y(`The axis is not within the rank of the tensor ${r}`)}default:throw new Y(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function Jm(t,n=-1){let e;return n<0&&(e=t[0].rank,e!==0?n=e:n=0),n===t[0].rank&&(n=-1),Et(t,n)}function aD(t,n){switch(t.rank){case 1:return jv([t,n]);case 2:return Hv([t,n],0);case 3:return Wv([t,n],0);case 4:return qv([t,n],0);default:throw new Y(`concatAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}}function tw(t,n){if(Array.isArray(n)||(n=[n]),t.rank!==n.length)throw new Y(`The length of input n (${n.length}) does not match the number of dimensions in input x (${t.rank})`);return Er(t,n)}function eg(t,n=0,e=1,r,o){return uf(t,n,e,r,o)}function Ks(t,n,e,r){if(t.rank<2||n.rank<2)throw new Ze(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${n.shape}`);if(n.rank>=3){let o=t.shape.slice(-1)[0],s=n.shape.slice(-2)[0];if(o!==s)throw new Ze(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = ${n.shape}`)}if(t.rank===2&&n.rank===2)return ku.matMul({a:t,b:n,transposeA:!1,transposeB:!1,bias:r?iD(t.rank,r,xo()):null,activation:e});{let o=t.shape.slice(),s=o.pop();t=U(t,[-1,s]);let i=n.shape.slice(),a=i.pop(),l=i.pop(),c=[...i,a],u=Array.from({length:n.rank},(h,g)=>g===0?n.rank-2:g<=n.rank-2?g-1:g);n=U(ut(n,u),[l,-1]);let p=[...o,...c];return U(ku.matMul({a:t,b:n,transposeA:!1,transposeB:!1,bias:r?iD(t.rank,r,xo()):null,activation:e}),p)}}function nw(t,n,e){return X(()=>(Array.isArray(n)?n=qt(n,"int32"):n=fe(n,"int32"),ia(t,n,e)))}function vf(t){return z(t,t)}function iD(t,n,e){let r=n.shape;if(n.rank!==1&&n.rank!==t)throw new Y(`Unexpected bias dimensions: ${n.rank}; expected it to be 1 or ${t}`);if(t===5){if(e==="channelsFirst")return r.length===1?U(n,[1,r[0],1,1,1]):U(n,[1,r[3],r[0],r[1],r[2]]);if(e==="channelsLast")return r.length===1?U(n,[1,1,1,1,r[0]]):U(n,[1].concat(r))}else if(t===4){if(e==="channelsFirst")return r.length===1?U(n,[1,r[0],1,1]):U(n,[1,r[2],r[0],r[1]]);if(e==="channelsLast")return r.length===1?U(n,[1,1,1,r[0]]):U(n,[1].concat(r))}else if(t===3){if(e==="channelsFirst")return r.length===1?U(n,[1,r[0],1]):U(n,[1,r[1],r[0]]);if(e==="channelsLast")return r.length===1?U(n,[1,1,r[0]]):U(n,[1].concat(r))}else if(t<3)return n;throw new Y(`Unsupported input rank by biasAdd: ${n.rank}`)}function vo(t,n,e){return X(()=>(e==null&&(e=xo()),wn(e),le(t,iD(t.rank,n,e))))}function r8(t,n=1){if(n!==1)throw new Ze(`Support for alpha values other than 1 (${n}) is not implemented yet.`);return oa(t)}function o8(t){return X(()=>ve(t,le(hn(t),1)))}function rw(t,n,e,r){return X(()=>RN(t,n,e,r))}function s8(t){return X(()=>{let n=le(.5,z(.2,t));return Qn(n,0,1)})}function Ru(t,n,e=!1){return e?t():n()}var i8=["fanIn","fanOut","fanAvg"],a8=["normal","uniform","truncatedNormal"];function Ice(t){ca(i8,"FanMode",t)}function Sce(t){ca(a8,"Distribution",t)}var bo=class extends de.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},u8=(()=>{class t extends bo{apply(e,r){return cn(e,r)}}return t.className="Zeros",t})();de.registerClass(u8);var ow=(()=>{class t extends bo{apply(e,r){return jn(e,r)}}return t.className="Ones",t})();de.registerClass(ow);var p8=(()=>{class t extends bo{constructor(e){if(super(),typeof e!="object")throw new Y(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new Y(`config must have value set but got ${e}`);this.value=e.value}apply(e,r){return X(()=>z(Ee(this.value),jn(e,r)))}getConfig(){return{value:this.value}}}return t.className="Constant",t})();de.registerClass(p8);var f8=(()=>{class t extends bo{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,r){return Jo(e,this.minval,this.maxval,r,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}return t.className="RandomUniform",t})();de.registerClass(f8);var d8=(()=>{class t extends bo{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if(r=r||"float32",r!=="float32"&&r!=="int32")throw new Ze(`randomNormal does not support dType ${r}.`);return eg(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return t.className="RandomNormal",t})();de.registerClass(d8);var h8=(()=>{class t extends bo{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,r){if(r=r||"float32",r!=="float32"&&r!=="int32")throw new Ze(`truncatedNormal does not support dType ${r}.`);return Um(e,this.mean,this.stddev,r,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return t.className="TruncatedNormal",t})();de.registerClass(h8);var m8=(()=>{class t extends bo{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,r){return X(()=>{if(e.length!==2||e[0]!==e[1])throw new Y("Identity matrix initializer can only be used for 2D square matrices.");return z(this.gain,of(e[0]))})}getConfig(){return{gain:this.gain}}}return t.className="Identity",t})();de.registerClass(m8);function Tce(t,n="channelsLast"){let e,r;if(wn(n),t.length===2)e=t[0],r=t[1];else if([3,4,5].indexOf(t.length)!==-1){if(n==="channelsFirst"){let o=qs(t,2);e=t[1]*o,r=t[0]*o}else if(n==="channelsLast"){let o=qs(t,0,t.length-2);e=t[t.length-2]*o,r=t[t.length-1]*o}}else{let o=qs(t);e=Math.sqrt(o),r=Math.sqrt(o)}return[e,r]}var ts=(()=>{class t extends bo{constructor(e){if(super(),e.scale<0)throw new Y(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,Ice(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,Sce(this.distribution),this.seed=e.seed}apply(e,r){let o=Tce(e),s=o[0],i=o[1],a=this.scale;if(this.mode==="fanIn"?a/=Math.max(1,s):this.mode==="fanOut"?a/=Math.max(1,i):a/=Math.max(1,(s+i)/2),this.distribution==="normal"){let l=Math.sqrt(a);if(r=r||"float32",r!=="float32"&&r!=="int32")throw new Ze(`${this.getClassName()} does not support dType ${r}.`);return Um(e,0,l,r,this.seed)}else{let l=Math.sqrt(3*a);return Jo(e,-l,l,r,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}return t.className="VarianceScaling",t})();de.registerClass(ts);var lD=(()=>{class t extends ts{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return ts.className}}return t.className="GlorotUniform",t})();de.registerClass(lD);var cD=(()=>{class t extends ts{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return ts.className}}return t.className="GlorotNormal",t})();de.registerClass(cD);var uD=(()=>{class t extends ts{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return ts.className}}return t.className="HeNormal",t})();de.registerClass(uD);var pD=(()=>{class t extends ts{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return ts.className}}return t.className="HeUniform",t})();de.registerClass(pD);var fD=(()=>{class t extends ts{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return ts.className}}return t.className="LeCunNormal",t})();de.registerClass(fD);var dD=(()=>{class t extends ts{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return ts.className}}return t.className="LeCunUniform",t})();de.registerClass(dD);var g8=(()=>{class t extends bo{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,r){return X(()=>{if(e.length<2)throw new Ze("Shape must be at least 2D.");if(r!=="int32"&&r!=="float32"&&r!==void 0)throw new TypeError(`Unsupported data type ${r}.`);r=r;let o=b.sizeFromShape(e.slice(0,-1)),s=e[e.length-1],i=o*s;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);let a=[Math.max(s,o),Math.min(s,o)],l=eg(a,0,1,r,this.seed),c=FN.qr(l,!1),u=c[0],f=c[1].flatten().stridedSlice([0],[Math.min(s,o)*Math.min(s,o)],[Math.min(s,o)+1]);return u=z(u,f.sign()),o<s&&(u=u.transpose()),z(Ee(this.gain),u.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}return t.className="Orthogonal",t})();de.registerClass(g8);var l8={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function c8(t,n={}){return la(t,de.SerializationMap.getMap().classNameMap,n,"initializer")}function un(t){return Zm(t)}function Kt(t){if(typeof t=="string"){let n=t in l8?l8[t]:t;if(n==="GlorotNormal")return new cD;if(n==="GlorotUniform")return new lD;if(n==="HeNormal")return new uD;if(n==="HeUniform")return new pD;if(n==="LeCunNormal")return new fD;if(n==="LeCunUniform")return new dD;{let e={};return e.className=n,e.config={},c8(e)}}else return t instanceof bo?t:c8(t)}function sw(t){return Array.isArray(t)&&Array.isArray(t[0])}function tg(t){return t.length===0?[]:Array.isArray(t[0])?t:[t]}function He(t){let n;if(Array.isArray(t)){if(t.length!==1)throw new Y(`Expected Tensor length to be 1; got ${t.length}`);n=t[0]}else n=t;return n}function at(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(t.length===1)return t=t,t[0];throw new Y(`Expected exactly 1 Shape; got ${t.length}`)}else return t}function ng(t){let n=0;for(let e of t)e.shape.length===0?n+=1:n+=e.shape.reduce((r,o)=>r*o);return n}var x8="Variable",B1=class{constructor(n,e="float32",r=x8,o=!0,s=null){this.dtype=e??"float32",this.shape=n.shape,this.id=Zb(),r=r??x8,this.originalName=Qb(r),this.name=Jb(this.originalName),this.trainable_=o,this.constraint=s,this.val=Nb(n,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(n){return this.assertNotDisposed(),Nce(this.val,n),this.val.id!==n.id&&(this.val.assign(n),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(n){this.trainable_=n,this.val.trainable=n}};function Nce(t,n){if(t.shape.toString()!==n.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(n.shape))}function z1(t){return t.map(n=>n.read())}function rg(t){t.forEach(n=>{n[0].write(n[1])})}var Qt=class{constructor(n){this.dtype=n.dtype,this.shape=n.shape,n.shape!=null?this.ndim=n.shape.length:this.ndim=n.ndim,this.maxNDim=n.maxNDim,this.minNDim=n.minNDim,this.axes=n.axes||{}}},no=class{constructor(n,e,r,o,s,i,a){this.dtype=n,this.shape=e,this.sourceLayer=r,this.inputs=o,this.callArgs=s,this.outputTensorIndex=a,this.id=Zb(),i!=null&&(this.originalName=Qb(i),this.name=Jb(this.originalName)),this.rank=e.length}},Dce=0,Bl=class{constructor(n,e){this.callArgs=e,this.id=Dce++,this.outboundLayer=n.outboundLayer,this.inboundLayers=n.inboundLayers,this.nodeIndices=n.nodeIndices,this.tensorIndices=n.tensorIndices,this.inputTensors=n.inputTensors,this.outputTensors=n.outputTensors,this.inputMasks=n.inputMasks,this.outputMasks=n.outputMasks,this.inputShapes=n.inputShapes,this.outputShapes=n.outputShapes;for(let r of n.inboundLayers)r?.outboundNodes.push(this);n.outboundLayer.inboundNodes.push(this)}getConfig(){let n=[];for(let e of this.inboundLayers)e!=null?n.push(e.name):n.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:n,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},kce=0,Qe=class extends de.Serializable{constructor(n={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=kce++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=n.name;if(!e){let r=this.getClassName();e=Hs(r)+"_"+_u(r)}if(this.name=e,this.trainable_=n.trainable==null?!0:n.trainable,n.inputShape!=null||n.batchInputShape!=null){let r;if(n.batchInputShape!=null)r=n.batchInputShape;else if(n.inputShape!=null){let s=null;n.batchSize!=null&&(s=n.batchSize),r=[s].concat(n.inputShape)}this.batchInputShape=r;let o=n.dtype;o==null&&(o=n.inputDType),o==null&&(o="float32"),this.dtype=o}n.weights!=null?this.initialWeights=n.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(n,e){return n.name+"_ib-"+e.toString()}getNodeAtIndex(n,e){if(this.inboundNodes.length===0)throw new mo(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=n)throw new Y(`Asked to get ${e} at node ${n}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[n]}getInputAt(n){return yr(this.getNodeAtIndex(n,"input").inputTensors)}getOutputAt(n){return yr(this.getNodeAtIndex(n,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Ss(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Ss(`Layer ${this.name} is not connected, no input to return.`);return yr(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Ss(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Ss(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return yr(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(n=>n())}get updates(){return this._updates}get built(){return this._built}set built(n){this._built=n}get trainable(){return this.trainable_}set trainable(n){this._trainableWeights.forEach(e=>e.trainable=n),this.trainable_=n}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(n=>n.trainable):[]}set trainableWeights(n){this._trainableWeights=n}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(n=>!n.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(n){this._nonTrainableWeights=n}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(n){let e=Lt(n);if(this.inputSpec==null||this.inputSpec.length===0)return;let r=Lt(this.inputSpec);if(e.length!==r.length)throw new Y(`Layer ${this.name} expects ${r.length} inputs, but it received ${e.length} input tensors. Input received: ${n}`);for(let o=0;o<e.length;o++){let s=e[o],i=r[o];if(i==null)continue;let a=s.rank;if(i.ndim!=null&&a!==i.ndim)throw new Y(`Input ${o} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${a}`);if(i.maxNDim!=null&&a>i.maxNDim)throw new Y(`Input ${o} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${a}`);if(i.minNDim!=null&&a<i.minNDim)throw new Y(`Input ${o} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${a}.`);if(i.dtype!=null&&s.dtype!==i.dtype)throw new Y(`Input ${o} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${s.dtype}.`);if(i.axes){let l=s.shape;for(let c in i.axes){let u=Number(c),p=i.axes[c],f=u>=0?l[u]:l[l.length+u];if(p!=null&&[p,null].indexOf(f)===-1)throw new Y(`Input ${o} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${p} but got shape ${l}.`)}}if(i.shape!=null)for(let l=0;l<i.shape.length;++l){let c=i.shape[l],u=s.shape[l];if(c!=null&&u!=null&&c!==u)throw new Y(`Input ${o} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${s.shape}.`)}}}call(n,e){return n}invokeCallHook(n,e){this._callHook!=null&&this._callHook(n,e)}setCallHook(n){this._callHook=n}clearCallHook(){this._callHook=null}apply(n,e){e=e||{},this.assertNotDisposed();let r=Lt(n),o=Rce(n),s=Mce(n);if(o===s)throw new Y("Arguments to apply() must be all SymbolicTensors or all Tensors");return vi(this.name,()=>{if(!this.built){this.assertInputCompatibility(n);let i=[];for(let a of Lt(n))i.push(a.shape);this.build(yr(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&s&&(this._refCount=1)}if(this.assertInputCompatibility(n),s){let i=this.call(n,e);this.supportsMasking&&this.setMaskMetadata(n,i);let a=Lt(i),l=[];for(let c of a)r.indexOf(c)!==-1&&(c=c.clone()),l.push(c);if(i=yr(l),this.activityRegularizer!=null)throw new Ze("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}else{let i=Ace(n),a=this.computeOutputShape(i),l,c=_ce(n);if(this.warnOnIncompatibleInputShape(Array.isArray(n)?i[0]:i),a!=null&&a.length>0&&Array.isArray(a[0])?l=a.map((u,p)=>new no(c,u,this,Lt(n),e,this.name,p)):l=new no(c,a,this,Lt(n),e,this.name),this.addInboundNode(n,l,null,null,i,a,e),this._refCount++,this.activityRegularizer!=null)throw new Ze("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(n){if(this.batchInputShape!=null)if(n.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(n)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((r,o)=>{r!=null&&n[o]!=null&&n[o]!==r&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(n)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Ss(`The layer ${this.name} has never been called and thus has no defined output shape.`);let n=[];for(let e of this.inboundNodes){let r=JSON.stringify(e.outputShapes);n.indexOf(r)===-1&&n.push(r)}if(n.length===1){let e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&e.length===1?e[0]:e}else throw new Ss(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new mo(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return ng(this.weights)}build(n){this.built=!0}getWeights(n=!1){return z1(n?this.trainableWeights:this.weights)}setWeights(n){X(()=>{let e=this.weights;if(e.length!==n.length)throw new Y(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${n.length}, but the layer was expecting ${e.length} weights. Provided weights: ${n}...`);if(e.length===0)return;let r=[],o=z1(e);for(let s=0;s<o.length;++s){let i=o[s],a=e[s],l=n[s];if(!b.arraysEqual(i.shape,l.shape))throw new Y(`Layer weight shape ${i.shape} not compatible with provided weight shape ${l.shape}`);r.push([a,l])}rg(r)})}addWeight(n,e,r,o,s,i,a,l){if(this._addedWeightNames.indexOf(n)!==-1)throw new Y(`Duplicate weight name ${n} for layer ${this.name}`);this._addedWeightNames.push(n),r==null&&(r="float32"),this.fastWeightInitDuringBuild&&(o=l!=null?l():Kt("zeros"));let c=o.apply(e,r),u=new B1(c,r,n,i,a);return c.dispose(),s!=null&&this.addLoss(()=>s.apply(u.read())),i==null&&(i=!0),i?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(n){this.fastWeightInitDuringBuild=n}addLoss(n){n==null||Array.isArray(n)&&n.length===0||(n=Lt(n),this._losses!==void 0&&this._losses!==null&&this.losses.push(...n))}computeOutputShape(n){return n}computeMask(n,e){if(!this.supportsMasking){if(e!=null)if(Array.isArray(e))e.forEach(r=>{if(r!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return e}setMaskMetadata(n,e,r){if(!this.supportsMasking)return;let o=this.computeMask(n,r),s=Lt(e),i=Lt(o);if(s.length!==i.length)throw new Error(`${this.name} outputs ${s.length} tensors but ${s.length} masks for those tensors`);for(let a=0;a<s.length;a++)s[a].kerasMask=i[a]}addInboundNode(n,e,r,o,s,i,a=null){let l=Lt(n);e=Lt(e),r=Lt(r),o=Lt(o),s=tg(s),i=tg(i);let c=[],u=[],p=[];for(let f of l)c.push(f.sourceLayer),u.push(f.nodeIndex),p.push(f.tensorIndex);new Bl({outboundLayer:this,inboundLayers:c,nodeIndices:u,tensorIndices:p,inputTensors:l,outputTensors:e,inputMasks:r,outputMasks:o,inputShapes:s,outputShapes:i},a);for(let f=0;f<e.length;f++)e[f].sourceLayer=this,e[f].nodeIndex=this.inboundNodes.length-1,e[f].tensorIndex=f}getConfig(){let n={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(n.batchInputShape=this.batchInputShape),this.dtype!=null&&(n.dtype=this.dtype),n}disposeWeights(){return this.weights.forEach(n=>n.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let n=0;return--this._refCount===0&&(n=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:n}}};function Ace(t){t=Lt(t);let n=[];for(let e of t)n.push(e.shape);return yr(n)}function _ce(t){return"float32"}function hD(t,n,e){if((n==null||e!=null&&e>0)&&(n=t.sourceLayer,e=t.nodeIndex),n.inboundNodes.length===0)return[t];{let r=n.inboundNodes[e];if(r.inboundLayers.length===0)return r.inputTensors;{let o=[];for(let s=0;s<r.inboundLayers.length;s++){let i=r.inputTensors[s],a=r.inboundLayers[s],l=r.nodeIndices[s],c=hD(i,a,l);for(let u of c)o.indexOf(u)===-1&&o.push(u)}return o}}}function Rce(t){let n=!0;for(let e of Lt(t))if(!(e instanceof no)){n=!1;break}return n}function Mce(t){let n=!0;for(let e of Lt(t))if(e instanceof no){n=!1;break}return n}var bf=(()=>{class t extends Qe{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:_u("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new Y("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let r=e.batchInputShape;if(r==null){if(e.inputShape==null)throw new Y("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");r=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new Y("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let o=e.dtype||"float32";this.batchInputShape=r,this.dtype=o,this.inputSpec=[{shape:r}];let s=new no(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new Bl({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[r],outputShapes:[r]})}apply(e,r){throw new Y(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}return t.className="InputLayer",t})();de.registerClass(bf);function mD(t){if(t.batchShape==null&&t.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(t.batchShape!=null&&t.shape!=null)throw new Y("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let n=t.batchShape;t.shape!=null&&n==null&&(n=[null].concat(t.shape));let e=t.dtype;return e==null&&(e="float32"),new bf({batchInputShape:n,name:t.name,dtype:e,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}function Oce(t,n){if(t.dtype==null||t.dtype===n.dtype)return n;try{return fe(n,t.dtype)}catch(e){throw new Y(`The dtype of the feed (${n.dtype}) can not be cast to the dtype of the key '${t.name}' (${t.dtype}).`)}}var ua=class t{constructor(n){if(this.id2Value={},this.id2Mask={},this.name2Id={},n instanceof t)for(let e in n.id2Value)this.id2Value[e]=n.id2Value[e],e in n.id2Mask&&(this.id2Mask[e]=n.id2Mask[e]);else{if(n==null)return;for(let e of n)this.add(e.key,e.value)}}add(n,e,r){if(this.id2Value[n.id]==null)this.id2Value[n.id]=Oce(n,e),this.name2Id[n.name]=n.id,r!=null&&(this.id2Mask[n.id]=r);else throw new Y(`Duplicate key: name=${n.name}, id=${n.id}`);return this}addFeed(n){this.add(n.key,n.value)}hasKey(n){return this.id2Value[n.id]!=null}names(){return Object.keys(this.name2Id)}getValue(n){if(n instanceof no){if(this.id2Value[n.id]==null)throw new Y(`Nonexistent key: ${n.name}`);return this.id2Value[n.id]}else{let e=this.name2Id[n];if(e==null)throw new Y(`Feed dict has no SymbolicTensor name: ${n}`);return this.id2Value[e]}}getMask(n){if(n instanceof no){if(this.id2Value[n.id]==null)throw new Y(`Nonexistent key: ${n.name}`);return this.id2Mask[n.id]}else{let e=this.name2Id[n];if(e==null)throw new Y(`Feed dict has no SymbolicTensor name: ${n}`);return this.id2Mask[e]}}disposeMasks(){this.id2Mask!=null&&Ve(this.id2Mask)}},iw=new F1,aw=new F1;function b8(t){iw?.setMaxEntries(t),aw?.setMaxEntries(t)}function wf(t,n,e,r){let o=e==null?!1:e.training,s=Array.isArray(t),i=s?t:[t],a=i.map(h=>h.name),l=[],c=n.names();for(let h of a)c.indexOf(h)!==-1?l.push(n.getValue(h)):l.push(null);r!=null&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);let u=a.join(",")+"|"+n.names().sort().join(","),p=iw.get(u),f;if(p==null){let h=Fce(i,n);p=h.sorted,f=h.recipientCounts,iw.put(u,p),aw.put(u,f)}f={},o||Object.assign(f,aw.get(u));let d=new ua(n);for(let h=0;h<p.length;++h){if(r!=null){let V=g1().numTensors;V>r.maxNumTensors&&(r.maxNumTensors=V),V<r.minNumTensors&&(r.minNumTensors=V)}let g=p[h],m=g.sourceLayer;if(m instanceof bf)continue;let y=[],x=[],C=[],I=!1;for(let V of g.inputs){let F=d.getValue(V),G=d.getMask(V);y.push(F),x.push(G),G!=null&&(I=!0),o||(f[V.name]--,f[V.name]===0&&!n.hasKey(V)&&a.indexOf(V.name)===-1&&!F.isDisposed&&V.sourceLayer.stateful!==!0&&C.push(F))}I&&(e=e||{},e.mask=x[0]);let D=Lt(m.apply(y,e)),O=null;m.supportsMasking&&(O=m.computeMask(y,x));let L=Lce(g),B=Array.isArray(L)?L:[L];for(let V=0;V<B.length;++V){d.hasKey(B[V])||d.add(B[V],D[V],Array.isArray(O)?O[0]:O);let F=a.indexOf(B[V].name);F!==-1&&(l[F]=D[V])}o||Ve(C)}return d.disposeMasks(),s?l:l[0]}function Fce(t,n){b.assert(t!=null&&t.length>0,()=>"Expected at least one fetch, got none");let e=[],r={};if(t.length===1){let o=v8(t[0],n);e=o.sorted,r=o.recipientMap}else{let o=new Set;for(let s of t){let{sorted:i,recipientMap:a}=v8(s,n);for(let l of i)o.has(l.name)||(e.push(l),o.add(l.name));for(let l in a)r[l]==null&&(r[l]=new Set),a[l].forEach(c=>r[l].add(c))}}return{sorted:e,recipientCounts:$ce(r)}}function $ce(t){let n={};for(let e in t)n[e]=t[e].size;return n}function v8(t,n){let e=new Set,r=[],o={};for(let a of n.names())e.add(a);let s=[],i=[];for(s.push(t);s.length>0;){let a=s[s.length-1];if(e.has(a.name)){s.pop();continue}let l=i[i.length-1]===s.length-1;if(a.inputs.length===0||l)s.pop(),r.push(a),e.add(a.name),l&&i.pop();else{i.push(s.length-1);for(let c of a.inputs)o[c.name]==null&&(o[c.name]=new Set),o[c.name].add(a.name),!e.has(c.name)&&s.push(c)}}return{sorted:r,recipientMap:o}}function Lce(t){let n;if(t.sourceLayer.inboundNodes.length===1)n=t.sourceLayer.output;else{let e=null;for(let r=0;r<t.sourceLayer.inboundNodes.length;++r)for(let o of t.sourceLayer.inboundNodes[r].outputTensors)if(o.id===t.id){e=r;break}n=t.sourceLayer.getOutputAt(e)}return n}var Pce=Z();Pce.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,b8);function gD(t,n){return X(()=>Wt(Ne(z(t,t),n,!0)))}var Cf=class extends de.Serializable{getConfig(){return{}}},I8=(()=>{class t extends Cf{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return X(()=>{let r=gD(e,this.axis),o=Qn(r,0,this.maxValue);return z(e,ve(o,le(Kn(),r)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}return t.className="MaxNorm",t})();de.registerClass(I8);var S8=(()=>{class t extends Cf{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return X(()=>ve(e,le(Kn(),gD(e,this.axis))))}getConfig(){return{axis:this.axis}}}return t.className="UnitNorm",t})();de.registerClass(S8);var T8=(()=>{class t extends Cf{apply(e){return Nr(e)}}return t.className="NonNeg",t})();de.registerClass(T8);var E8=(()=>{class t extends Cf{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return X(()=>{let r=gD(e,this.axis),o=le(z(this.rate,Qn(r,this.minValue,this.maxValue)),z(1-this.rate,r));return z(e,ve(o,le(Kn(),r)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}return t.className="MinMaxNorm",t})();de.registerClass(E8);var w8={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Dn(t){return Zm(t)}function C8(t,n={}){return la(t,de.SerializationMap.getMap().classNameMap,n,"constraint")}function kn(t){if(t==null)return null;if(typeof t=="string"){let e={className:t in w8?w8[t]:t,config:{}};return C8(e)}else return t instanceof Cf?t:C8(t)}function zl(t){return te(this,null,function*(){if(t==null)return;let n=[],e=[],r=[];for(let o in t){let s=t[o];if(typeof s!="number"){let i=s;n.push(i.data()),e.push(o),r.push(i)}}if(n.length>0){let o=yield Promise.all(n);for(let s=0;s<o.length;++s)t[e[s]]=o[s][0];Ve(r)}})}function lw(t){if(t!=null)for(let n in t){let e=t[n];typeof e!="number"&&e.dispose()}}var Vce=125,Mu=class{constructor(){this.validationData=null}setParams(n){this.params=n}onEpochBegin(n,e){return te(this,null,function*(){})}onEpochEnd(n,e){return te(this,null,function*(){})}onBatchBegin(n,e){return te(this,null,function*(){})}onBatchEnd(n,e){return te(this,null,function*(){})}onTrainBegin(n){return te(this,null,function*(){})}onTrainEnd(n){return te(this,null,function*(){})}setModel(n){}},cw=class{constructor(n,e=10){n==null&&(n=[]),this.callbacks=n,this.queueLength=e}append(n){this.callbacks.push(n)}setParams(n){for(let e of this.callbacks)e.setParams(n)}setModel(n){for(let e of this.callbacks)e.setModel(n)}onEpochBegin(n,e){return te(this,null,function*(){e==null&&(e={});for(let r of this.callbacks)yield r.onEpochBegin(n,e)})}onEpochEnd(n,e){return te(this,null,function*(){e==null&&(e={});for(let r of this.callbacks)yield r.onEpochEnd(n,e)})}onBatchBegin(n,e){return te(this,null,function*(){e==null&&(e={});for(let r of this.callbacks)yield r.onBatchBegin(n,e)})}onBatchEnd(n,e){return te(this,null,function*(){e==null&&(e={});for(let r of this.callbacks)yield r.onBatchEnd(n,e)})}onTrainBegin(n){return te(this,null,function*(){n==null&&(n={});for(let e of this.callbacks)yield e.onTrainBegin(n)})}onTrainEnd(n){return te(this,null,function*(){n==null&&(n={});for(let e of this.callbacks)yield e.onTrainEnd(n)})}},yD=class extends Mu{constructor(){super()}onEpochBegin(n){return te(this,null,function*(){this.seen=0,this.totals={}})}onBatchEnd(n,e){return te(this,null,function*(){e==null&&(e={});let r=e.size==null?0:e.size;this.seen+=r;for(let o in e){let s=e[o];if(typeof s=="number")this.totals.hasOwnProperty(o)||(this.totals[o]=0),this.totals[o]=this.totals[o]+s*r;else{let i;o in this.totals?i=this.totals[o]:this.totals[o]=0;let a=X(()=>le(this.totals[o],z(s,r)));this.totals[o]=a,i?.dispose()}}})}onEpochEnd(n,e){return te(this,null,function*(){if(e!=null)for(let r of this.params.metrics)this.totals[r]!=null&&(typeof this.totals[r]=="number"?e[r]=this.totals[r]/this.seen:X(()=>{let o=z(ve(1,this.seen),this.totals[r]);e[r]=o,this.totals[r].dispose(),mn(e[r])}))})}},uw=class extends Mu{onTrainBegin(n){return te(this,null,function*(){this.epoch=[],this.history={}})}onEpochEnd(n,e){return te(this,null,function*(){e==null&&(e={}),this.epoch.push(n);for(let r in e)this.history[r]==null&&(this.history[r]=[]),this.history[r].push(e[r])})}syncData(){return te(this,null,function*(){let n=[],e=[],r=[];for(let s in this.history){let i=this.history[s];for(let a=0;a<i.length;++a)if(typeof i[a]!="number"){let l=i[a];n.push(l.data()),e.push(s),r.push(a)}}let o=yield Promise.all(n);for(let s=0;s<o.length;++s)this.history[e[s]][r[s]].dispose(),this.history[e[s]][r[s]]=o[s][0]})}},pw=class extends Mu{constructor(n,e){if(super(),this.currentEpoch=0,this.nowFunc=n.nowFunc,this.nextFrameFunc=n.nextFrameFunc||O1,this.yieldEvery=e||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=Vce),this.yieldEvery==="never"&&n.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");b.isNumber(this.yieldEvery)&&(this.maybeWait=j5(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=n.onTrainBegin,this.trainEnd=n.onTrainEnd,this.epochBegin=n.onEpochBegin,this.epochEnd=n.onEpochEnd,this.batchBegin=n.onBatchBegin,this.batchEnd=n.onBatchEnd,this.yield=n.onYield}maybeWait(n,e,r){return te(this,null,function*(){let o=[];this.yield!=null&&(yield zl(r),o.push(this.yield(n,e,r))),o.push(this.nextFrameFunc()),yield Promise.all(o)})}onEpochBegin(n,e){return te(this,null,function*(){this.currentEpoch=n,this.epochBegin!=null&&(yield zl(e),yield this.epochBegin(n,e))})}onEpochEnd(n,e){return te(this,null,function*(){let r=[];this.epochEnd!=null&&(yield zl(e),r.push(this.epochEnd(n,e))),this.yieldEvery==="epoch"&&r.push(this.nextFrameFunc()),yield Promise.all(r)})}onBatchBegin(n,e){return te(this,null,function*(){this.batchBegin!=null&&(yield zl(e),yield this.batchBegin(n,e))})}onBatchEnd(n,e){return te(this,null,function*(){let r=[];this.batchEnd!=null&&(yield zl(e),r.push(this.batchEnd(n,e))),this.yieldEvery==="batch"?r.push(this.nextFrameFunc()):b.isNumber(this.yieldEvery)&&r.push(this.maybeWait(this.currentEpoch,n,e)),yield Promise.all(r)})}onTrainBegin(n){return te(this,null,function*(){this.trainBegin!=null&&(yield zl(n),yield this.trainBegin(n))})}onTrainEnd(n){return te(this,null,function*(){this.trainEnd!=null&&(yield zl(n),yield this.trainEnd(n))})}};function fw(t,n){return t==null&&(t={}),t instanceof Mu?[t]:Array.isArray(t)&&t[0]instanceof Mu?t:Lt(t).map(r=>new pw(r,n))}var N8=(()=>{class t{constructor(){}static registerCallbackConstructor(e,r){b.assert(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),t.checkForDuplicate(r),t.constructors[e]==null&&(t.constructors[e]=[]),t.constructors[e].push(r)}static checkForDuplicate(e){for(let r in t.constructors)t.constructors[+r].forEach(s=>{if(s===e)throw new Y("Duplicate callback constructor.")})}static clear(){t.constructors={}}static createCallbacks(e){let r=[];for(let o in t.constructors){let s=+o;e>=s&&r.push(...t.constructors[s])}return r.map(o=>new o)}}return t.constructors={},t})();function dw(t,n,e,r,o,s,i,a,l){let c=new uw,u=[new yD,...N8.createCallbacks(n)];t!=null&&u.push(...t),u.push(c);let p=new cw(u);return p.setParams({epochs:e,initialEpoch:r,samples:o,steps:s,batchSize:i,verbose:n,doValidation:a,metrics:l}),{callbackList:p,history:c}}function ns(t,n={},e=!1){return la(t,de.SerializationMap.getMap().classNameMap,n,"layer",e)}function V1(t,n){return X(()=>{t.dtype!=="float32"&&(t=fe(t,"float32"));let e=Ne(vf(t),n,!0),r=Bs(e.shape,Kn()),o=Wt(Fo(e,r));return ve(t,o)})}function If(t,n){return X(()=>ln(vf(Ie(n,t)),-1))}function G1(t,n){return X(()=>ln(hn(Ie(n,t)),-1))}function j1(t,n){return X(()=>{let e=Ie(t,n),r=Qn(hn(t),Kn(),Number.MAX_VALUE),o=hn(ve(e,r));return z(100,ln(o,-1))})}function Uce(t,n){return X(()=>{let e=Qn(n,Kn(),Number.MAX_VALUE),r=mr(le(1,e)),o=Qn(t,Kn(),Number.MAX_VALUE),s=mr(le(1,o));return ln(vf(Ie(r,s)),-1)})}function Gce(t,n){return X(()=>{let e=Fo(0,Ie(1,z(t,n)));return ln(vf(e),-1)})}function jce(t,n){return X(()=>{let e=Fo(0,Ie(1,z(t,n)));return ln(e,-1)})}function Hce(t,n){return X(()=>{let e=Ne(z(t,n),-1),r=hr(z(Ie(1,t),n),-1);return Fo(0,le(1,Ie(r,e)))})}function Wce(t,n){return X(()=>{let e=Math.log(2),r=Ie(n,t),o=Ie(le(r,mi(z(-2,r))),e);return ln(o,-1)})}function Sf(t,n,e=!1){return X(()=>{if(e)n=Eu(n);else{let r=Ne(n,n.shape.length-1,!0);n=ve(n,r)}return n=Qn(n,Kn(),1-Kn()),ft(Ne(z(fe(t,"float32"),mr(n)),n.shape.length-1))})}function og(t,n,e=!1){return X(()=>{let r=fe(sa(t8(t)),"int32");n=Qn(n,Kn(),1-Kn());let o=n.shape,s=U(af(r,o[o.length-1]),o);return Sf(s,n,e)})}function qce(t,n){if(!b.arraysEqual(t.shape,n.shape))throw new Y(`logits and labels must have the same shape, but got shapes ${JSON.stringify(t.shape)} and ${JSON.stringify(n.shape)}`);return X(()=>{let e=Nr(n),r=ft(hn(n));return le(Ie(e,z(n,t)),bu(gn(r)))})}function sg(t,n){return X(()=>{let e;return e=Qn(n,Kn(),1-Kn()),e=mr(ve(e,Ie(1,e))),ln(qce(t,e),-1)})}function Kce(t,n){return X(()=>{let e=Qn(t,Kn(),1),r=Qn(n,Kn(),1);return Ne(z(t,mr(ve(e,r))),-1)})}function Xce(t,n){return X(()=>{let e=mr(le(Kn(),n));return ln(Ie(n,z(t,e)),-1)})}function hw(t,n){return X(()=>{let e=V1(t,-1),r=V1(n,-1),o=z(e,r);return ft(Ne(o,-1))})}var U1={meanSquaredError:If,meanAbsoluteError:G1,meanAbsolutePercentageError:j1,meanSquaredLogarithmicError:Uce,squaredHinge:Gce,hinge:jce,categoricalHinge:Hce,logcosh:Wce,categoricalCrossentropy:Sf,sparseCategoricalCrossentropy:og,binaryCrossentropy:sg,kullbackLeiblerDivergence:Kce,poisson:Xce,cosineProximity:hw};function mw(t){if(typeof t=="string"){if(t in U1)return U1[t];let n=`Unknown loss ${t}`;throw t.toLowerCase().includes("softmaxcrossentropy")&&(n=`Unknown loss ${t}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new Y(n)}else return t}function yw(t,n){return X(()=>{let e=z(.5,cr(n)),r=to(En(n,e),t.dtype);return ln(eo(t,r),-1)})}function xw(t,n){return X(()=>to(eo(Ji(t,-1),Ji(n,-1)),"float32"))}function Yce(t,n){return X(()=>fe(Ne(Pr(eo(t,1),eo(n,1))),"float32"))}function Zce(t,n){return X(()=>fe(Ne(Pr(eo(t,0),eo(n,1))),"float32"))}function k8(t,n){return X(()=>{let e=Yce(t,n),r=Zce(t,n),o=le(e,r);return fe(sn(En(o,0),ve(e,o),0),"float32")})}function xD(t,n){return sg(t,n)}function vD(t,n){return t.rank===n.rank&&(t=Zt(t,[t.rank-1])),n=Ji(n,-1),n.dtype!==t.dtype&&(n=fe(n,t.dtype)),fe(eo(t,n),"float32")}var Qce=If,Jce=If,eue=G1,tue=G1,nue=j1,rue=j1,vw=Sf,oue=hw,bD=og,gw={binaryAccuracy:yw,categoricalAccuracy:xw,precision:k8,categoricalCrossentropy:vw,sparseCategoricalCrossentropy:bD,mse:Qce,MSE:Jce,mae:eue,MAE:tue,mape:nue,MAPE:rue,cosine:oue};function A8(t){if(typeof t=="string"&&t in gw)return gw[t];if(typeof t!="string"&&t!=null)return t;throw new Y(`Unknown metric ${t}`)}function H1(t){if(Ts(t!==null,`Unknown LossOrMetricFn ${t}`),typeof t=="string")return t;{let n;for(let e of Object.keys(U1))if(U1[e]===t){n=e;break}if(n!==void 0)return n;for(let e of Object.keys(gw))if(gw[e]===t){n=e;break}return n!==void 0?n:t.name}}function R8(t){let n={Adagrad:()=>yf.adagrad(.01),Adadelta:()=>yf.adadelta(1,.95,Kn()),Adam:()=>yf.adam(.001,.9,.999,Kn()),Adamax:()=>yf.adamax(.002,.9,.999,Kn(),0),RMSProp:()=>yf.rmsprop(.001,.9,0,Kn()),SGD:()=>yf.sgd(.01)};if(n.adagrad=n.Adagrad,n.adadelta=n.Adadelta,n.adam=n.Adam,n.adamax=n.Adamax,n.rmsprop=n.RMSProp,n.sgd=n.SGD,t in n)return n[t]();throw new Y(`Unknown Optimizer ${t}`)}function CD(t,n,e=!1){if(t==null||typeof t!="object"||Object.getPrototypeOf(t)!==Object.prototype||!wD(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){let r=JSON.stringify(t);r.length>1048576&&console.warn(`User-defined metadata of model "${n}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function wD(t){if(t===null)return!0;if(typeof t=="object")if(Object.getPrototypeOf(t)===Object.prototype){let n=Object.keys(t);for(let e of n)if(typeof e!="string"||!wD(t[e]))return!1;return!0}else if(Array.isArray(t)){for(let n of t)if(!wD(n))return!1;return!0}else return!1;else{let n=typeof t;return n==="string"||n==="number"||n==="boolean"}}function M8(t,n,e,r=console.log){let o=aue(t),s=["Layer (type)","Input Shape","Output shape","Param #"];o?(n=n||90,e=e||[.32,.61,.89,1]):(n=n||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(u=>Math.floor(n*u)));let i;if(!o){s.push("Receives inputs"),i=[];for(let u in t.nodesByDepth)i.push(...t.nodesByDepth[u])}r("_".repeat(n)),bw(s,e,r),r("=".repeat(n));let a=t.layers;for(let u=0;u<a.length;++u)o?lue(a[u],e,r):cue(a[u],e,i,r),r((u===a.length-1?"=":"_").repeat(n));t.checkTrainableWeightsConsistency();let l=iue(t),c=ng(t.nonTrainableWeights);r(`Total params: ${l+c}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${c}`),r("_".repeat(n))}function iue(t){let n;return t.collectedTrainableWeights!=null?n=ng(t.collectedTrainableWeights):n=ng(t.trainableWeights),n}function aue(t){let n=!0,e=[],r=[];for(let o in t.nodesByDepth)e.push(t.nodesByDepth[o]);for(let o of e){if(o.length>1||o.length===1&&o[0].inboundLayers.length>1){n=!1;break}r.push(...o)}if(n)for(let o of t.layers){let s=!1;for(let i of o.inboundNodes)if(r.indexOf(i)!==-1)if(s){n=!1;break}else s=!0;if(!n)break}return n}function bw(t,n,e=console.log){let r="";for(let o=0;o<t.length;++o)o>0&&(r=r.slice(0,r.length-1)+" "),r+=t[o],r=r.slice(0,n[o]),r+=" ".repeat(n[o]-r.length);e(r)}function lue(t,n,e){let r,o;try{o=t.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch(l){o="multiple"}try{r=JSON.stringify(t.outputShape)}catch(l){r="multiple"}let s=t.name,i=t.getClassName(),a=[`${s} (${i})`,o,r,t.countParams().toString()];bw(a,n,e)}function cue(t,n,e,r){let o,s;try{s=t.inboundNodes.map(p=>JSON.stringify(p.inputShapes)).join(",")}catch(p){s="multiple"}try{o=JSON.stringify(t.outputShape)}catch(p){o="multiple"}let i=[];for(let p of t.inboundNodes)if(!(e!=null&&e.length>0&&e.indexOf(p)===-1))for(let f=0;f<p.inboundLayers.length;++f){let d=p.inboundLayers[f].name,h=p.nodeIndices[f],g=p.tensorIndices[f];i.push(`${d}[${h}][${g}]`)}let a=t.name,l=t.getClassName(),c=i.length===0?"":i[0],u=[`${a} (${l})`,s,o,t.countParams().toString(),c];bw(u,n,r);for(let p=1;p<i.length;++p)bw(["","","","",i[p]],n,r)}function O8(t,n,e){return(t==="inboundNodes"||t==="outputLayers"||t==="inputLayers")&&n===0&&typeof e=="string"}function W1(t,n){if(t===null)return null;if(typeof t=="string")return $l(t);if(typeof t=="number"||typeof t=="boolean")return t;if(t instanceof Array){let e=[],r=t.length;for(let o=0;o<r;++o){let s=t[o];O8(n,o,s)?e.push(s):e.push(W1(s,n))}return e}else{let e={};for(let r of Object.keys(t)){let o=t[r];if(r==="name"&&typeof o=="string")e[r]=o;else{let s=$l(r);e[s]=W1(o,s)}}return e}}function ww(t,n){if(t==null)return null;if(typeof t=="string")return Hs(t);if(typeof t=="number"||typeof t=="boolean")return t;if(t instanceof Array){let e=[],r=t.length;for(let o=0;o<r;++o){let s=t[o];O8(n,o,s)?e.push(s):e.push(ww(s,n))}return e}else{let e={};for(let r of Object.keys(t)){let o=t[r],s=Hs(r);(r==="name"||r==="className")&&typeof o=="string"?e[s]=o:e[s]=ww(o,r)}return e}}var ig="4.22.0";var uue=t=>{let n=Object.keys(t);if(n.length===0)return!1;let e=n[0].split("/");return!isNaN(parseInt(e[e.length-1],10))},Cw=class t extends Qe{constructor(n){if(super({}),this.containerNodes=new Set,this.name=n.name,this.name==null){let x=this.getClassName().toLowerCase();this.name=_u(x)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(n.inputs)?this.inputs=n.inputs.slice():this.inputs=[n.inputs],Array.isArray(n.outputs)?this.outputs=n.outputs.slice():this.outputs=[n.outputs],Ws(this.inputs).length!==this.inputs.length)throw new Y(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(x=>x.name)}`);Ws(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(x=>x.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let x of this.outputs){let C=x.sourceLayer,I=x.nodeIndex,D=x.tensorIndex;this.outputLayers.push(C),this.outputLayersNodeIndices.push(I),this.outputLayersTensorIndices.push(D)}for(let x of this.inputs){let C=x.sourceLayer,I=x.nodeIndex,D=x.tensorIndex;Ts(I===0,"input layer has >1 nodes"),Ts(D===0,"input layer has >1 tensors"),this.inputLayers.push(C),this.inputLayersNodeIndices.push(I),this.inputLayersTensorIndices.push(D)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let x=0;x<this.inputLayers.length;x++){let C=this.inputLayers[x];if(!(C instanceof bf))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${n.inputs}. Input ${x} (0-based) originates from layer type ${C.getClassName()}.`);this.inputNames.push(C.name),this.feedInputShapes.push(C.batchInputShape),this.feedInputNames.push(C.name)}for(let x of this.outputLayers)this.outputNames.push(x.name);this.internalInputShapes=this.inputs.map(x=>x.shape),this.internalOutputShapes=this.outputs.map(x=>x.shape);let e={},r={},o={},s={},i={},a=[],l=(x,C,I,D,O,L)=>{(D==null||O==null||L==null)&&(D=x.sourceLayer,O=x.nodeIndex,L=x.tensorIndex);let B=D.inboundNodes[O];if(I.indexOf(B)!==-1)throw new mo(`The tensor ${x.name} at layer "${D.name}" is part of a cycle.`);if(C.indexOf(B)!==-1)return;this.containerNodes.add(t.nodeKey(D,O)),D.id in i||(i[D.id]=Object.keys(i).length),I.indexOf(B)===-1&&I.push(B);let V=B.inboundLayers.length;for(let F=0;F<V;F++){let G=B.inputTensors[F],ee=B.inboundLayers[F],Q=B.nodeIndices[F],oe=B.tensorIndices[F];l(G,C,I,ee,Q,oe)}for(C.push(B);I.indexOf(B)>=0;)I.splice(I.indexOf(B),1);a.push(B)},c=[],u=[];for(let x of this.outputs)l(x,c,u);let p=a.slice().reverse();for(let x of p){r[x.id]=x,x.id in e||(e[x.id]=0);let C=e[x.id],I=o[x.outboundLayer.id]==null?0:o[x.outboundLayer.id];C=Math.max(C,I),o[x.outboundLayer.id]=C,s[x.outboundLayer.id]=x.outboundLayer,e[x.id]=C;for(let D=0;D<x.inboundLayers.length;D++){let O=x.inboundLayers[D],L=x.nodeIndices[D],B=O.inboundNodes[L],V=e[B.id]==null?0:e[B.id];e[B.id]=Math.max(C+1,V),r[B.id]=B}}let f={};for(let x in e){let C=e[x];C in f||(f[C]=[]),f[C].push(r[x])}let d={};for(let x in o){let C=o[x];C in d||(d[C]=[]),d[C].push(s[x])}let h=Object.keys(d).map(x=>parseInt(x,10)).sort($1);this.layers=[];for(let x of h){let C=d[x];C.sort((I,D)=>{let O=i[I.id],L=i[D.id];return O<L?-1:O>L?1:0});for(let I of C)I instanceof t&&this.internalContainerRefs.push(I),this.layers.push(I)}this.layersByDepth=d,h=Object.keys(f).map(x=>parseInt(x,10)).sort($1);let g=this.inputs.slice(),m=[];for(let x of h)for(let C of f[x]){let I=C.outboundLayer;if(I!=null){for(let D of C.inputTensors)if(g.indexOf(D)===-1)throw new mo(`Graph disconnected: cannot obtain value for tensor ${D} at layer "${I.name}". The following previous layers were accessed without issue: ${m}`);for(let D of C.outputTensors)g.push(D);m.push(I.name)}}this.nodesByDepth=f;let y=this.layers.map(x=>x.name);for(let x of y){let C=y.filter(I=>I===x).length;if(C!==1)throw new mo(`The name "${x}" is used ${C} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new Bl({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(x=>null),outputMasks:this.outputs.map(x=>null),inputShapes:this.inputs.map(x=>x.shape),outputShapes:this.outputs.map(x=>x.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let n={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let e of this.layers)n.numDisposedVariables+=e.dispose().numDisposedVariables;for(let e of this.internalContainerRefs)n.numDisposedVariables+=e.dispose().numDisposedVariables}return n.refCountAfterDispose=this._refCount,n}get trainable(){return this.trainable_}set trainable(n){this.layers.forEach(e=>{e._trainableWeights.forEach(r=>r.trainable=n)}),this.trainable_=n}get trainableWeights(){if(this._trainableWeights.length>0)throw new Y("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let n=[];for(let e of this.layers)n=n.concat(e.trainableWeights);return n}get nonTrainableWeights(){let n=[];for(let e of this.layers)n.push(...e.nonTrainableWeights);if(!this.trainable){let e=[];for(let r of this.layers)e.push(...r.trainableWeights);return e.concat(n)}return n}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(n,e=!0){let r={},o=0,s=uue(n);s&&this.parseWeights(n);for(let a of this.layers)for(let[l,c]of a.weights.entries()){let u=s?`${c.name.split("/").slice(0,-1).join("/")+"/"}${l}`:c.originalName;if(r[u]!=null)throw new Y(`Duplicate weight name: ${u}`);r[u]=c,o++}let i=[];for(let a in n){let l=a;if(r[a]==null){let c=a.split("/");l=c.slice(0,-2).concat([c[c.length-1]]).join("/")}if(r[l]!=null)i.push([r[l],n[a]]);else if(e)throw new Y(`Provided weight data has no target variable: ${a}`);delete r[l]}if(e){let a=[];for(let l in r)a.push(l);if(a.length>0)throw new Y(`${a.length} of ${o} weights are not set: ${a}`)}rg(i)}parseWeights(n){for(let e in Object.keys(n)){let r=e.split("/"),o=["vars","layer_checkpoint_dependencies"],s=r.map(i=>i.startsWith("_")?i.slice(1):i).filter(i=>!o.includes(i)).join("/");s!==e&&(n[s]=n[e],delete n[e])}}updatedConfig(){let n=this.getConfig(),e={};return e.className=this.getClassName(),e.config=n,e.kerasVersion=`tfjs-layers ${ig}`,e.backend="TensorFlow.js",e}toJSON(n,e=!0){let r=ww(this.updatedConfig());return e?JSON.stringify(r):r}call(n,e){return X(()=>{n=Lt(n);let r=new ua;for(let o=0;o<this.inputs.length;++o)r.add(this.inputs[o],n[o]);return wf(this.outputs,r,e)})}computeMask(n,e){return X(()=>{n=Lt(n);let r;return e==null?r=js(null,n.length):r=Lt(e),this.runInternalGraph(n,r)[1]})}computeOutputShape(n){let e=tg(n);if(e.length!==this.inputLayers.length)throw new Y(`Invalid inputShape argument ${n}: model has ${this.inputLayers.length} tensor inputs.`);let r={};for(let a=0;a<e.length;a++){let l=this.inputLayers[a],c=e[a],u=l.name+"_0_0";r[u]=c}let o=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort($1);if(o.length>1)for(let a of o){let l=this.nodesByDepth[a];for(let c of l){let u=c.outboundLayer;if(this.inputLayers.map(g=>g.id).indexOf(u.id)!==-1)continue;let p=[];for(let g=0;g<c.inboundLayers.length;g++){let m=c.inboundLayers[g],y=c.nodeIndices[g],x=c.tensorIndices[g],C=`${m.name}_${y}_${x}`,I=r[C];p.push(I)}let f=u.computeOutputShape(yr(p)),d=tg(f),h=u.inboundNodes.indexOf(c);for(let g=0;g<d.length;g++){let m=`${u.name}_${h}_${g}`;r[m]=d[g]}}}let s=[],i=[];for(let a=0;a<this.outputLayers.length;a++){let l=this.outputLayers[a],c=this.outputLayersNodeIndices[a],u=this.outputLayersTensorIndices[a],p=`${l.name}_${c}_${u}`;i.push(p)}for(let a=0;a<i.length;a++){let l=i[a];Ts(l in r),s.push(r[l])}return yr(s)}runInternalGraph(n,e){e==null&&(e=js(null,n.length));let r={};for(let l=0;l<this.inputs.length;++l){let c=this.inputs[l],u=n[l],p=e[l];r[c.id]=[u,p]}let o=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort($1);for(let l of o){let c=this.nodesByDepth[l];for(let u of c){let p=u.outboundLayer,f=u.inputTensors,d=u.outputTensors,h=new Array;for(let g of f)g.id in r&&h.push(r[g.id]);if(h.length===f.length){let g={},m,y,x,C;if(u.callArgs!=null&&(g=u.callArgs),h.length===1){let[I,D]=h[0];g.mask==null&&(g.mask=D),x=Lt(p.call(I,g)),C=Lt(p.computeMask(I,D)),m=[I],y=[D]}else m=h.map(I=>I[0]),y=h.map(I=>I[1]),g.mask==null&&(g.mask=y),x=Lt(p.call(m,g)),C=Lt(p.computeMask(m,y));if(p.activityRegularizer)throw new Ze("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let I=0;I<d.length;++I){let D=d[I],O=x[I],L=C[I];r[D.id]=[O,L]}}}}let s=[],i=[],a=[];for(let l of this.outputs){Ts(l.id in r,`Could not compute output ${l.name} : ${l.id}`);let[c,u]=r[l.id];a.push(c.shape),s.push(c),i.push(u)}return[s,i,a]}buildNodeConversionMap(n){let e={},r;for(let o of this.layers){r=o instanceof t?1:0;for(let s=0;s<o.inboundNodes.length;s++){let i=t.nodeKey(o,s);this.containerNodes.has(i)&&(e[i]=r,r+=1)}}return e}getLayer(n,e){if(e!=null)return this.findLayer(e);if(n==null)throw new Y("Provide either a layer name or layer index");if(typeof n=="number")return this.findLayer(n);for(let r of this.layers)if(r.name===n)return r;throw new Y(`No such layer: ${n}`)}findLayer(n){if(this.layers.length<=n)throw new Y(`Was asked to retrieve layer at index ${n}, but model only has ${this.layers.length} layer(s).`);return this.layers[n]}calculateLosses(){return X(()=>{let n=[];for(let e of this.layers)for(let r=0;r<e.inboundNodes.length;++r){let o=t.nodeKey(e,r);this.containerNodes.has(o)&&n.push(...e.calculateLosses())}return n})}getConfig(){let n={name:this.name},e=this.buildNodeConversionMap(this.layers),r=[];for(let i of this.layers){let a=i.getClassName(),l=i.getConfig(),c=[];for(let p=0;p<i.inboundNodes.length;p++){let f=i.inboundNodes[p],d=t.nodeKey(i,p),h={};if(this.containerNodes.has(d)){if(f.callArgs)try{JSON.stringify(f.callArgs),h=f.callArgs}catch(g){console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${f.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),h={}}if(f.inboundLayers.length>0){let g=[];for(let m=0;m<f.inboundLayers.length;m++){let y=f.inboundLayers[m],x=f.nodeIndices[m],C=f.tensorIndices[m],I=t.nodeKey(y,x),D=e[I];D==null&&(D=0),g.push([y.name,D,C,h])}c.push(g)}}}let u={};u.name=i.name,u.className=a,u.config=l,u.inboundNodes=c,r.push(u)}n.layers=r;let o=[];for(let i=0;i<this.inputLayers.length;i++){let a=this.inputLayers[i],l=this.inputLayersNodeIndices[i],c=t.nodeKey(a,l);if(!this.containerNodes.has(c))continue;let u=e[c];u==null&&(u=0);let p=this.inputLayersTensorIndices[i];o.push([a.name,u,p])}n.inputLayers=o;let s=[];for(let i=0;i<this.outputLayers.length;i++){let a=this.outputLayers[i],l=this.outputLayersNodeIndices[i],c=t.nodeKey(a,l);if(!this.containerNodes.has(c))continue;let u=e[c];u==null&&(u=0);let p=this.outputLayersTensorIndices[i];s.push([a.name,u,p])}return n.outputLayers=s,n}static fromConfig(n,e,r={},o=!1){let s={},i={};function a(m,y){m.name in i?i[m.name].push(y):i[m.name]=[y]}function l(m,y){let x=[],C;for(let I of y){let D=I[0],O=I[1],L=I[2];if(C=I[3]==null?{}:I[3],!(D in s)){a(m,y);return}let B=s[D];if(B.inboundNodes.length<=O){a(m,y);return}let V=B.inboundNodes[O];x.push(V.outputTensors[L])}x.length>0&&m.apply(yr(x),C)}function c(m){let y=m.name,x=ns(m,e.customObjects!=null?e.customObjects:{});x.setFastWeightInitDuringBuild(o),s[y]=x,m.inboundNodes.forEach(I=>{if(!(I instanceof Array))throw new Y(`Corrupted configuration, expected array for nodeData: ${I}`);a(x,I)})}let u=e.name,p=e.layers;for(let m of p)c(m);for(;!U5(i);)for(let m of p){let y=s[m.name];if(y.name in i){let x=i[y.name];delete i[y.name];for(let C of x)l(y,C)}}let f=[],d=[],h=e.inputLayers;for(let m of h){let y=m[0],x=m[1],C=m[2];Ts(y in s);let D=s[y].inboundNodes[x].outputTensors;f.push(D[C])}let g=e.outputLayers;for(let m of g){let y=m[0],x=m[1],C=m[2];Ts(y in s);let D=s[y].inboundNodes[x].outputTensors;d.push(D[C])}return new n({inputs:f,outputs:d,name:u})}get stateful(){if(this._stateful)throw new Y("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let n of this.layers)if(n.stateful)return!0;return!1}resetStates(){X(()=>{this.layers.forEach(n=>{n.stateful&&n.resetStates()})})}};function pue(t,n,e){let r=n.length;if(t==null||Array.isArray(t)&&t.length===0)return n.map(o=>null);if(r===1)return Array.isArray(t)&&t.length===1?t:typeof t=="object"&&n[0]in t?[t[n[0]]]:[t];if(Array.isArray(t)){if(t.length!==r)throw new Error(`Provided ${e} is an array of ${t.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return t}else if(typeof t=="object"&&Object.keys(t).length>0&&typeof t[Object.keys(t)[0]]=="object"){let o=[];return n.forEach(s=>{s in t?o.push(t[s]):o.push(null)}),o}else throw new Error(`The model has multiple (${r}) outputs, so ${e} must be either an array with ${r} elements or an object with ${n} keys. Provided ${e} not understood: ${JSON.stringify(t)}`)}function Iw(t,n){return pue(t,n,"classWeight")}function Sw(t,n,e,r){return te(this,null,function*(){if(n!=null||r!=null)throw new Error("Support sampleWeight is not implemented yet");if(e!=null){let o=X(()=>{if(t.shape.length===1)return po(t);if(t.shape.length===2){if(t.shape[1]>1)return Ji(t,1);if(t.shape[1]===1)return U(t,[t.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(yield o.data());Ve(o);let i=[];return s.forEach(a=>{if(e[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);i.push(e[a])}),qt(i,"float32")}else return null})}function F8(t,n){return z(t,n)}var fue=32;function P8(t,n){let e,r,o=n;e=o.xs,r=o.ys,b.assert(e!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${n}`);let s=$8("input",t.inputNames,e),i=$8("output",t.outputNames,r),a=s[0].shape[0];b.assert(s.length===t.inputs.length,()=>`LayersModel has ${t.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(t.inputNames)})`),b.assert(i.length===t.outputs.length,()=>`LayersModel has ${t.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(t.outputNames)})`);for(let l=0;l<s.length;l++)b.assert(s[l].shape[0]===a,()=>`Batch size mismatch: input ${t.inputNames[l]} has ${s[l].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);for(let l=0;l<i.length;l++)b.assert(i[l].shape[0]===a,()=>`Batch size mismatch: output ${t.outputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);return{xs:s,ys:i}}function $8(t,n,e){if(e instanceof ot)return[e];if(Array.isArray(e))return b.assert(e.length===n.length,()=>`Received an array of ${e.length} Tensors, but expected ${n.length} to match the ${t} keys ${n}.`),e;{let r=[];for(let o of n){if(e[o]==null)throw new Y(`The feature data generated by the dataset lacks the required ${t} key '${o}'.`);r.push(e[o])}return r}}function due(t){if(t.length===3)throw new Ze("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}function B8(t,n,e){return te(this,null,function*(){let r=e.batchesPerEpoch!=null;if(b.assert(t.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),b.assert(e!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),b.assert(e.epochs!=null&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),b.assert(!r||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),b.assert(e.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{let o=e.validationData!=null,s,i;if(o)if(L8(e.validationData))b.assert(e.validationBatches==null||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{let m=due(e.validationData);s=m.xs,i=m.ys}let a=t.makeTrainFunction(),l=t.getDedupedMetricsNames(),c;o?c=l.slice().concat(l.map(m=>"val_"+m)):c=l.slice();let u=fw(e.callbacks,e.yieldEvery),p=e.verbose==null?1:e.verbose,{callbackList:f,history:d}=dw(u,p,e.epochs,null,null,hue(n,e),null,o,c);f.setModel(t),t.history=d,yield f.onTrainBegin(),t.stopTraining_=!1;let h=e.initialEpoch==null?0:e.initialEpoch,g=yield n.iterator();for(;h<e.epochs;){let m={};yield f.onEpochBegin(h);let y=0,x=0;for(r||(g=yield n.iterator());!r||y<e.batchesPerEpoch;){let C=yield g.next();if(r&&C.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(C.value!=null){let{xs:I,ys:D}=P8(t,C.value),O={};O.batch=x,O.size=I[0].shape[0],yield f.onBatchBegin(x,O);let L=[];if(e.classWeight!=null){let F=Iw(e.classWeight,t.outputNames);for(let G=0;G<F.length;++G)L.push(yield Sw(D[G],null,F[G]))}let B=I.concat(D).concat(L),V=a(B);Ve(B);for(let F=0;F<l.length;++F){let G=l[F],ee=V[F];O[G]=ee,mn(ee)}yield f.onBatchEnd(x,O),lw(O),x++,y++}if(r?y>=e.batchesPerEpoch:C.done){if(o){let I;L8(e.validationData)?I=Lt(yield t.evaluateDataset(e.validationData,{batches:e.validationBatches})):I=Lt(t.evaluate(s,i,{batchSize:e.validationBatchSize==null?fue:e.validationBatchSize,verbose:0}));for(let D=0;D<t.metricsNames.length;++D)m[`val_${t.metricsNames[D]}`]=I[D]}break}if(t.stopTraining_)break}if(yield f.onEpochEnd(h,m),h++,t.stopTraining_)break}return yield f.onTrainEnd(),yield t.history.syncData(),t.history}finally{t.isTraining=!1}})}function hue(t,n){let e=null;return n.batchesPerEpoch!=null?e=n.batchesPerEpoch:Number.isFinite(t.size)&&(e=t.size),e}function L8(t){return typeof t.iterator=="function"}function mue(t){return typeof t.next=="function"}function z8(t,n,e){return te(this,null,function*(){e=e||{};let r=e.batches!=null,o=t.testFunction,s=[];if(e.verbose>0)throw new Ze("Verbose mode is not implemented yet.");b.assert(!r||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);let i=mue(n)?n:yield n.iterator(),a=0,l=0;for(;!r||l<e.batches;){let c=yield i.next();if(s=X(()=>{if(c.value){let{xs:u,ys:p}=P8(t,c.value),f=u.concat(p),d=X(()=>o(f));if(Ve(f),l===0)for(let g=0;g<d.length;++g)s.push(Ee(0));let h=f[0].shape[0];for(let g=0;g<d.length;++g){let m=d[g],y=s[g];s[g]=X(()=>le(s[g],z(h,m))),l>0&&Ve(y)}Ve(d),a+=h,++l}return s}),c.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<s.length;++c){let u=s[c];s[c]=ve(s[c],a),Ve(u)}return yr(s)})}function Tw(t){b.assert(t>0&&Number.isInteger(t),()=>`batchSize is required to be a positive integer, but got ${t}`)}function ag(t,n,e){return t==null?[null]:Array.isArray(t)?t.map(r=>Ll(r,n,e-n)):Ll(t,n,e-n)}function Ew(t,n){return X(()=>t==null?null:Array.isArray(t)?t.map(e=>Ew(e,n)):nw(t,n.dtype==="int32"?n:fe(n,"int32")))}function Nw(t,n){let e=[],r=0,o=null;for(;r<t;)o=r+n,o>=t&&(o=t),e.push([r,o]),r=o;return e}function ID(t){let n=[];t instanceof ot&&(t=[t]);for(let e=0;e<t.length;++e){let r=t[e];if(r.rank===1)n.push(Pl(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");n.push(r)}}return n}function Xs(t,n){if(t==null)return;let e=[];if(n instanceof ot)e.push(n.id);else if(Array.isArray(n))n.forEach(o=>e.push(o.id));else if(n!=null)for(let o in n){let s=n[o];e.push(s.id)}let r=[];if(t instanceof ot)e.indexOf(t.id)===-1&&r.push(t);else if(Array.isArray(t))t.forEach(o=>{e.indexOf(o.id)===-1&&r.push(o)});else if(t!=null)for(let o in t){let s=t[o];e.indexOf(s.id)===-1&&r.push(s)}r.forEach(o=>{o.isDisposed||o.dispose()})}function gue(t){return t instanceof ot}function SD(t){return Array.isArray(t)}function V8(t){return!gue(t)&&!SD(t)}function U8(t,n,e,r=!0,o=""){if(n==null||n.length===0){if(t!=null){let i=!1;if(SD(t)&&t.length>0)i=!0;else if(V8(t)){for(let a in t)if(t.hasOwnProperty(a)){i=!0;break}}else i=!0;if(i)throw new Y(`Error when checking model ${o} expected no data, but got ${t}`)}return[]}if(t==null)return n.map(i=>null);let s;if(V8(t)){t=t,s=[];for(let i of n){if(t[i]==null)throw new Y(`No data provided for "${i}". Need data for each key in: ${n}`);s.push(t[i])}}else if(SD(t)){if(t=t,t.length!==n.length)throw new Y(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${n.length} Tensor(s), but instead got the following list of Tensor(s): ${t}`);s=t}else{if(t=t,n.length>1)throw new Y(`The model ${o} expects ${n.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${t.shape}`);s=[t]}if(s=ID(s),e!=null)for(let i=0;i<n.length;++i){if(e[i]==null)continue;let a=s[i];if(a.shape.length!==e[i].length)throw new Y(`Error when checking ${o}: expected ${n[i]} to have ${e[i].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<e[i].length;++l){if(l===0&&!r)continue;let c=a.shape[l],u=e[i][l];if(u!=null&&u>=0&&c!==u)throw new Y(`${o} expected a batch of elements where each example has shape [${e[i].slice(1,e[i].length)}] (i.e.,tensor shape [*,${e[i].slice(1,e[i].length)}]) but the ${o} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return s}function yue(t,n,e){let r=Ws(t.map(s=>s.shape[0]));r.sort();let o=Ws(n.map(s=>s.shape[0]));if(o.sort(),r.length>1)throw new Y(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(s=>s.shape))}`);if(o.length>1)throw new Y(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(s=>s.shape))}`);if(r.length>0&&o.length>0&&!b.arraysEqual(r,o))throw new Y(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${o[0]} target sample(s).`)}function xue(t,n,e){let r=[If,sg,Sf];for(let o=0;o<t.length;++o){let s=t[o],i=n[o],a=e[o];if(i!=null){if(i===Sf&&s.shape[s.shape.length-1]===1)throw new Y(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(i)!==-1){let l=s.shape.slice(1),c=a.slice(1);for(let u=0;u<l.length;++u){let p=l[u],f=c[u];if(f!=null&&p!==f)throw new Y(`A target Tensor with shape ${s.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function G8(t,n,e,r=!0,o=""){let s;if(Array.isArray(t)){if(t.length!==n.length)throw new Y(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${n.length} Tensor(s), but instead got ${t.length} Tensors(s).`);s=t}else{if(n.length>1)throw new Y(`The model expects ${n.length} ${o} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(t.shape)}.`);s=[t]}if(e!=null)for(let i=0;i<n.length;++i){if(e[i]==null)continue;let a=s[i];if(a.shape.length!==e[i].length)throw new Y(`Error when checking ${o}: expected ${n[i]} to have ${e[i].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<e[i].length;++l){if(l===0&&!r)continue;let c=a.shape[l],u=e[i][l];if(u!=null&&u!==c)throw new Y(`Error when checking ${o}: expected ${n[i]} to have shape ${JSON.stringify(e[i])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function vue(t,n){if(t==null||Array.isArray(t)&&t.length===0)return n.map(r=>[]);let e;if(typeof t=="string"||typeof t=="function")e=[t];else if(Array.isArray(t)||typeof t=="object")e=t;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${t}`);if(Array.isArray(e))return n.map(r=>e);{let r=[];for(let o of n){let s=e.hasOwnProperty(o)?e[o]:[];Array.isArray(s)||(s=[s]),r.push(s)}return r}}var bue="layers-model",Vl=(()=>{class t extends Cw{constructor(e){super(e),this.isTraining=!1}summary(e,r,o=console.log){if(!this.built)throw new Y("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");M8(this,e,r,o)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=R8(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof zr))throw new Y("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let r=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(let a in e.loss)if(this.outputNames.indexOf(a)===-1)throw new Y(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(let a of this.outputNames)e.loss[a]==null&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),r.push(mw(e.loss[a]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new Y(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);r=e.loss.map(l=>mw(l))}else{let a=mw(e.loss);this.outputs.forEach(l=>{r.push(a)})}this.lossFunctions=r,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){let l=this.internalOutputShapes[a],c=this.outputNames[a];this.feedOutputNames.push(c),this.feedOutputShapes.push(l),this.feedLossFns.push(this.lossFunctions[a])}let o=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],vi("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(o.indexOf(a)!==-1)continue;let l=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([l,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});let s=vue(e.metrics,this.outputNames),i=(a,l,c)=>{this.outputNames.length>1&&(l=this.outputNames[a]+"_"+l),this.metricsNames.push(l),this.metricsTensors.push([c,a])};vi("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(o.indexOf(a)!==-1)continue;let l=s[a];(u=>{let f,d,h;for(let g of u){if(typeof g=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(g)!==-1){let y=this.internalOutputShapes[a];y[y.length-1]===1||this.lossFunctions[a]===sg?["accuracy","acc"].indexOf(g)!==-1?d=yw:["crossentropy","ce"].indexOf(g)!==-1&&(d=xD):this.lossFunctions[a]===og?["accuracy","acc"].indexOf(g)!==-1?d=vD:["crossentropy","ce"].indexOf(g)!==-1&&(d=bD):["accuracy","acc"].indexOf(g)!==-1?d=xw:["crossentropy","ce"].indexOf(g)!==-1&&(d=vw);let x;["accuracy","acc"].indexOf(g)!==-1?x="acc":["crossentropy","ce"].indexOf(g)!==-1&&(x="ce"),h=d,f=""+x}else h=A8(g),f=""+H1(g);let m;vi(f,()=>{m=h}),i(a,f,m)}})(l)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,r,o={}){let s=o.batchSize==null?32:o.batchSize;Tw(s);let a=this.standardizeUserDataXY(e,r,!0,s);try{let l=a[0].concat(a[1]);this.makeTestFunction();let c=this.testFunction,u=this.testLoop(c,l,s,o.verbose,o.steps);return yr(u)}finally{Xs(a[0],e),Xs(a[1],r)}}evaluateDataset(e,r){return te(this,null,function*(){return this.makeTestFunction(),z8(this,e,r)})}checkNumSamples(e,r,o,s="steps"){let i;if(o!=null){if(i=null,r!=null)throw new Y(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${r}`)}else if(e!=null)Array.isArray(e)?i=e[0].shape[0]:i=e.shape[0];else throw new Y(`Either the input data should have a defined shape, or ${s} shoud be specified.`);return i}execute(e,r){if(Array.isArray(r)&&r.length===0)throw new Y("`outputs` is an empty Array, which is not allowed.");let o=Array.isArray(r),s=o?r:[r],i=this.retrieveSymbolicTensors(s),a=new ua;if(e instanceof ot&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new Y(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let c=0;c<this.inputs.length;++c)a.add(this.inputs[c],e[c])}else for(let c of this.inputs){let u=e[c.name];if(u==null)throw new Y(`No value is provided for the model's input ${c.name}`);a.add(c,u)}let l=wf(i,a);return o?l:l[0]}retrieveSymbolicTensors(e){let r=js(null,e.length),o=e.length;for(let s of this.layers){let i=Array.isArray(s.output)?s.output:[s.output],a=i.map(l=>l.name);for(let l=0;l<e.length;++l){let c=a.indexOf(e[l]);if(c!==-1&&(r[l]=i[c],o--),o===0)break}if(o===0)break}if(o>0){let s=[];throw r.forEach((i,a)=>{i==null&&s.push(e[a])}),new Y(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(s)}`)}return r}predictLoop(e,r=32,o=!1){return X(()=>{let s=this.checkNumSamples(e);if(o)throw new Ze("Verbose predictLoop() is not implemented yet.");let i=Nw(s,r),a=this.outputs.map(l=>[]);for(let l=0;l<i.length;++l)X(()=>{let u=i[l][0],p=i[l][1],f=ag(e,u,p),d=[];if(Array.isArray(f))for(let g=0;g<f.length;++g)d.push({key:this.inputs[g],value:f[g]});else d.push({key:this.inputs[0],value:f});let h=new ua(d);return wf(this.outputs,h)}).forEach((u,p)=>a[p].push(u));return yr(a.map(l=>Et(l,0)))})}predict(e,r={}){let o=ID(e);G8(o,this.inputNames,this.feedInputShapes,!1);try{let s=r.batchSize==null?32:r.batchSize;return Tw(s),this.predictLoop(o,s)}finally{Xs(o,e)}}predictOnBatch(e){G8(e,this.inputNames,this.feedInputShapes,!0);let r=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,r)}standardizeUserDataXY(e,r,o=!0,s){if(this.optimizer_==null)throw new mo("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let i=[];for(let a=0;a<this.feedOutputShapes.length;++a){let l=this.feedOutputShapes[a];this.feedLossFns[a]===og?i.push(l.slice(0,l.length-1).concat([1])):i.push(l)}if(e=U8(e,this.feedInputNames,this.feedInputShapes,!1,"input"),r=U8(r,this.feedOutputNames,i,!1,"target"),yue(e,r,null),xue(r,this.feedLossFns,this.feedOutputShapes),this.stateful&&s!=null&&s>0&&e[0].shape[0]%s!==0)throw new Y(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${e[0].shape[0]} sample(s).`);return[e,r]}standardizeUserData(e,r,o,s,i=!0,a){return te(this,null,function*(){let[l,c]=this.standardizeUserDataXY(e,r,i,a);if(o!=null)throw new Error("sample weight is not supported yet.");let u=null;if(s!=null){let p=Iw(s,this.outputNames);u=[];for(let f=0;f<p.length;++f)u.push(yield Sw(c[f],null,p[f]))}return[l,c,u]})}testLoop(e,r,o,s=0,i){return X(()=>{let a=this.checkNumSamples(r,o,i,"steps"),l=[];if(s>0)throw new Ze("Verbose mode is not implemented yet.");if(i!=null)throw new Ze("steps mode in testLoop() is not implemented yet");{let c=Nw(a,o),u=qt(yo(0,a));for(let p=0;p<c.length;++p){let f=c[p][0],d=c[p][1],h=Ll(u,f,d-f),g=Ew(r,h),m=e(g);if(p===0)for(let y=0;y<m.length;++y)l.push(Ee(0));for(let y=0;y<m.length;++y){let x=m[y];l[y]=le(l[y],z(d-f,x))}}for(let p=0;p<l.length;++p)l[p]=ve(l[p],a)}return l})}getDedupedMetricsNames(){let e=this.metricsNames,r=[];for(let o=0;o<e.length;++o){let s=e[o],i=s;if(nD(e,s)>1){let a=nD(e.slice(0,o),s);i+=`_${a}`}r.push(i)}return r}makeTrainFunction(){return e=>{let r=[],o=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],l=()=>{let f=[];for(let m=0;m<this.inputs.length;++m)f.push({key:this.inputs[m],value:o[m]});let d=new ua(f),h=wf(this.outputs,d,{training:!0}),g;for(let m=0;m<this.lossFunctions.length;++m){let y=this.lossFunctions[m],x=y(s[m],h[m]);i[m]!=null&&(x=F8(x,i[m]));let C=ln(x);r.push(C),m===0?g=x:g=le(g,x)}for(let m=0;m<this.metricsTensors.length;++m){let y;if(this.outputs.length>1&&m<this.outputs.length)y=r[m];else{let x=this.metricsTensors[m][0],C=this.metricsTensors[m][1];y=ln(x(s[C],h[C]))}mn(y),a.push(y)}return g=ln(g),this.calculateLosses().forEach(m=>{g=le(g,m)}),g},c=this.collectedTrainableWeights.map(f=>f.read());return[this.optimizer_.minimize(l,!0,c)].concat(a)}}makeTestFunction(){this.testFunction=e=>X(()=>{let r=[],o,s=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let u=0;u<this.inputs.length;++u)a.push({key:this.inputs[u],value:s[u]});let l=new ua(a),c=wf(this.outputs,l);for(let u=0;u<this.lossFunctions.length;++u){let p=this.lossFunctions[u],f=ln(p(i[u],c[u]));u===0?o=f:o=le(o,f),r.push(o)}for(let u=0;u<this.metricsTensors.length;++u){let p=this.metricsTensors[u][0],f=this.metricsTensors[u][1],d=ln(p(i[f],c[f]));r.push(d)}return r})}fit(s,i){return te(this,arguments,function*(e,r,o={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let a,l,c,u,p,f,d,h,g;try{let m=o.batchSize==null?32:o.batchSize;Tw(m);let x=yield this.standardizeUserData(e,r,o.sampleWeight,o.classWeight,!1,m);a=x[0],l=x[1],g=x[2];let C=!1,I;if(o.validationData!=null&&o.validationData.length>0){if(C=!0,o.validationData.length===2)p=o.validationData[0],f=o.validationData[1];else throw o.validationData.length===3?new Ze("validationData including sample weights is not supported yet."):new Y(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${o.validationData} is invalid.`);let Q=yield this.standardizeUserData(p,f,null,null,!0,m);d=Q[0],h=Q[1],I=d.concat(h)}else if(o.validationSplit!=null&&o.validationSplit>0&&o.validationSplit<1){C=!0;let ee=Math.floor(a[0].shape[0]*(1-o.validationSplit)),Q=a[0].shape[0];d=ag(a,ee,Q),c=a,a=ag(a,0,ee),h=ag(l,ee,Q),u=l,l=ag(l,0,ee),I=d.concat(h)}else o.validationSteps!=null&&(C=!0);let D=a.concat(l).concat(g);this.checkTrainableWeightsConsistency();let O=this.makeTrainFunction(),L=this.getDedupedMetricsNames(),B,V;C?(this.makeTestFunction(),B=this.testFunction,V=L.slice().concat(L.map(ee=>"val_"+ee))):(B=null,I=[],V=L.slice());let F=fw(o.callbacks,o.yieldEvery);return yield this.fitLoop(O,D,L,m,o.epochs,o.verbose,F,B,I,o.shuffle,V,o.initialEpoch,null,null)}finally{this.isTraining=!1,Xs(a,e),Xs(l,r),Xs(c,e),Xs(u,r),Xs(d,p),Xs(h,f),g!=null&&Ve(g)}})}fitLoop(e,r,o,s,i,a,l,c,u,p,f,d,h,g){return te(this,null,function*(){s==null&&(s=32),i==null&&(i=1),p==null&&(p=!0),d==null&&(d=0);let m=!1;if(c!=null&&u!=null&&(m=!0),g!=null&&(m=!0,h==null))throw new Y("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let y=this.checkNumSamples(r,s,h,"steps_per_epoch"),x;y!=null&&(x=yo(0,y)),a==null&&(a=1);let{callbackList:C,history:I}=dw(l,a,i,d,y,h,s,m,f);C.setModel(this),this.history=I,yield C.onTrainBegin(),this.stopTraining_=!1;for(let D=d;D<i;++D){yield C.onEpochBegin(D);let O={};if(h!=null)throw new Ze("stepsPerEpoch mode is not implemented yet.");{if(p==="batch")throw new Ze("batch shuffling is not implemneted yet");p&&b.shuffle(x);let L=qt(x),B=Nw(y,s);for(let V=0;V<B.length;++V){let F={};if(yield C.onBatchBegin(V,F),X(()=>{let G=B[V][0],ee=B[V][1],Q=Ll(L,G,ee-G);F.batch=V,F.size=ee-G;let oe=Ew(r,Q),ae=e(oe);for(let J=0;J<o.length;++J){let re=o[J],se=ae[J];F[re]=se,mn(se)}if(V===B.length-1&&m){let J=this.testLoop(c,u,s);for(let re=0;re<o.length;++re){let se=o[re],pe=J[re];mn(pe),O["val_"+se]=pe}}}),yield C.onBatchEnd(V,F),lw(F),this.stopTraining_)break}L.dispose()}if(yield C.onEpochEnd(D,O),this.stopTraining_)break}return yield C.onTrainEnd(),yield this.history.syncData(),this.history})}fitDataset(e,r){return te(this,null,function*(){return B8(this,e,r)})}trainOnBatch(e,r){return te(this,null,function*(){let o=yield this.standardizeUserData(e,r),s=o[0],i=o[1],l=this.makeTrainFunction()(s.concat(i)),c=[];for(let u of l){let p=yield u.data();c.push(p[0])}return Ve(l),Xs(o[0],e),Xs(o[1],r),yr(c)})}getNamedWeights(e){let r=[],o=e!=null&&e.trainableOnly,s=o?this.trainableWeights:this.weights,i=this.getWeights(o);for(let a=0;a<s.length;++a)o&&!s[a].trainable||r.push({name:s[a].originalName,tensor:i[a]});return r}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let r=g1().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=r-g1().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=Hs(this.loss);else if(Array.isArray(this.loss)){for(let r of this.loss)if(typeof r!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(r=>Hs(r))}else{let r=Object.keys(this.loss);e={};let o=this.loss;for(let s of r)if(typeof o[s]=="string")e[s]=Hs(o[s]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Hs(H1(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Hs(H1(e)));{let e={};for(let r in this.metrics)e[r]=Hs(H1(this.metrics[r]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let r=W1(e.optimizer_config),o=ns(r),s;if(typeof e.loss=="string")s=$l(e.loss);else if(Array.isArray(e.loss))s=e.loss.map(a=>$l(a));else if(e.loss!=null){s={};for(let a in e.loss)s[a]=$l(e.loss[a])}let i;if(Array.isArray(e.metrics))i=e.metrics.map(a=>$l(a));else if(e.metrics!=null){i={};for(let a in e.metrics)i[a]=$l(e.metrics[a])}this.compile({loss:s,metrics:i,optimizer:o})}save(e,r){return te(this,null,function*(){if(typeof e=="string"){let u=yi.getSaveHandlers(e);if(u.length===0)throw new Y(`Cannot find any save handlers for URL '${e}'`);if(u.length>1)throw new Y(`Found more than one (${u.length}) save handlers for URL '${e}'`);e=u[0]}if(e.save==null)throw new Y("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let o=yield yi.encodeWeights(this.getNamedWeights(r)),l={modelTopology:this.toJSON(null,!1),format:bue,generatedBy:`TensorFlow.js tfjs-layers v${ig}`,convertedBy:null};if((r==null?!1:r.includeOptimizer)&&this.optimizer!=null){l.trainingConfig=this.getTrainingConfig();let u="optimizer",{data:p,specs:f}=yield yi.encodeWeights(yield this.optimizer.getWeights(),u);o.specs.push(...f),o.data=yi.concatenateArrayBuffers([o.data,p])}return this.userDefinedMetadata!=null&&(CD(this.userDefinedMetadata,this.name,!0),l.userDefinedMetadata=this.userDefinedMetadata),l.weightData=o.data,l.weightSpecs=o.specs,e.save(l)})}setUserDefinedMetadata(e){CD(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}return t.className="Model",t})();de.registerClass(Vl);var wue=(()=>{class t extends Vl{}return t.className="Functional",t})();de.registerClass(wue);var TD=(()=>{class t extends Vl{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:_u("sequential_"),e.layers!=null)for(let r of e.layers)this.add(r)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(o=>o<0))throw new Y(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){let r=e instanceof t||e instanceof Vl,o;if(r){if(o=e,o.outputs.length!==1)throw new Y("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(o.inputs.length!==1)throw new Y("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new Y("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let s=mD({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(s)}if(r)this.outputs=o.outputs,this.inputs=o.inputs;else{if(e.inboundNodes.length!==1)throw new Y(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new Y("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=hD(this.outputs[0])}this.inboundNodes=[],new Bl({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:js(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(s=>s.shape),outputShapes:this.outputs[0].shape})}else{let s=e.apply(this.outputs[0]);if(Array.isArray(s))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[s],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,r){return this.model==null&&this.build(),this.model.call(e,r)}build(e){if(at(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Vl({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,r,o=console.log){this.built||this.build(),super.summary(e,r,o)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,r,o={}){if(!this.built)throw new mo("The model needs to be compiled before being used.");return this.model.evaluate(e,r,o)}evaluateDataset(e,r){return te(this,null,function*(){if(!this.built)throw new mo("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,r)})}predict(e,r={}){return this.model==null&&this.build(),this.model.predict(e,r)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}fit(s,i){return te(this,arguments,function*(e,r,o={}){if(!this.built)throw new mo("The model needs to be compiled before being used.");return this.model.fit(e,r,o)})}fitDataset(e,r){return te(this,null,function*(){if(!this.built)throw new mo("The model needs to be compiled before being used.");return this.model.fitDataset(e,r)})}trainOnBatch(e,r){return te(this,null,function*(){return this.model.trainOnBatch(e,r)})}static fromConfig(e,r,o={},s=!1){let i,a={};if(r instanceof Array){if(r[0].className==null||r[0].className==="Merge")throw new Y("Legacy serialization format not supported yet.");i=r}else b.assert(r.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=r.layers,delete r.layers,a=r;let l=new e(a);if(!(l instanceof t))throw new Ze(`Sequential.fromConfig called on non-Sequential input: ${l}`);for(let c of i){let p=ns(c,void 0,s);s&&p.setFastWeightInitDuringBuild(!0),l.add(p)}return l}set stopTraining(e){if(this.model==null)throw new Y("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new Y("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let e=[];for(let r of this.layers){let o={};o.className=r.getClassName(),o.config=r.getConfig(),e.push(o)}return{name:this.name,layers:e}}}return t.className="Sequential",t})();de.registerClass(TD);var Dr=class extends de.Serializable{getConfig(){return{}}},Iue=(()=>{class t extends Dr{apply(e,r=1){return r8(e,r)}}return t.className="elu",t})();de.registerClass(Iue);var Sue=(()=>{class t extends Dr{apply(e){return Rm(e)}}return t.className="selu",t})();de.registerClass(Sue);var Tue=(()=>{class t extends Dr{apply(e){return Nr(e)}}return t.className="relu",t})();de.registerClass(Tue);var Eue=(()=>{class t extends Dr{apply(e){return X(()=>Is(6,Nr(e)))}}return t.className="relu6",t})();de.registerClass(Eue);var Nue=(()=>{class t extends Dr{apply(e){return e}}return t.className="linear",t})();de.registerClass(Nue);var Due=(()=>{class t extends Dr{apply(e){return Tr(e)}}return t.className="sigmoid",t})();de.registerClass(Due);var kue=(()=>{class t extends Dr{apply(e){return s8(e)}}return t.className="hardSigmoid",t})();de.registerClass(kue);var Aue=(()=>{class t extends Dr{apply(e){return mi(e)}}return t.className="softplus",t})();de.registerClass(Aue);var _ue=(()=>{class t extends Dr{apply(e){return o8(e)}}return t.className="softsign",t})();de.registerClass(_ue);var Rue=(()=>{class t extends Dr{apply(e){return hi(e)}}return t.className="tanh",t})();de.registerClass(Rue);var ND=(()=>{class t extends Dr{apply(e,r=-1){return Eu(e,r)}}return t.className="softmax",t})();de.registerClass(ND);var Mue=(()=>{class t extends Dr{apply(e,r=-1){return Em(e,r)}}return t.className="logSoftmax",t})();de.registerClass(Mue);var Oue=(()=>{class t extends Dr{apply(e){return X(()=>X(()=>{let r=Math.sqrt(2),o=z(.5,le(1,wm(ve(e,r))));return z(e,o)}))}}return t.className="gelu",t})();de.registerClass(Oue);var Fue=(()=>{class t extends Dr{apply(e){return X(()=>z(.5,z(e,le(1,hi(z(Wt(ve(2,Math.PI)),le(e,z(.044715,Lr(e,3)))))))))}}return t.className="gelu_new",t})();de.registerClass(Fue);var $ue=(()=>{class t extends Dr{apply(e){return X(()=>z(e,hi(mi(e))))}}return t.className="mish",t})();de.registerClass($ue);var Lue=(()=>{class t extends Dr{apply(e,r=1){return X(()=>z(Tr(z(e,r)),e))}}return t.className="swish",t})();de.registerClass(Lue);function wi(t){return t.getClassName()}function ED(t,n={}){return la(t,de.SerializationMap.getMap().classNameMap,n,"activation")}function Ci(t){if(t==null){let n={};return n.className="linear",n.config={},ED(n)}if(typeof t=="string"){let n={};return n.className=t,n.config={},ED(n)}else return t instanceof Dr?t:ED(t)}function Pue(t){if(t!=null&&typeof t!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${t}`)}var Dw=class extends de.Serializable{},W8=(()=>{class t extends Dw{constructor(e){super(),Pue(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return X(()=>{let r=cn([1]);return this.hasL1&&(r=le(r,Ne(z(this.l1,hn(e))))),this.hasL2&&(r=le(r,Ne(z(this.l2,vf(e))))),U(r,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,r){return new e({l1:r.l1,l2:r.l2})}}return t.className="L1L2",t})();de.registerClass(W8);var j8={l1l2:"L1L2"};function Ut(t){return Zm(t)}function H8(t,n={}){return la(t,de.SerializationMap.getMap().classNameMap,n,"regularizer")}function Jt(t){if(t==null)return null;if(typeof t=="string"){let e={className:t in j8?j8[t]:t,config:{}};return H8(e)}else return t instanceof Dw?t:H8(t)}var q8=(()=>{class t extends Qe{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,r){e=He(e);let o=Nr(e);return this.maxValue!=null&&(o=Qn(o,0,this.maxValue)),o}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ReLU",t})();de.registerClass(q8);var K8=(()=>{class t extends Qe{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,r){let o=He(e);return vu(o,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return t.className="LeakyReLU",t})();de.registerClass(K8);var X8=(()=>{class t extends Qe{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=Kt(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Jt(e.alphaRegularizer),this.alphaConstraint=kn(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new Y(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=at(e);let r=e.slice(1);if(this.sharedAxes!=null)for(let s of this.sharedAxes)r[s-1]=1;this.alpha=this.addWeight("alpha",r,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let o={};if(this.sharedAxes!=null)for(let s=1;s<e.length;++s)o[s]=e[s];this.inputSpec=[new Qt({ndim:e.length,axes:o})],this.built=!0}call(e,r){return e=He(e),Tu(e,this.alpha.read())}getConfig(){let e={alphaInitializer:un(this.alphaInitializer),alphaRegularizer:Ut(this.alphaRegularizer),alphaConstraint:Dn(this.alphaConstraint),sharedAxes:this.sharedAxes},r=super.getConfig();return Object.assign(e,r),e}}return t.className="PReLU",t})();de.registerClass(X8);var Y8=(()=>{class t extends Qe{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Ze(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,r){let o=He(e);return oa(o)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ELU",t})();de.registerClass(Y8);var Z8=(()=>{class t extends Qe{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,r){let o=He(e);return z(o,fe(En(o,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ThresholdedReLU",t})();de.registerClass(Z8);var Q8=(()=>{class t extends Qe{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new ND().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,r){return X(()=>{let o=He(e),s=r.mask;if(s!=null){let i=z(Ie(jn(o.shape),fe(s,o.dtype)),Ee(-1e9));o=le(o,i)}return this.axis instanceof Array?this.axis.length>1?gn(Ie(o,wu(o,this.axis,!0))):this.softmax(o,this.axis[0]):this.softmax(o,this.axis)})}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Softmax",t})();de.registerClass(Q8);function Ou(t,n,e){if(typeof t=="number")return js(t,n);if(t.length!==n)throw new Y(`The ${e} argument must be an integer or tuple of ${n} integers. Received: ${t.length} elements.`);for(let r=0;r<n;++r){let o=t[r];if(!J5(o))throw new Y(`The ${e} argument must be an integer or tuple of ${n} integers. Received: ${JSON.stringify(t)} including a non-integer number ${o}`)}return t}function $o(t,n,e,r,o=1){if(t==null)return t;let s=n+(n-1)*(o-1),i;return e==="same"?i=t:i=t-s+1,Math.floor((i+r-1)/r)}function Ii(t,n,e,r){if(t==null)return null;if(r==="valid")t=t*n+bi([e-n,0]);else if(r==="same")t=t*n;else throw new Y(`Unsupport padding mode: ${r}.`);return t}function K1(t,n){return X(()=>(wn(n),n==="channelsFirst"?ut(t,[0,2,3,1]):t))}function DD(t,n){return X(()=>(wn(n),n==="channelsFirst"?ut(t,[0,2,3,4,1]):t))}function zue(t,n,e,r=1,o="valid",s,i=1){return X(()=>{if(s==null&&(s=xo()),wn(s),t.shape.length!==3)throw new Y(`The input of a conv1dWithBias operation should be 3, but is ${t.shape.length} instead.`);if(n.shape.length!==3)throw new Y(`The kernel for a conv1dWithBias operation should be 3, but is ${n.shape.length} instead`);if(e!=null&&e.shape.length!==1)throw new Y(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(s==="channelsFirst"&&(t=ut(t,[0,2,1])),o==="causal")throw new Ze("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=hm(t,n,r,o==="same"?"same":"valid","NWC",i);return e!=null&&(a=vo(a,e)),a})}function J8(t,n,e,r=[1,1],o="valid",s,i,a=null){return X(()=>{if(s==null&&(s=xo()),wn(s),t.rank!==3&&t.rank!==4)throw new Y(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);if(n.rank!==3&&n.rank!==4)throw new Y(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);let l=K1(t,s);if(o==="causal")throw new Ze("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=ku.conv2d({x:l,filter:n,strides:r,pad:o==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:e,activation:a}),s==="channelsFirst"&&(l=ut(l,[0,3,1,2])),l})}function Vue(t,n,e,r=[1,1,1],o="valid",s,i){return X(()=>{if(s==null&&(s=xo()),wn(s),t.rank!==4&&t.rank!==5)throw new Y(`conv3dWithBias expects input to be of rank 4 or 5, but received ${t.rank}.`);if(n.rank!==4&&n.rank!==5)throw new Y(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${t.rank}.`);let a=DD(t,s);if(o==="causal")throw new Ze("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=Kv(a,n,r,o==="same"?"same":"valid","NDHWC",i),e!=null&&(a=vo(a,e)),s==="channelsFirst"&&(a=ut(a,[0,4,1,2,3])),a})}var q1=class t extends Qe{constructor(n,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.verifyArgs(e),this.rank=n,Bn(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Ze(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Ou(e.kernelSize,n,"kernelSize"),this.strides=Ou(e.strides==null?1:e.strides,n,"strides"),this.padding=e.padding==null?"valid":e.padding,go(this.padding),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,wn(this.dataFormat),this.activation=Ci(e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.biasInitializer=Kt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=kn(e.biasConstraint),this.biasRegularizer=Jt(e.biasRegularizer),this.activityRegularizer=Jt(e.activityRegularizer),this.dilationRate=Ou(e.dilationRate==null?1:e.dilationRate,n,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new Y(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new Y(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new Y(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(n){if(Ts("kernelSize"in n,"required key 'kernelSize' not in config"),typeof n.kernelSize!="number"&&!Kb(n.kernelSize,"number",1,3))throw new Y(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(n.kernelSize)}.`)}getConfig(){let n={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:wi(this.activation),useBias:this.useBias,biasInitializer:un(this.biasInitializer),biasRegularizer:Ut(this.biasRegularizer),activityRegularizer:Ut(this.activityRegularizer),biasConstraint:Dn(this.biasConstraint)},e=super.getConfig();return Object.assign(n,e),n}},lg=class t extends q1{constructor(n,e){super(n,e),this.kernel=null,t.verifyArgs(e),this.filters=e.filters,Bn(this.filters,"filters"),this.kernelInitializer=Kt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=kn(e.kernelConstraint),this.kernelRegularizer=Jt(e.kernelRegularizer)}build(n){n=at(n);let e=this.dataFormat==="channelsFirst"?1:n.length-1;if(n[e]==null)throw new Y(`The channel dimension of the input should be defined. Found ${n[e]}`);let r=n[e],o=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:r}}],this.built=!0}call(n,e){return X(()=>{n=He(n);let r,o=this.bias==null?null:this.bias.read(),s=Xb(this.activation.getClassName());if(s!=null&&this.rank===2)r=J8(n,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)r=zue(n,this.kernel.read(),o,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)r=J8(n,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)r=Vue(n,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Ze("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(r=this.activation.apply(r))}return r})}computeOutputShape(n){n=at(n);let e=[],r=this.dataFormat==="channelsLast"?n.slice(1,n.length-1):n.slice(2);for(let s=0;s<r.length;++s){let i=$o(r[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);e.push(i)}let o=[n[0]];return this.dataFormat==="channelsLast"?(o=o.concat(e),o.push(this.filters)):(o.push(this.filters),o=o.concat(e)),o}getConfig(){let n={filters:this.filters,kernelInitializer:un(this.kernelInitializer),kernelRegularizer:Ut(this.kernelRegularizer),kernelConstraint:Dn(this.kernelConstraint)},e=super.getConfig();return Object.assign(n,e),n}static verifyArgs(n){if(!("filters"in n)||typeof n.filters!="number"||n.filters<1)throw new Y(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(n.filters)}`)}},kD=(()=>{class t extends lg{constructor(e){super(2,e),t.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Kb(e.kernelSize,"number",1,2))throw new Y(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}return t.className="Conv2D",t})();de.registerClass(kD);var AD=(()=>{class t extends lg{constructor(e){super(3,e),t.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new Y(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}return t.className="Conv3D",t})();de.registerClass(AD);var e7=(()=>{class t extends kD{constructor(e){if(super(e),this.inputSpec=[new Qt({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new Y(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=at(e),e.length!==4)throw new Y("Input should have rank 4; Received input shape: "+JSON.stringify(e));let r=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[r]==null)throw new Y("The channel dimension of the inputs should be defined. Found `None`.");let o=e[r],s=this.kernelSize.concat([this.filters,o]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Qt({ndim:4,axes:{[r]:o}})],this.built=!0}call(e,r){return X(()=>{let o=He(e);if(o.shape.length!==4)throw new Y(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${o.shape.length}`);let s=o.shape,i=s[0],a,l;this.dataFormat==="channelsFirst"?(a=2,l=3):(a=1,l=2);let c=s[a],u=s[l],p=this.kernelSize[0],f=this.kernelSize[1],d=this.strides[0],h=this.strides[1],g=Ii(c,d,p,this.padding),m=Ii(u,h,f,this.padding),y=[i,g,m,this.filters];this.dataFormat!=="channelsLast"&&(o=ut(o,[0,2,3,1]));let x=gm(o,this.kernel.read(),y,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(x=ut(x,[0,3,1,2])),this.bias!=null&&(x=vo(x,this.bias.read(),this.dataFormat)),this.activation!=null&&(x=this.activation.apply(x)),x})}computeOutputShape(e){e=at(e);let r=e.slice(),o,s,i;this.dataFormat==="channelsFirst"?(o=1,s=2,i=3):(o=3,s=1,i=2);let a=this.kernelSize[0],l=this.kernelSize[1],c=this.strides[0],u=this.strides[1];return r[o]=this.filters,r[s]=Ii(r[s],c,a,this.padding),r[i]=Ii(r[i],u,l,this.padding),r}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}}return t.className="Conv2DTranspose",t})();de.registerClass(e7);var t7=(()=>{class t extends AD{constructor(e){if(super(e),this.inputSpec=[new Qt({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new Y(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=at(e),e.length!==5)throw new Y("Input should have rank 5; Received input shape: "+JSON.stringify(e));let r=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[r]==null)throw new Y("The channel dimension of the inputs should be defined. Found `None`.");let o=e[r],s=this.kernelSize.concat([this.filters,o]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Qt({ndim:5,axes:{[r]:o}})],this.built=!0}call(e,r){return X(()=>{let o=He(e);if(o.shape.length!==5)throw new Y(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${o.shape.length}`);let s=o.shape,i=s[0],a,l,c;this.dataFormat==="channelsFirst"?(c=2,a=3,l=4):(c=1,a=2,l=3);let u=s[c],p=s[a],f=s[l],d=this.kernelSize[0],h=this.kernelSize[1],g=this.kernelSize[2],m=this.strides[0],y=this.strides[1],x=this.strides[2],C=Ii(u,m,d,this.padding),I=Ii(p,y,h,this.padding),D=Ii(f,x,g,this.padding),O=[i,C,I,D,this.filters];this.dataFormat!=="channelsLast"&&(o=ut(o,[0,2,3,4,1]));let L=Yv(o,this.kernel.read(),O,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(L=ut(L,[0,4,1,2,3])),this.bias!==null&&(L=vo(L,this.bias.read(),this.dataFormat)),this.activation!==null&&(L=this.activation.apply(L)),L})}computeOutputShape(e){e=at(e);let r=e.slice(),o,s,i,a;this.dataFormat==="channelsFirst"?(o=1,s=2,i=3,a=4):(o=4,s=1,i=2,a=3);let l=this.kernelSize[0],c=this.kernelSize[1],u=this.kernelSize[2],p=this.strides[0],f=this.strides[1],d=this.strides[2];return r[o]=this.filters,r[s]=Ii(r[s],p,l,this.padding),r[i]=Ii(r[i],f,c,this.padding),r[a]=Ii(r[a],d,u,this.padding),r}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}}return t.className="Conv3DTranspose",t})();de.registerClass(t7);var Uue=(()=>{class t extends lg{constructor(e,r){if(super(e,r),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,r.filters==null)throw new Y("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(r.kernelInitializer!=null||r.kernelRegularizer!=null||r.kernelConstraint!=null)throw new Y("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(r.padding!=null&&r.padding!=="same"&&r.padding!=="valid")throw new Y(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(r.padding)}`);this.depthMultiplier=r.depthMultiplier==null?1:r.depthMultiplier,this.depthwiseInitializer=Kt(r.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Jt(r.depthwiseRegularizer),this.depthwiseConstraint=kn(r.depthwiseConstraint),this.pointwiseInitializer=Kt(r.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Jt(r.pointwiseRegularizer),this.pointwiseConstraint=kn(r.pointwiseConstraint)}build(e){if(e=at(e),e.length<this.rank+2)throw new Y(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let r=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[r]==null||e[r]<0)throw new Y(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[r])}`);let o=e[r],s=this.kernelSize.concat([o,this.depthMultiplier]),i=[];for(let l=0;l<this.rank;++l)i.push(1);i.push(o*this.depthMultiplier,this.filters);let a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new Qt({ndim:this.rank+2,axes:{[r]:o}})],this.built=!0}call(e,r){return X(()=>{e=He(e);let o;if(this.rank===1)throw new Ze("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=ut(e,[0,2,3,1])),o=Mm(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(o=vo(o,this.bias.read(),this.dataFormat)),this.activation!=null&&(o=this.activation.apply(o)),this.dataFormat==="channelsFirst"&&(o=ut(o,[0,3,1,2])),o})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=un(this.depthwiseInitializer),e.pointwiseInitializer=un(this.pointwiseInitializer),e.depthwiseRegularizer=Ut(this.depthwiseRegularizer),e.pointwiseRegularizer=Ut(this.pointwiseRegularizer),e.depthwiseConstraint=Dn(this.depthwiseConstraint),e.pointwiseConstraint=Dn(this.pointwiseConstraint),e}}return t.className="SeparableConv",t})();var n7=(()=>{class t extends Uue{constructor(e){super(2,e)}}return t.className="SeparableConv2D",t})();de.registerClass(n7);var r7=(()=>{class t extends lg{constructor(e){super(1,e),t.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){let e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Kb(e.kernelSize,"number",1,1))throw new Y(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}return t.className="Conv1D",t})();de.registerClass(r7);var o7=(()=>{class t extends Qe{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,r){return X(()=>{if(e=He(e),this.dataFormat==="channelsLast"){let o=P1(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return P1(o,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let o=P1(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return P1(o,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Cropping2D",t})();de.registerClass(o7);var s7=(()=>{class t extends Qe{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,wn(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,Z5(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){let r=e[2]==null?null:this.size[0]*e[2],o=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],r,o]}else{let r=e[1]==null?null:this.size[0]*e[1],o=e[2]==null?null:this.size[1]*e[2];return[e[0],r,o,e[3]]}}call(e,r){return X(()=>{let o=He(e),s=o.shape;if(this.dataFormat==="channelsFirst"){o=ut(o,[0,2,3,1]);let i=this.size[0]*s[2],a=this.size[1]*s[3],l=this.interpolation==="nearest"?nr.resizeNearestNeighbor(o,[i,a]):nr.resizeBilinear(o,[i,a]);return ut(l,[0,3,1,2])}else{let i=this.size[0]*s[1],a=this.size[1]*s[2];return this.interpolation==="nearest"?nr.resizeNearestNeighbor(o,[i,a]):nr.resizeBilinear(o,[i,a])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},r=super.getConfig();return Object.assign(e,r),e}}return t.className="UpSampling2D",t})();de.registerClass(s7);function Gue(t,n,e=[1,1],r="valid",o,s){return X(()=>{o==null&&(o=xo()),wn(o);let i=K1(t,o);if(t.rank!==4)throw new Y(`Input for depthwiseConv2d is required to be 4-D, but is instead ${t.rank}-D`);if(n.rank!==4)throw new Y(`depthwiseKernel is required to be 4-D, but is instead ${n.rank}-D`);return i=ra(i,n,e,r==="same"?"same":"valid","NHWC",s),o==="channelsFirst"&&(i=ut(i,[0,3,1,2])),i})}var i7=(()=>{class t extends q1{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=Kt(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=kn(e.depthwiseConstraint),this.depthwiseRegularizer=Jt(e.depthwiseRegularizer)}build(e){if(e=at(e),e.length<4)throw new Y(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let r=this.dataFormat==="channelsFirst"?1:3;if(e[r]==null||e[r]<0)throw new Y(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[r]}).`);let o=e[r],s=[this.kernelSize[0],this.kernelSize[1],o,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",s,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[o*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,r){return X(()=>{e=He(e);let o=Gue(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(o=vo(o,this.bias.read(),this.dataFormat)),this.activation!=null&&(o=this.activation.apply(o)),o})}computeOutputShape(e){e=at(e);let r=this.dataFormat==="channelsFirst"?e[2]:e[1],o=this.dataFormat==="channelsFirst"?e[3]:e[2],s=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=$o(r,this.kernelSize[0],this.padding,this.strides[0]),a=$o(o,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],s,i,a]:[e[0],i,a,s]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=un(this.depthwiseInitializer),e.depthwiseRegularizer=Ut(this.depthwiseRegularizer),e.depthwiseConstraint=Dn(this.depthwiseRegularizer),e}}return t.className="DepthwiseConv2D",t})();de.registerClass(i7);function _D(t,n,e,r){if(Array.isArray(t)){if(n!=null||e!=null)throw new Y("When inputs is an array, neither initialState or constants should be provided");r!=null&&(e=t.slice(t.length-r,t.length),t=t.slice(0,t.length-r)),t.length>1&&(n=t.slice(1,t.length)),t=t[0]}function o(s){return s==null||Array.isArray(s)?s:[s]}return n=o(n),e=o(e),{inputs:t,initialState:n,constants:e}}function RD(t,n,e,r=!1,o,s,i=!1,a=!1){return X(()=>{let l=n.shape.length;if(l<3)throw new Y(`Input should be at least 3D, but is ${l}D.`);let c=[1,0].concat(yo(2,l));if(n=ut(n,c),s!=null)throw new Ze("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),o!=null&&(o=fe(fe(o,"bool"),"float32"),o.rank===l-1&&(o=an(o,-1)),o=ut(o,c)),r&&(n=Jn(n,0),o!=null&&(o=Jn(o,0)));let u=[],p,f=e,d=n.shape[0],h=tr(n),g;o!=null&&(g=tr(o));for(let y=0;y<d;++y){let x=h[y],C=X(()=>t(x,f));if(o==null)p=C[0],f=C[1];else{let I=X(()=>{let D=g[y],O=Ie(cr(D),D),L=le(z(C[0],D),z(f[0],O)),B=f.map((V,F)=>le(z(C[1][F],D),z(V,O)));return{output:L,newStates:B}});p=I.output,f=I.newStates}a&&u.push(p)}let m;return a&&(m=Nn(u,1)),[p,m,f]})}var $u=(()=>{class t extends Qe{constructor(e){super(e);let r;if(e.cell==null)throw new Y("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?r=new FD({cells:e.cell}):r=e.cell,r.stateSize==null)throw new Y("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=r,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new Qt({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return yo(0,e).map(r=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){sw(e)&&(e=e[0]),e=e;let r=this.cell.stateSize;Array.isArray(r)||(r=[r]);let o=r[0],s;if(this.returnSequences?s=[e[0],e[1],o]:s=[e[0],o],this.returnState){let i=[];for(let a of r)i.push([e[0],a]);return[s].concat(i)}else return s}computeMask(e,r){return X(()=>{Array.isArray(r)&&(r=r[0]);let o=this.returnSequences?r:null;if(this.returnState){let s=this.states.map(i=>null);return[o].concat(s)}else return o})}get states(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,r=[];for(let o=0;o<e;++o)r.push(null);return r}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new Ze("Constants support is not implemented in RNN yet.");sw(e)&&(e=e[0]),e=e;let o=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new Qt({shape:[o,null,...s]});let i=[e[0]].concat(e.slice(2));this.cell.build(i);let a;if(Array.isArray(this.cell.stateSize)?a=this.cell.stateSize:a=[this.cell.stateSize],this.stateSpec!=null){if(!b.arraysEqual(this.stateSpec.map(l=>l.shape[l.shape.length-1]),a))throw new Y(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(l=>new Qt({shape:[null,l]}));this.stateful&&this.resetStates()}resetStates(e,r=!1){X(()=>{if(!this.stateful)throw new Ss("Cannot call resetStates() on an RNN Layer that is not stateful.");let o=this.inputSpec[0].shape[0];if(o==null)throw new Y("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>cn([o,s])):this.states_=[cn([o,this.cell.stateSize])];else if(e==null)Ve(this.states_),this.keptStates!=null&&(Ve(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>cn([o,s])):this.states_[0]=cn([o,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Y(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);r===!0?this.keptStates.push(this.states_.slice()):Ve(this.states_);for(let s=0;s<this.states_.length;++s){let i=e[s],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[s]:this.cell.stateSize,l=[o,a];if(!b.arraysEqual(i.shape,l))throw new Y(`State ${s} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${i.shape}`);this.states_[s]=i}}this.states_=this.states_.map(s=>mn(s.clone()))})}apply(e,r){let o=r==null?null:r.initialState,s=r==null?null:r.constants;r==null&&(r={});let i=_D(e,o,s,this.numConstants);e=i.inputs,o=i.initialState,s=i.constants;let a=[],l=[];if(o!=null){r.initialState=o,a=a.concat(o),this.stateSpec=[];for(let u of o)this.stateSpec.push(new Qt({shape:u.shape}));l=l.concat(this.stateSpec)}if(s!=null&&(r.constants=s,a=a.concat(s),this.numConstants=s.length),a[0]instanceof no){let u=[e].concat(a),p=this.inputSpec.concat(l),f=this.inputSpec;this.inputSpec=p;let d=super.apply(u,r);return this.inputSpec=f,d}else return super.apply(e,r)}call(e,r){return X(()=>{let o=r==null?null:r.mask,s=r==null?null:r.training,i=r==null?null:r.initialState;e=He(e),i==null&&(this.stateful?i=this.states_:i=this.getInitialState(e));let a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==a)throw new Y(`RNN Layer has ${a} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let l={training:s},u=RD((g,m)=>{let y=this.cell.call([g].concat(m),l);return[y[0],y.slice(1)]},e,i,this.goBackwards,o,null,this.unroll,this.returnSequences),p=u[0],f=u[1],d=u[2];this.stateful&&this.resetStates(d,s);let h=this.returnSequences?f:p;return this.returnState?[h].concat(d):h})}getInitialState(e){return X(()=>{let r=cn(e.shape);return r=Ne(r,[1,2]),r=Pl(r),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(o=>o>1?tw(r,[1,o]):r):this.cell.stateSize>1?[tw(r,[1,this.cell.stateSize])]:[r]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){let e=super.getConfig(),r={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(r.numConstants=this.numConstants);let o=this.cell.getConfig();return this.getClassName()===t.className&&(r.cell={className:this.cell.getClassName(),config:o}),Object.assign(Object.assign(Object.assign({},o),e),r)}static fromConfig(e,r,o={}){let s=r.cell,i=ns(s,o);return new e(Object.assign(r,{cell:i}))}}return t.className="RNN",t})();de.registerClass($u);var Fu=class extends Qe{},MD=(()=>{class t extends Fu{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Bn(this.units,"units"),this.activation=Ci(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Kt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Kt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Kt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Jt(e.kernelRegularizer),this.recurrentRegularizer=Jt(e.recurrentRegularizer),this.biasRegularizer=Jt(e.biasRegularizer),this.kernelConstraint=kn(e.kernelConstraint),this.recurrentConstraint=kn(e.recurrentConstraint),this.biasConstraint=kn(e.biasConstraint),this.dropout=xf([1,bi([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=xf([1,bi([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=at(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,r){return X(()=>{if(e=e,e.length!==2)throw new Y(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let o=e[1];e=e[0];let s=r.training==null?!1:r.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Ul({ones:()=>cr(e),rate:this.dropout,training:s,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Ul({ones:()=>cr(o),rate:this.recurrentDropout,training:s,dropoutFunc:this.dropoutFunc}));let i,a=this.dropoutMask,l=this.recurrentDropoutMask;a!=null?i=Ks(z(e,a),this.kernel.read()):i=Ks(e,this.kernel.read()),this.bias!=null&&(i=vo(i,this.bias.read())),l!=null&&(o=z(o,l));let c=le(i,Ks(o,this.recurrentKernel.read()));return this.activation!=null&&(c=this.activation.apply(c)),[c,c]})}getConfig(){let e=super.getConfig(),r={units:this.units,activation:wi(this.activation),useBias:this.useBias,kernelInitializer:un(this.kernelInitializer),recurrentInitializer:un(this.recurrentInitializer),biasInitializer:un(this.biasInitializer),kernelRegularizer:Ut(this.kernelRegularizer),recurrentRegularizer:Ut(this.recurrentRegularizer),biasRegularizer:Ut(this.biasRegularizer),activityRegularizer:Ut(this.activityRegularizer),kernelConstraint:Dn(this.kernelConstraint),recurrentConstraint:Dn(this.recurrentConstraint),biasConstraint:Dn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),r)}}return t.className="SimpleRNNCell",t})();de.registerClass(MD);var a7=(()=>{class t extends $u{constructor(e){e.cell=new MD(e),super(e)}call(e,r){return X(()=>{this.cell.dropoutMask!=null&&(Ve(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ve(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let o=r==null?null:r.mask,s=r==null?null:r.training,i=r==null?null:r.initialState;return super.call(e,{mask:o,training:s,initialState:i})})}static fromConfig(e,r){return new e(r)}}return t.className="SimpleRNN",t})();de.registerClass(a7);var OD=(()=>{class t extends Fu{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new Y("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Bn(this.units,"units"),this.activation=Ci(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Ci(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Kt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Kt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Kt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Jt(e.kernelRegularizer),this.recurrentRegularizer=Jt(e.recurrentRegularizer),this.biasRegularizer=Jt(e.biasRegularizer),this.kernelConstraint=kn(e.kernelConstraint),this.recurrentConstraint=kn(e.recurrentConstraint),this.biasConstraint=kn(e.biasConstraint),this.dropout=xf([1,bi([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=xf([1,bi([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=at(e);let r=e[e.length-1];this.kernel=this.addWeight("kernel",[r,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,r){return X(()=>{if(e=e,e.length!==2)throw new Y(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let o=r.training==null?!1:r.training,s=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Ul({ones:()=>cr(e),rate:this.dropout,training:o,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Ul({ones:()=>cr(s),rate:this.recurrentDropout,training:o,count:3,dropoutFunc:this.dropoutFunc}));let i=this.dropoutMask,a=this.recurrentDropoutMask,l,c,u;0<this.dropout&&this.dropout<1&&(e=z(e,i[0]));let p=Ks(e,this.kernel.read());this.useBias&&(p=vo(p,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=z(s,a[0]));let f=this.recurrentKernel.read(),[d,h]=er(f,[2*this.units,this.units],f.rank-1),g=Ks(s,d),[m,y,x]=er(p,3,p.rank-1),[C,I]=er(g,2,g.rank-1);l=this.recurrentActivation.apply(le(m,C)),c=this.recurrentActivation.apply(le(y,I));let D=Ks(z(c,s),h);u=this.activation.apply(le(x,D));let O=le(z(l,s),z(le(1,ft(l)),u));return[O,O]})}getConfig(){let e=super.getConfig(),r={units:this.units,activation:wi(this.activation),recurrentActivation:wi(this.recurrentActivation),useBias:this.useBias,kernelInitializer:un(this.kernelInitializer),recurrentInitializer:un(this.recurrentInitializer),biasInitializer:un(this.biasInitializer),kernelRegularizer:Ut(this.kernelRegularizer),recurrentRegularizer:Ut(this.recurrentRegularizer),biasRegularizer:Ut(this.biasRegularizer),activityRegularizer:Ut(this.activityRegularizer),kernelConstraint:Dn(this.kernelConstraint),recurrentConstraint:Dn(this.recurrentConstraint),biasConstraint:Dn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),r)}}return t.className="GRUCell",t})();de.registerClass(OD);var l7=(()=>{class t extends $u{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new OD(e),super(e)}call(e,r){return X(()=>{this.cell.dropoutMask!=null&&(Ve(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ve(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let o=r==null?null:r.mask,s=r==null?null:r.training,i=r==null?null:r.initialState;return super.call(e,{mask:o,training:s,initialState:i})})}static fromConfig(e,r){return r.implmentation===0&&(r.implementation=1),new e(r)}}return t.className="GRU",t})();de.registerClass(l7);var X1=(()=>{class t extends Fu{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Bn(this.units,"units"),this.activation=Ci(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Ci(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Kt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Kt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Kt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Jt(e.kernelRegularizer),this.recurrentRegularizer=Jt(e.recurrentRegularizer),this.biasRegularizer=Jt(e.biasRegularizer),this.kernelConstraint=kn(e.kernelConstraint),this.recurrentConstraint=kn(e.recurrentConstraint),this.biasConstraint=kn(e.biasConstraint),this.dropout=xf([1,bi([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=xf([1,bi([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var r;e=at(e);let o=e[e.length-1];this.kernel=this.addWeight("kernel",[o,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let s;if(this.useBias){if(this.unitForgetBias){let i=this.biasInitializer,a=this.units;s=new(r=class extends bo{apply(c,u){let p=i.apply([a]),f=new ow().apply([a]),d=i.apply([a*2]);return aD(aD(p,f),d)}},r.className="CustomInit",r)}else s=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,s,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,r){return X(()=>{let o=r.training==null?!1:r.training;if(e=e,e.length!==3)throw new Y(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let s=e[1],i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Ul({ones:()=>cr(e),rate:this.dropout,training:o,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Ul({ones:()=>cr(s),rate:this.recurrentDropout,training:o,count:4,dropoutFunc:this.dropoutFunc}));let a=this.dropoutMask,l=this.recurrentDropoutMask,c,u,p,f;0<this.dropout&&this.dropout<1&&(e=z(e,a[0]));let d=Ks(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=z(s,l[0])),d=le(d,Ks(s,this.recurrentKernel.read())),this.useBias&&(d=vo(d,this.bias.read()));let[h,g,m,y]=er(d,4,d.rank-1);c=this.recurrentActivation.apply(h),u=this.recurrentActivation.apply(g),p=le(z(u,i),z(c,this.activation.apply(m))),f=this.recurrentActivation.apply(y);let x=z(f,this.activation.apply(p));return[x,x,p]})}getConfig(){let e=super.getConfig(),r={units:this.units,activation:wi(this.activation),recurrentActivation:wi(this.recurrentActivation),useBias:this.useBias,kernelInitializer:un(this.kernelInitializer),recurrentInitializer:un(this.recurrentInitializer),biasInitializer:un(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Ut(this.kernelRegularizer),recurrentRegularizer:Ut(this.recurrentRegularizer),biasRegularizer:Ut(this.biasRegularizer),activityRegularizer:Ut(this.activityRegularizer),kernelConstraint:Dn(this.kernelConstraint),recurrentConstraint:Dn(this.recurrentConstraint),biasConstraint:Dn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),r)}}return t.className="LSTMCell",t})();de.registerClass(X1);var c7=(()=>{class t extends $u{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new X1(e),super(e)}call(e,r){return X(()=>{this.cell.dropoutMask!=null&&(Ve(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ve(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let o=r==null?null:r.mask,s=r==null?null:r.training,i=r==null?null:r.initialState;return super.call(e,{mask:o,training:s,initialState:i})})}static fromConfig(e,r){return r.implmentation===0&&(r.implementation=1),new e(r)}}return t.className="LSTM",t})();de.registerClass(c7);var FD=(()=>{class t extends Fu{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let r of this.cells.slice().reverse())Array.isArray(r.stateSize)?e.push(...r.stateSize):e.push(r.stateSize);return e}call(e,r){return X(()=>{e=e;let o=e.slice(1),s=[];for(let l of this.cells.slice().reverse())Array.isArray(l.stateSize)?s.push(o.splice(0,l.stateSize.length)):s.push(o.splice(0,1));s.reverse();let i=[],a;for(let l=0;l<this.cells.length;++l){let c=this.cells[l];o=s[l],l===0?a=[e[0]].concat(o):a=[a[0]].concat(o),a=c.call(a,r),i.push(a.slice(1))}o=[];for(let l of i.slice().reverse())o.push(...l);return[a[0]].concat(o)})}build(e){sw(e)&&(e=e[0]),e=e;let r;this.cells.forEach((o,s)=>{vi(`RNNCell_${s}`,()=>{o.build(e),Array.isArray(o.stateSize)?r=o.stateSize[0]:r=o.stateSize,e=[e[0],r]})}),this.built=!0}getConfig(){let e=super.getConfig(),r=i=>({className:i.getClassName(),config:i.getConfig()}),s={cells:this.cells.map(r)};return Object.assign(Object.assign({},e),s)}static fromConfig(e,r,o={}){let s=[];for(let i of r.cells)s.push(ns(i,o));return new e({cells:s})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let r of this.cells)e.push(...r.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let r of this.cells)e.push(...r.nonTrainableWeights);if(!this.trainable){let r=[];for(let o of this.cells)r.push(...o.trainableWeights);return r.concat(e)}return e}getWeights(){let e=[];for(let r of this.cells)e.push(...r.weights);return z1(e)}setWeights(e){let r=[];for(let o of this.cells){let s=o.weights.length,i=e.splice(s);for(let a=0;a<o.weights.length;++a)r.push([o.weights[a],i[a]])}rg(r)}}return t.className="StackedRNNCells",t})();de.registerClass(FD);function Ul(t){let{ones:n,rate:e,training:r=!1,count:o=1,dropoutFunc:s}=t,i=()=>s!=null?s(n(),e):rw(n(),e),a=()=>Ru(i,n,r);return!o||o<=1?mn(a().clone()):Array(o).fill(void 0).map(a).map(c=>mn(c.clone()))}var jue=function(t,n){var e={};for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&n.indexOf(r)<0&&(e[r]=t[r]);if(t!=null&&typeof Object.getOwnPropertySymbols=="function")for(var o=0,r=Object.getOwnPropertySymbols(t);o<r.length;o++)n.indexOf(r[o])<0&&Object.prototype.propertyIsEnumerable.call(t,r[o])&&(e[r[o]]=t[r[o]]);return e};var Hue=(()=>{class t extends $u{constructor(e){if(e.unroll)throw new Ze("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Ze("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Qt({ndim:5})]}call(e,r){return X(()=>{if(this.cell.dropoutMask!=null&&(Ve(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ve(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),r&&r.constants)throw new Y("ConvRNN2D cell does not support constants");let o=r==null?null:r.mask,s=r==null?null:r.training,i=r==null?null:r.initialState;return super.call(e,{mask:o,training:s,initialState:i})})}computeOutputShape(e){let r=this.computeSingleOutputShape(e);return this.returnSequences||(r=[r[0],...r.slice(2)]),this.returnState&&(r=[r,...Array(2).fill([e[0],...r.slice(-3)])]),r}getInitialState(e){return X(()=>{let{stateSize:r}=this.cell,o=e.shape,s=this.computeSingleOutputShape(o),i=[s[0],...s.slice(2)],a=cn(i);return Array.isArray(r)?Array(r.length).fill(a):[a]})}resetStates(e,r=!1){X(()=>{if(!this.stateful)throw new Ss("Cannot call resetStates() on an RNN Layer that is not stateful.");let o=this.inputSpec[0].shape,s=this.computeSingleOutputShape(o),i=[s[0],...s.slice(2)];if(o[0]==null)throw new Y("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>cn(i)):this.states_=[cn(i)];else if(e==null)Ve(this.states_),this.keptStates!=null&&(Ve(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>cn(i)):this.states_[0]=cn(i);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Y(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);r?this.keptStates.push(this.states_.slice()):Ve(this.states_);for(let l=0;l<this.states_.length;++l){let c=e[l],u=i;if(!b.arraysEqual(c.shape,u))throw new Y(`State ${l} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${c.shape}`);this.states_[l]=c}}this.states_=this.states_.map(l=>mn(l.clone()))})}computeSingleOutputShape(e){let{dataFormat:r,filters:o,kernelSize:s,padding:i,strides:a,dilationRate:l}=this.cell,c=r==="channelsFirst",u=e[c?3:2],p=e[c?4:3],f=$o(u,s[0],i,a[0],l[0]),d=$o(p,s[1],i,a[1],l[1]);return[...e.slice(0,2),...c?[o,f,d]:[f,d,o]]}}return t.className="ConvRNN2D",t})(),$D=(()=>{class t extends X1{constructor(e){let{filters:r,kernelSize:o,strides:s,padding:i,dataFormat:a,dilationRate:l}=e;super(Object.assign(Object.assign({},e),{units:r})),this.filters=r,Bn(this.filters,"filters"),this.kernelSize=Ou(o,2,"kernelSize"),this.kernelSize.forEach(c=>Bn(c,"kernelSize")),this.strides=Ou(s||1,2,"strides"),this.strides.forEach(c=>Bn(c,"strides")),this.padding=i||"valid",go(this.padding),this.dataFormat=a||"channelsLast",wn(this.dataFormat),this.dilationRate=Ou(l||1,2,"dilationRate"),this.dilationRate.forEach(c=>Bn(c,"dilationRate"))}build(e){var r;e=at(e);let o=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[o]==null)throw new Y(`The channel dimension of the input should be defined. Found ${e[o]}`);let s=e[o],i=4,a=this.kernelSize.concat([s,this.filters*i]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let l=this.kernelSize.concat([this.filters,this.filters*i]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",l,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let c;if(this.unitForgetBias){let u=this.biasInitializer,p=this.filters;c=new(r=class extends bo{apply(d,h){let g=u.apply([p]),m=jn([p]),y=u.apply([p*2]);return Jm([g,m,y])}},r.className="CustomInit",r)}else c=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*i],null,c,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,r){return X(()=>{if(e.length!==3)throw new Y(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let o=r.training||!1,s=e[0],i=e[1],a=e[2],l=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Ul({ones:()=>cr(s),rate:this.dropout,training:o,count:l,dropoutFunc:this.dropoutFunc}));let c=this.dropoutMask,u=(be,Te,Se)=>!Te||!Te[Se]?be:z(Te[Se],be),p=u(s,c,0),f=u(s,c,1),d=u(s,c,2),h=u(s,c,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Ul({ones:()=>cr(i),rate:this.recurrentDropout,training:o,count:l,dropoutFunc:this.dropoutFunc}));let g=this.recurrentDropoutMask,m=u(i,g,0),y=u(i,g,1),x=u(i,g,2),C=u(i,g,3),I=3,[D,O,L,B]=er(this.kernel.read(),l,I),[V,F,G,ee]=this.useBias?er(this.bias.read(),l):[null,null,null,null];p=this.inputConv(p,D,V,this.padding),f=this.inputConv(f,O,F,this.padding),d=this.inputConv(d,L,G,this.padding),h=this.inputConv(h,B,ee,this.padding);let[Q,oe,ae,J]=er(this.recurrentKernel.read(),l,I);m=this.recurrentConv(m,Q),y=this.recurrentConv(y,oe),x=this.recurrentConv(x,ae),C=this.recurrentConv(C,J);let re=this.recurrentActivation.apply(le(p,m)),se=this.recurrentActivation.apply(le(f,y)),pe=le(z(se,a),z(re,this.activation.apply(le(d,x)))),xe=z(this.recurrentActivation.apply(le(h,C)),this.activation.apply(pe));return[xe,xe,pe]})}getConfig(){let e=super.getConfig(),{units:r}=e,o=jue(e,["units"]),s={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},o),s)}inputConv(e,r,o,s){let i=Mo(e,r,this.strides,s||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return o?vo(i,o,this.dataFormat):i}recurrentConv(e,r){return Mo(e,r,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}return t.className="ConvLSTM2DCell",t})();de.registerClass($D);var u7=(()=>{class t extends Hue{constructor(e){let r=new $D(e);super(Object.assign(Object.assign({},e),{cell:r}))}static fromConfig(e,r){return new e(r)}}return t.className="ConvLSTM2D",t})();de.registerClass(u7);var LD=(()=>{class t extends Qe{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let r=e.shape,o=[];for(let s=0;s<this.noiseShape.length;++s)o.push(this.noiseShape[s]==null?r[s]:this.noiseShape[s]);return o}call(e,r){return X(()=>{this.invokeCallHook(e,r);let o=He(e);if(0<this.rate&&this.rate<1){let s=r.training==null?!1:r.training,i=this.getNoiseShape(o);return Ru(()=>rw(o,this.rate,i,this.seed),()=>o,s)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},r=super.getConfig();return Object.assign(e,r),e}dispose(){return super.dispose()}}return t.className="Dropout",t})();de.registerClass(LD);var p7=(()=>{class t extends LD{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let r=e.shape;return[r[0],1,r[2]]}}return t.className="SpatialDropout1D",t})();de.registerClass(p7);var f7=(()=>{class t extends Qe{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let r=null;e.batchSize!=null&&(r=e.batchSize),this.batchInputShape=[r,e.inputDim]}this.units=e.units,Bn(this.units,"units"),this.activation=Ci(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=Kt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Kt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=kn(e.kernelConstraint),this.biasConstraint=kn(e.biasConstraint),this.kernelRegularizer=Jt(e.kernelRegularizer),this.biasRegularizer=Jt(e.biasRegularizer),this.activityRegularizer=Jt(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=at(e);let r=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[r,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:r}}],this.built=!0}computeOutputShape(e){e=at(e);let r=e.slice();return r[r.length-1]=this.units,r}call(e,r){return X(()=>{this.invokeCallHook(e,r);let o=He(e),s=Xb(this.activation.getClassName()),i;return s!=null?i=Ks(o,this.kernel.read(),s,this.bias?this.bias.read():null):(i=Ks(o,this.kernel.read()),this.bias!=null&&(i=vo(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))),i})}getConfig(){let e={units:this.units,activation:wi(this.activation),useBias:this.useBias,kernelInitializer:un(this.kernelInitializer),biasInitializer:un(this.biasInitializer),kernelRegularizer:Ut(this.kernelRegularizer),biasRegularizer:Ut(this.biasRegularizer),activityRegularizer:Ut(this.activityRegularizer),kernelConstraint:Dn(this.kernelConstraint),biasConstraint:Dn(this.biasConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Dense",t})();de.registerClass(f7);var d7=(()=>{class t extends Qe{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=at(e);for(let r of e.slice(1))if(r==null)throw new Y(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],qs(e,1)]}call(e,r){return X(()=>{this.invokeCallHook(e,r);let o=He(e);if(this.dataFormat==="channelsFirst"&&o.rank>1){let s=[0];for(let i=2;i<o.rank;++i)s.push(i);s.push(1),o=ut(o,s)}return n8(o)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let r=super.getConfig();return Object.assign(e,r),e}}return t.className="Flatten",t})();de.registerClass(d7);var h7=(()=>{class t extends Qe{constructor(e){super(e),this.supportsMasking=!0,this.activation=Ci(e.activation)}call(e,r){return X(()=>{this.invokeCallHook(e,r);let o=He(e);return this.activation.apply(o)})}getConfig(){let e={activation:wi(this.activation)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Activation",t})();de.registerClass(h7);var m7=(()=>{class t extends Qe{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,r){return X(()=>(e=He(e),e8(e,this.n)))}getConfig(){let e={n:this.n},r=super.getConfig();return Object.assign(e,r),e}}return t.className="RepeatVector",t})();de.registerClass(m7);var g7=(()=>{class t extends Qe{constructor(e){super(e),this.targetShape=e.targetShape;for(let r=0;r<this.targetShape.length;++r)this.isUnknown(this.targetShape[r])&&(this.targetShape[r]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,r){let o="Total size of new array must be unchanged.",s=r.slice(),i=1,a=null;for(let c=0;c<s.length;++c){let u=s[c];if(this.isUnknown(u))if(a===null)a=c;else throw new Y("Can only specifiy one unknown dimension.");else i*=u}let l=qs(e);if(a!==null){if(i===0||l%i!==0)throw new Y(o);s[a]=l/i}else if(l!==i)throw new Y(o);return s}computeOutputShape(e){let r=!1;for(let o=0;o<e.length;++o)if(this.isUnknown(e[o])){r=!0;break}return r?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,r){return X(()=>{this.invokeCallHook(e,r);let o=He(e),s=o.shape,i=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return U(o,i)})}getConfig(){let e={targetShape:this.targetShape},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Reshape",t})();de.registerClass(g7);var y7=(()=>{class t extends Qe{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let r=yo(1,e.dims.length+1);if(!b.arraysEqual(e.dims.slice().sort(),r))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Qt({ndim:this.dims.length+1})]}computeOutputShape(e){e=at(e);let r=e.slice();return this.dims.forEach((o,s)=>{r[s+1]=e[o]}),r}call(e,r){return ut(He(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Permute",t})();de.registerClass(y7);var x7=(()=>{class t extends Qe{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),r={maskValue:this.maskValue};return Object.assign(r,e),r}computeMask(e,r){let o=He(e);return ef(gi(o,this.maskValue),-1)}call(e,r){return X(()=>{this.invokeCallHook(e,r);let o=He(e),a=ef(gi(o,this.maskValue),-1,!0);return z(o,fe(a,o.dtype))})}}return t.className="Masking",t})();de.registerClass(x7);var v7=(()=>{class t extends Qe{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let r=null;e.batchSize!=null&&(r=e.batchSize),e.inputLength==null?this.batchInputShape=[r,null]:this.batchInputShape=[r].concat(Lt(e.inputLength))}this.inputDim=e.inputDim,Bn(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Bn(this.outputDim,"outputDim"),this.embeddingsInitializer=Kt(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Jt(e.embeddingsRegularizer),this.activityRegularizer=Jt(e.activityRegularizer),this.embeddingsConstraint=kn(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,r){return X(()=>this.maskZero?(e=He(e),gi(e,Ge(e))):null)}computeOutputShape(e){if(e=at(e),this.inputLength==null)return[...e,this.outputDim];let r=Lt(this.inputLength);if(r.length!==e.length-1)throw new Y(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let o=0;for(let s=0;s<r.length;++s){let i=r[s],a=e[s+1];if(i!=null&&a!=null&&i!==a)throw new Y(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);i==null&&(r[o]=a),o++}}return[e[0],...r,this.outputDim]}call(e,r){return X(()=>{this.invokeCallHook(e,r);let o=He(e);o.dtype!=="int32"&&(o=to(o,"int32"));let s=nw(this.embeddings.read(),U(o,[o.size]));return U(s,at(this.computeOutputShape(o.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:un(this.embeddingsInitializer),embeddingsRegularizer:Ut(this.embeddingsRegularizer),activityRegularizer:Ut(this.activityRegularizer),embeddingsConstraint:Dn(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Embedding",t})();de.registerClass(v7);var Gl=class extends Qe{constructor(n){super(n||{}),this.supportsMasking=!0}mergeFunction(n){throw new Ze}computeElementwiseOpOutputShape(n,e){if(n==null||e==null)return null;if(n.length<e.length)return this.computeElementwiseOpOutputShape(e,n);if(e.length===0)return n;let r=n.slice(0,n.length-e.length);for(let o=0;o<e.length;++o){let s=n[n.length-e.length+o],i=e[o];if(s==null||i==null||s<0||i<0)r.push(null);else if(s===1)r.push(i);else if(i===1)r.push(s);else{if(s!==i)throw new Y("Operands could not be broadcast together with shapes "+JSON.stringify(n)+" "+JSON.stringify(e));r.push(s)}}return r}build(n){if(Array.isArray(n)&&!Array.isArray(n[0])&&(n=[at(n)]),n=n,n.length<2)throw new Y(`A merge layer should be called on an Array of at least 2 inputs. Got ${n.length} input(s).`);let e=[];for(let s of n)s!=null&&s[0]!==null&&e.push(s[0]);if(e=Ws(e),e.length>1)throw new Y(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(n)}.`);let r=n[0]==null?null:n[0].slice(1);for(let s=1;s<n.length;++s){let i=n[s]==null?null:n[s].slice(1);r=this.computeElementwiseOpOutputShape(r,i)}let o=n.map(s=>s.length);n.indexOf(null)===-1&&Ws(o).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(n,e){return X(()=>{if(n=n,this.reshapeRequired){let r=[],o=n.map(s=>s.rank);if(o.indexOf(null)===-1){let s=bi(o);for(let i of n){let a=i.rank;for(let l=0;l<s-a;++l)i=Pl(i,1);r.push(i)}return this.mergeFunction(r)}else{let s=!1;for(let l of n){let c=l.rank;if(c==null){let u=l.shape,p=u[0],f=u.slice(1).concat([p]),d=U(l,[p].concat(qs(u.slice(1))));d=ut(d,[1,0]),d=U(d,f),r.push(d),s=!0}else if(c>1){let u=yo(1,c).concat([0]);r.push(ut(l,u)),s=!0}else r.push(l)}let i=this.mergeFunction(r),a=i.rank;if(s){if(a==null){let l=i.shape,c=l.length,u=l[c-1],p=[u].concat(l.slice(0,l.length-1));i=U(ut(U(i,[-1,u]),[1,0]),p)}else if(a>1){let l=[a-1].concat(yo(0,a-1));i=ut(i,l)}}return i}}else return this.mergeFunction(n)})}computeOutputShape(n){n=n;let e;n[0]==null?e=null:e=n[0].slice(1);for(let o=1;o<n.length;++o){let s=n[o]==null?null:n[o].slice(1);e=this.computeElementwiseOpOutputShape(e,s)}let r=[];for(let o of n)o!=null&&o[0]!==null&&r.push(o[0]);return r=Ws(r),r.length===1?e=r.concat(e):e=[null].concat(e),e}computeMask(n,e){return X(()=>{if(e==null)return null;if(!Array.isArray(e))throw new Y("`mask` should be an Array");if(!Array.isArray(n))throw new Y("`inputs` should be an Array");if(e.length!==n.length)throw new Y(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${n.length} vs ${e.length})`);if(e.every(o=>o==null))return null;e=e.map(o=>o==null?o:an(o,0));let r=e[0];for(let o=1;o<e.length-1;++o)r=Pr(r,e[o]);return r})}},b7=(()=>{class t extends Gl{constructor(e){super(e)}mergeFunction(e){return X(()=>{let r=e[0].clone();for(let o=1;o<e.length;++o)r=le(r,e[o]);return r})}}return t.className="Add",t})();de.registerClass(b7);var w7=(()=>{class t extends Gl{constructor(e){super(e)}mergeFunction(e){return X(()=>{let r=e[0].clone();for(let o=1;o<e.length;++o)r=z(r,e[o]);return r})}}return t.className="Multiply",t})();de.registerClass(w7);var C7=(()=>{class t extends Gl{constructor(e){super(e)}mergeFunction(e){return X(()=>{let r=e[0].clone();for(let o=1;o<e.length;++o)r=le(r,e[o]);return z(1/e.length,r)})}}return t.className="Average",t})();de.registerClass(C7);var I7=(()=>{class t extends Gl{constructor(e){super(e)}mergeFunction(e){return X(()=>{let r=e[0];for(let o=1;o<e.length;++o)r=Fo(r,e[o]);return r})}}return t.className="Maximum",t})();de.registerClass(I7);var S7=(()=>{class t extends Gl{constructor(e){super(e)}mergeFunction(e){return X(()=>{let r=e[0];for(let o=1;o<e.length;++o)r=Is(r,e[o]);return r})}}return t.className="Minimum",t})();de.registerClass(S7);var T7=(()=>{class t extends Gl{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new Y("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let r=!0;for(let s of e)if(s!=null){r=!1;break}if(r)return;let o=[];for(let s=0;s<e.length;++s){let i=e[s].slice();i.splice(this.axis,1);let a=!1;for(let l of o)if(b.arraysEqual(l,i)){a=!0;break}a||o.push(i)}if(o.length>1)throw new Y("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return X(()=>Jm(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new Y("A `Concatenate` layer should be called on a list of inputs.");let r=e,o=r[0].slice(),s=this.axis<0?o.length+this.axis:this.axis;for(let i of r.slice(1)){if(o[s]==null||i[s]==null){o[s]=null;break}o[s]+=i[s]}return o}computeMask(e,r){if(r==null)return null;if(!Array.isArray(r))throw new Y("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new Y("`inputs` should be an array for Concatenate");if(r.length!==e.length)throw new Y(`Mismatch in the length of mask (${r.length}) and the legnth of inputs (${e.length})`);return X(()=>{let o=!0;if(r.forEach(a=>{if(a!=null){o=!1;return}}),o)return null;let s=[];for(let a=0;a<e.length;++a)r[a]==null?s.push(fe(cr(e[a]),"bool")):r[a].rank<e[a].rank?s.push(an(r[a],-1)):s.push(r[a]);let i=Et(s,this.axis);return fm(i,-1,!1)})}getConfig(){let e={axis:this.axis},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Concatenate",t})();de.registerClass(T7);function Y1(t,n){for(;t<0;)t+=n;return t}function Wue(t,n,e){if(t.shape.length>3||n.shape.length>3)throw new Ze("batchDot is not implemented for tensors of 4D or higher rank yet");if(b.assert(t.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${t.shape.length}`),b.assert(t.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${n.shape.length}`),typeof e=="number"&&(e=[e,e]),t.dtype==="complex64"||n.dtype==="complex64")throw new Ze("batchDot is not implemented for complex64-type Tensors yet.");let r=t.shape.length,o=n.shape.length;e==null&&(e=[r-1,o-2]);let s=e;return X(()=>{let i;if(r>o){i=r-o;let l=[];for(let c=0;c<i;++c)l.push(1);n=U(n,n.shape.concat(l))}else if(o>r){i=o-r;let l=[];for(let c=0;c<i;++c)l.push(1);t=U(t,t.shape.concat(l))}else i=0;let a;if(t.shape.length===2&&n.shape.length===2)s[0]===s[1]?a=Ne(z(t,n),s[0]):a=Ne(z(ut(t,[1,0]),n),s[1]);else{let l=s[0]!==t.shape.length-1,c=s[1]===n.shape.length-1;a=ct(t,n,l,c)}if(i>0){let l;r>o?l=r+o-3:l=r-1;let c=[];for(let u=l;u<l+i;++u)c.push(u);a=Zt(a,c)}return a.shape.length===1&&(a=an(a,1)),a})}var E7=(()=>{class t extends Gl{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){b.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let r=e[0],o=e[1];if(r.length>3||o.length>3)throw new Ze("Dot layer does not support tensors of 4D or higher rank yet.");let s=this.interpretAxes(r,o);if(r[s[0]]!==o[s[1]])throw new Y(`Dimension incompatibility: ${r[s[0]]} !== ${o[s[1]]}`)}mergeFunction(e){if(e.length!==2)throw new Y(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let r=e[0],o=e[1],s;return Array.isArray(this.axes)?s=this.axes.map((i,a)=>Y1(i,e[a].shape.length)):s=[Y1(this.axes,r.shape.length),Y1(this.axes,o.shape.length)],this.normalize&&(r=V1(r,s[0]),o=V1(o,s[1])),Wue(r,o,s)}interpretAxes(e,r){let o;return Array.isArray(this.axes)?o=this.axes:o=[Y1(this.axes,e.length),Y1(this.axes,r.length)],o}computeOutputShape(e){b.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let r=e[0].slice(),o=e[1].slice();if(r.length>3||o.length>3)throw new Ze("Dot layer does not support tensors of 4D or higher rank yet.");let s=this.interpretAxes(r,o);r.splice(s[0],1),o.splice(s[1],1),o.splice(0,1);let i=r.concat(o);return i.length===1&&i.push(1),i}computeMask(e,r){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},r=super.getConfig();return Object.assign(e,r),e}}return t.className="Dot",t})();de.registerClass(E7);var N7=(()=>{class t extends Qe{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),r={stddev:this.stddev};return Object.assign(r,e),r}call(e,r){return X(()=>{this.invokeCallHook(e,r);let o=He(e);return Ru(()=>le(eg(o.shape,0,this.stddev),o),()=>o,r.training||!1)})}}return t.className="GaussianNoise",t})();de.registerClass(N7);var D7=(()=>{class t extends Qe{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return X(()=>{this.invokeCallHook(e,r);let o=He(e);return this.rate>0&&this.rate<1?Ru(()=>{let i=Math.sqrt(this.rate/(1-this.rate));return z(o,eg(o.shape,1,i))},()=>o,r.training||!1):o})}}return t.className="GaussianDropout",t})();de.registerClass(D7);var k7=(()=>{class t extends Qe{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||He(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),r={rate:this.rate};return Object.assign(r,e),r}call(e,r){return X(()=>{if(this.rate<1&&this.rate>0){let o=this._getNoiseShape(e);return Ru(()=>{let i=He(e),c=-1.6732632423543772*1.0507009873554805,u=fo(Jo(o),this.rate);u=to(u,"float32");let p=((1-this.rate)*(1+this.rate*c**2))**-.5,f=-p*c*this.rate,d=le(z(i,u),z(le(u,-1),c));return le(z(d,p),f)},()=>He(e),r.training||!1)}return e})}}return t.className="AlphaDropout",t})();de.registerClass(k7);function Z1(t,n,e,r,o,s=.001){let i;if(t.rank===2)i=Bv(t,n,e,r,o,s);else if(t.rank===3)i=zv(t,n,e,r,o,s);else if(t.rank===4)i=Vv(t,n,e,r,o,s);else throw new Ze(`batchNormalization is not implemented for array of rank ${t.rank} yet`);return i}function que(t,n,e,r,o=.001){return X(()=>{let s=sf(t,r),i=s.mean,a=s.variance;return[Z1(t,i,a,e,n,o),i,a]})}function Kue(t,n,e,r,o=.001){return X(()=>{let s=sf(t,r),i=s.mean,a=s.variance,l=[];for(let h of yo(0,t.rank))r.indexOf(h)!==-1?l.push(1):l.push(t.shape[h]);let c=U(i,l),u=U(a,l),p=n==null?null:U(n,l),f=e==null?null:U(e,l);return[Z1(t,c,u,f,p,o),i,a]})}function Xue(t,n,e,r,o=.001){return b.arraysEqual(r.slice().sort(),yo(0,t.rank-1))?que(t,n,e,r,o):Kue(t,n,e,r,o)}var A7=(()=>{class t extends Qe{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=Kt(e.betaInitializer||"zeros"),this.gammaInitializer=Kt(e.gammaInitializer||"ones"),this.movingMeanInitializer=Kt(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Kt(e.movingVarianceInitializer||"ones"),this.betaConstraint=kn(e.betaConstraint),this.gammaConstraint=kn(e.gammaConstraint),this.betaRegularizer=Jt(e.betaRegularizer),this.gammaRegularizer=Jt(e.gammaRegularizer)}build(e){e=at(e);let r=this.axis>=0?this.axis:this.axis+e.length,o=e[r];if(o==null)throw new Y(`Axis ${r} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Qt({ndim:e.length,axes:{[r]:o}})];let s=[o];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,r){return X(()=>{let o=r.training==null?!1:r.training,s=He(e),i=s.shape,a=i.length,l=yo(0,a),c=this.axis>=0?this.axis:this.axis+a;l.splice(c,1);let u=js(1,a);u[c]=i[c];let p=l.slice();p.sort();let f=!b.arraysEqual(p,yo(0,a).slice(0,a-1)),d=()=>{if(f){let C=U(this.movingMean.read(),u),I=U(this.movingVariance.read(),u),D=this.center?U(this.beta.read(),u):null,O=this.scale?U(this.gamma.read(),u):null;return Z1(s,C,I,D,O,this.epsilon)}else return Z1(s,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!o)return d();let[h,g,m]=Xue(s,this.gamma.read(),this.beta.read(),l,this.epsilon),y=(C,I,D)=>{X(()=>{let O=1-D,L=C.read(),B=z(Ie(L,I),O);C.write(Ie(L,B))})};return y(this.movingMean,g,this.momentum),y(this.movingVariance,m,this.momentum),h})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:un(this.betaInitializer),gammaInitializer:un(this.gammaInitializer),movingMeanInitializer:un(this.movingMeanInitializer),movingVarianceInitializer:un(this.movingVarianceInitializer),betaRegularizer:Ut(this.betaRegularizer),gammaRegularizer:Ut(this.gammaRegularizer),betaConstraint:Dn(this.betaConstraint),gammaConstraint:Dn(this.gammaConstraint)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="BatchNormalization",t})();de.registerClass(A7);var _7=(()=>{class t extends Qe{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let r of this.axis)if(!Number.isInteger(r))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=Kt(e.betaInitializer||"zeros"),this.gammaInitializer=Kt(e.gammaInitializer||"ones"),this.betaRegularizer=Jt(e.betaRegularizer),this.gammaRegularizer=Jt(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=at(e);let r=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=r);for(let i of this.axis)if(i<0||i>=r)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==Ws(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let o=this.axis.map(i=>e[i]),s=!0;this.scale?this.gamma=this.addWeight("gamma",o,"float32",this.gammaInitializer,this.gammaRegularizer,s):this.gamma=null,this.center?this.beta=this.addWeight("beta",o,"float32",this.betaInitializer,this.betaRegularizer,s):this.beta=null,this.built=!0}call(e,r){let o=He(e),s=o.shape,i=s.length;return X(()=>{let{mean:l,variance:c}=sf(o,this.axis,!0),u=js(1,i);for(let m of this.axis)u[m]=s[m];let p=m=>m!=null&&m.shape.length!==i?U(m,u):m,f=this.scale?p(this.gamma.read()):null,d=this.center?p(this.beta.read()):null,h=[],g=[];for(let m=0;m<i;++m)this.axis.indexOf(m)!==-1?(h.push(s[m]),g.push(1)):(h.push(1),g.push(s[m]));return l=Er(l,h),c=Er(c,h),f!=null&&(f=Er(f,g)),d!=null&&(d=Er(d,g)),Z1(o,l,c,d,f,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:un(this.betaInitializer),gammaInitializer:un(this.gammaInitializer),betaRegularizer:Ut(this.betaRegularizer),gammaRegularizer:Ut(this.gammaRegularizer)},r=super.getConfig();return Object.assign(e,r),e}}return t.className="LayerNormalization",t})();de.registerClass(_7);function Yue(t,n,e){return X(()=>{if(t.rank!==4)throw new Y(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(n==null&&(n=[[1,1],[1,1]]),n.length!==2||n[0].length!==2||n[1].length!==2)throw new Y("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(e==null&&(e=xo()),e!=="channelsLast"&&e!=="channelsFirst")throw new Y(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return e==="channelsFirst"?r=[[0,0],[0,0],n[0],n[1]]:r=[[0,0],n[0],n[1],[0,0]],ho(t,r)})}var R7=(()=>{class t extends Qe{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?xo():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new Y(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let r,o;if(typeof e.padding[0]=="number")r=[e.padding[0],e.padding[0]],o=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new Y(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(r=e.padding[0],e.padding[1].length!==2)throw new Y(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);o=e.padding[1]}this.padding=[r,o]}this.inputSpec=[new Qt({ndim:4})]}computeOutputShape(e){e=at(e);let r,o;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?r=e[2]+this.padding[0][0]+this.padding[0][1]:r=null,e[3]!=null&&e[3]>=0?o=e[3]+this.padding[1][0]+this.padding[1][1]:o=null,[e[0],e[1],r,o]):(e[1]!=null&&e[1]>=0?r=e[1]+this.padding[0][0]+this.padding[0][1]:r=null,e[2]!=null&&e[2]>=0?o=e[2]+this.padding[1][0]+this.padding[1][1]:o=null,[e[0],r,o,e[3]])}call(e,r){return X(()=>Yue(He(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},r=super.getConfig();return Object.assign(e,r),e}}return t.className="ZeroPadding2D",t})();de.registerClass(R7);function Ow(t,n,e,r,o,s){return X(()=>{wn(o),rD(s),go(r),e==null&&(e=[1,1]),r==null&&(r="valid"),o==null&&(o=xo()),s==null&&(s="max"),t=K1(t,o);let i,a=r==="same"?"same":"valid";return s==="max"?i=Iu(t,n,e,a):i=hu(t,n,e,a),o==="channelsFirst"&&(i=ut(i,[0,3,1,2])),i})}function M7(t,n,e,r,o,s){return X(()=>{wn(o),rD(s),go(r),e==null&&(e=[1,1,1]),r==null&&(r="valid"),o==null&&(o=xo()),s==null&&(s="max"),t=DD(t,o);let i,a=r==="same"?"same":"valid";return s==="max"?i=ub(t,n,e,a):i=Pv(t,n,e,a),o==="channelsFirst"&&(i=ut(i,[0,4,1,2,3])),i})}var kw=class extends Qe{constructor(n){if(n.poolSize==null&&(n.poolSize=2),super(n),typeof n.poolSize=="number")this.poolSize=[n.poolSize];else if(Array.isArray(n.poolSize)&&n.poolSize.length===1&&typeof n.poolSize[0]=="number")this.poolSize=n.poolSize;else throw new Y(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(n.poolSize)}`);if(Bn(this.poolSize,"poolSize"),n.strides==null)this.strides=this.poolSize;else if(typeof n.strides=="number")this.strides=[n.strides];else if(Array.isArray(n.strides)&&n.strides.length===1&&typeof n.strides[0]=="number")this.strides=n.strides;else throw new Y(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(n.strides)}`);Bn(this.strides,"strides"),this.padding=n.padding==null?"valid":n.padding,go(this.padding),this.inputSpec=[new Qt({ndim:3})]}computeOutputShape(n){n=at(n);let e=$o(n[1],this.poolSize[0],this.padding,this.strides[0]);return[n[0],e,n[2]]}call(n,e){return X(()=>{this.invokeCallHook(n,e),n=Pl(He(n),2);let r=this.poolingFunction(He(n),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Zt(r,[2])})}getConfig(){let n={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(n,e),n}},O7=(()=>{class t extends kw{constructor(e){super(e)}poolingFunction(e,r,o,s,i){return wn(i),go(s),Ow(e,r,o,s,i,"max")}}return t.className="MaxPooling1D",t})();de.registerClass(O7);var F7=(()=>{class t extends kw{constructor(e){super(e)}poolingFunction(e,r,o,s,i){return wn(i),go(s),Ow(e,r,o,s,i,"avg")}}return t.className="AveragePooling1D",t})();de.registerClass(F7);var Aw=class extends Qe{constructor(n){if(n.poolSize==null&&(n.poolSize=[2,2]),super(n),this.poolSize=Array.isArray(n.poolSize)?n.poolSize:[n.poolSize,n.poolSize],n.strides==null)this.strides=this.poolSize;else if(Array.isArray(n.strides)){if(n.strides.length!==2)throw new Y(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${n.strides.length}.`);this.strides=n.strides}else this.strides=[n.strides,n.strides];Bn(this.poolSize,"poolSize"),Bn(this.strides,"strides"),this.padding=n.padding==null?"valid":n.padding,this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,wn(this.dataFormat),go(this.padding),this.inputSpec=[new Qt({ndim:4})]}computeOutputShape(n){n=at(n);let e=this.dataFormat==="channelsFirst"?n[2]:n[1],r=this.dataFormat==="channelsFirst"?n[3]:n[2];return e=$o(e,this.poolSize[0],this.padding,this.strides[0]),r=$o(r,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[n[0],n[1],e,r]:[n[0],e,r,n[3]]}call(n,e){return X(()=>(this.invokeCallHook(n,e),this.poolingFunction(He(n),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let n={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(n,e),n}},$7=(()=>{class t extends Aw{constructor(e){super(e)}poolingFunction(e,r,o,s,i){return wn(i),go(s),Ow(e,r,o,s,i,"max")}}return t.className="MaxPooling2D",t})();de.registerClass($7);var L7=(()=>{class t extends Aw{constructor(e){super(e)}poolingFunction(e,r,o,s,i){return wn(i),go(s),Ow(e,r,o,s,i,"avg")}}return t.className="AveragePooling2D",t})();de.registerClass(L7);var _w=class extends Qe{constructor(n){if(n.poolSize==null&&(n.poolSize=[2,2,2]),super(n),this.poolSize=Array.isArray(n.poolSize)?n.poolSize:[n.poolSize,n.poolSize,n.poolSize],n.strides==null)this.strides=this.poolSize;else if(Array.isArray(n.strides)){if(n.strides.length!==3)throw new Y(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${n.strides.length}.`);this.strides=n.strides}else this.strides=[n.strides,n.strides,n.strides];Bn(this.poolSize,"poolSize"),Bn(this.strides,"strides"),this.padding=n.padding==null?"valid":n.padding,this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,wn(this.dataFormat),go(this.padding),this.inputSpec=[new Qt({ndim:5})]}computeOutputShape(n){n=at(n);let e=this.dataFormat==="channelsFirst"?n[2]:n[1],r=this.dataFormat==="channelsFirst"?n[3]:n[2],o=this.dataFormat==="channelsFirst"?n[4]:n[3];return e=$o(e,this.poolSize[0],this.padding,this.strides[0]),r=$o(r,this.poolSize[1],this.padding,this.strides[1]),o=$o(o,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[n[0],n[1],e,r,o]:[n[0],e,r,o,n[4]]}call(n,e){return X(()=>(this.invokeCallHook(n,e),this.poolingFunction(He(n),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let n={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(n,e),n}},P7=(()=>{class t extends _w{constructor(e){super(e)}poolingFunction(e,r,o,s,i){return wn(i),go(s),M7(e,r,o,s,i,"max")}}return t.className="MaxPooling3D",t})();de.registerClass(P7);var B7=(()=>{class t extends _w{constructor(e){super(e)}poolingFunction(e,r,o,s,i){return wn(i),go(s),M7(e,r,o,s,i,"avg")}}return t.className="AveragePooling3D",t})();de.registerClass(B7);var Rw=class extends Qe{constructor(n){super(n),this.inputSpec=[new Qt({ndim:3})]}computeOutputShape(n){return[n[0],n[2]]}call(n,e){throw new Ze}},z7=(()=>{class t extends Rw{constructor(e){super(e||{})}call(e,r){return X(()=>{let o=He(e);return ln(o,1)})}}return t.className="GlobalAveragePooling1D",t})();de.registerClass(z7);var V7=(()=>{class t extends Rw{constructor(e){super(e||{})}call(e,r){return X(()=>{let o=He(e);return hr(o,1)})}}return t.className="GlobalMaxPooling1D",t})();de.registerClass(V7);var Mw=class extends Qe{constructor(n){super(n),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,wn(this.dataFormat),this.inputSpec=[new Qt({ndim:4})]}computeOutputShape(n){return n=n,this.dataFormat==="channelsLast"?[n[0],n[3]]:[n[0],n[1]]}call(n,e){throw new Ze}getConfig(){let n={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(n,e),n}},U7=(()=>{class t extends Mw{call(e,r){return X(()=>{let o=He(e);return this.dataFormat==="channelsLast"?ln(o,[1,2]):ln(o,[2,3])})}}return t.className="GlobalAveragePooling2D",t})();de.registerClass(U7);var G7=(()=>{class t extends Mw{call(e,r){return X(()=>{let o=He(e);return this.dataFormat==="channelsLast"?hr(o,[1,2]):hr(o,[2,3])})}}return t.className="GlobalMaxPooling2D",t})();de.registerClass(G7);var Fw=class extends Qe{constructor(n){super(n),this.layer=n.layer}build(n){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(n){this.layer!=null&&(this.layer.trainable=n)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(n){this.layer.setWeights(n)}getConfig(){let n={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(n,e),n}setFastWeightInitDuringBuild(n){super.setFastWeightInitDuringBuild(n),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(n)}static fromConfig(n,e,r={}){let o=e.layer,s=ns(o,r);delete e.layer;let i={layer:s};return Object.assign(i,e),new n(i)}},j7=(()=>{class t extends Fw{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=at(e),e.length<3)throw new Y(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let r=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(r),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=at(e);let r=[e[0]].concat(e.slice(2)),o=this.layer.computeOutputShape(r),s=e[1];return[o[0],s].concat(o.slice(1))}call(e,r){return X(()=>(e=He(e),RD((a,l)=>[He(this.layer.call(a,r)),[]],e,[],!1,null,null,!1,!0)[1]))}}return t.className="TimeDistributed",t})();de.registerClass(j7);function Zue(t){ca(X5,"BidirectionalMergeMode",t)}var Que="concat",H7=(()=>{class t extends Fw{constructor(e){super(e);let r=e.layer.getConfig(),o={};o.className=e.layer.getClassName(),o.config=r,this.forwardLayer=ns(o),r.goBackwards=r.goBackwards!==!0;let s={};if(s.className=e.layer.getClassName(),s.config=r,this.backwardLayer=ns(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?Que:e.mergeMode,Zue(this.mergeMode),e.weights)throw new Ze("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let r=e.length,o=Math.floor(r/2);this.forwardLayer.setWeights(e.slice(0,o)),this.backwardLayer.setWeights(e.slice(o))}computeOutputShape(e){let r=this.forwardLayer.computeOutputShape(e);Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),r=r;let o,s,i;return this.returnState&&(i=r.slice(1)),o=r[0],o=o,this.mergeMode==="concat"?(o[o.length-1]*=2,s=[o]):this.mergeMode==null?s=[o,o.slice()]:s=[o],this.returnState?this.mergeMode==null?s.concat(i).concat(i.slice()):[o].concat(i).concat(i.slice()):yr(s)}apply(e,r){let o=r==null?null:r.initialState,s=r==null?null:r.constants;r==null&&(r={});let i=_D(e,o,s,this.numConstants);if(e=i.inputs,o=i.initialState,s=i.constants,Array.isArray(e)&&(o=e.slice(1),e=e[0]),(o==null||o.length===0)&&s==null)return super.apply(e,r);let a=[],l=[];if(o!=null){let u=o.length;if(u%2>0)throw new Y("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");r.initialState=o,a.push(...o);let p=o.map(f=>new Qt({shape:f.shape}));this.forwardLayer.stateSpec=p.slice(0,u/2),this.backwardLayer.stateSpec=p.slice(u/2),l.push(...p)}if(s!=null)throw new Ze("Support for constants in Bidirectional layers is not implemented yet.");let c=a[0]instanceof no;for(let u of a)if(u instanceof no!==c)throw new Y("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(c){let u=[e].concat(a),p=this.inputSpec.concat(l),f=this.inputSpec;this.inputSpec=p;let d=super.apply(u,r);return this.inputSpec=f,d}else return super.apply(e,r)}call(e,r){return X(()=>{let o=r.initialState,s,i;if(o==null)s=this.forwardLayer.call(e,r),i=this.backwardLayer.call(e,r);else{let c=o.slice(0,o.length/2),u=o.slice(o.length/2);s=this.forwardLayer.call(e,Object.assign(r,{initialState:c})),i=this.backwardLayer.call(e,Object.assign(r,{initialState:u}))}let a;this.returnState&&(Array.isArray(s)&&(a=s.slice(1).concat(i.slice(1))),s=s[0],i=i[0]),this.returnSequences&&(i=Jn(i,1));let l;return this.mergeMode==="concat"?l=Jm([s,i]):this.mergeMode==="sum"?l=le(s,i):this.mergeMode==="ave"?l=z(.5,le(s,i)):this.mergeMode==="mul"?l=z(s,i):this.mergeMode==null&&(l=[s,i]),this.returnState?this.mergeMode==null?l.concat(a):[l].concat(a):l})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){vi(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),vi(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,r){Array.isArray(r)&&(r=r[0]);let o;if(this.returnSequences?this.mergeMode==null?o=[r,r]:o=r:this.mergeMode==null?o=[null,null]:o=null,this.returnState){let i=this.forwardLayer.states.map(a=>null);return Array.isArray(o)?o.concat(i).concat(i):[o].concat(i).concat(i)}else return o}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},r=super.getConfig();return Object.assign(e,r),e}static fromConfig(e,r){let o=ns(r.layer);if(delete r.layer,r.numConstants!=null)throw new Ze("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let s=r;return s.layer=o,new e(s)}}return t.className="Bidirectional",t})();de.registerClass(H7);var W7=(()=>{class t extends Qe{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return X(()=>(e=He(e),e.dtype!=="float32"&&(e=to(e,"float32")),le(z(e,this.scale),this.offset)))}}return t.className="Rescaling",t})();de.registerClass(W7);var{resizeBilinear:Jue,cropAndResize:epe}=nr,q7=(()=>{class t extends Qe{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,r,o,s,i,a,l,c){return X(()=>{let u,p=!1,f=r/a,d=o/l,h=(s+r)/a,g=(i+o)/l,m=[f,d,h,g],y=[];e.rank===3?(p=!0,u=Nn([e])):u=e;for(let O=0;O<u.shape[0];O++)y.push(m);let x=fr(y,[y.length,4]),C=aa(0,y.length,1,"int32"),D=epe(u,x,C,[s,i],"nearest");return p?to(He(tr(D)),c):to(D,c)})}upsize(e,r,o,s){return X(()=>{let i=Jue(e,[r,o]);return to(i,s)})}call(e,r){return X(()=>{let o=He(e),s=o.dtype,i=o.shape,a=i[i.length-3],l=i[i.length-2],c=0;a!==this.height&&(c=Math.floor((a-this.height)/2));let u=0;return l!==this.width&&(u=Math.floor((l-this.width)/2),u===0&&(u=1)),c>=0&&u>=0?this.centerCrop(o,c,u,this.height,this.width,a,l,s):this.upsize(e,this.height,this.width,s)})}getConfig(){let e={height:this.height,width:this.width},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){e=at(e);let r=e.length-3,o=e.length-2;return e[r]=this.height,e[o]=this.width,e}}return t.className="CenterCrop",t})();de.registerClass(q7);function K7(t,n,e,r){let o=He(t);if(o.dtype!=="int32"&&(o=to(o,"int32")),n==="int")return o;let s=o.shape;if(o.rank===0&&(o=an(o,-1)),n==="oneHot"&&o.shape[o.shape.length-1]!==1&&(o=an(o,-1)),o.rank>2)throw new Y(`When outputMode is not int, maximum output rank is 2 Received outputMode ${n} and input shape ${s} which would result in output rank ${o.rank}.`);let i=["multiHot","oneHot"].includes(n),a=o,l;if(typeof r<"u"&&n==="count"?l=b1(a,r,e,i):l=b1(a,[],e,i),n!=="tfIdf")return l;if(r)return z(l,r);throw new Y("When outputMode is 'tfIdf', weights must be provided.")}var X7=(()=>{class t extends Qe{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){return e=at(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,r){return X(()=>{e=He(e),e.dtype!=="int32"&&(e=to(e,"int32"));let o;if(typeof r.countWeights<"u"){if(this.outputMode!=="count")throw new Y(`countWeights is not used when outputMode !== count.
              Received countWeights=${r.countWeights}`);o=He(r.countWeights)}let s=hr(e),i=kl(e),a=En(this.numTokens,s).bufferSync().get(0),l=fo(i,0).bufferSync().get(0);if(!(a&&l))throw new Y(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return K7(e,this.outputMode,this.numTokens,o)})}}return t.className="CategoryEncoding",t})();de.registerClass(X7);var npe=["bilinear","nearest"],Y7=new Set(npe),Z7=(()=>{class t extends Qe{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(Y7.has(e.interpolation))this.interpolation=e.interpolation;else throw new Y(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=at(e);let r=e[2];return[this.height,this.width,r]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},r=super.getConfig();return Object.assign(e,r),e}call(e,r){return X(()=>{let o=[this.height,this.width];if(this.interpolation==="bilinear")return nr.resizeBilinear(e,o,!this.cropToAspectRatio);if(this.interpolation==="nearest")return nr.resizeNearestNeighbor(e,o,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...Y7]} are supported`)})}}return t.className="Resizing",t})();de.registerClass(Z7);var Q7=(()=>{class t{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}return t.className="RandomSeed",t})();var J7=(()=>{class t extends Qe{constructor(e){super(e),this.randomGenerator=new Q7(e.seed)}getConfig(){let e={seed:this.randomGenerator.seed},r=super.getConfig();return Object.assign(e,r),e}}return t.className="BaseRandomLayer",t})();var rpe=["bilinear","nearest"],e9=new Set(rpe),t9=(()=>{class t extends J7{constructor(e){super(e);let{factor:r,interpolation:o="bilinear"}=e;if(this.factor=r,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new Y(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new Y(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new Y(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(o)if(e9.has(o))this.interpolation=o;else throw new Y(`Invalid interpolation parameter: ${o} is not implemented`)}getConfig(){let e={factor:this.factor,interpolation:this.interpolation},r=super.getConfig();return Object.assign(e,r),e}computeOutputShape(e){e=at(e);let r=e[2];return[this.imgHeight,-1,r]}call(e,r){return X(()=>{let o=He(e);this.imgHeight=o.shape[o.shape.length-3];let s=o.shape[o.shape.length-2];this.widthFactor=Jo([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*s;i=Math.round(i);let a=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return nr.resizeBilinear(e,a);case"nearest":return nr.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...e9]} are supported`)}})}}return t.className="RandomWidth",t})();de.registerClass(t9);var cpe=Z();cpe.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,t=>{t&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var rs=(function(t){return t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF",t})(rs||{}),n9;(function(t){let n;(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n=t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))})(n9||(n9={}));var ppe={};function $w(t){return ppe[t]}function S(t,n,e,r,o){let s=n.inputParams[t];if(s&&s.inputIndexStart!==void 0){let a=s.inputIndexStart,l=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?a+1:s.inputIndexEnd,c=a<0?n.inputNames.length+a:a;if(s.type==="tensor")return Xn(n.inputNames[c],e,r,o);if(s.type==="tensors"){let f=n.inputs.slice(a,l);return n.inputNames.slice(a,l).filter((h,g)=>{var m;return((m=f[g])===null||m===void 0?void 0:m.op)!=="NoOp"}).map(h=>Xn(h,e,r,o))}let u=Xn(n.inputNames[c],e,r,o),p=u.dataSync();return s.type==="number"?p[0]:b.toNestedArray(u.shape,p)}let i=n.attrParams[t];return i&&i.value}function Xn(t,n,e,r){let[o,s]=wo(t,e);if(r!=null){let a=r.getHashTableHandleByName(o);if(a!=null)return a}let i=e.currentContextIds.find(a=>!!n[Lw(o,a)]);return i!==void 0?n[Lw(o,i)][s]:void 0}function PD(t,n,e){return n[Lw(t,e.currentContextId)]}function Si(t,n){let[e,r,o]=wo(t,n);return[Lw(e,n&&n.currentContextId),r,o]}function Lw(t,n){return n?`${t}-${n}`:t}function wo(t,n){if(t==="")return["",0,void 0];let e=n!=null&&n.parseNodeNameCache!=null;if(e){let s=n.parseNodeNameCache.get(t);if(s!=null)return s}let r=t.split(":"),o;if(r.length===1)o=[t,0,void 0];else{let s=r[0],i=r.length===3?r[1]:void 0,a=Number(r[r.length-1]);o=[s,a,i]}return e&&n.parseNodeNameCache.set(t,o),o}function Q1(t,n,e){let r=S("pad",t,n,e);if(r==="explicit"){r=S("explicitPaddings",t,n,e);let o=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)o[s][0]=r[s*2],o[s][1]=r[s*2+1];return o}return r}function Ti(t){return t.kept?t:po(t)}var BD={};Xt(BD,{json:()=>fpe});var fpe=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var zD={};Xt(zD,{json:()=>dpe});var dpe=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var VD={};Xt(VD,{json:()=>hpe});var hpe=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}];var UD={};Xt(UD,{json:()=>mpe});var mpe=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var GD={};Xt(GD,{json:()=>gpe});var gpe=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var jD={};Xt(jD,{json:()=>ype});var ype=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var HD={};Xt(HD,{json:()=>xpe});var xpe=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var WD={};Xt(WD,{json:()=>vpe});var vpe=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var qD={};Xt(qD,{json:()=>bpe});var bpe=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}];var KD={};Xt(KD,{json:()=>wpe});var wpe=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}];var XD={};Xt(XD,{json:()=>Cpe});var Cpe=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}];var YD={};Xt(YD,{json:()=>Ipe});var Ipe=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}];var ZD={};Xt(ZD,{json:()=>Spe});var Spe=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}];var QD={};Xt(QD,{json:()=>Tpe});var Tpe=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var JD={};Xt(JD,{json:()=>Epe});var Epe=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}];var e4={};Xt(e4,{json:()=>Npe});var Npe=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var t4={};Xt(t4,{json:()=>Dpe});var Dpe=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var n4={};Xt(n4,{json:()=>kpe});var kpe=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var r4={};Xt(r4,{json:()=>Ape});var Ape=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var J1=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let n=[BD,zD,VD,UD,GD,jD,HD,WD,qD,KD,XD,YD,ZD,QD,JD,e4,t4,n4,r4],e=[].concat(...n.map(r=>r.json));this.opMappers=e.reduce((r,o)=>(r[o.tfOpName]=o,r),{})}transformGraph(n,e={}){let r=n.node,o=[],s=[],i=[],a=r.reduce((g,m)=>(g[m.name]=this.mapNode(m),m.op.startsWith("Placeholder")?o.push(g[m.name]):m.op==="Const"?s.push(g[m.name]):(m.input==null||m.input.length===0)&&i.push(g[m.name]),g),{}),l=[],c=[],u={},p={};e!=null&&(u=this.mapSignatureEntries(e.inputs),p=this.mapSignatureEntries(e.outputs));let f=Object.keys(a);f.forEach(g=>{let m=a[g];m.inputNames.forEach((y,x)=>{let[C,,I]=Si(y),D=a[C];if(D.outputs!=null){let O=D.outputs.indexOf(I);if(O!==-1){let L=`${C}:${O}`;m.inputNames[x]=L}}m.inputs.push(D),D.children.push(m)})}),Object.keys(p).length===0?f.forEach(g=>{let m=a[g];m.children.length===0&&c.push(m)}):Object.keys(p).forEach(g=>{let[m]=Si(g),y=a[m];y!=null&&(y.signatureKey=p[g],c.push(y))}),Object.keys(u).length>0?Object.keys(u).forEach(g=>{let[m]=Si(g),y=a[m];y&&(y.signatureKey=u[g],l.push(y))}):l=o;let d={};n.library!=null&&n.library.function!=null&&(d=n.library.function.reduce((g,m)=>(g[m.signature.name]=this.mapFunction(m),g),{}));let h={nodes:a,inputs:l,outputs:c,weights:s,placeholders:o,signature:e,functions:d};return i.length>0&&(h.initNodes=i),h}mapSignatureEntries(n){return Object.keys(n||{}).reduce((e,r)=>(e[n[r].name]=r,e),{})}mapNode(n){let e=$w(n.op)||this.opMappers[n.op]||{};n.attr==null&&(n.attr={});let r={name:n.name,op:n.op,category:e.category,inputNames:(n.input||[]).map(o=>o.startsWith("^")?o.slice(1):o),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:n.attr,outputs:e.outputs};return e.inputs!=null&&(r.inputParams=e.inputs.reduce((o,s)=>(o[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},o),{})),e.attrs!=null&&(r.attrParams=e.attrs.reduce((o,s)=>{let i=s.type,a;switch(s.type){case"string":a=Pw(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=Pw(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":a=Hw(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=Hw(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":a=zw(n.attr,s.tfName,s.defaultValue||0),a===void 0&&s.tfDeprecatedName&&(a=zw(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":a=jw(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=jw(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":a=Bw(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=Bw(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":a=qw(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=qw(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":a=Gw(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=Gw(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":a=Ww(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=Ww(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":a=Vw(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=Vw(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":a=Uw(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=Uw(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":a=r9(n.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=r9(n.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${n.op}`)}return o[s.name]={value:a,type:i},o},{})),r}mapFunction(n){let e=n.nodeDef,r=[],o=[],s={};e!=null&&(s=e.reduce((p,f)=>(p[f.name]=this.mapNode(f),f.op==="Const"&&o.push(p[f.name]),p),{}));let i=[],a=[];n.signature.inputArg.forEach(p=>{let[f]=Si(p.name),d={name:f,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:o4(p.type),type:"dtype"}},children:[]};d.signatureKey=p.name,i.push(d),s[f]=d}),Object.keys(s).forEach(p=>{let f=s[p];f.inputNames.forEach((d,h)=>{let[g,,m]=Si(d),y=s[g];if(y.outputs!=null){let x=y.outputs.indexOf(m);if(x!==-1){let C=`${g}:${x}`;f.inputNames[h]=C}}f.inputs.push(y),y.children.push(f)})});let c=n.ret;n.signature.outputArg.forEach(p=>{let[f,d]=Si(c[p.name]),h=s[f];h!=null&&(h.defaultOutput=d,a.push(h))});let u=this.mapArgsToSignature(n);return{nodes:s,inputs:i,outputs:a,weights:o,placeholders:r,signature:u}}mapArgsToSignature(n){return{methodName:n.signature.name,inputs:n.signature.inputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r),e),{}),outputs:n.signature.outputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r,n.ret),e),{})}}mapArgToTensorInfo(n,e){let r=n.name;return e!=null&&(r=e[r]),{name:r,dtype:n.type}}};function _pe(t){let n=Z().global;if(typeof n.atob<"u")return n.atob(t);if(typeof Buffer<"u")return new Buffer(t,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function o9(t,n){let e=Array.isArray(t)?String.fromCharCode.apply(null,t):_pe(t);return n?e:e.toLowerCase()}function Pw(t,n,e,r=!1){let o=t[n];return o!=null?o9(o.s,r):e}function Bw(t,n,e){let r=t[n];return r?r.b:e}function zw(t,n,e){let r=t[n]||{},o=r.i!=null?r.i:r.f!=null?r.f:e;return typeof o=="number"?o:parseInt(o,10)}function o4(t){switch(typeof t=="string"&&(t=rs[t]),t){case rs.DT_FLOAT:case rs.DT_HALF:return"float32";case rs.DT_INT32:case rs.DT_INT64:case rs.DT_INT8:case rs.DT_UINT8:return"int32";case rs.DT_BOOL:return"bool";case rs.DT_DOUBLE:return"float32";case rs.DT_STRING:return"string";case rs.DT_COMPLEX64:case rs.DT_COMPLEX128:return"complex64";default:return null}}function r9(t,n,e){let r=t[n];return r&&r.func?r.func.name:e}function Vw(t,n,e){let r=t[n];return r&&r.type?o4(r.type):e}function Uw(t,n,e){let r=t[n];return r&&r.list&&r.list.type?r.list.type.map(o=>o4(o)):e}function s9(t){if(!t.unknownRank)return t.dim!=null?t.dim.map(n=>typeof n.size=="number"?n.size:parseInt(n.size,10)):[]}function Gw(t,n,e){let r=t[n];return r&&r.shape?s9(r.shape):e}function jw(t,n,e){let r=t[n];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(o=>typeof o=="number"?o:parseInt(o,10)):e}function Hw(t,n,e,r=!1){let o=t[n];return o&&o.list&&o.list.s?o.list.s.map(s=>o9(s,r)):e}function Ww(t,n,e){let r=t[n];return r&&r.list&&r.list.shape?r.list.shape.map(o=>s9(o)):e}function qw(t,n,e){let r=t[n];return r&&r.list&&r.list.b?r.list.b:e}var Kw=class{constructor(n,e,r){this.node=n,this.tensorMap=e,this.context=r,this.inputs=[],this.attrs={},this.inputs=n.inputNames.map(o=>this.getInput(o)),n.rawAttrs!=null&&(this.attrs=Object.keys(n.rawAttrs).reduce((o,s)=>(o[s]=this.getAttr(s),o),{}))}getInput(n){return Xn(n,this.tensorMap,this.context)}getAttr(n,e){let r=this.node.rawAttrs[n];if(r.tensor!=null)return Xn(n,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return zw(this.node.rawAttrs,n,e);if(r.s!=null)return Pw(this.node.rawAttrs,n,e);if(r.b!=null)return Bw(this.node.rawAttrs,n,e);if(r.shape!=null)return Gw(this.node.rawAttrs,n,e);if(r.type!=null)return Vw(this.node.rawAttrs,n,e);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return jw(this.node.rawAttrs,n,e);if(r.list.s!=null)return Hw(this.node.rawAttrs,n,e);if(r.list.shape!=null)return Ww(this.node.rawAttrs,n,e);if(r.list.b!=null)return qw(this.node.rawAttrs,n,e);if(r.list.type!=null)return Uw(this.node.rawAttrs,n,e)}return e}};var Ft={};Xt(Ft,{OP_SCOPE_SUFFIX:()=>aN,abs:()=>hn,acos:()=>Dv,acosh:()=>kv,add:()=>le,addN:()=>k$,all:()=>fm,any:()=>ef,argMax:()=>Ji,argMin:()=>Rv,asin:()=>Mv,asinh:()=>Ov,atan:()=>Fv,atan2:()=>$v,atanh:()=>Lv,avgPool:()=>hu,avgPool3d:()=>Pv,basicLSTMCell:()=>R$,batchNorm:()=>ta,batchNorm2d:()=>Bv,batchNorm3d:()=>zv,batchNorm4d:()=>Vv,batchToSpaceND:()=>mu,bincount:()=>Uv,bitwiseAnd:()=>O$,booleanMaskAsync:()=>gie,broadcastArgs:()=>F$,broadcastTo:()=>na,buffer:()=>Be,cast:()=>fe,ceil:()=>Gv,clipByValue:()=>Qn,clone:()=>po,complex:()=>Ro,concat:()=>Et,concat1d:()=>jv,concat2d:()=>Hv,concat3d:()=>Wv,concat4d:()=>qv,conv1d:()=>hm,conv2d:()=>Mo,conv2dTranspose:()=>gm,conv3d:()=>Kv,conv3dTranspose:()=>Yv,cos:()=>gu,cosh:()=>xm,cosineWindow:()=>_1,cumprod:()=>nf,cumsum:()=>vm,denseBincount:()=>b1,depthToSpace:()=>Zv,depthwiseConv2d:()=>ra,diag:()=>$$,dilation2d:()=>Qv,div:()=>ve,divNoNan:()=>Jv,dot:()=>eb,dropout:()=>RN,einsum:()=>yu,elu:()=>oa,enclosingPowerOfTwo:()=>MN,ensureShape:()=>P$,equal:()=>eo,erf:()=>wm,euclideanNorm:()=>tb,exp:()=>gn,expandDims:()=>an,expm1:()=>nb,eye:()=>of,fft:()=>Nu,fill:()=>Bs,floor:()=>sa,floorDiv:()=>um,fused:()=>ku,gather:()=>ia,gatherND:()=>Eie,greater:()=>En,greaterEqual:()=>fo,ifft:()=>Ml,imag:()=>xu,image:()=>nr,inTopKAsync:()=>kie,irfft:()=>Bm,isFinite:()=>rb,isInf:()=>ob,isNaN:()=>sb,leakyRelu:()=>vu,less:()=>_l,lessEqual:()=>Qo,linalg:()=>FN,linspace:()=>V$,localResponseNormalization:()=>ib,log:()=>mr,log1p:()=>bu,logSigmoid:()=>ab,logSoftmax:()=>Em,logSumExp:()=>wu,logicalAnd:()=>Pr,logicalNot:()=>Cu,logicalOr:()=>Nm,logicalXor:()=>lb,losses:()=>_ae,lowerBound:()=>U$,matMul:()=>ct,max:()=>hr,maxPool:()=>Iu,maxPool3d:()=>ub,maxPoolWithArgmax:()=>G$,maximum:()=>Fo,mean:()=>ln,meshgrid:()=>j$,min:()=>kl,minimum:()=>Is,mirrorPad:()=>pb,mod:()=>fb,moments:()=>sf,movingAverage:()=>vie,mul:()=>z,multiRNNCell:()=>H$,multinomial:()=>W$,neg:()=>ft,norm:()=>Al,notEqual:()=>gi,oneHot:()=>af,ones:()=>jn,onesLike:()=>cr,op:()=>A,outerProduct:()=>q$,pad:()=>ho,pad1d:()=>K$,pad2d:()=>X$,pad3d:()=>Y$,pad4d:()=>Z$,pool:()=>db,pow:()=>Lr,prelu:()=>Tu,print:()=>Nv,prod:()=>hb,raggedGather:()=>Q$,raggedRange:()=>J$,raggedTensorToTensor:()=>eL,rand:()=>tL,randomGamma:()=>xL,randomNormal:()=>uf,randomStandardNormal:()=>vL,randomUniform:()=>Jo,randomUniformInt:()=>bL,range:()=>aa,real:()=>Rl,reciprocal:()=>vb,relu:()=>Nr,relu6:()=>km,reshape:()=>U,reverse:()=>Jn,reverse1d:()=>wL,reverse2d:()=>CL,reverse3d:()=>IL,reverse4d:()=>SL,rfft:()=>Du,round:()=>Am,rsqrt:()=>_m,scalar:()=>Ee,scatterND:()=>wie,searchSorted:()=>N1,selu:()=>Rm,separableConv2d:()=>Mm,setdiff1dAsync:()=>TL,sigmoid:()=>Tr,sign:()=>bb,signal:()=>Aae,sin:()=>Fm,sinh:()=>$m,slice:()=>Ue,slice1d:()=>Lm,slice2d:()=>k1,slice3d:()=>Pm,slice4d:()=>pf,softmax:()=>Eu,softplus:()=>mi,spaceToBatchND:()=>Su,sparse:()=>Rae,sparseToDense:()=>Sie,spectral:()=>kae,split:()=>er,sqrt:()=>Wt,square:()=>lt,squaredDifference:()=>zm,squeeze:()=>Zt,stack:()=>Nn,step:()=>Vs,stridedSlice:()=>Cb,string:()=>Mae,sub:()=>Ie,sum:()=>Ne,tan:()=>Ib,tanh:()=>hi,tensor:()=>fr,tensor1d:()=>qt,tensor2d:()=>es,tensor3d:()=>Sb,tensor4d:()=>EL,tensor5d:()=>NL,tensor6d:()=>DL,tensorScatterUpdate:()=>_L,tile:()=>Er,topk:()=>Tb,transpose:()=>ut,truncatedNormal:()=>Um,unique:()=>Eb,unsortedSegmentSum:()=>Gm,unstack:()=>tr,upperBound:()=>RL,variable:()=>Nb,where:()=>sn,whereAsync:()=>kb,zeros:()=>cn,zerosLike:()=>Ge});var i9=(t,n,e,r=Ft)=>{switch(t.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(S("a",t,n,e),S("b",t,n,e))];case"AddN":return[r.addN(S("tensors",t,n,e))];case"FloorMod":case"Mod":return[r.mod(S("a",t,n,e),S("b",t,n,e))];case"Mul":return[r.mul(S("a",t,n,e),S("b",t,n,e))];case"RealDiv":case"Div":return[r.div(S("a",t,n,e),S("b",t,n,e))];case"DivNoNan":return[r.divNoNan(S("a",t,n,e),S("b",t,n,e))];case"FloorDiv":return[r.floorDiv(S("a",t,n,e),S("b",t,n,e))];case"Sub":return[r.sub(S("a",t,n,e),S("b",t,n,e))];case"Minimum":return[r.minimum(S("a",t,n,e),S("b",t,n,e))];case"Maximum":return[r.maximum(S("a",t,n,e),S("b",t,n,e))];case"Pow":return[r.pow(S("a",t,n,e),S("b",t,n,e))];case"SquaredDifference":return[r.squaredDifference(S("a",t,n,e),S("b",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};var a9=(t,n,e,r=Ft)=>{switch(t.op){case"Abs":case"ComplexAbs":return[r.abs(S("x",t,n,e))];case"Acos":return[r.acos(S("x",t,n,e))];case"Acosh":return[r.acosh(S("x",t,n,e))];case"Asin":return[r.asin(S("x",t,n,e))];case"Asinh":return[r.asinh(S("x",t,n,e))];case"Atan":return[r.atan(S("x",t,n,e))];case"Atan2":return[r.atan2(S("x",t,n,e),S("y",t,n,e))];case"Atanh":return[r.atanh(S("x",t,n,e))];case"Ceil":return[r.ceil(S("x",t,n,e))];case"Complex":return[r.complex(S("real",t,n,e),S("imag",t,n,e))];case"Cos":return[r.cos(S("x",t,n,e))];case"Cosh":return[r.cosh(S("x",t,n,e))];case"Elu":return[r.elu(S("x",t,n,e))];case"Erf":return[r.erf(S("x",t,n,e))];case"Exp":return[r.exp(S("x",t,n,e))];case"Expm1":return[r.expm1(S("x",t,n,e))];case"Floor":return[r.floor(S("x",t,n,e))];case"Log":return[r.log(S("x",t,n,e))];case"Log1p":return[r.log1p(S("x",t,n,e))];case"Imag":return[r.imag(S("x",t,n,e))];case"Neg":return[r.neg(S("x",t,n,e))];case"Reciprocal":return[r.reciprocal(S("x",t,n,e))];case"Real":return[r.real(S("x",t,n,e))];case"Relu":return[r.relu(S("x",t,n,e))];case"Round":return[r.round(S("x",t,n,e))];case"Selu":return[r.selu(S("x",t,n,e))];case"Sigmoid":return[r.sigmoid(S("x",t,n,e))];case"Sin":return[r.sin(S("x",t,n,e))];case"Sign":return[r.sign(S("x",t,n,e))];case"Sinh":return[r.sinh(S("x",t,n,e))];case"Softplus":return[r.softplus(S("x",t,n,e))];case"Sqrt":return[r.sqrt(S("x",t,n,e))];case"Square":return[r.square(S("x",t,n,e))];case"Tanh":return[r.tanh(S("x",t,n,e))];case"Tan":return[r.tan(S("x",t,n,e))];case"ClipByValue":return[r.clipByValue(S("x",t,n,e),S("clipValueMin",t,n,e),S("clipValueMax",t,n,e))];case"Relu6":return[r.relu6(S("x",t,n,e))];case"Rsqrt":return[r.rsqrt(Xn(t.inputNames[0],n,e))];case"LeakyRelu":return[r.leakyRelu(S("x",t,n,e),S("alpha",t,n,e))];case"Prelu":return[r.prelu(S("x",t,n,e),S("alpha",t,n,e))];case"IsNan":return[r.isNaN(Xn(t.inputNames[0],n,e))];case"IsInf":return[r.isInf(Xn(t.inputNames[0],n,e))];case"IsFinite":return[r.isFinite(Xn(t.inputNames[0],n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};function os(t,n,e=""){if(!(typeof t=="number"||typeof n=="number")){b.assert(t.length===n.length,()=>e+` Shapes ${t} and ${n} must match`);for(let r=0;r<t.length;r++){let o=t[r],s=n[r];b.assert(o<0||s<0||o===s,()=>e+` Shapes ${t} and ${n} must match`)}}}function l9(t){return!(typeof t=="number"||t.some(n=>n<0))}function cg(t,n,e){let r=Xw(t,e),o=!l9(r);if(o&&n.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(o&&n.forEach(s=>{r=Xw(s.shape,r)}),!l9(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function Xw(t,n){if(typeof t=="number")return n;if(typeof n=="number")return t;if(t.length!==n.length)throw new Error(`Incompatible ranks during merge: ${t} vs. ${n}`);let e=[];for(let r=0;r<t.length;++r){let o=t[r],s=n[r];if(o>=0&&s>=0&&o!==s)throw new Error(`Incompatible shape during merge: ${t} vs. ${n}`);e[r]=o>=0?o:s}return e}var Yw=class{constructor(n,e,r,o,s,i,a){this.name=n,this.dtype=e,this.maxSize=r,this.elementShape=o,this.identicalElementShapes=s,this.dynamicSize=i,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=Ee(0),mn(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(n){this.tensors.forEach(e=>{(n==null||!n.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(n){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(n<0||n>=this.size())throw new Error(`Tried to read from index ${n}, but array size is: ${this.size()}`);let e=this.tensors[n];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${n} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(n){return n.map(e=>this.read(e))}write(n,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(n<0||!this.dynamicSize&&n>=this.maxSize)throw new Error(`Tried to write to index ${n}, but array is not resizeable and size is: ${this.maxSize}`);let r=this.tensors[n]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${n},
          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=e.shape),os(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${n}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${n}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${n}, because it has already been written.`);r.tensor=e,mn(e),r.written=!0,this.tensors[n]=r}writeMany(n,e){if(n.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${n.length} is not the same as tensors size: ${e.length}.`);n.forEach((r,o)=>this.write(r,e[o]))}gather(n,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(n)n=n.slice(0,this.size());else{n=[];for(let o=0;o<this.size();o++)n.push(o)}if(n.length===0)return fr([],[0].concat(this.elementShape));let r=this.readMany(n);return os(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),Nn(r,0)}concat(n){if(n&&n!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${n}`);if(this.size()===0)return fr([],[0].concat(this.elementShape));let e=[];for(let o=0;o<this.size();o++)e.push(o);let r=this.readMany(e);return os(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),Et(r,0)}scatter(n,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(n.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${n.length} vs. ${e.shape[0]}`);let r=Math.max(...n);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(n,tr(e,0))}split(n,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let r=0,o=n.map(l=>(r+=l,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&n.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${n.length}), and the TensorArray is not marked as dynamically resizeable`);let s=r===0?0:e.size/r,i=[];X(()=>{e=U(e,[1,r,s]);for(let l=0;l<n.length;++l){let u=[0,l===0?0:o[l-1],0],p=[1,n[l],s];i[l]=U(Ue(e,u,p),this.elementShape)}return i});let a=[];for(let l=0;l<n.length;l++)a[l]=l;this.writeMany(a,i)}};var ug=class t{get id(){return this.idTensor.id}constructor(n,e,r,o=-1){this.tensors=n,this.elementShape=e,this.elementDtype=r,n?.forEach(s=>{if(r!==s.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${s.dtype}`);os(e,s.shape,"TensorList shape mismatch: "),mn(s)}),this.idTensor=Ee(0),this.maxNumElements=o,mn(this.idTensor)}copy(){return new t([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(n){this.tensors.forEach(e=>{(n==null||!n.has(e.id))&&e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(n,e,r=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);os(n,this.elementShape,"TensorList shape mismatch: ");let o=cg(this.elementShape,this.tensors,n);return X(()=>{let s=this.tensors.map(i=>U(i,o));return Nn(s,0)})}popBack(n,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let r=cg(this.elementShape,this.tensors,n),o=this.tensors.pop();return o.kept=!1,os(o.shape,n,"TensorList shape mismatch: "),U(o,r)}pushBack(n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(os(n.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");mn(n),this.tensors.push(n)}resize(n){if(n<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${n}`);if(this.maxNumElements!==-1&&n>this.maxNumElements)throw new Error(`TensorListResize input size ${n} is greater maxNumElement ${this.maxNumElements}.`);let e=new t([],this.elementShape,this.elementDtype,this.maxNumElements);e.tensors.length=n;for(let r=0;r<Math.min(this.tensors.length,n);++r)e.tensors[r]=this.tensors[r];return e}getItem(n,e,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(n<0||n>this.tensors.length)throw new Error(`Trying to access element ${n} in a list with ${this.tensors.length} elements.`);if(this.tensors[n]==null)throw new Error(`element at index ${n} is null.`);os(this.tensors[n].shape,e,"TensorList shape mismatch: ");let o=cg(this.elementShape,this.tensors,e);return U(this.tensors[n],o)}setItem(n,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(n<0||this.maxNumElements!==-1&&n>=this.maxNumElements)throw new Error(`Trying to set element ${n} in a list with max ${this.maxNumElements} elements.`);os(this.elementShape,e.shape,"TensorList shape mismatch: "),mn(e),this.tensors[n]!=null&&(this.tensors[n].kept=!1),this.tensors[n]=e}gather(n,e,r){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);os(this.elementShape,r,"TensorList shape mismatch: "),n=n.slice(0,this.size());let o=cg(this.elementShape,this.tensors,r);return n.length===0?fr([],[0].concat(o)):X(()=>{let s=n.map(i=>U(this.tensors[i],o));return Nn(s,0)})}concat(n,e){if(n&&n!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${n}`);os(this.elementShape,e,"TensorList shape mismatch: ");let r=cg(this.elementShape,this.tensors,e);return this.size()===0?fr([],[0].concat(r)):X(()=>{let o=this.tensors.map(s=>U(s,r));return Et(o,0)})}};function c9(t,n,e){let r=t.dtype;if(t.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${t.shape}`);if(t.dtype!==e)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${e}`);let o=t.shape.slice(1);os(o,n,"TensorList shape mismatch: ");let s=tr(t);return new ug(s,n,r)}function u9(t,n,e,r){return new ug([],t,n,r)}function p9(t,n,e,r){if(n.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${n.length} vs. ${t.shape[0]}`);let o=Math.max(...n);if(r!=null&&r!==-1&&o>=r)throw new Error(`Max index must be < array size (${o}  vs. ${r})`);let s=new ug([],e,t.dtype,r),i=tr(t,0);return n.forEach((a,l)=>{s.setItem(a,i[l])}),s}function f9(t,n,e){let r=0,o=n.map(u=>(r+=u,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);let s=t.shape.slice(1),i=Xw(s,e),a=r===0?0:t.size/r,l=X(()=>{let u=[];t=U(t,[1,r,a]);for(let p=0;p<n.length;++p){let d=[0,p===0?0:o[p-1],0],h=[1,n[p],a];u[p]=U(Ue(t,d,h),i)}return t.dispose(),u}),c=new ug([],e,t.dtype,n.length);for(let u=0;u<l.length;u++)c.setItem(u,l[u]);return c}var d9=(t,n,e)=>te(null,null,function*(){switch(t.op){case"If":case"StatelessIf":{let r=S("thenBranch",t,n,e),o=S("elseBranch",t,n,e),s=S("cond",t,n,e),i=S("args",t,n,e);return(yield s.data())[0]?e.functionMap[r].executeFunctionAsync(i,e.tensorArrayMap,e.tensorListMap):e.functionMap[o].executeFunctionAsync(i,e.tensorArrayMap,e.tensorListMap)}case"While":case"StatelessWhile":{let r=S("body",t,n,e),o=S("cond",t,n,e),s=S("args",t,n,e),i=yield e.functionMap[o].executeFunctionAsync(s,e.tensorArrayMap,e.tensorListMap),a=s.map(u=>u.id),l=yield i[0].data();i.forEach(u=>{!u.kept&&a.indexOf(u.id)===-1&&u.dispose()});let c=s;for(;l[0];){let u=c;c=yield e.functionMap[r].executeFunctionAsync(c,e.tensorArrayMap,e.tensorListMap);let p=c.map(d=>d.id);u.forEach(d=>{!d.kept&&a.indexOf(d.id)===-1&&p.indexOf(d.id)===-1&&d.dispose()});let f=yield e.functionMap[o].executeFunctionAsync(c,e.tensorArrayMap,e.tensorListMap);l=yield f[0].data(),f.forEach(d=>{!d.kept&&a.indexOf(d.id)===-1&&p.indexOf(d.id)===-1&&d.dispose()})}return c}case"LoopCond":{let r=S("pred",t,n,e);return[Ti(r)]}case"Switch":{let r=S("pred",t,n,e),o=S("data",t,n,e);return o.kept||(o=Ti(o)),(yield r.data())[0]?[void 0,o]:[o,void 0]}case"Merge":{let r=t.inputNames.find(o=>Xn(o,n,e)!==void 0);if(r){let o=Xn(r,n,e);return[Ti(o)]}return}case"Enter":{let r=S("frameName",t,n,e),o=S("tensor",t,n,e);return e.enterFrame(r),[Ti(o)]}case"Exit":{let r=S("tensor",t,n,e);return e.exitFrame(),[Ti(r)]}case"NextIteration":{let r=S("tensor",t,n,e);return e.nextIteration(),[Ti(r)]}case"TensorArrayV3":{let r=S("size",t,n,e),o=S("dtype",t,n,e),s=S("elementShape",t,n,e),i=S("dynamicSize",t,n,e),a=S("clearAfterRead",t,n,e),l=S("identicalElementShapes",t,n,e),c=S("name",t,n,e),u=new Yw(c,o,r,s,l,i,a);return e.addTensorArray(u),[u.idTensor,Ee(1)]}case"TensorArrayWriteV3":{let r=S("tensorArrayId",t,n,e),o=S("index",t,n,e),s=S("tensor",t,n,e),i=e.getTensorArray(r.id);return i.write(o,s),[i.idTensor]}case"TensorArrayReadV3":{let r=S("tensorArrayId",t,n,e),o=S("index",t,n,e);return[e.getTensorArray(r.id).read(o)]}case"TensorArrayGatherV3":{let r=S("tensorArrayId",t,n,e),o=S("indices",t,n,e),s=S("dtype",t,n,e);return[e.getTensorArray(r.id).gather(o,s)]}case"TensorArrayScatterV3":{let r=S("tensorArrayId",t,n,e),o=S("indices",t,n,e),s=S("tensor",t,n,e),i=e.getTensorArray(r.id);return i.scatter(o,s),[i.idTensor]}case"TensorArrayConcatV3":{let r=S("tensorArrayId",t,n,e),o=e.getTensorArray(r.id),s=S("dtype",t,n,e);return[o.concat(s)]}case"TensorArraySplitV3":{let r=S("tensorArrayId",t,n,e),o=S("tensor",t,n,e),s=S("lengths",t,n,e),i=e.getTensorArray(r.id);return i.split(s,o),[i.idTensor]}case"TensorArraySizeV3":{let r=S("tensorArrayId",t,n,e),o=e.getTensorArray(r.id);return[Ee(o.size(),"int32")]}case"TensorArrayCloseV3":{let r=S("tensorArrayId",t,n,e),o=e.getTensorArray(r.id);return o.clearAndClose(),[o.idTensor]}case"TensorListSetItem":{let r=S("tensorListId",t,n,e),o=S("index",t,n,e),s=S("tensor",t,n,e),i=e.getTensorList(r.id);return i.setItem(o,s),[i.idTensor]}case"TensorListGetItem":{let r=S("tensorListId",t,n,e),o=S("index",t,n,e),s=S("elementShape",t,n,e),i=S("elementDType",t,n,e);return[e.getTensorList(r.id).getItem(o,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let r=S("indices",t,n,e),o=S("tensor",t,n,e),s=S("elementShape",t,n,e),i=S("numElements",t,n,e),a=p9(o,r,s,i);return e.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r=S("elementShape",t,n,e),o=S("elementDType",t,n,e),s;t.op==="TensorListReserve"?s="numElements":s="maxNumElements";let i=S(s,t,n,e),a=t.op==="TensorListReserve"?-1:i,l=u9(r,o,i,a);return e.addTensorList(l),[l.idTensor]}case"TensorListGather":{let r=S("tensorListId",t,n,e),o=S("indices",t,n,e),s=S("elementShape",t,n,e),i=S("elementDType",t,n,e);return[e.getTensorList(r.id).gather(o,i,s)]}case"TensorListStack":{let r=S("tensorListId",t,n,e),o=S("elementShape",t,n,e),s=S("elementDType",t,n,e),i=S("numElements",t,n,e);return[e.getTensorList(r.id).stack(o,s,i)]}case"TensorListFromTensor":{let r=S("tensor",t,n,e),o=S("elementShape",t,n,e),s=S("elementDType",t,n,e),i=c9(r,o,s);return e.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let r=S("tensorListId",t,n,e),o=e.getTensorList(r.id),s=S("dtype",t,n,e),i=S("elementShape",t,n,e);return[o.concat(s,i)]}case"TensorListPushBack":{let r=S("tensorListId",t,n,e),o=S("tensor",t,n,e),s=e.getTensorList(r.id);return s.pushBack(o),[s.idTensor]}case"TensorListPopBack":{let r=S("tensorListId",t,n,e),o=S("elementShape",t,n,e),s=S("elementDType",t,n,e);return[e.getTensorList(r.id).popBack(o,s)]}case"TensorListSplit":{let r=S("tensor",t,n,e),o=S("elementShape",t,n,e),s=S("lengths",t,n,e),i=f9(r,s,o);return e.addTensorList(i),[i.idTensor]}case"TensorListLength":{let r=S("tensorListId",t,n,e),o=e.getTensorList(r.id);return[Ee(o.size(),"int32")]}case"TensorListResize":{let r=S("tensorListId",t,n,e),o=S("size",t,n,e),i=e.getTensorList(r.id).resize(o);return e.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});function h9(t,n,e){let[r,o]=S("fusedOps",t,n,e),s=r==="biasadd",i=!s,a=o==="prelu",l=r==="fusedbatchnorm",c=S("numArgs",t,n,e);if(s){if(a&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&s&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let u=S("strides",t,n,e),p=Q1(t,n,e),f=S("dataFormat",t,n,e).toUpperCase(),d=S("dilations",t,n,e),[h,g]=S("args",t,n,e);i&&(g=h,h=void 0);let m=S("leakyreluAlpha",t,n,e);return{stride:u,pad:p,dataFormat:f,dilations:d,biasArg:h,preluArg:g,activationFunc:o,leakyreluAlpha:m}}var m9=(t,n,e,r=Ft)=>{switch(t.op){case"Conv1D":{let o=S("stride",t,n,e),s=S("pad",t,n,e),i=S("dataFormat",t,n,e).toUpperCase(),a=S("dilation",t,n,e);return[r.conv1d(S("x",t,n,e),S("filter",t,n,e),o,s,i,a)]}case"Conv2D":{let o=S("strides",t,n,e),s=Q1(t,n,e),i=S("dataFormat",t,n,e).toUpperCase(),a=S("dilations",t,n,e);return[r.conv2d(S("x",t,n,e),S("filter",t,n,e),[o[1],o[2]],s,i,[a[1],a[2]])]}case"_FusedConv2D":{let{stride:o,pad:s,dataFormat:i,dilations:a,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:p}=h9(t,n,e);return[r.fused.conv2d({x:S("x",t,n,e),filter:S("filter",t,n,e),strides:[o[1],o[2]],pad:s,dataFormat:i,dilations:[a[1],a[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:p})]}case"FusedDepthwiseConv2dNative":{let{stride:o,pad:s,dataFormat:i,dilations:a,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:p}=h9(t,n,e);return[r.fused.depthwiseConv2d({x:S("x",t,n,e),filter:S("filter",t,n,e),strides:[o[1],o[2]],pad:s,dataFormat:i,dilations:[a[1],a[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:p})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let o=S("outputShape",t,n,e),s=S("strides",t,n,e),i=Q1(t,n,e);return[r.conv2dTranspose(S("x",t,n,e),S("filter",t,n,e),o,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let o=S("strides",t,n,e),s=Q1(t,n,e),i=S("dilations",t,n,e),a=S("dataFormat",t,n,e).toUpperCase();return[r.depthwiseConv2d(S("input",t,n,e),S("filter",t,n,e),[o[1],o[2]],s,a,[i[1],i[2]])]}case"Conv3D":{let o=S("strides",t,n,e),s=S("pad",t,n,e),i=S("dataFormat",t,n,e).toUpperCase(),a=S("dilations",t,n,e);return[r.conv3d(S("x",t,n,e),S("filter",t,n,e),[o[1],o[2],o[3]],s,i,[a[1],a[2],a[3]])]}case"AvgPool":{let o=S("strides",t,n,e),s=S("pad",t,n,e),i=S("kernelSize",t,n,e);return[r.avgPool(S("x",t,n,e),[i[1],i[2]],[o[1],o[2]],s)]}case"MaxPool":{let o=S("strides",t,n,e),s=S("pad",t,n,e),i=S("kernelSize",t,n,e);return[r.maxPool(S("x",t,n,e),[i[1],i[2]],[o[1],o[2]],s)]}case"MaxPoolWithArgmax":{let o=S("strides",t,n,e),s=S("pad",t,n,e),i=S("kernelSize",t,n,e),a=S("includeBatchInIndex",t,n,e),{result:l,indexes:c}=r.maxPoolWithArgmax(S("x",t,n,e),[i[1],i[2]],[o[1],o[2]],s,a);return[l,c]}case"AvgPool3D":{let o=S("strides",t,n,e),s=S("pad",t,n,e),i=S("kernelSize",t,n,e);return[r.avgPool3d(S("x",t,n,e),[i[1],i[2],i[3]],[o[1],o[2],o[3]],s)]}case"MaxPool3D":{let o=S("strides",t,n,e),s=S("pad",t,n,e),i=S("kernelSize",t,n,e);return[r.maxPool3d(S("x",t,n,e),[i[1],i[2],i[3]],[o[1],o[2],o[3]],s)]}case"Dilation2D":{let o=S("strides",t,n,e),s=S("pad",t,n,e),i=S("dilations",t,n,e),a=o[1],l=o[2],c=i[1],u=i[2];return[r.dilation2d(S("x",t,n,e),S("filter",t,n,e),[a,l],s,[c,u],"NHWC")]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};var g9=(t,n,e,r=Ft)=>{switch(t.op){case"Fill":{let o=S("shape",t,n,e),s=S("dtype",t,n,e),i=S("value",t,n,e);return[r.fill(o,i,s)]}case"LinSpace":{let o=S("start",t,n,e),s=S("stop",t,n,e),i=S("num",t,n,e);return[r.linspace(o,s,i)]}case"Multinomial":{let o=S("logits",t,n,e),s=S("numSamples",t,n,e),i=S("seed",t,n,e);return[r.multinomial(o,s,i)]}case"OneHot":{let o=S("indices",t,n,e),s=S("depth",t,n,e),i=S("onValue",t,n,e),a=S("offValue",t,n,e),l=S("dtype",t,n,e);return[r.oneHot(o,s,i,a,l)]}case"Ones":return[r.ones(S("shape",t,n,e),S("dtype",t,n,e))];case"OnesLike":return[r.onesLike(S("x",t,n,e))];case"RandomStandardNormal":return[r.randomStandardNormal(S("shape",t,n,e),S("dtype",t,n,e),S("seed",t,n,e))];case"RandomUniform":return[r.randomUniform(S("shape",t,n,e),S("minval",t,n,e),S("maxval",t,n,e),S("dtype",t,n,e))];case"RandomUniformInt":return[r.randomUniformInt(S("shape",t,n,e),S("minval",t,n,e),S("maxval",t,n,e),S("seed",t,n,e))];case"Range":{let o=S("start",t,n,e),s=S("stop",t,n,e),i=S("step",t,n,e);return[r.range(o,s,i,S("dtype",t,n,e))]}case"TruncatedNormal":{let o=S("shape",t,n,e),s=S("mean",t,n,e),i=S("stdDev",t,n,e),a=S("seed",t,n,e);return[r.truncatedNormal(o,s,i,S("dtype",t,n,e),a)]}case"Zeros":return[r.zeros(S("shape",t,n,e),S("dtype",t,n,e))];case"ZerosLike":return[r.zerosLike(S("x",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};function s4(t,n,e){let r=S("boxes",t,n,e),o=S("scores",t,n,e),s=S("maxOutputSize",t,n,e),i=S("iouThreshold",t,n,e),a=S("scoreThreshold",t,n,e),l=S("softNmsSigma",t,n,e);return{boxes:r,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:a,softNmsSigma:l}}var y9=(s,i,a,l,...c)=>te(null,[s,i,a,l,...c],function*(t,n,e,r,o=Ft){switch(t.op){case"NonMaxSuppressionV5":{let{boxes:u,scores:p,maxOutputSize:f,iouThreshold:d,scoreThreshold:h,softNmsSigma:g}=s4(t,n,e),m=yield o.image.nonMaxSuppressionWithScoreAsync(u,p,f,d,h,g);return[m.selectedIndices,m.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:u,scores:p,maxOutputSize:f,iouThreshold:d,scoreThreshold:h}=s4(t,n,e),g=S("padToMaxOutputSize",t,n,e),m=yield o.image.nonMaxSuppressionPaddedAsync(u,p,f,d,h,g);return[m.selectedIndices,m.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:u,scores:p,maxOutputSize:f,iouThreshold:d,scoreThreshold:h}=s4(t,n,e);return[yield o.image.nonMaxSuppressionAsync(u,p,f,d,h)]}case"Where":{let u=o.cast(S("condition",t,n,e),"bool"),p=[yield o.whereAsync(u)];return u.dispose(),p}case"ListDiff":return o.setdiff1dAsync(S("x",t,n,e),S("y",t,n,e));default:throw TypeError(`Node type ${t.op} is not implemented`)}});var x9=(t,n,e,r=Ft)=>{switch(t.op){case"LowerBound":{let o=S("sortedSequence",t,n,e),s=S("values",t,n,e);return[r.lowerBound(o,s)]}case"TopKV2":{let o=S("x",t,n,e),s=S("k",t,n,e),i=S("sorted",t,n,e),a=r.topk(o,s,i);return[a.values,a.indices]}case"UpperBound":{let o=S("sortedSequence",t,n,e),s=S("values",t,n,e);return[r.upperBound(o,s)]}case"Unique":{let o=S("x",t,n,e),s=r.unique(o);return[s.values,s.indices]}case"UniqueV2":{let o=S("x",t,n,e),s=S("axis",t,n,e),i=r.unique(o,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};var v9=(t,n,e,r=Ft)=>{switch(t.op){case"Const":return n[t.name];case"PlaceholderWithDefault":let o=S("default",t,n,e);return[Xn(t.name,n,e)||o];case"Placeholder":return[Xn(t.name,n,e)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let u=S("x",t,n,e);return[Ti(u)]}case"IdentityN":return S("x",t,n,e).map(u=>Ti(u));case"Snapshot":let s=S("x",t,n,e);return[Ti(s)];case"Shape":return[r.tensor1d(S("x",t,n,e).shape,"int32")];case"ShapeN":return S("x",t,n,e).map(u=>r.tensor1d(u.shape));case"Size":return[r.scalar(S("x",t,n,e).size,"int32")];case"Rank":return[r.scalar(S("x",t,n,e).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":let i=S("x",t,n,e),a=S("data",t,n,e),l=S("message",t,n,e),c=S("summarize",t,n,e);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let u=0;u<a.length;u++)console.log(Array.prototype.slice.call(a[u].dataSync()).slice(0,c));return[i];default:throw TypeError(`Node type ${t.op} is not implemented`)}};var Zw=class{get id(){return this.handle.id}constructor(n,e){this.keyDType=n,this.valueDType=e,this.handle=Ee(0),this.tensorMap=new Map,mn(this.handle)}clearAndClose(){this.tensorMap.forEach(n=>n.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Ee(this.size(),"int32")}import(n,e){return te(this,null,function*(){this.checkKeyAndValueTensor(n,e);let r=yield n.data();return this.tensorMap.forEach(o=>o.dispose()),this.tensorMap.clear(),X(()=>{let o=tr(e),s=r.length,i=o.length;b.assert(s===i,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${i} elements.`);for(let a=0;a<s;a++){let l=r[a],c=o[a];mn(c),this.tensorMap.set(l,c)}return this.handle})})}find(n,e){return te(this,null,function*(){this.checkKeyAndValueTensor(n,e);let r=yield n.data();return X(()=>{let o=[];for(let s=0;s<r.length;s++){let i=r[s],a=this.findWithDefault(i,e);o.push(a)}return Nn(o)})})}findWithDefault(n,e){let r=this.tensorMap.get(n);return r??e}checkKeyAndValueTensor(n,e){if(n.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${n.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}};var b9=(t,n,e,r)=>te(null,null,function*(){switch(t.op){case"HashTable":case"HashTableV2":{let o=r.getHashTableHandleByName(t.name);if(o!=null)return[o];{let s=S("keyDType",t,n,e),i=S("valueDType",t,n,e),a=new Zw(s,i);return r.addHashTable(t.name,a),[a.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let o=S("tableHandle",t,n,e,r),s=S("keys",t,n,e),i=S("values",t,n,e);return[yield r.getHashTableById(o.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let o=S("tableHandle",t,n,e,r),s=S("keys",t,n,e),i=S("defaultValue",t,n,e);return[yield r.getHashTableById(o.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let o=S("tableHandle",t,n,e,r);return[r.getHashTableById(o.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});var w9=(t,n,e,r=Ft)=>{switch(t.op){case"ResizeBilinear":{let o=S("images",t,n,e),s=S("size",t,n,e),i=S("alignCorners",t,n,e),a=S("halfPixelCenters",t,n,e);return[r.image.resizeBilinear(o,[s[0],s[1]],i,a)]}case"ResizeNearestNeighbor":{let o=S("images",t,n,e),s=S("size",t,n,e),i=S("alignCorners",t,n,e),a=S("halfPixelCenters",t,n,e);return[r.image.resizeNearestNeighbor(o,[s[0],s[1]],i,a)]}case"CropAndResize":{let o=S("image",t,n,e),s=S("boxes",t,n,e),i=S("boxInd",t,n,e),a=S("cropSize",t,n,e),l=S("method",t,n,e),c=S("extrapolationValue",t,n,e);return[r.image.cropAndResize(o,s,i,a,l,c)]}case"ImageProjectiveTransformV3":{let o=S("images",t,n,e),s=S("transforms",t,n,e),i=S("outputShape",t,n,e),a=S("fillValue",t,n,e),l=S("interpolation",t,n,e),c=S("fillMode",t,n,e);return[r.image.transform(o,s,l.toLowerCase(),c.toLowerCase(),a,i)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};var C9=(t,n,e,r=Ft)=>{switch(t.op){case"Equal":return[r.equal(S("a",t,n,e),S("b",t,n,e))];case"NotEqual":return[r.notEqual(S("a",t,n,e),S("b",t,n,e))];case"Greater":return[r.greater(S("a",t,n,e),S("b",t,n,e))];case"GreaterEqual":return[r.greaterEqual(S("a",t,n,e),S("b",t,n,e))];case"Less":return[r.less(S("a",t,n,e),S("b",t,n,e))];case"LessEqual":return[r.lessEqual(S("a",t,n,e),S("b",t,n,e))];case"LogicalAnd":return[r.logicalAnd(S("a",t,n,e),S("b",t,n,e))];case"LogicalNot":return[r.logicalNot(S("a",t,n,e))];case"LogicalOr":return[r.logicalOr(S("a",t,n,e),S("b",t,n,e))];case"Select":case"SelectV2":return[r.where(S("condition",t,n,e),S("a",t,n,e),S("b",t,n,e))];case"BitwiseAnd":return[r.bitwiseAnd(S("a",t,n,e),S("b",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};var I9=(t,n,e,r=Ft)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(S("a",t,n,e),S("b",t,n,e),S("transposeA",t,n,e),S("transposeB",t,n,e))];case"Einsum":return[r.einsum(S("equation",t,n,e),...S("tensors",t,n,e))];case"Transpose":return[r.transpose(S("x",t,n,e),S("perm",t,n,e))];case"_FusedMatMul":let[o,s]=S("fusedOps",t,n,e),i=o==="biasadd",a=s==="prelu",l=S("numArgs",t,n,e),c=S("leakyreluAlpha",t,n,e);if(i){if(a&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[u,p]=S("args",t,n,e);return[r.fused.matMul({a:S("a",t,n,e),b:S("b",t,n,e),transposeA:S("transposeA",t,n,e),transposeB:S("transposeB",t,n,e),bias:u,activation:s,preluActivationWeights:p,leakyreluAlpha:c})];case"MatrixBandPart":return[r.linalg.bandPart(S("a",t,n,e),S("numLower",t,n,e),S("numUpper",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};var S9=(t,n,e,r=Ft)=>{switch(t.op){case"EuclideanNorm":return[r.euclideanNorm(S("x",t,n,e),S("axis",t,n,e),S("keepDims",t,n,e))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(S("x",t,n,e),S("mean",t,n,e),S("variance",t,n,e),S("offset",t,n,e),S("scale",t,n,e),S("epsilon",t,n,e))];case"FusedBatchNormV3":return[r.batchNorm(S("x",t,n,e),S("mean",t,n,e),S("variance",t,n,e),S("offset",t,n,e),S("scale",t,n,e),S("epsilon",t,n,e))];case"LRN":return[r.localResponseNormalization(S("x",t,n,e),S("radius",t,n,e),S("bias",t,n,e),S("alpha",t,n,e),S("beta",t,n,e))];case"Softmax":return[r.softmax(S("x",t,n,e))];case"LogSoftmax":return[r.logSoftmax(S("x",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};var T9=(t,n,e,r=Ft)=>{switch(t.op){case"RaggedGather":{let{outputNestedSplits:o,outputDenseValues:s}=r.raggedGather(S("paramsNestedSplits",t,n,e),S("paramsDenseValues",t,n,e),S("indices",t,n,e),S("outputRaggedRank",t,n,e));return o.concat(s)}case"RaggedRange":{let{rtNestedSplits:o,rtDenseValues:s}=r.raggedRange(S("starts",t,n,e),S("limits",t,n,e),S("splits",t,n,e));return[o,s]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(S("shape",t,n,e),S("values",t,n,e),S("defaultValue",t,n,e),S("rowPartitionTensors",t,n,e),S("rowPartitionTypes",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};var E9=(t,n,e,r=Ft)=>{switch(t.op){case"Max":{let a=S("axis",t,n,e),l=S("keepDims",t,n,e);return[r.max(S("x",t,n,e),a,l)]}case"Mean":{let a=S("axis",t,n,e),l=S("keepDims",t,n,e);return[r.mean(S("x",t,n,e),a,l)]}case"Min":{let a=S("axis",t,n,e),l=S("keepDims",t,n,e);return[r.min(S("x",t,n,e),a,l)]}case"Sum":{let a=S("axis",t,n,e),l=S("keepDims",t,n,e);return[r.sum(S("x",t,n,e),a,l)]}case"All":{let a=S("axis",t,n,e),l=S("keepDims",t,n,e);return[r.all(S("x",t,n,e),a,l)]}case"Any":{let a=S("axis",t,n,e),l=S("keepDims",t,n,e);return[r.any(S("x",t,n,e),a,l)]}case"ArgMax":{let a=S("axis",t,n,e);return[r.argMax(S("x",t,n,e),a)]}case"ArgMin":{let a=S("axis",t,n,e);return[r.argMin(S("x",t,n,e),a)]}case"Prod":{let a=S("axis",t,n,e),l=S("keepDims",t,n,e);return[r.prod(S("x",t,n,e),a,l)]}case"Cumprod":{let a=S("axis",t,n,e),l=S("exclusive",t,n,e),c=S("reverse",t,n,e);return[r.cumprod(S("x",t,n,e),a,l,c)]}case"Cumsum":{let a=S("axis",t,n,e),l=S("exclusive",t,n,e),c=S("reverse",t,n,e);return[r.cumsum(S("x",t,n,e),a,l,c)]}case"Bincount":let o=S("x",t,n,e),s=S("weights",t,n,e),i=S("size",t,n,e);return[r.bincount(o,s,i)];case"DenseBincount":{let a=S("x",t,n,e),l=S("weights",t,n,e),c=S("size",t,n,e),u=S("binaryOutput",t,n,e);return[r.denseBincount(a,l,c,u)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};var N9=(t,n,e,r=Ft)=>{switch(t.op){case"ConcatV2":case"Concat":{let o=S("n",t,n,e),s=S("axis",t,n,e),i=S("tensors",t,n,e);return i=i.slice(0,o),[r.concat(i,s)]}case"Gather":{let o=S("x",t,n,e),s=S("indices",t,n,e);return[r.gather(o,r.cast(s,"int32"),0)]}case"GatherV2":{let o=S("axis",t,n,e),s=S("batchDims",t,n,e),i=S("x",t,n,e),a=S("indices",t,n,e);return[r.gather(i,r.cast(a,"int32"),o,s)]}case"Reverse":{let o=S("dims",t,n,e),s=[];for(let a=0;a<o.length;a++)o[a]&&s.push(a);let i=S("x",t,n,e);return[r.reverse(i,s)]}case"ReverseV2":{let o=S("axis",t,n,e),s=S("x",t,n,e);return[r.reverse(s,o)]}case"Slice":{let o=S("begin",t,n,e),s=S("size",t,n,e);return[r.slice(S("x",t,n,e),o,s)]}case"StridedSlice":{let o=S("begin",t,n,e),s=S("end",t,n,e),i=S("strides",t,n,e),a=S("beginMask",t,n,e),l=S("endMask",t,n,e),c=S("ellipsisMask",t,n,e),u=S("newAxisMask",t,n,e),p=S("shrinkAxisMask",t,n,e),f=S("x",t,n,e);return[r.stridedSlice(f,o,s,i,a,l,c,u,p)]}case"Pack":return X(()=>{let o=S("axis",t,n,e),s=S("tensors",t,n,e),i=s[0].shape,a=r.squeeze(s[0]).shape,l=s.map(c=>{let u=b.arraysEqual(c.shape,i);if(!u&&!b.arraysEqual(r.squeeze(c).shape,a))throw new Error("the input tensors shape does not match");return u?c:r.reshape(c,i)});return[r.stack(l,o)]});case"Unpack":{let o=S("axis",t,n,e),s=S("tensor",t,n,e);return r.unstack(s,o)}case"Tile":{let o=S("reps",t,n,e);return[r.tile(S("x",t,n,e),o)]}case"Split":case"SplitV":{let o=S("axis",t,n,e),s=S("numOrSizeSplits",t,n,e),i=S("x",t,n,e);return r.split(i,s,o)}case"ScatterNd":{let o=S("indices",t,n,e),s=S("values",t,n,e),i=S("shape",t,n,e);return[r.scatterND(o,s,i)]}case"GatherNd":{let o=S("x",t,n,e),s=S("indices",t,n,e);return[r.gatherND(o,s)]}case"SparseToDense":{let o=S("sparseIndices",t,n,e),s=S("outputShape",t,n,e),i=S("sparseValues",t,n,e),a=S("defaultValue",t,n,e);return[r.sparseToDense(o,i,s,i.dtype===a.dtype?a:r.cast(a,i.dtype))]}case"TensorScatterUpdate":{let o=S("indices",t,n,e),s=S("values",t,n,e),i=S("tensor",t,n,e);return[r.tensorScatterUpdate(i,o,s)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};var D9=(t,n,e,r=Ft)=>{switch(t.op){case"SparseFillEmptyRows":{let{outputIndices:o,outputValues:s,emptyRowIndicator:i,reverseIndexMap:a}=r.sparse.sparseFillEmptyRows(S("indices",t,n,e),S("values",t,n,e),S("denseShape",t,n,e),S("defaultValue",t,n,e));return[o,s,i,a]}case"SparseReshape":{let{outputIndices:o,outputShape:s}=r.sparse.sparseReshape(S("inputIndices",t,n,e),S("inputShape",t,n,e),S("newShape",t,n,e));return[o,s]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(S("data",t,n,e),S("indices",t,n,e),S("segmentIds",t,n,e))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(S("data",t,n,e),S("indices",t,n,e),S("segmentIds",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};var k9=(t,n,e,r=Ft)=>{switch(t.op){case"FFT":return[r.fft(S("x",t,n,e))];case"IFFT":return[r.ifft(S("x",t,n,e))];case"RFFT":return[r.rfft(S("x",t,n,e))];case"IRFFT":return[r.irfft(S("x",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};var A9=(t,n,e,r=Ft)=>{switch(t.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(S("input",t,n,e),S("pattern",t,n,e),S("rewrite",t,n,e),S("replaceGlobal",t,n,e))];case"StringNGrams":{let{nGrams:o,nGramsSplits:s}=r.string.stringNGrams(S("data",t,n,e),S("dataSplits",t,n,e),S("separator",t,n,e),S("nGramWidths",t,n,e),S("leftPad",t,n,e),S("rightPad",t,n,e),S("padWidth",t,n,e),S("preserveShortSequences",t,n,e));return[o,s]}case"StringSplit":{let{indices:o,values:s,shape:i}=r.string.stringSplit(S("input",t,n,e),S("delimiter",t,n,e),S("skipEmpty",t,n,e));return[o,s,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(S("input",t,n,e),S("numBuckets",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};var _9=(t,n,e,r=Ft)=>{switch(t.op){case"Cast":return[r.cast(S("x",t,n,e),S("dtype",t,n,e))];case"ExpandDims":{let o=S("axis",t,n,e);return[r.expandDims(S("x",t,n,e),o)]}case"Squeeze":{let o=S("axis",t,n,e);return[r.squeeze(S("x",t,n,e),o)]}case"Reshape":return[r.reshape(S("x",t,n,e),S("shape",t,n,e))];case"EnsureShape":return[r.ensureShape(S("x",t,n,e),S("shape",t,n,e))];case"MirrorPad":return[r.mirrorPad(S("x",t,n,e),S("padding",t,n,e),S("mode",t,n,e))];case"PadV2":case"Pad":return[r.pad(S("x",t,n,e),S("padding",t,n,e),S("constantValue",t,n,e))];case"SpaceToBatchND":{let o=S("blockShape",t,n,e),s=S("paddings",t,n,e);return[r.spaceToBatchND(S("x",t,n,e),o,s)]}case"BatchToSpaceND":{let o=S("blockShape",t,n,e),s=S("crops",t,n,e);return[r.batchToSpaceND(S("x",t,n,e),o,s)]}case"DepthToSpace":{let o=S("blockSize",t,n,e),s=S("dataFormat",t,n,e).toUpperCase();return[r.depthToSpace(S("x",t,n,e),o,s)]}case"BroadcastTo":return[r.broadcastTo(S("x",t,n,e),S("shape",t,n,e))];case"BroadcastArgs":return[r.broadcastArgs(S("s0",t,n,e),S("s1",t,n,e))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};function i4(t,n,e,r,o=X){let s=((i,a,l)=>{switch(i.category){case"arithmetic":return o(()=>i9(i,a,l));case"basic_math":return o(()=>a9(i,a,l));case"control":return d9(i,a,l);case"convolution":return o(()=>m9(i,a,l));case"creation":return o(()=>g9(i,a,l));case"dynamic":return y9(i,a,l);case"evaluation":return o(()=>x9(i,a,l));case"image":return o(()=>w9(i,a,l));case"graph":return o(()=>v9(i,a,l));case"logical":return o(()=>C9(i,a,l));case"matrices":return o(()=>I9(i,a,l));case"normalization":return o(()=>S9(i,a,l));case"ragged":return o(()=>T9(i,a,l));case"reduction":return o(()=>E9(i,a,l));case"slice_join":return o(()=>N9(i,a,l));case"sparse":return o(()=>D9(i,a,l));case"spectral":return o(()=>k9(i,a,l));case"string":return o(()=>A9(i,a,l));case"transformation":return o(()=>_9(i,a,l));case"hash_table":return b9(i,a,l,r);case"custom":let c=$w(i.op);if(c&&c.customExecutor)return c.customExecutor(new Kw(i,a,l));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,n,e);return b.isPromise(s)?s.then(i=>[].concat(i)):[].concat(s)}var ex=class{constructor(n={},e={},r={},o={},s){this.weightMap=n,this.tensorArrayMap=e,this.tensorListMap=r,this.functionMap=o,this.parseNodeNameCache=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(n,e){return{id:n,frameName:e,iterationId:0}}set currentContext(n){this.contexts!==n&&(this.contexts=n,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let n=[];for(let e=0;e<this.contexts.length-1;e++){let r=this.contexts.slice(0,this.contexts.length-e);n.push(this.contextIdforContexts(r))}n.push(""),this._currentContextIds=n}contextIdforContexts(n){return n?n.map(e=>e.id===0&&e.iterationId===0?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(n){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,n)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let n=Object.assign({},this.contexts[this.contexts.length-1]);n.iterationId+=1,n.id=this.lastId,this.contexts.splice(-1,1,n),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(n){return this.weightMap[n]}addTensorArray(n){this.tensorArrayMap[n.id]=n}getTensorArray(n){return this.tensorArrayMap[n]}addTensorList(n){this.tensorListMap[n.id]=n}getTensorList(n){return this.tensorListMap[n]}dispose(n){for(let e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(n);for(let e in this.tensorListMap)this.tensorListMap[e].clearAndClose(n)}};function a4(t,n,e,r){let o=new Set,s=[],i=null,a=null,l=new Set,c=new Set(Object.keys(t).map(f=>wo(f)[0]));r=r||[];let u=new Set(r.map(f=>wo(f.name)[0])),p=[...n];for(;p.length>0;){let f=p.pop();if((Lu(f)||rfe(f)||ofe(f))&&i==null&&(i=f,a=i.children.map(d=>d.name).filter(d=>o.has(d))),o.add(f.name),e[f.name]==null&&!c.has(f.name)&&!u.has(f.name)){if(f.inputs.length===0){s.push(f.name);continue}f.inputs.forEach(d=>{l.has(d.name)||(l.add(d.name),p.push(d))})}}return{inputs:t,outputs:n,usedNodes:o,missingInputs:s,dynamicNode:i,syncInputs:a}}function R9(t,n){let{usedNodes:e,inputs:r}=n,o=Object.keys(r).map(m=>wo(m)[0]).map(m=>t.nodes[m]),s=t.initNodes||[],i=m=>e.has(typeof m=="string"?m:m.name);function a(m){return[...new Map(m.map(y=>[y.name,y])).values()]}let l=a([...o,...t.weights,...s]).filter(i),c=a([...l,...Object.values(t.nodes)]).filter(i),u=new Map(c.map(m=>[m.name,m])),p={};for(let m of c){p[m.name]=p[m.name]||0;for(let y of m.children)i(y)||(p[y.name]=Number.POSITIVE_INFINITY),p[y.name]=(p[y.name]||0)+1}let f=Object.entries(p).filter(([,m])=>m===0).map(([m])=>m),d=[...f];for(;f.length>0;){let m=f.pop(),y=u.get(m);for(let x of y.children.filter(i))--p[x.name]===0&&(d.push(x.name),f.push(x.name))}let h=d.map(m=>u.get(m)),g=Qpe(h,l);return Jpe(g,l),g}function Qpe(t,n){let e=new Map(t.map(i=>[i.name,i])),r=n.map(i=>i.name),o=new Set(r);for(;r.length>0;){let i=r.pop(),a=e.get(i);for(let l of a.children)!e.has(l.name)||o.has(l.name)||(o.add(l.name),r.push(l.name))}return t.filter(i=>o.has(i.name))}var pg=class extends Error{constructor(n){super(`NodesExecutionOrderError: ${n}`)}};function Jpe(t,n){let e=new Map(t.map((a,l)=>[a.name,l])),r=new Set(n.map(a=>a.name)),o=a=>r.has(typeof a=="string"?a:a.name),s=new Set(t.map(a=>a.name)),i=a=>s.has(typeof a=="string"?a:a.name);for(let a of t){for(let l of a.children.filter(i)){if(!e.has(l.name))throw new pg(`Child ${l.name} of node ${a.name} is unreachable.`);if(e.get(a.name)>e.get(l.name))throw new pg(`Node ${a.name} is scheduled to run after its child ${l.name}.`)}if(!o(a))for(let l of a.inputs){if(!e.has(l.name))throw new pg(`Input ${l.name} of node ${a.name} is unreachable.`);if(e.get(l.name)>e.get(a.name))throw new pg(`Node ${a.name} is scheduled to run before its input ${l.name}.`)}}}function M9(t){let n=new Map(t.map((a,l)=>[a.name,l])),e=Number.MAX_SAFE_INTEGER,r=t.map((a,l)=>Lu(a)?e:l),o=a=>{let l=r[n.get(a.name)];return l??-1},s=t.map((a,l)=>a.children.map(o).reduce((c,u)=>Math.max(c,u),r[l])),i=new Map;for(let a=0;a<t.length;++a){let l=s[a];if(l===e)continue;let c=t[a],u=t[l];i.has(u.name)||i.set(u.name,[]),i.get(u.name).push(c)}return i}var efe=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),tfe=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),nfe=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Lu(t){return efe.has(t.op)}function rfe(t){return tfe.has(t.op)}function ofe(t){return nfe.has(t.op)}var tx=class t{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(n){let e=Object.keys(n).map(r=>n[r].map(o=>o.id));this._weightIds=[].concat(...e),this._weightMap=n}set resourceManager(n){this._resourceManager=n}get inputs(){return this._inputs.map(n=>({name:n.name,shape:n.attrParams.shape?n.attrParams.shape.value:void 0,dtype:n.attrParams.dtype?n.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(n=>({name:n.name,shape:n.attrParams.shape?n.attrParams.shape.value:void 0,dtype:n.attrParams.dtype?n.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(n=>n.signatureKey||n.name)}get outputNodes(){return this._outputs.map(n=>{let e=n.signatureKey||n.name;return n.defaultOutput?`${e}:${n.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((n,e)=>(n[e]=this._functions[e].signature,n),{})}constructor(n,e){this.graph=n,this.parent=e,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=n.outputs,this._inputs=n.inputs,this._initNodes=n.initNodes,this._signature=n.signature,this._functions=n.functions,n.functions!=null&&Object.keys(n.functions).forEach(r=>{this._functionExecutorMap[r]=new t(n.functions[r],this)})}getCompilationKey(n,e){let r=n.map(s=>s.name).sort(),o=e.map(s=>s.name).sort();return r.join(this.SEPARATOR)+"--"+o.join(this.SEPARATOR)}compile(n,e){let r=a4(n,e,this.weightMap,this._initNodes),{missingInputs:o,dynamicNode:s,syncInputs:i}=r;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(o.length>0){let c=e.map(p=>p.name),u=Object.keys(n);throw new Error(`Cannot compute the outputs [${c}] from the provided inputs [${u}]. Missing the following inputs: [${o}]`)}let a=R9(this.graph,r),l=M9(a);return{orderedNodes:a,nodeLiveUntilMap:l}}cloneAndKeepTensor(n){if(n==null)return null;let e=n.clone();return mn(e),e}cloneTensorList(n){return n?n.map(r=>this.cloneAndKeepTensor(r)):null}cloneTensorMap(n){return Object.fromEntries(Object.entries(n).map(([e,r])=>[e,this.cloneTensorList(r)]))}execute(n,e){this.disposeIntermediateTensors(),n=this.mapInputs(n);let r=Object.keys(n).sort();this.checkInputs(n),this.checkInputShapeAndType(n),e=this.mapOutputs(e),this.checkOutputs(e);let o=r.map(f=>this.graph.nodes[wo(f)[0]]),s=e.map(f=>wo(f)[0]),i=new Set(s),a=s.map(f=>this.graph.nodes[f]);a.length===0&&(a=this._outputs);let l=this.getCompilationKey(o,a),c=this.compiledMap.get(l);c==null&&(c=this.compile(n,a),this.compiledMap.set(l,c));try{this.keepIntermediateTensors=Z().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){this.keepIntermediateTensors=!1,console.warn(f.message)}let u={},p={};return X(()=>{let f=new ex(this.weightMap,u,p,this.functionExecutorMap,this.parseNodeNameCache),d=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(n).forEach(y=>{let[x,C]=wo(y,f),I=[];I[C]=n[y],d[x]=I,this.keepIntermediateTensors&&(this.clonedTensorsMap[x]=this.cloneTensorList(I))});let h=this.getFrozenTensorIds(d),{orderedNodes:g,nodeLiveUntilMap:m}=c;for(let y of g){if(d[y.name])continue;let x=i4(y,d,f,this._resourceManager);if(b.isPromise(x))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);d[y.name]=x,this.keepIntermediateTensors&&(this.clonedTensorsMap[y.name]=this.cloneTensorList(x)),this.checkTensorForDisposalWithNodeLiveUntilInfo(y,d,f,h,i,m.get(y.name))}return this.parent==null&&f.dispose(h),e.map(y=>Xn(y,d,f))})}getFrozenTensorIds(n){let e=[].concat.apply([],Object.keys(n).map(r=>n[r]).map(r=>r.map(o=>o.id)));return new Set(e)}checkTensorForDisposal(n,e,r,o,s,i,a){if(!(Lu(e)||i.has(n))){for(let l of r[n])l!=null&&(a[l.id]=(a[l.id]||0)+e.children.length);for(let l of e.inputs){if(Lu(l))continue;let c=PD(l.name,r,o);if(c!=null)for(let u of c){if(!u||u.kept||s.has(u.id))continue;let p=a[u.id];p===1?(u.dispose(),delete a[u.id]):p!=null&&a[u.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(n,e,r,o,s,i){function a(l){return Lu(l)||s.has(l.name)}if(!(Lu(n)||i==null))for(let l of i){if(a(l))continue;let c=PD(l.name,e,r);for(let u of c)!u||u.kept||o.has(u.id)||u.dispose()}}executeAsync(n,e){return te(this,null,function*(){return this._executeAsync(n,e)})}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(n=>{for(let e of n)e&&!e.isDisposed&&e.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}_executeAsync(i,a){return te(this,arguments,function*(n,e,r=!1,o={},s={}){this.disposeIntermediateTensors(),r||(n=this.mapInputs(n),this.checkInputs(n),this.checkInputShapeAndType(n),e=this.mapOutputs(e),this.checkOutputs(e));try{this.keepIntermediateTensors=Z().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){this.keepIntermediateTensors=!1,console.warn(h.message)}let l=new ex(this.weightMap,o,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let c=yield this.executeWithControlFlow(n,l,e,r),u=e.map(h=>Xn(h,c,l)),p=u.map(h=>h.id),f=Object.keys(n).map(h=>n[h].id),d=new Set([...p,...f,...this.weightIds]);return Object.values(c).forEach(h=>{h.forEach(g=>{g&&!g.isDisposed&&!d.has(g.id)&&g.dispose()})}),this.parent==null&&l.dispose(d),u})}executeFunctionAsync(n,e,r){return te(this,null,function*(){let o=n.reduce((s,i,a)=>(s[this.inputs[a].name]=i,s),{});return this._executeAsync(o,this.outputNodes,!0,e,r)})}executeWithControlFlow(n,e,r,o){return te(this,null,function*(){let s=Object.keys(n),i=s.map(I=>this.graph.nodes[wo(I)[0]]),a=r.map(I=>wo(I)[0]),l=new Set(a),c=a.map(I=>this.graph.nodes[I]);c.length===0&&(c=this._outputs);let{usedNodes:u,missingInputs:p,dynamicNode:f,syncInputs:d}=a4(n,c,this.weightMap,this._initNodes),h=[...i,...this.graph.weights,...this._initNodes||[]].map(I=>({node:I,contexts:e.currentContext})),g=Object.assign({},this.weightMap);Object.keys(n).forEach(I=>{let[D,O]=wo(I),L=[];L[O]=n[I],g[D]=L});let m={},y=this.getFrozenTensorIds(g),x={};for(;h.length>0;){let I=this.processStack(i,h,e,g,x,y,l,m,u);yield Promise.all(I)}f==null&&!o&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let C=c.filter(I=>!Lu(I)&&!Xn(I.name,g,e)).map(I=>I.name);if(C.length>0){let I="";throw f!=null&&(I=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${C}] from the provided inputs [${s}]. Consider providing the following inputs: [${p}]. ${I}`)}return g})}processStack(n,e,r,o,s,i,a,l,c){let u=[];for(;e.length>0;){let p=e.pop();r.currentContext=p.contexts;let f="";if(p.node.op==="Enter"&&S("isConstant",p.node,o,r)&&([f]=Si(p.node.name,r)),o[p.node.name]==null){let d=i4(p.node,o,r,this._resourceManager);f||([f]=Si(p.node.name,r));let h=r.currentContext;b.isPromise(d)?u.push(d.then(g=>(o[f]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(g)),r.currentContext=h,this.checkTensorForDisposal(f,p.node,o,r,i,a,l),this.processChildNodes(p.node,e,r,o,s,c),g))):(o[f]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(d)),this.checkTensorForDisposal(f,p.node,o,r,i,a,l),this.processChildNodes(p.node,e,r,o,s,c))}else this.processChildNodes(p.node,e,r,o,s,c)}return u}processChildNodes(n,e,r,o,s,i){n.children.forEach(a=>{let[l]=Si(a.name,r);s[l]||!i.has(a.name)||(a.op==="Merge"?a.inputNames.some(c=>!!Xn(c,o,r))&&(s[l]=!0,e.push({contexts:r.currentContext,node:a})):a.inputNames.every(c=>!!Xn(c,o,r))&&(s[l]=!0,e.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(n=>this.weightMap[n].forEach(e=>e.dispose()))}checkInputShapeAndType(n){Object.keys(n).forEach(e=>{let r=n[e],[o]=wo(e),s=this.graph.nodes[o];if(s.attrParams.shape&&s.attrParams.shape.value){let i=s.attrParams.shape.value,a=i.length===r.shape.length&&r.shape.every((l,c)=>i[c]===-1||i[c]===l);b.assert(a,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${i}], but was [${r.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&b.assert(r.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(n){var e,r;let o={};for(let s in n){let i=(r=(e=this._signature)===null||e===void 0?void 0:e.inputs)===null||r===void 0?void 0:r[s];i!=null?o[i.name]=n[s]:o[s]=n[s]}return o}checkInputs(n){let e=Object.keys(n).filter(r=>{let[o]=wo(r);return this.graph.nodes[o]==null});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(n){return n.map(e=>{var r,o;let s=(o=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||o===void 0?void 0:o[e];return s!=null?s.name:e},{})}checkOutputs(n){n.forEach(e=>{let[r]=wo(e);if(!this.graph.nodes[r])throw new Error(`The output '${e}' is not found in the graph`)})}};var Qw=class{constructor(n={},e={}){this.hashTableNameToHandle=n,this.hashTableMap=e}addHashTable(n,e){this.hashTableNameToHandle[n]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(n){return this.hashTableNameToHandle[n]}getHashTableById(n){return this.hashTableMap[n]}dispose(){for(let n in this.hashTableMap)this.hashTableMap[n].clearAndClose(),delete this.hashTableMap[n];for(let n in this.hashTableNameToHandle)this.hashTableNameToHandle[n].dispose(),delete this.hashTableNameToHandle[n]}};var sfe="?tfjs-format=file",ife="model.json",Jw=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(n,e={},r=yi){this.modelUrl=n,this.loadOptions=e,this.version="n/a",this.io=r,e==null&&(this.loadOptions={}),this.resourceManager=new Qw}findIOHandler(){let n=this.modelUrl;if(n.load!=null)this.handler=n;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(n,this.loadOptions);else{let e=this.io.getLoadHandlers(n,this.loadOptions);if(e.length===0)e.push(this.io.browserHTTPRequest(n,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[n]}'`);this.handler=e[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let n=this.handler.load();return b.isPromise(n)?n.then(e=>e.getWeightStream==null?this.loadSync(e):this.loadStreaming(e)):this.loadSync(n)}loadSync(n){let e=this.io.decodeWeights(n.weightData,n.weightSpecs);return this.loadWithWeightMap(n,e)}loadStreaming(n){return te(this,null,function*(){if(n.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");let e=yield Cv(n.getWeightStream(),n.weightSpecs);return this.loadWithWeightMap(n,e)})}loadWithWeightMap(n,e){this.artifacts=n;let r=this.artifacts.modelTopology,o=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let s=this.artifacts.userDefinedMetadata;s.signature!=null&&(o=s.signature),s.structuredOutputKeys!=null&&(this.structuredOutputKeys=s.structuredOutputKeys)}if(this.signature=o,this.version=`${r.versions.producer}.${r.versions.minConsumer}`,this.executor=new tx(J1.Instance.transformGraph(r,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(e),this.executor.resourceManager=this.resourceManager,n.modelInitializer!=null&&n.modelInitializer.node!=null){let s=J1.Instance.transformGraph(n.modelInitializer);this.initializer=new tx(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=n.initializerSignature}return!0}save(n,e){return te(this,null,function*(){if(typeof n=="string"){let r=this.io.getSaveHandlers(n);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${n}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${n}'`);n=r[0]}if(n.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return n.save(this.artifacts)})}addStructuredOutputNames(n){if(this.structuredOutputKeys){let e=n instanceof ot?[n]:n,r={};return e.forEach((o,s)=>r[this.structuredOutputKeys[s]]=o),r}return n}predict(n,e){let r=this.execute(n,this.outputNodes);return this.addStructuredOutputNames(r)}predictAsync(n,e){return te(this,null,function*(){let r=yield this.executeAsync(n,this.outputNodes);return this.addStructuredOutputNames(r)})}normalizeInputs(n){var e;if(!(n instanceof ot)&&!Array.isArray(n)){let s=(e=this.signature)===null||e===void 0?void 0:e.inputs;if(s!=null)for(let i in s){let a=s[i];a.resourceId!=null&&(n[i]=this.resourceIdToCapturedInput[a.resourceId])}return n}n=Array.isArray(n)?n:[n];let r=Object.keys(this.resourceIdToCapturedInput).length;if(n.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${n.length} input tensors provided.`);let o=0;return this.inputNodes.reduce((s,i)=>{var a,l,c;let u=(c=(l=(a=this.signature)===null||a===void 0?void 0:a.inputs)===null||l===void 0?void 0:l[i])===null||c===void 0?void 0:c.resourceId;return u!=null?s[i]=this.resourceIdToCapturedInput[u]:s[i]=n[o++],s},{})}normalizeOutputs(n){return n=n||this.outputNodes,Array.isArray(n)?n:[n]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}executeInitializerGraphAsync(){return te(this,null,function*(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))})}setResourceIdToCapturedInput(n){if(this.resourceIdToCapturedInput={},this.initializerSignature){let e=this.initializerSignature.outputs,r=Object.keys(e);for(let o=0;o<r.length;o++){let s=r[o],i=e[s];this.resourceIdToCapturedInput[i.resourceId]=n[o]}}}execute(n,e){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),n=this.normalizeInputs(n),e=this.normalizeOutputs(e);let r=this.executor.execute(n,e);return r.length>1?r:r[0]}executeAsync(n,e){return te(this,null,function*(){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(yield this.executeInitializerGraphAsync()),n=this.normalizeInputs(n),e=this.normalizeOutputs(e);let r=yield this.executor.executeAsync(n,e);return r.length>1?r:r[0]})}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(n){return Object.keys(n).reduce((e,r)=>(e[r]=[n[r]],e),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Ve(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};function nx(r){return te(this,arguments,function*(t,n={},e=yi){if(t==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");n==null&&(n={}),n.fromTFHub&&typeof t=="string"&&(t=afe(t));let o=new Jw(t,n,e);return yield o.load(),o})}function afe(t){return t.endsWith("/")||(t=t+"/"),`${t}${ife}${sfe}`}var mfe=wa(D1());var dfe=wa(D1());function he(t,n){Array.isArray(t)||(t=[t]),t.forEach(e=>{e!=null&&b.assert(e.dtype!=="complex64",()=>`${n} does not support complex64 tensors in the CPU backend.`)})}var Efe=Vr.whereImpl,F9=(()=>{class t extends Ua{nextDataId(){return t.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Ep(this,Ps())}write(e,r,o){this.firstUse&&(this.firstUse=!1,Z().get("IS_NODE")&&_.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let s={id:this.nextDataId()};return this.data.set(s,{values:e,dtype:o,refCount:1}),s}makeTensorInfo(e,r,o){let s;if(r==="string"&&o!=null&&o.length>0&&b.isString(o[0])){let i=o.map(a=>b.encodeString(a));s=this.write(i,e,r)}else s=this.write(o,e,r);return{dataId:s,shape:e,dtype:r}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){let r=this.data.get(e);r.refCount++}decRef(e){if(this.data.has(e)){let r=this.data.get(e);r.refCount--}}move(e,r,o,s,i){this.data.set(e,{values:r,dtype:s,refCount:i})}numDataIds(){return this.data.numDataIds()}read(e){return te(this,null,function*(){return this.readSync(e)})}readSync(e){let{dtype:r,complexTensorInfos:o}=this.data.get(e);if(r==="complex64"){let s=this.readSync(o.real.dataId),i=this.readSync(o.imag.dataId);return _.mergeRealAndImagArrays(s,i)}return b.convertBackendValuesAndArrayBuffer(this.data.get(e).values,r)}bufferSync(e){let r=this.readSync(e.dataId);if(e.dtype==="string")try{let o=r.map(s=>b.decodeString(s));return Be(e.shape,e.dtype,o)}catch(o){throw new Error("Failed to decode encoded string bytes into utf-8")}return Be(e.shape,e.dtype,r)}makeOutput(e,r,o){return Ps().makeTensorFromTensorInfo(this.makeTensorInfo(r,o,e),this)}disposeData(e,r=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!r&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:o}=this.data.get(e);o!=null&&(this.disposeData(o.real.dataId,!0),this.disposeData(o.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return te(this,null,function*(){let r=b.now();return e(),{kernelMs:b.now()-r}})}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){he([e],"where");let r=this.readSync(e.dataId);return Efe(e.shape,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return t.nextDataId=0,t})();var B4={};Xt(B4,{addImpl:()=>p4,bincountImpl:()=>hg,bincountReduceImpl:()=>eC,bitwiseAndImpl:()=>f4,castImpl:()=>u4,ceilImpl:()=>d4,concatImpl:()=>tC,equalImpl:()=>h4,expImpl:()=>g4,expm1Impl:()=>x4,floorDivImpl:()=>b4,floorImpl:()=>v4,gatherNdImpl:()=>nC,gatherV2Impl:()=>rC,greaterEqualImpl:()=>C4,greaterImpl:()=>w4,lessEqualImpl:()=>S4,lessImpl:()=>I4,linSpaceImpl:()=>oC,logImpl:()=>T4,maxImpl:()=>sC,maximumImpl:()=>E4,minimumImpl:()=>N4,multiplyImpl:()=>rx,negImpl:()=>D4,notEqualImpl:()=>k4,prodImpl:()=>A4,raggedGatherImpl:()=>iC,raggedRangeImpl:()=>aC,raggedTensorToTensorImpl:()=>lC,rangeImpl:()=>cC,rsqrtImpl:()=>R4,scatterImpl:()=>Ei,sigmoidImpl:()=>fB,simpleAbsImpl:()=>c4,sliceImpl:()=>O4,sparseFillEmptyRowsImpl:()=>uC,sparseReshapeImpl:()=>pC,sparseSegmentReductionImpl:()=>gg,sqrtImpl:()=>mB,squaredDifferenceImpl:()=>F4,staticRegexReplaceImpl:()=>$4,stridedSliceImpl:()=>fC,stringNGramsImpl:()=>dC,stringSplitImpl:()=>hC,stringToHashBucketFastImpl:()=>mC,subImpl:()=>P4,tileImpl:()=>gC,topKImpl:()=>yC,transposeImpl:()=>mg,uniqueImpl:()=>xC});function c4(t){let n=new Float32Array(t.length);for(let e=0;e<t.length;++e)n[e]=Math.abs(t[e]);return n}var Nfe=t=>{let{x:n}=t.inputs,e=t.backend;he(n,"abs");let r=new Float32Array(b.sizeFromShape(n.shape)),o=e.data.get(n.dataId).values;return r=c4(o),e.makeOutput(r,n.shape,n.dtype)},$9={kernelName:"Abs",backendName:"cpu",kernelFunc:Nfe};function bt(t){return(n,e,r,o,s)=>{let i=_.assertAndGetBroadcastShape(n,e),a=i.length,l=b.computeStrides(i),c=b.sizeFromShape(i),u=b.getTypedArrayFromDType(s,c),p=n.length,f=e.length,d=b.computeStrides(n),h=b.computeStrides(e),g=_.getBroadcastDims(n,i),m=_.getBroadcastDims(e,i);if(g.length+m.length===0)for(let y=0;y<u.length;++y)u[y]=t(r[y%r.length],o[y%o.length]);else for(let y=0;y<u.length;++y){let x=b.indexToLoc(y,a,l),C=x.slice(-p);g.forEach(L=>C[L]=0);let I=b.locToIndex(C,p,d),D=x.slice(-f);m.forEach(L=>D[L]=0);let O=b.locToIndex(D,f,h);u[y]=t(r[I],o[O])}return[u,i]}}function ur(t){let{inputs:n,backend:e}=t,{real:r,imag:o}=n,s=e.data.get(r.dataId).values,i=e.data.get(o.dataId).values,a=e.makeTensorInfo(r.shape,"complex64"),l=e.data.get(a.dataId);return l.complexTensorInfos={real:e.makeTensorInfo(r.shape,"float32",s),imag:e.makeTensorInfo(o.shape,"float32",i)},a}var L9={kernelName:nh,backendName:"cpu",kernelFunc:ur};function fg(t,n,e="float32"){if(e==="complex64"){let o=fg(t,n,"float32"),s=fg(t,n,"float32");return ur({inputs:{real:o,imag:s},backend:t})}let r=b.makeZerosTypedArray(b.sizeFromShape(n),e);return t.makeTensorInfo(n,e,r)}function Ur(t){let{inputs:n,backend:e}=t,{x:r}=n;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var P9={kernelName:Ki,backendName:"cpu",kernelFunc:Ur};function Ys(t){let{inputs:n,backend:e}=t,{input:r}=n,o=e.data.get(r.dataId).complexTensorInfos.real,s=e.data.get(o.dataId).values;return e.makeTensorInfo(o.shape,o.dtype,s)}var B9={kernelName:Mh,backendName:"cpu",kernelFunc:Ys};function u4(t,n,e,r){if(r==="int32"){let o=Int32Array.from(t);return[n,"int32",o]}if(r==="bool"){let o=b.toTypedArray([0],e),[s,i]=bt((a,l)=>a!==l?1:0)(n,[],t,o,"bool");return[i,"bool",s]}throw new Error(`Error in Cast: failed to cast ${e} to ${r}`)}function Zs(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{dtype:s}=r;if(s==="complex64"){if(o.dtype==="complex64")return Ur({inputs:{x:o},backend:e});let u=fg(e,o.shape,o.dtype),p=Zs({inputs:{x:o},backend:e,attrs:{dtype:"float32"}}),f=ur({inputs:{real:p,imag:u},backend:e});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(p),f}if(o.dtype==="complex64"){let u=Ys({inputs:{input:o},backend:e}),p=Zs({inputs:{x:u},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(u),p}if(!b.hasEncodingLoss(o.dtype,s)){let u=Ur({inputs:{x:o},backend:e});return{dataId:u.dataId,shape:u.shape,dtype:s}}let i=e.data.get(o.dataId).values,[a,l,c]=u4(i,o.shape,o.dtype,s);return e.makeTensorInfo(a,l,c)}var z9={kernelName:qi,backendName:"cpu",kernelFunc:Zs};function _t(t,n,e,r){return e==null?({inputs:o,backend:s})=>{let{a:i,b:a}=o,l=s;he([i,a],t);let c=l.data.get(i.dataId).values,u=l.data.get(a.dataId).values,p=i.dtype==="string"?_.fromUint8ToStringArray(c):c,f=i.dtype==="string"?_.fromUint8ToStringArray(u):u,d=r||i.dtype,[h,g]=n(i.shape,a.shape,p,f,d);return l.makeTensorInfo(g,d,h)}:({inputs:o,backend:s})=>{let{a:i,b:a}=o,l=s;if(i.dtype==="complex64"||a.dtype==="complex64"){let c=Zs({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),u=l.data.get(c.dataId),p=u.complexTensorInfos.real,f=u.complexTensorInfos.imag,d=l.data.get(p.dataId).values,h=l.data.get(f.dataId).values,g=Zs({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),m=l.data.get(g.dataId),y=m.complexTensorInfos.real,x=m.complexTensorInfos.imag,C=l.data.get(y.dataId).values,I=l.data.get(x.dataId).values,[D,O,L]=e(i.shape,a.shape,d,h,C,I),B=l.makeTensorInfo(L,"float32",D),V=l.makeTensorInfo(L,"float32",O),F=ur({inputs:{real:B,imag:V},backend:l});return l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(g),l.disposeIntermediateTensorInfo(B),l.disposeIntermediateTensorInfo(V),F}else{let c=l.data.get(i.dataId).values,u=l.data.get(a.dataId).values,p=r||i.dtype,[f,d]=n(i.shape,a.shape,c,u,p);return l.makeTensorInfo(d,p,f)}}}function dg(t){return(n,e,r,o,s,i)=>{let a=_.assertAndGetBroadcastShape(n,e),l=b.sizeFromShape(a),c=a.length,u=b.computeStrides(a),p=b.getTypedArrayFromDType("float32",l),f=b.getTypedArrayFromDType("float32",l),d=_.getBroadcastDims(n,a),h=_.getBroadcastDims(e,a),g=_.mergeRealAndImagArrays(r,o),m=_.mergeRealAndImagArrays(s,i),y=n.length,x=b.computeStrides(n),C=e.length,I=b.computeStrides(e);if(d.length+h.length===0)for(let D=0;D<p.length;D++){let O=D%g.length,L=D%m.length,B=t(g[O*2],g[O*2+1],m[L*2],m[L*2+1]);p[D]=B.real,f[D]=B.imag}else for(let D=0;D<p.length;D++){let O=b.indexToLoc(D,c,u),L=O.slice(-y);d.forEach(ee=>L[ee]=0);let B=b.locToIndex(L,y,x),V=O.slice(-C);h.forEach(ee=>V[ee]=0);let F=b.locToIndex(V,C,I),G=t(g[B*2],g[B*2+1],m[F*2],m[F*2+1]);p[D]=G.real,f[D]=G.imag}return[p,f,a]}}var p4=bt((t,n)=>t+n),Dfe=dg((t,n,e,r)=>({real:t+e,imag:n+r})),pa=_t("Add",p4,Dfe),V9={kernelName:"Add",backendName:"cpu",kernelFunc:pa};function hg(t,n,e,r,o){let s=b.sizeFromShape(r),i=b.makeZerosTypedArray(o,e);for(let a=0;a<t.length;a++){let l=t[a];if(l<0)throw new Error("Input x must be non-negative!");l>=o||(s>0?i[l]+=n[a]:i[l]+=1)}return i}function eC(t,n,e,r=!1){let o=t.shape[0],s=t.shape[1],i=Be([o,e],n.dtype);for(let a=0;a<o;a++)for(let l=0;l<s;l++){let c=t.get(a,l);if(c<0)throw new Error("Input x must be non-negative!");c>=e||(r?i.set(1,a,c):n.size>0?i.set(i.get(a,c)+n.get(a,l),a,c):i.set(i.get(a,c)+1,a,c))}return i}var f4=bt((t,n)=>t&n),kfe=_t(Ap,f4),U9={kernelName:Ap,backendName:"cpu",kernelFunc:kfe};function vr(t){return(n,e,r)=>{let o=b.getArrayFromDType(e,n.length);for(let s=0;s<n.length;++s)o[s]=t(n[s],r);return o}}function Je(t,n,e){let r=vr(n);return Lo(t,r,e)}function Lo(t,n,e){return({inputs:r,attrs:o,backend:s})=>{let{x:i}=r;he(i,t);let a=s,l=a.data.get(i.dataId).values,c;if(i.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");c=_.fromUint8ToStringArray(l)}else c=l;let u=e||i.dtype,p=n(c,u,o);return a.makeTensorInfo(i.shape,u,p)}}var d4=vr(t=>Math.ceil(t)),Afe=Lo(Za,d4),G9={kernelName:Za,backendName:"cpu",kernelFunc:Afe};function tC(t,n,e,r){let o=b.getArrayFromDType(e,b.sizeFromShape(n));if(r&&e!=="string"){let s=0;t.forEach(i=>{let a=b.sizeFromShape(i.shape);o.set(i.vals,s),s+=a})}else{let s=0;t.forEach(i=>{let a=e==="string"?_.fromUint8ToStringArray(i.vals):i.vals,l=0;for(let c=0;c<i.shape[0];++c){let u=c*n[1]+s;for(let p=0;p<i.shape[1];++p)o[u+p]=a[l++]}s+=i.shape[1]})}return o}var h4=bt((t,n)=>t===n?1:0),m4=_t(_p,h4,null,"bool"),j9={kernelName:_p,backendName:"cpu",kernelFunc:m4};var g4=vr(t=>Math.exp(t)),y4=Lo("Exp",g4,"float32"),H9={kernelName:"Exp",backendName:"cpu",kernelFunc:y4};var x4=vr(t=>Math.expm1(t)),_fe=Lo(tl,x4),W9={kernelName:tl,backendName:"cpu",kernelFunc:_fe};var v4=vr(t=>Math.floor(t)),Rfe=Lo(nl,v4),q9={kernelName:nl,backendName:"cpu",kernelFunc:Rfe};var b4=bt((t,n)=>Math.floor(t/n)),Mfe=_t(rl,b4,null,"int32"),K9={kernelName:rl,backendName:"cpu",kernelFunc:Mfe};function nC(t,n,e,r,o,s,i,a,l){let c=Be([r,s],e);for(let u=0;u<r;u++){let p=[],f=0;for(let d=0;d<o;d++){let h=t[u*o+d];f+=h*i[d],p.push(h)}if(f<0||f>=l/s)throw new Error(`Invalid indices: ${p} does not index into ${a}`);for(let d=0;d<s;d++)c.values[u*s+d]=n.get(...n.indexToLoc(f*s+d))}return c}function rC(t,n,e){let r=Be(e,t.dtype);for(let o=0;o<r.size;++o){let i=r.indexToLoc(o).slice(),a=i[0],l=i[2],c=n.locToIndex([a,l]);i[2]=n.values[c];let u=t.locToIndex(i);0<=u&&u<t.values.length&&(r.values[o]=t.values[u])}return r}var w4=bt((t,n)=>t>n?1:0),Ofe=_t(Rp,w4,null,"bool"),X9={kernelName:Rp,backendName:"cpu",kernelFunc:Ofe};var C4=bt((t,n)=>t>=n?1:0),Ffe=_t(ol,C4,null,"bool"),Y9={kernelName:ol,backendName:"cpu",kernelFunc:Ffe};var I4=bt((t,n)=>t<n?1:0),$fe=_t(Mp,I4,null,"bool"),Z9={kernelName:Mp,backendName:"cpu",kernelFunc:$fe};var S4=bt((t,n)=>t<=n?1:0),Lfe=_t(Op,S4,null,"bool"),Q9={kernelName:Op,backendName:"cpu",kernelFunc:Lfe};function oC(t,n,e){let r=(n-t)/(e-1),o=b.makeZerosTypedArray(e,"float32");o[0]=t;for(let s=1;s<o.length;s++)o[s]=o[s-1]+r;return o}var T4=vr(t=>Math.log(t)),Pfe=Lo("Log",T4),J9={kernelName:"Log",backendName:"cpu",kernelFunc:Pfe};function sC(t,n,e,r){let o=b.getTypedArrayFromDType(r,b.sizeFromShape(e));for(let s=0;s<o.length;++s){let i=s*n,a=t[i];for(let l=0;l<n;++l){let c=t[i+l];(Number.isNaN(c)||c>a)&&(a=c)}o[s]=a}return o}var E4=bt((t,n)=>Math.max(t,n)),Bfe=_t(cl,E4),eB={kernelName:cl,backendName:"cpu",kernelFunc:Bfe};var N4=bt((t,n)=>Math.min(t,n)),zfe=_t(ul,N4),tB={kernelName:ul,backendName:"cpu",kernelFunc:zfe};var rx=bt((t,n)=>t*n),Vfe=dg((t,n,e,r)=>({real:t*e-n*r,imag:t*r+n*e})),Tf=_t(pl,rx,Vfe),nB={kernelName:pl,backendName:"cpu",kernelFunc:Tf};function D4(t,n,e){let r=b.createScalarValue(-1,e);return rx([],n,r,t,e)}function Ufe(t){let{inputs:n,backend:e}=t,{x:r}=n;he(r,"neg");let o=e.data.get(r.dataId).values,[s,i]=D4(o,r.shape,r.dtype);return e.makeTensorInfo(i,r.dtype,s)}var rB={kernelName:"Neg",backendName:"cpu",kernelFunc:Ufe};var k4=bt((t,n)=>t!==n?1:0),Gfe=_t(Pp,k4,null,"bool"),oB={kernelName:Pp,backendName:"cpu",kernelFunc:Gfe};function mg(t,n,e,r,o){let s=n.length,i=b.sizeFromShape(n),a=b.computeStrides(n),l=b.computeStrides(o),c=b.getTypedArrayFromDType(e,b.sizeFromShape(o));for(let u=0;u<i;++u){let p=b.indexToLoc(u,s,a),f=new Array(p.length);for(let h=0;h<f.length;h++)f[h]=p[r[h]];let d=b.locToIndex(f,s,l);c[d]=t[u]}return c}function An(t){let{inputs:n,attrs:e,backend:r}=t,{x:o}=n,{perm:s}=e;he(o,"transpose");let i=o.shape.length,a=new Array(i);for(let p=0;p<a.length;p++)a[p]=o.shape[s[p]];let l=r.data.get(o.dataId).values,c=mg(l,o.shape,o.dtype,s,a);return{dataId:r.write(c,a,o.dtype),shape:a,dtype:o.dtype}}var sB={kernelName:Yi,backendName:"cpu",kernelFunc:An};function A4(t,n,e,r){let[o,s]=_.computeOutAndReduceShapes(t,r),i=Wn(n,"int32"),a=b.makeZerosTypedArray(b.sizeFromShape(o),i),l=b.sizeFromShape(s);for(let c=0;c<a.length;++c){let u=c*l,p=1;for(let f=0;f<l;++f)p*=e[u+f];a[c]=p}return{outVals:a,outShape:o,outDtype:i}}function jfe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,keepDims:i}=r;he(o,"prod");let a=o.shape.length,l=b.parseAxisParam(s,o.shape),c=_.getAxesPermutation(l,a),u=l,p=o,f=[];c!=null&&(p=An({inputs:{x:o},backend:e,attrs:{perm:c}}),f.push(p),u=_.getInnerMostAxes(u.length,a));let d=e.data.get(p.dataId).values,{outVals:h,outShape:g,outDtype:m}=A4(p.shape,p.dtype,d,u),y=g;return i&&(y=_.expandShapeToKeepDim(g,l)),f.forEach(x=>e.disposeIntermediateTensorInfo(x)),e.makeTensorInfo(y,m,h)}var iB={kernelName:Xc,backendName:"cpu",kernelFunc:jfe};function Hfe(t,n,e){t.forEach((r,o)=>{if(r<0||r>=e){let s=b.indexToLoc(o,n.length,b.computeStrides(n)).join(",");throw new Error(`indices[${s}] = ${r} is not in [0, ${e})`)}})}function Wfe(t,n){for(let e=0;e<t.length;++e){let r=t[e],o=e===t.length-1?n:t[e+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>o)throw new Error("Ragged splits must not point past values");for(let s=1;s<r.length;++s)if(r[s-1]>r[s])throw new Error("Ragged splits must be sorted in ascending order")}}function qfe(t,n,e,r){let o=[],s=0,i=n.length-1+e.length,a=new Array(i).fill(null).map(()=>[0]);Wfe(e,r);let l=1;for(let c=0;c<n.length-1;++c){l*=n[c];let u=n[c+1];for(let p=1;p<l+1;++p)a[c].push(p*u)}for(let c=0;c<t.length;++c){let u=t[c],p=t[c]+1;for(let f=0;f<e.length;++f){let d=e[f],h=f+n.length-1;if(h>=0){let g=a[h],m=g[g.length-1]-d[u];for(let y=u;y<p;++y)a[h].push(d[y+1]+m)}u=d[u],p=d[p]}p!==u&&(o.push([u,p]),s+=p-u)}return{outSplits:a,valueSlices:o,numValues:s}}function Kfe(t){let n=[];for(let e=0;e<t.length;++e){let r=t[e].length,o=b.getArrayFromDType("int32",r);n.push(o),t[e].forEach((s,i)=>o[i]=s)}return n}function aB(t,n){let e=t.slice(0,n);for(;e.length<n;)e.push(1);for(let r=n;r<t.length;r++)e[n-1]*=t[r];return e}function Xfe(t,n,e,r,o,s){let i=aB(n,2)[1],a=aB(s,2)[1],l=0;for(let c of e)for(let u=c[0];u<c[1];++u){for(let p=0;p<r;++p)o[l*a+p]=t[u*i+p];++l}}function Yfe(t,n,e,r,o){let s=n.slice();s[0]=o;let i=b.getArrayFromDType(e,b.sizeFromShape(s)),a=t.length,l=a===0?0:a/n[0];return Xfe(t,n,r,l,i,s),[i,s]}function iC(t,n,e,r,o,s,i,a){if(t.length===0)throw new Error("paramsNestedSplits must be non empty");if(n[0].length===0)throw new Error("Split tensors must not be scalars");let l=n[0][0]-1;if(Hfe(s,i,l),r.length===0)throw new Error("params.rank must be nonzero");let c=r[0],{outSplits:u,valueSlices:p,numValues:f}=qfe(s,i,t,c),d=Kfe(u),h=Yfe(e,r,o,p,f);return[d,h[0],h[1]]}var lB=2147483647;function aC(t,n,e,r,o,s,i){if(n.length>1)throw new Error("starts must be a scalar or vector");if(o.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");let a=n.length===0,l=o.length===0,c=i.length===0,u=[];a||u.push(n[0]),l||u.push(o[0]),c||u.push(i[0]);for(let m=1;m<u.length;++m)if(u[m]!==u[m-1])throw new Error("starts, limits, and deltas must have the same shape");let p=u.length===0?1:u[0],f=b.getArrayFromDType("int32",p+1);f[0]=0;for(let m=0;m<p;++m){let y=a?t[0]:t[m],x=l?r[0]:r[m],C=c?s[0]:s[m];if(C===0)throw new Error("Requires delta != 0");let I;if(C>0&&x<y||C<0&&x>y)I=0;else if(I=Math.ceil(Math.abs((x-y)/C)),I>lB)throw new Error(`Requires ((limit - start) / delta) <= ${lB}`);f[m+1]=f[m]+I}let d=f[p],h=b.getArrayFromDType(e,d),g=0;for(let m=0;m<p;++m){let y=f[m+1]-f[m],x=a?t[0]:t[m],C=c?s[0]:s[m];for(let I=0;I<y;++I)h[g++]=x,x+=C}return[f,h]}var Qs=_.RowPartitionType,_4=class t{constructor(n,e,r,o,s,i,a,l,c,u){this.shape=n,this.shapeShape=e,this.values=r,this.valuesShape=o,this.valuesDType=s,this.defaultValue=i,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=_.getRowPartitionTypesHelper(u),this.raggedRank=_.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(n){return this.rowPartitionTypes[0]===Qs.FIRST_DIM_SIZE?this.rowPartitionTypes[n+1]:this.rowPartitionTypes[n]}getRowPartitionTensor(n){return this.rowPartitionTypes[0]===Qs.FIRST_DIM_SIZE?this.rowPartitionValues[n+1]:this.rowPartitionValues[n]}getMaxWidth(n){let e=this.getRowPartitionTensor(n-1);switch(this.getRowPartitionTypeByDimension(n-1)){case Qs.VALUE_ROWIDS:return t.getMaxWidthValueRowID(e);case Qs.ROW_SPLITS:return t.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${Qs[this.getRowPartitionTypeByDimension(n-1)]}`)}}static getMaxWidthRowSplit(n){let e=n.length;if(e===0||e===1)return 0;let r=0;for(let o=0;o<e-1;++o){let s=n[o+1]-n[o];s>r&&(r=s)}return r}static getMaxWidthValueRowID(n){let e=n.length;if(e===0)return 0;let r=0,o=n[0],s=0;for(let i=1;i<e;++i){let a=n[i];a!==o&&(o=a,s=Math.max(i-r,s),r=i)}return Math.max(e-r,s)}tensorShapeFromTensor(n,e,r=!0){if(e.length===0){if(n[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return uB(n,r)}calculateOutputSize(n){let e=this.valuesShape,r=this.defaultValueShape;_.validateDefaultValueShape(r,e);let o=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=_.combineRaggedTensorToTensorShapes(this.raggedRank,o,e);i[0]<0&&(i[0]=n);for(let a=1;a<=this.raggedRank;++a)i[a]<0&&(i[a]=this.getMaxWidth(a));return i}calculateFirstParentOutputIndex(n,e,r){let o=Math.min(n,r),s=[],i=0;for(let a=0;a<o;++a,i+=e)s.push(i);for(let a=o;a<n;++a)s.push(-1);return b.assert(s.length===n,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(n,e,r,o){let s=n.length,i=[];for(let a=0;a<s-1;++a){let l=n[a+1]-n[a],c=Math.min(o,l),u=e[a];u===-1&&(c=0);for(let p=0;p<c;++p)i.push(u),u+=r;for(let p=0;p<l-c;++p)i.push(-1)}if(s>0&&i.length!==n[s-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(n,e,r,o){let s=n.length,i=[];if(s===0)return[];let a=0,l=n[0];if(l>=e.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${e.length}`);let c=e[l];i.push(c);for(let u=1;u<s;++u){let p=n[u];if(p===l)c>=0&&(++a,a<o?c+=r:c=-1);else{if(a=0,l=p,p>=e.length)throw new Error(`Got nextValueRowId=${p} which is not less than ${e.length}`);c=e[p]}i.push(c)}if(i.length!==n.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(n,e,r,o){let s=this.getRowPartitionTensor(n),i=this.getRowPartitionTypeByDimension(n);switch(i){case Qs.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,e,r,o);case Qs.ROW_SPLITS:if(s.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(s,e,r,o);default:throw new Error(`Unsupported partition type: ${Qs[i]}`)}}getFirstDimensionSize(){let n=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let e=this.rowPartitionTypes[0];switch(e){case Qs.FIRST_DIM_SIZE:return n[0];case Qs.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Qs.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Qs[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let e=this.getFirstDimensionSize(),r=this.calculateOutputSize(e),o=new Array(this.raggedRank+1);o[o.length-1]=1;for(let l=o.length-2;l>=0;--l)o[l]=o[l+1]*r[l+1];let s=uB(r,!1),i=b.getArrayFromDType(this.valuesDType,b.sizeFromShape(s));if(o[0]*r[0]>0){let l=this.calculateFirstParentOutputIndex(e,o[0],r[0]);for(let c=1;c<=this.raggedRank;++c)l=this.calculateOutputIndex(c-1,l,o[c],r[c]);this.setOutput(this.raggedRank,l,i,s)}return[s,i]}setOutput(n,e,r,o){if(r.length===0)return;let s=this.values,i=r,a=o.slice();a=a.slice(n+1);let l=b.sizeFromShape(a),c=e.length,u=this.defaultValue;if(u.length!==l&&u.length!==1){let h=this.defaultValueShape;X(()=>{let g=U(u,h);u=na(g,a).dataSync()})}let p=0,f=0,d=0;for(let h=0;h<=c;++h){let g=h<c?e[h]:-1;if(g===d){++d;continue}if(f<d){let m=s.subarray(p*l),y=i.subarray(f*l),x=(d-f)*l;cB(y,m,x)}if(h>=c){let m=r.length;g=Math.floor(m/l)}if(g>d)if(this.defaultValue.length===1)i.subarray(d*l,g*l).fill(this.defaultValue[0]),d=g;else for(;g>d;){let m=i.slice(d*l);cB(m,u,l),++d}g<0?(p=h+1,f=d):(p=h,f=d,d=f+1)}}};function cB(t,n,e){for(let r=0;r<e;r++)t[r]=n[r]}function uB(t,n){let e=[];for(let r of t){if(r<0){if(!n)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}e.push(r)}return e}function lC(t,n,e,r,o,s,i,a,l,c){return new _4(t,n,e,r,o,s,i,a,l,c).compute()}function cC(t,n,e,r){let o=t===n,s=t<n&&e<0,i=n<t&&e>1;if(o||s||i)return b.makeZerosTypedArray(0,r);let a=Math.abs(Math.ceil((n-t)/e)),l=b.makeZerosTypedArray(a,r);n<t&&e===1&&(e=-1),l[0]=t;for(let c=1;c<l.length;c++)l[c]=l[c-1]+e;return l}var R4=vr(t=>1/Math.sqrt(t)),Zfe=Lo(gl,R4),pB={kernelName:gl,backendName:"cpu",kernelFunc:Zfe};function Ei(t,n,e,r,o,s,i,a,l,c){let u=[r/o,o],p=t.values,f=n.values;if(r===0)return Be(e,n.dtype);let d=l instanceof $t?l:Be(u,n.dtype);typeof l=="string"||typeof l=="number"?d.values.fill(l):typeof l=="boolean"&&d.values.fill(+l);for(let h=0;h<s;h++){let g=[],m=0;for(let y=0;y<i;y++){let x=p[h*i+y];g.push(x),m+=x*a[y]}if(m<0||m>=r/o)throw new Error(`Invalid indices: ${g} does not index into ${e}`);for(let y=0;y<o;y++)c?d.values[m*o+y]+=f[h*o+y]:d.values[m*o+y]=n.rank===0?f[0]:f[h*o+y]}return d}var fB=vr(t=>1/(1+Math.exp(-t))),M4=Je(bl,t=>1/(1+Math.exp(-t))),dB={kernelName:bl,backendName:"cpu",kernelFunc:M4};function O4(t,n,e,r,o){let s=gr.isSliceContinous(r,n,e),i=b.sizeFromShape(e),a=b.computeStrides(r);if(s){let p=gr.computeFlatOffset(n,a);return o==="string"?t.slice(p,p+i):t.subarray(p,p+i)}let l=o==="string"?_.fromUint8ToStringArray(t):t,c=Be(r,o,l),u=Be(e,o);for(let p=0;p<u.size;++p){let f=u.indexToLoc(p),d=f.map((h,g)=>h+n[g]);u.set(c.get(...d),...f)}return o==="string"?_.fromStringArrayToUint8(u.values):u.values}function Js(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{begin:s,size:i}=r;he(o,"slice");let[a,l]=gr.parseSliceParams(o,s,i);gr.assertParamsValid(o,a,l);let c=e.data.get(o.dataId).values,u=O4(c,a,l,o.shape,o.dtype);return e.makeTensorInfo(l,o.dtype,u)}var hB={kernelName:tu,backendName:"cpu",kernelFunc:Js};function uC(t,n,e,r,o,s,i){let a=n[0],l=s[0],c=new Array(l),u=new Array(a),p=n[1];if(l===0){if(a!==0)throw new Error(_.getSparseFillEmptyRowsIndicesDenseShapeMismatch(a));let m=b.getArrayFromDType(e,0),y=b.getArrayFromDType(o,0);return[m,[0,p],y,c,u]}let f=!0,d=0,h=new Array(l).fill(0);for(let m=0;m<a;++m){let y=t[m*p];if(y<0)throw new Error(_.getSparseFillEmptyRowsNegativeIndexErrorMessage(m,y));if(y>=l)throw new Error(_.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(m,y,l));++h[y],f=f&&y>=d,d=y}let g=!0;for(let m=0;m<l;++m){let y=h[m]===0;c[m]=y,g=g&&!y,h[m]=Math.max(h[m],1),m>0&&(h[m]+=h[m-1])}if(g&&f){let m=t,y=r;for(let x=0;x<a;++x)u[x]=x;return[m,[a,p],y,c,u]}else{let m=h[l-1],y=b.getArrayFromDType(e,m*p),x=b.getArrayFromDType(o,m),C=new Array(l).fill(0);for(let I=0;I<a;++I){let D=t[I*p],O=C[D],L=(D===0?0:h[D-1])+O;C[D]++;for(let B=0;B<p;++B)y[L*p+B]=t[I*p+B];x[L]=r[I],u[I]=L}for(let I=0;I<l;++I)if(C[I]===0){let O=I===0?0:h[I-1];y[O*p+0]=I;for(let L=1;L<p;++L)y[O*p+L]=0;x[O]=i}return[y,[m,p],x,c,u]}}function pC(t,n,e,r,o){let s=b.sizeFromShape(r),i=n[0],a=o.length,l=[],c=1,u=-1;for(let m=0;m<a;++m){let y=o[m];if(y===-1){if(u!==-1)throw new Error(_.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(u,m));u=m,l.push(1)}else{if(y<0)throw new Error(_.getSparseReshapeNegativeOutputDimErrorMessage(m,y));c*=y,l.push(y)}}if(u!==-1){if(c<=0)throw new Error(_.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let m=Math.trunc(s/c);if(c*m!==s)throw new Error(_.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[u]=m}if(b.sizeFromShape(l)!==s)throw new Error(_.getSparseReshapeInputOutputMismatchErrorMessage(r,l));let f=r.length,d=[];if(f>0){d[f-1]=1;for(let m=f-2;m>=0;--m)d[m]=d[m+1]*r[m+1]}let h=[];if(a>0){h[a-1]=1;for(let m=a-2;m>=0;--m)h[m]=h[m+1]*l[m+1]}let g=b.getArrayFromDType(e,i*a);for(let m=0;m<i;++m){let y=0;for(let x=0;x<f;++x)y+=t[m*f+x]*d[x];for(let x=0;x<a;++x)g[m*a+x]=Math.trunc(y/h[x]),y%=h[x]}return[g,[i,a],l]}function gg(t,n,e,r,o,s=!1,i=0){let a=r.length,l=[n[0],t.length/n[0]],c=l[1],p=a>0?o[a-1]+1:0;if(p<0)throw new Error(_.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=n.slice();f[0]=p;let d=f.reduce((C,I)=>C*I,1),h=b.getArrayFromDType(e,d);if(a===0)return p>0&&h.fill(i),[h,f];if(p<=0)throw new Error(_.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let g=0,m=1,y=0,x=o[g];for(;;){let C=0;if(m<a){if(C=o[m],x===C){++m;continue}if(x>=C)throw new Error(_.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(x<0||x>=p)throw new Error(_.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(x,p));x>y&&h.fill(i,y*c,x*c);for(let I=g;I<m;++I){let D=r[I];if(D<0||D>=l[0])throw new Error(_.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(I,r[I],l[0]));for(let O=0;O<c;O++)h[x*c+O]+=t[D*c+O]}if(s)for(let I=0;I<c;I++)h[x*c+I]/=m-g;if(g=m,++m,y=x+1,x=C,m>a)break}return y<p&&h.fill(i,y*c,p*c),[h,f]}var mB=vr(t=>Math.sqrt(t)),Qfe=Je(Cl,t=>Math.sqrt(t)),gB={kernelName:Cl,backendName:"cpu",kernelFunc:Qfe};var F4=bt((t,n)=>{let e=t-n;return e*e}),Jfe=_t(Il,F4),yB={kernelName:Il,backendName:"cpu",kernelFunc:Jfe};var $4=vr((t,n)=>{let{pattern:e,replaceGlobal:r,rewrite:o}=n;return t.replace(new RegExp(e,r?"g":""),o)}),ede=Lo(Bp,$4),xB={kernelName:Bp,backendName:"cpu",kernelFunc:ede};function fC(t,n,e,r){let o=Be(t,n.dtype);for(let s=0;s<o.size;s++){let i=o.indexToLoc(s),a=new Array(i.length);for(let l=0;l<a.length;l++)a[l]=i[l]*e[l]+r[l];o.set(n.get(...a),...i)}return o}var L4=class{constructor(n,e,r,o,s,i){this.separator=b.encodeString(n),this.nGramWidths=e,this.leftPad=b.encodeString(r),this.rightPad=b.encodeString(o),this.padWidth=s,this.preserveShort=i}getPadWidth(n){return Math.min(this.padWidth<0?n-1:this.padWidth,n-1)}getNumNGrams(n,e){let r=this.getPadWidth(e);return Math.max(0,n+2*r-e+1)}createNGrams(n,e,r,o,s,i){for(let a=0;a<s;++a){let l=this.getPadWidth(i),c=Math.max(0,l-a),u=Math.max(0,l-(s-(a+1))),p=i-(c+u),f=e+(c>0?0:a-l),d=0;d+=c*this.leftPad.length;for(let x=0;x<p;++x)d+=n[f+x].length;d+=u*this.rightPad.length;let h=c+u+p-1;d+=h*this.separator.length,r[o+a]=new Uint8Array(d);let g=r[o+a],m=0,y=x=>x.forEach(C=>g[m++]=C);for(let x=0;x<c;++x)y(this.leftPad),y(this.separator);for(let x=0;x<p-1;++x)y(n[f+x]),y(this.separator);if(p>0){y(n[f+p-1]);for(let x=0;x<u;++x)y(this.separator),y(this.rightPad)}else{for(let x=0;x<u-1;++x)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(n,e){let r=n.length,o=e.length;if(o>0){let l=e[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<o;++c){let u=e[c]>=l;if(u=u&&e[c]<=r,!u)throw new Error(`Invalid split value ${e[c]}, must be in [${l}, ${r}]`);l=e[c]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}let s=o-1,i=b.getArrayFromDType("int32",o);if(r===0||o===0){let l=new Array(r);for(let c=0;c<=s;++c)i[c]=0;return[l,i]}i[0]=0;for(let l=1;l<=s;++l){let c=e[l]-e[l-1],u=0;this.nGramWidths.forEach(p=>{u+=this.getNumNGrams(c,p)}),this.preserveShort&&c>0&&u===0&&(u=1),i[l]=i[l-1]+u}let a=new Array(i[s]);for(let l=0;l<s;++l){let c=e[l],u=i[l];if(this.nGramWidths.forEach(p=>{let f=e[l+1]-e[l],d=this.getNumNGrams(f,p);this.createNGrams(n,c,a,u,d,p),u+=d}),this.preserveShort&&u===i[l]){let p=e[l+1]-e[l];if(p===0)continue;let f=p+2*this.padWidth;this.createNGrams(n,c,a,u,1,f)}}return[a,i]}};function dC(t,n,e,r,o,s,i,a){return new L4(e,r,o,s,i,a).compute(t,n)}function tde(t,n,e,r){if(!t.length)return;if(n.length===0){for(let s=0;s<t.length;++s)r.push(t.subarray(s,s+1));return}if(n.length===1){let s=n[0],i=t.indexOf(s);for(;i!==-1;){let a=t.subarray(0,i);(!e||a.length!==0)&&r.push(a),t=t.subarray(i+1),i=t.indexOf(s)}(!e||t.length!==0)&&r.push(t);return}let o=0;for(let s=0;s<t.length+1;s++)if(s===t.length||n.indexOf(t[s])!==-1){let i=t.subarray(o,s);(!e||i.length!==0)&&r.push(i),o=s+1}}function hC(t,n,e){let r=t.length,o=[],s=0,i=0,a=new Array(r);for(let f=0;f<r;++f){let d=o.length;tde(t[f],n,e,o);let h=o.length-d;a[f]=h,s+=h,i=Math.max(i,h)}let l=b.getArrayFromDType("int32",s*2),c=new Array(s),u=[r,i],p=0;for(let f=0;f<r;++f)for(let d=0;d<a[f];++d)l[p*2]=f,l[p*2+1]=d,c[p]=o[p],++p;return[l,c,u]}function mC(t,n){let e=b.getArrayFromDType("int32",t.length);for(let r=0;r<t.length;++r)e[r]=b.fingerPrint64(t[r]).modulo(n).getLowBitsUnsigned();return e}var P4=bt((t,n)=>t-n),nde=dg((t,n,e,r)=>({real:t-e,imag:n-r})),ox=_t("Sub",P4,nde),vB={kernelName:"Sub",backendName:"cpu",kernelFunc:ox};function gC(t,n){let e=new Array(t.rank);for(let o=0;o<e.length;o++)e[o]=t.shape[o]*n[o];let r=Be(e,t.dtype);for(let o=0;o<r.values.length;++o){let s=r.indexToLoc(o),i=new Array(t.rank);for(let l=0;l<i.length;l++)i[l]=s[l]%t.shape[l];let a=t.locToIndex(i);r.values[o]=t.values[a]}return r}var sx=(t,n)=>{let e=n.value-t.value;return e===0?t.index-n.index:e};function bB(t,n,e=0,r=t.length-1){for(;r>e;){if(r-e>600){let a=r-e+1,l=n-e+1,c=Math.log(a),u=.5*Math.exp(2*c/3),p=.5*Math.sqrt(c*u*(a-u)/a)*Math.sign(l-a/2),f=Math.max(e,Math.floor(n-l*u/a+p)),d=Math.min(r,Math.floor(n+(a-l)*u/a+p));bB(t,n,f,d)}let o=t[n],s=e,i=r;for(b.swap(t,e,n),sx(t[r],o)>0&&b.swap(t,e,r);s<i;){for(b.swap(t,s,i),s++,i--;sx(t[s],o)<0;)s=s+1;for(;sx(t[i],o)>0;)i=i-1}sx(t[e],o)===0?b.swap(t,e,i):(i=i+1,b.swap(t,i,r)),i<=n&&(e=i+1),n<=i&&(r=i-1)}}function yC(t,n,e,r,o){let s=n[n.length-1],[i,a]=[t.length/s,s],l=b.getTypedArrayFromDType(e,i*r),c=b.getTypedArrayFromDType("int32",i*r);for(let p=0;p<i;p++){let f=p*a,d=t.subarray(f,f+a),h=new Array(d.length);d.forEach((x,C)=>h[C]={value:x,index:C}),r<h.length&&(bB(h,r),h=h.slice(0,r)),o&&h.sort(sx);let g=p*r,m=l.subarray(g,g+r),y=c.subarray(g,g+r);for(let x=0;x<r;x++)m[x]=h[x].value,y[x]=h[x].index}let u=n.slice();return u[u.length-1]=r,[Be(u,e,l),Be(u,"int32",c)]}function xC(t,n,e,r){let o=b.parseAxisParam(n,e)[0],s=[1,e[0],1];for(let h=0;h<o;h++)s[0]*=e[h];s[1]=e[o];for(let h=o+1;h<e.length;h++)s[2]*=e[h];let i=new Map,a=new Int32Array(e[o]),l=new $t(s,r,t),c=[],u=s[0]===1&&s[2]===1;for(let h=0;h<e[o];h++){let g;if(u)g=t[h].toString();else{let y=[];for(let x=0;x<s[0];x++)for(let C=0;C<s[2];C++)y.push(l.get(x,h,C));g=y.join(",")}let m=i.get(g);if(m!=null)a[h]=m;else{let y=i.size;i.set(g,y),a[h]=y,c.push(h)}}let p=s.slice();p[1]=i.size;let f=new $t(p,r);c.forEach((h,g)=>{for(let m=0;m<s[0];m++)for(let y=0;y<s[2];y++)f.set(l.get(m,h,y),m,g,y)});let d=e.slice();return d[o]=p[1],{outputValues:f.values,outputShape:d,indices:a}}vv("cpu",()=>new F9,1);var z4=Je("Elu",t=>t>=0?t:Math.exp(t)-1),wB={kernelName:"Elu",backendName:"cpu",kernelFunc:z4};function V4(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{alpha:s}=r;he([o],"leakyRelu");let i=b.sizeFromShape(o.shape),a=e.data.get(o.dataId).values,l=b.getTypedArrayFromDType("float32",i);for(let c=0;c<a.length;c++)l[c]=a[c]<0?s*a[c]:a[c];return e.makeTensorInfo(o.shape,"float32",l)}var CB={kernelName:Bc,backendName:"cpu",kernelFunc:V4};var rde=bt((t,n)=>t<0?n*t:t);function U4(t){let{inputs:n,backend:e}=t,{x:r,alpha:o}=n;he([r,o],"prelu");let s=e.data.get(r.dataId).values,i=e.data.get(o.dataId).values,[a,l]=rde(r.shape,o.shape,s,i,"float32");return e.makeTensorInfo(l,"float32",a)}var IB={kernelName:Kc,backendName:"cpu",kernelFunc:U4};var G4=Je(dl,t=>Math.max(0,t)),SB={kernelName:dl,backendName:"cpu",kernelFunc:G4};var j4=Je(hl,t=>Math.min(Math.max(0,t),6)),TB={kernelName:hl,backendName:"cpu",kernelFunc:j4};function Ef(t,n,e,r,o){if(e==="linear")return Ur({inputs:{x:n},backend:t});if(e==="relu")return G4({inputs:{x:n},backend:t});if(e==="elu")return z4({inputs:{x:n},backend:t});if(e==="relu6")return j4({inputs:{x:n},backend:t});if(e==="prelu")return U4({inputs:{x:n,alpha:r},backend:t});if(e==="leakyrelu")return V4({inputs:{x:n},backend:t,attrs:{alpha:o}});if(e==="sigmoid")return M4({inputs:{x:n},backend:t});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function wt(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{shape:s}=r,i=b.sizeFromShape(o.shape),a=b.inferFromImplicitShape(s,i),l=b.sizeFromShape(a);b.assert(i===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${o.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),e.incRef(o.dataId);let c=e.data.get(o.dataId);if(c.complexTensorInfos!=null){let u=c.complexTensorInfos.real,p=c.complexTensorInfos.imag;u.shape=a,p.shape=a}return{dataId:o.dataId,shape:a,dtype:o.dtype}}var EB={kernelName:Yc,backendName:"cpu",kernelFunc:wt};function H4(t){let{inputs:n,backend:e,attrs:r}=t,{a:o,b:s}=n,{transposeA:i,transposeB:a}=r;he([o,s],"matMul");let l=o.shape.length,c=s.shape.length,u=i?o.shape[l-2]:o.shape[l-1],p=a?s.shape[c-1]:s.shape[c-2],f=i?o.shape[l-1]:o.shape[l-2],d=a?s.shape[c-2]:s.shape[c-1],h=o.shape.slice(0,-2),g=s.shape.slice(0,-2),m=b.sizeFromShape(h),y=b.sizeFromShape(g),C=Zo.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)).concat([f,d]);b.assert(u===p,()=>`Error in matMul: inner shapes (${u}) and (${p}) of Tensors with shapes ${o.shape} and ${s.shape} and transposeA=${i} and transposeB=${a} must match.`);let I=i?[m,u,f]:[m,f,u],D=a?[y,d,p]:[y,p,d],O=wt({inputs:{x:o},backend:e,attrs:{shape:I}}),L=wt({inputs:{x:s},backend:e,attrs:{shape:D}}),B=i?O.shape[1]:O.shape[2],V=i?O.shape[2]:O.shape[1],F=a?L.shape[1]:L.shape[2],G=Math.max(m,y),ee=e.data.get(O.dataId).values,Q=e.data.get(L.dataId).values,oe=b.computeStrides(O.shape),ae=b.computeStrides(L.shape),[J,re,se]=i?[oe[0],1,oe[1]]:[oe[0],oe[1],1],[pe,xe,be]=a?[1,ae[1],ae[0]]:[ae[1],1,ae[0]],Te=V*F,Se=Be([G,V,F],O.dtype),Re=Se.values,De=e.blockSize;for(let Oe=0;Oe<G;Oe++){let We=Oe%m,et=Oe%y;for(let je=0;je<V;je+=De){let tt=Math.min(je+De,V);for(let qe=0;qe<F;qe+=De){let Rt=Math.min(qe+De,F);for(let Bt=0;Bt<B;Bt+=De){let pn=Math.min(Bt+De,B);for(let Nt=je;Nt<tt;Nt++)for(let St=qe;St<Rt;St++){let Ht=0;for(let Dt=Bt;Dt<pn;Dt++){let or=ee[We*J+Nt*re+Dt*se],$n=Q[Dt*pe+St*xe+et*be];Ht+=or*$n}Re[Oe*Te+(Nt*F+St)]+=Ht}}}}}return e.disposeIntermediateTensorInfo(O),e.disposeIntermediateTensorInfo(L),e.makeTensorInfo(C,Se.dtype,Se.values)}var NB={kernelName:Ec,backendName:"cpu",kernelFunc:H4};function ode(t){let{inputs:n,backend:e,attrs:r}=t,{a:o,b:s,bias:i,preluActivationWeights:a}=n,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:p}=r,f,d,h,g=[];f=H4({inputs:{a:o,b:s},attrs:{transposeA:l,transposeB:c},backend:e}),i&&(d=pa({inputs:{a:f,b:i},backend:e}),g.push(f),f=d),u&&(h=Ef(e,f,u,a,p),g.push(f),f=h);for(let y of g)e.disposeIntermediateTensorInfo(y);return f}var DB={kernelName:zp,backendName:"cpu",kernelFunc:ode};var sde=Je(ja,t=>Math.acos(t)),kB={kernelName:ja,backendName:"cpu",kernelFunc:sde};var ide=Je(Ha,t=>Math.acosh(t)),AB={kernelName:Ha,backendName:"cpu",kernelFunc:ide};function ade(t){let{inputs:n,backend:e}=t,r=n;he(n,"addN");let o=r.map(a=>e.data.get(a.dataId).values),s=Be(r[0].shape,r[0].dtype),i=s.values;for(let a=0;a<r.length;a++){let l=o[a];for(let c=0;c<i.length;c++)i[c]+=l[c]}return e.makeTensorInfo(s.shape,s.dtype,s.values)}var _B={kernelName:wc,backendName:"cpu",kernelFunc:ade};function lde(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,keepDims:i}=r;he(o,"all");let a=b.parseAxisParam(s,o.shape),l=a,c=_.getAxesPermutation(l,o.shape.length),u=o;c!=null&&(u=An({inputs:{x:o},backend:e,attrs:{perm:c}}),l=_.getInnerMostAxes(l.length,o.shape.length)),_.assertAxesAreInnerMostDims("all",l,u.shape.length);let[p,f]=_.computeOutAndReduceShapes(u.shape,l),d=b.sizeFromShape(f),h=b.makeZerosTypedArray(b.sizeFromShape(p),u.dtype),g=e.data.get(u.dataId).values;for(let y=0;y<h.length;++y){let x=y*d,C=g[x];for(let I=0;I<d;++I){let D=g[x+I];C=C&&D}h[y]=C}c!=null&&e.disposeIntermediateTensorInfo(u);let m=e.makeTensorInfo(p,u.dtype,h);if(i){let y=_.expandShapeToKeepDim(p,a),x=wt({inputs:{x:m},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(m),x}return m}var RB={kernelName:"All",backendName:"cpu",kernelFunc:lde};function cde(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,keepDims:i}=r;he(o,"any");let a=b.parseAxisParam(s,o.shape),l=a,c=_.getAxesPermutation(l,o.shape.length),u=o;c!=null&&(u=An({inputs:{x:o},backend:e,attrs:{perm:c}}),l=_.getInnerMostAxes(l.length,o.shape.length)),_.assertAxesAreInnerMostDims("any",l,u.shape.length);let[p,f]=_.computeOutAndReduceShapes(u.shape,l),d=b.sizeFromShape(f),h=b.makeZerosTypedArray(b.sizeFromShape(p),u.dtype),g=e.data.get(u.dataId).values;for(let y=0;y<h.length;++y){let x=y*d,C=g[x];for(let I=0;I<d;++I){let D=g[x+I];C=C||D}h[y]=C}c!=null&&e.disposeIntermediateTensorInfo(u);let m=e.makeTensorInfo(p,u.dtype,h);if(i){let y=_.expandShapeToKeepDim(p,a),x=wt({inputs:{x:m},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(m),x}return m}var MB={kernelName:"Any",backendName:"cpu",kernelFunc:cde};function ude(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s}=r;he(o,"argMax");let i=b.parseAxisParam(s,o.shape),a=_.getAxesPermutation(i,o.shape.length),l=o,c=[];a!=null&&(l=An({inputs:{x:o},backend:e,attrs:{perm:a}}),c.push(l),i=_.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],_.assertAxesAreInnerMostDims("argMax",i,l.shape.length);let[u,p]=_.computeOutAndReduceShapes(l.shape,i),f=b.sizeFromShape(u),d=b.makeZerosTypedArray(f,"int32"),h=b.sizeFromShape(p),g=e.data.get(l.dataId).values;for(let m=0;m<d.length;++m){let y=m*h,x=g[y],C=0;for(let I=0;I<h;++I){let D=g[y+I];D>x&&(x=D,C=I)}d[m]=C}return c.forEach(m=>e.disposeIntermediateTensorInfo(m)),e.makeTensorInfo(u,"int32",d)}var OB={kernelName:Cc,backendName:"cpu",kernelFunc:ude};function pde(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s}=r;he(o,"argMin");let i=b.parseAxisParam(s,o.shape),a=_.getAxesPermutation(i,o.shape.length),l=o,c=[];a!=null&&(l=An({inputs:{x:o},backend:e,attrs:{perm:a}}),c.push(l),i=_.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],_.assertAxesAreInnerMostDims("argMin",i,l.shape.length);let[u,p]=_.computeOutAndReduceShapes(l.shape,i),f=b.sizeFromShape(u),d=b.makeZerosTypedArray(f,"int32"),h=b.sizeFromShape(p),g=e.data.get(l.dataId).values;for(let m=0;m<d.length;++m){let y=m*h,x=g[y],C=0;for(let I=0;I<h;++I){let D=g[y+I];D<x&&(x=D,C=I)}d[m]=C}return c.forEach(m=>e.disposeIntermediateTensorInfo(m)),e.makeTensorInfo(u,"int32",d)}var FB={kernelName:Ic,backendName:"cpu",kernelFunc:pde};var fde=Je(Wa,t=>Math.asin(t)),$B={kernelName:Wa,backendName:"cpu",kernelFunc:fde};var dde=Je(qa,t=>Math.asinh(t)),LB={kernelName:qa,backendName:"cpu",kernelFunc:dde};var hde=Je(Ka,t=>Math.atan(t)),PB={kernelName:Ka,backendName:"cpu",kernelFunc:hde};var mde=bt((t,n)=>Math.atan2(t,n)),gde=_t(Ya,mde),BB={kernelName:Ya,backendName:"cpu",kernelFunc:gde};var yde=Je(Xa,t=>Math.atanh(t)),zB={kernelName:Xa,backendName:"cpu",kernelFunc:yde};function yg(t,n,e,r,o,s){let i=o.strideHeight,a=o.strideWidth,l=o.dilationHeight,c=o.dilationWidth,u=o.effectiveFilterHeight,p=o.effectiveFilterWidth,f=o.padInfo.top,d=o.padInfo.left,h=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=Be(o.outShape,e),m=g.values,y=o.outShape[1]*o.outShape[2]*o.outShape[3],x=o.outShape[2]*o.outShape[3],C=o.outShape[3];for(let I=0;I<o.batchSize;++I){let D=I*y,O=I*r[0];for(let L=0;L<o.inChannels;++L)for(let B=0;B<o.outHeight;++B){let V=B*i-f,F=Math.max(0,V),G=Math.min(o.inHeight,u+V),ee=D+B*x;for(let Q=0;Q<o.outWidth;++Q){let oe=Q*a-d,ae=Math.max(0,oe),J=Math.min(o.inWidth,p+oe),re=h,se=0,pe=0;for(let be=F;be<G;be+=l){let Te=O+be*r[1];for(let Se=ae;Se<J;Se+=c){let Re=Te+Se*r[2],De=t[Re+L];s==="max"&&De>re?re=De:s==="avg"&&(se+=De,pe++)}if(isNaN(re))break}let xe=ee+Q*C+L;m[xe]=s==="avg"?se/pe:re}}}return g}function vC(t,n,e,r,o=!1,s=!1){let i=Be(r.outShape,"int32"),a=r.strideHeight,l=r.strideWidth,c=r.dilationHeight,u=r.dilationWidth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,d=r.padInfo.top,h=r.padInfo.left,g=Be(n,e,t);for(let m=0;m<r.batchSize;++m)for(let y=0;y<r.inChannels;++y)for(let x=0;x<r.outHeight;++x){let C=x*a-d,I=C;for(;I<0;)I+=c;let D=Math.min(r.inHeight,p+C);for(let O=0;O<r.outWidth;++O){let L=O*l-h,B=L;for(;B<0;)B+=u;let V=Math.min(r.inWidth,f+L),F=Number.NEGATIVE_INFINITY,G=-1;for(let ee=I;ee<D;ee+=c){let Q=ee-C;for(let oe=B;oe<V;oe+=u){let ae=oe-L,J=g.get(m,ee,oe,y);J>F&&(F=J,o?G=s?((m*r.inHeight+ee)*r.inWidth+oe)*r.inChannels+y:(ee*r.inWidth+oe)*r.inChannels+y:G=Q*f+ae)}}i.set(G,m,x,O,y)}}return i}function bC(t,n,e,r,o,s){let i=o.strideDepth,a=o.strideHeight,l=o.strideWidth,c=o.dilationDepth,u=o.dilationHeight,p=o.dilationWidth,f=o.effectiveFilterDepth,d=o.effectiveFilterHeight,h=o.effectiveFilterWidth,g=o.padInfo.front,m=o.padInfo.top,y=o.padInfo.left,x=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,C=Be(o.outShape,e),I=C.values,D=o.outShape[1]*o.outShape[2]*o.outShape[3]*o.outShape[4],O=o.outShape[2]*o.outShape[3]*o.outShape[4],L=o.outShape[3]*o.outShape[4],B=o.outShape[4];for(let V=0;V<o.batchSize;++V){let F=V*D,G=V*r[0];for(let ee=0;ee<o.inChannels;++ee)for(let Q=0;Q<o.outDepth;++Q){let oe=Q*i-g,ae=oe;for(;ae<0;)ae+=c;let J=Math.min(o.inDepth,f+oe),re=F+Q*O;for(let se=0;se<o.outHeight;++se){let pe=se*a-m,xe=pe;for(;xe<0;)xe+=u;let be=Math.min(o.inHeight,d+pe),Te=re+se*L;for(let Se=0;Se<o.outWidth;++Se){let Re=Se*l-y,De=Re;for(;De<0;)De+=p;let Oe=Math.min(o.inWidth,h+Re),We=Te+Se*B,et=x,je=0,tt=0;for(let Rt=ae;Rt<J;Rt+=c){let Bt=G+Rt*r[1];for(let pn=xe;pn<be;pn+=u){let Nt=Bt+pn*r[2];for(let St=De;St<Oe;St+=p){let Ht=Nt+St*r[3],Dt=t[Ht+ee];if(s==="max"&&Dt>et?et=Dt:s==="avg"&&(je+=Dt,tt++),isNaN(et))break}if(isNaN(et))break}if(isNaN(et))break}let qe=We+ee;I[qe]=s==="avg"?je/Math.max(tt,1):et}}}}return C}function VB(t,n){let e=Be(n.outShape,"int32"),r=n.strideDepth,o=n.strideHeight,s=n.strideWidth,i=n.dilationDepth,a=n.dilationHeight,l=n.dilationWidth,c=n.effectiveFilterDepth,u=n.effectiveFilterHeight,p=n.effectiveFilterWidth,f=n.padInfo.front,d=n.padInfo.top,h=n.padInfo.left;for(let g=0;g<n.batchSize;++g)for(let m=0;m<n.inChannels;++m)for(let y=0;y<n.outDepth;++y){let x=y*r-f,C=x;for(;C<0;)C+=i;let I=Math.min(n.inDepth,c+x);for(let D=0;D<n.outHeight;++D){let O=D*o-d,L=O;for(;L<0;)L+=a;let B=Math.min(n.inHeight,u+O);for(let V=0;V<n.outWidth;++V){let F=V*s-h,G=F;for(;G<0;)G+=l;let ee=Math.min(n.inWidth,p+F),Q=Number.NEGATIVE_INFINITY,oe=-1;for(let ae=C;ae<I;ae+=i){let J=ae-x;for(let re=L;re<B;re+=a){let se=re-O;for(let pe=G;pe<ee;pe+=l){let xe=pe-F,be=t.get(g,ae,re,pe,m);be>=Q&&(Q=be,oe=J*u*p+se*u+xe)}}}e.set(oe,g,y,D,V,m)}}}return e}function xde(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n;he(o,"avgPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:l}=r,c=1;b.assert(_.eitherStridesOrDilationsAreOne(i,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let u=_.computePool2DInfo(o.shape,s,i,c,a,l),p;if(u.filterWidth===1&&u.filterHeight===1&&b.arraysEqual(u.inShape,u.outShape))p=Ur({inputs:{x:o},backend:e});else{let f=e.data.get(o.dataId).values,d=b.computeStrides(o.shape),h=yg(f,o.shape,o.dtype,d,u,"avg");p=e.makeTensorInfo(u.outShape,o.dtype,h.values)}return p}var UB={kernelName:Sc,backendName:"cpu",kernelFunc:xde};function vde(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{filterSize:s,strides:i,pad:a,dimRoundingMode:l,dataFormat:c}=r;he(o,"avgPool3d");let u=_.computePool3DInfo(o.shape,s,i,1,a,l,c),p=e.data.get(o.dataId).values,f=bC(p,o.shape,o.dtype,b.computeStrides(o.shape),u,"avg");return e.makeTensorInfo(f.shape,"float32",f.values)}var GB={kernelName:Tc,backendName:"cpu",kernelFunc:vde};function bde(t){let{inputs:n,backend:e,attrs:r}=t,{dy:o,input:s}=n,{filterSize:i,strides:a,pad:l,dimRoundingMode:c}=r;he([o,s],"avgPool3DGrad");let u=_.computePool3DInfo(s.shape,i,a,1,l,c),p=u.strideDepth,f=u.strideHeight,d=u.strideWidth,h=u.filterDepth,g=u.filterHeight,m=u.filterWidth,y=u.dilationDepth,x=u.dilationHeight,C=u.dilationWidth,I=u.effectiveFilterDepth,D=u.effectiveFilterHeight,O=u.effectiveFilterWidth,L=I-1-u.padInfo.front,B=O-1-u.padInfo.left,V=D-1-u.padInfo.top,F=Be(s.shape,"float32"),G=1/(h*g*m),ee=e.bufferSync(o);for(let Q=0;Q<u.batchSize;++Q)for(let oe=0;oe<u.inChannels;++oe)for(let ae=0;ae<u.inDepth;++ae)for(let J=0;J<u.inHeight;++J)for(let re=0;re<u.inWidth;++re){let se=ae-L,pe=J-V,xe=re-B,be=0;for(let Te=0;Te<I;Te+=y){let Se=(se+Te)/p;if(!(Se<0||Se>=u.outDepth||Math.floor(Se)!==Se))for(let Re=0;Re<D;Re+=x){let De=(pe+Re)/f;if(!(De<0||De>=u.outHeight||Math.floor(De)!==De))for(let Oe=0;Oe<O;Oe+=C){let We=(xe+Oe)/d;if(We<0||We>=u.outWidth||Math.floor(We)!==We)continue;let et=ee.get(Q,Se,De,We,oe);be+=et}}}F.set(be*G,Q,ae,J,re,oe)}return e.makeTensorInfo(F.shape,F.dtype,F.values)}var jB={kernelName:Jd,backendName:"cpu",kernelFunc:bde};function wde(t){let{inputs:n,backend:e,attrs:r}=t,{dy:o,input:s}=n,i=s;he([o,s],"avgPoolGrad");let{filterSize:a,strides:l,pad:c}=r,u=_.computePool2DInfo(i.shape,a,l,1,c),p=u.strideHeight,f=u.strideWidth,d=u.filterHeight,h=u.filterWidth,g=u.dilationHeight,m=u.dilationWidth,y=u.effectiveFilterHeight,x=u.effectiveFilterWidth,C=x-1-u.padInfo.left,I=y-1-u.padInfo.top,D=Be(i.shape,"float32"),O=1/(d*h),L=e.data.get(o.dataId).values,B=Be(o.shape,"float32",L);for(let V=0;V<u.batchSize;++V)for(let F=0;F<u.inChannels;++F)for(let G=0;G<u.inHeight;++G)for(let ee=0;ee<u.inWidth;++ee){let Q=G-I,oe=ee-C,ae=0;for(let J=0;J<y;J+=g){let re=(Q+J)/p;if(!(re<0||re>=u.outHeight||Math.floor(re)!==re))for(let se=0;se<x;se+=m){let pe=(oe+se)/f;if(pe<0||pe>=u.outWidth||Math.floor(pe)!==pe)continue;let xe=B.get(V,re,pe,F);ae+=xe}}D.set(ae*O,V,G,ee,F)}return e.makeTensorInfo(D.shape,D.dtype,D.values)}var HB={kernelName:Qd,backendName:"cpu",kernelFunc:wde};function Cde(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,scale:s,offset:i,mean:a,variance:l}=n;b.assert(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),b.assert(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),b.assert(s==null||a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),he([o,a,l,s,i],"batchNorm");let{varianceEpsilon:c}=r;c==null&&(c=.001);let u=e.data.get(o.dataId).values,p=e.data.get(a.dataId).values,f=e.data.get(l.dataId).values,d=s?e.data.get(s.dataId).values:new Float32Array([1]),h=i?e.data.get(i.dataId).values:new Float32Array([0]),g=new Float32Array(u.length),m=h.length,y=d.length,x=f.length,C=p.length,I=0,D=0,O=0,L=0;for(let B=0;B<u.length;++B)g[B]=h[I++]+(u[B]-p[D++])*d[O++]/Math.sqrt(f[L++]+c),I>=m&&(I=0),D>=C&&(D=0),O>=y&&(O=0),L>=x&&(L=0);return e.makeTensorInfo(o.shape,o.dtype,g)}var WB={kernelName:Lc,backendName:"cpu",kernelFunc:Cde};function Ide(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{blockShape:s,crops:i}=r;he([o],"batchToSpaceND");let a=s.reduce((y,x)=>y*x),l=_.getReshaped(o.shape,s,a),c=_.getPermuted(l.length,s.length),u=_.getReshapedPermuted(o.shape,s,a),p=_.getSliceBeginCoords(i,s.length),f=_.getSliceSize(u,i,s.length),d=wt({inputs:{x:o},backend:e,attrs:{shape:l}}),h=An({inputs:{x:d},backend:e,attrs:{perm:c}}),g=wt({inputs:{x:h},backend:e,attrs:{shape:u}}),m=Js({inputs:{x:g},backend:e,attrs:{begin:p,size:f}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(g),m}var qB={kernelName:Nc,backendName:"cpu",kernelFunc:Ide};function Sde(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,weights:s}=n,{size:i}=r,a=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,c=hg(a,l,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,c)}var KB={kernelName:eh,backendName:"cpu",kernelFunc:Sde};function Tde(t){let{inputs:n,backend:e}=t,{s0:r,s1:o}=n,s=e.data.get(r.dataId).values,i=e.data.get(o.dataId).values,a=_.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}var XB={kernelName:th,backendName:"cpu",kernelFunc:Tde};var Ede=Je(Qa,(t,n)=>{let e=n;return t>e.clipValueMax?e.clipValueMax:t<e.clipValueMin?e.clipValueMin:t}),YB={kernelName:Qa,backendName:"cpu",kernelFunc:Ede};var Nde=t=>{let{x:n}=t.inputs,e=t.backend,r=new Float32Array(b.sizeFromShape(n.shape)),o=e.data.get(n.dataId),s=o.complexTensorInfos.real,i=o.complexTensorInfos.imag,a=e.data.get(s.dataId).values,l=e.data.get(i.dataId).values;for(let c=0;c<a.length;c++){let u=a[c],p=l[c];r[c]=Math.hypot(u,p)}return e.makeOutput(r,n.shape,"float32")},ZB={kernelName:Dc,backendName:"cpu",kernelFunc:Nde};function fa(t){let{inputs:n,backend:e}=t,{input:r}=n,o=e.data.get(r.dataId).complexTensorInfos.imag,s=e.data.get(o.dataId).values;return e.makeTensorInfo(o.shape,o.dtype,s)}var QB={kernelName:vh,backendName:"cpu",kernelFunc:fa};function Pu(t){let{inputs:n,backend:e,attrs:r}=t,{axis:o}=r,s=b.parseAxisParam(o,n[0].shape)[0],i=n.map(g=>g.shape);_.assertParamsConsistent(i,s);let a=_.computeOutShape(n.map(g=>g.shape),s);if(b.sizeFromShape(a)===0)return e.makeTensorInfo(a,n[0].dtype,[]);let l=n.filter(g=>b.sizeFromShape(g.shape)>0);if(l.length===1)return Ur({inputs:{x:l[0]},backend:e});if(l[0].dtype==="complex64"){let g=l.map(I=>Ys({inputs:{input:I},backend:e})),m=l.map(I=>fa({inputs:{input:I},backend:e})),y=Pu({inputs:g,backend:e,attrs:{axis:s}}),x=Pu({inputs:m,backend:e,attrs:{axis:s}}),C=ur({inputs:{real:y,imag:x},backend:e});return g.forEach(I=>e.disposeIntermediateTensorInfo(I)),m.forEach(I=>e.disposeIntermediateTensorInfo(I)),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(x),C}let c=l.map(g=>{let y=[-1,b.sizeFromShape(g.shape.slice(s))];return wt({inputs:{x:g},backend:e,attrs:{shape:y}})}),u=c.map(g=>({vals:e.data.get(g.dataId).values,shape:g.shape}));a=_.computeOutShape(c.map(g=>g.shape),1);let p=c[0].shape[0]===1,f=tC(u,a,n[0].dtype,p),d=_.computeOutShape(l.map(g=>g.shape),s),h=e.makeTensorInfo(d,n[0].dtype,f);return c.forEach(g=>e.disposeIntermediateTensorInfo(g)),h}var JB={kernelName:kc,backendName:"cpu",kernelFunc:Pu};function W4(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,filter:s}=n,{strides:i,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=r;he([o,s],"conv2d");let p=_.convertConv2DDataFormat(l),f=_.computeConv2DInfo(o.shape,s.shape,i,c,a,u,!1,p),d=f.filterHeight,h=f.filterWidth,g=f.dilationHeight,m=f.dilationWidth,y=f.padInfo.left,x=f.padInfo.top,C=f.dataFormat==="channelsLast",I=new $t(f.outShape,o.dtype),D=b.computeStrides(o.shape),O=b.computeStrides(s.shape),L=D[0],B=C?D[1]:D[2],V=C?D[2]:1,F=C?1:D[1],G=I.strides[0],ee=C?I.strides[1]:I.strides[2],Q=C?I.strides[2]:1,oe=C?1:I.strides[1],ae=e.data.get(o.dataId).values,J=e.data.get(s.dataId).values,re=I.values;for(let se=0;se<f.batchSize;++se){let pe=se*L,xe=se*G;for(let be=0;be<f.outHeight;++be){let Te=xe+be*ee,Se=be*f.strideHeight-x;for(let Re=0;Re<d;++Re){let De=Se+Re*g;if(De<0||De>=f.inHeight)continue;let Oe=Re*O[0],We=pe+De*B;for(let et=0;et<f.outWidth;++et){let je=Te+et*Q,tt=et*f.strideWidth-y;for(let qe=0;qe<h;++qe){let Rt=tt+qe*m;if(Rt<0||Rt>=f.inWidth)continue;let Bt=Oe+qe*O[1],pn=We+Rt*V,Nt=Bt;for(let St=0;St<f.inChannels;++St){let Ht=ae[pn+St*F];for(let Dt=0;Dt<f.outChannels;++Dt)re[je+Dt*oe]+=Ht*J[Nt+Dt];Nt+=f.outChannels}}}}}}return e.makeTensorInfo(I.shape,I.dtype,re)}var ez={kernelName:Ac,backendName:"cpu",kernelFunc:W4};function Dde(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,dy:s}=n,{strides:i,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=r;he([o,s],"conv2dBackpropFilter");let p=_.convertConv2DDataFormat(l),f=_.computeConv2DInfo(o.shape,u,i,1,a,c,!1,p),{strideHeight:d,strideWidth:h,filterHeight:g,filterWidth:m}=f,y=f.dataFormat==="channelsLast",x=new $t(f.filterShape,"float32"),C=f.padInfo.left,I=f.padInfo.top,D=e.data.get(o.dataId).values,O=e.data.get(s.dataId).values,L=new $t(o.shape,o.dtype,D),B=new $t(s.shape,s.dtype,O);for(let V=0;V<g;++V){let F=Math.max(0,Math.ceil((I-V)/d)),G=Math.min(f.outHeight,(f.inHeight+I-V)/d);for(let ee=0;ee<m;++ee){let Q=Math.max(0,Math.ceil((C-ee)/h)),oe=Math.min(f.outWidth,(f.inWidth+C-ee)/h);for(let ae=0;ae<f.inChannels;++ae)for(let J=0;J<f.outChannels;++J){let re=0;for(let se=0;se<f.batchSize;++se)for(let pe=F;pe<G;++pe){let xe=V+pe*d-I;for(let be=Q;be<oe;++be){let Te=ee+be*h-C;y?re+=L.get(se,xe,Te,ae)*B.get(se,pe,be,J):re+=L.get(se,ae,xe,Te)*B.get(se,J,pe,be)}}x.set(re,V,ee,ae,J)}}}return e.makeTensorInfo(x.shape,x.dtype,x.values)}var tz={kernelName:rh,backendName:"cpu",kernelFunc:Dde};function kde(t){let{inputs:n,backend:e,attrs:r}=t,{dy:o,filter:s}=n,{inputShape:i,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=r;he([o,s],"conv2dBackpropInput");let p=b.computeStrides(s.shape),f=b.computeStrides(o.shape),d=_.convertConv2DDataFormat(c),h=_.computeConv2DInfo(i,s.shape,a,1,l,u,!1,d),g=new $t(h.inShape,"float32"),m=g.values,y=e.data.get(o.dataId).values,x=e.data.get(s.dataId).values,[C,I,D]=p,{batchSize:O,filterHeight:L,filterWidth:B,inChannels:V,inHeight:F,inWidth:G,outChannels:ee,outHeight:Q,outWidth:oe,strideHeight:ae,strideWidth:J}=h;d=h.dataFormat;let re=L-1-h.padInfo.top,se=B-1-h.padInfo.left,pe=d==="channelsLast",xe=g.strides[0],be=pe?g.strides[1]:g.strides[2],Te=pe?g.strides[2]:1,Se=pe?1:g.strides[1],Re=f[0],De=pe?f[1]:f[2],Oe=pe?f[2]:1,We=pe?1:f[1];for(let et=0;et<O;++et)for(let je=0;je<V;++je)for(let tt=0;tt<F;++tt){let qe=tt-re,Rt=Math.max(0,Math.ceil(qe/ae)),Bt=Math.min(Q,(L+qe)/ae);for(let pn=0;pn<G;++pn){let Nt=pn-se,St=Math.max(0,Math.ceil(Nt/J)),Ht=Math.min(oe,(B+Nt)/J),Dt=0;for(let $n=Rt;$n<Bt;++$n){let yn=$n*ae-qe;for(let sr=St;sr<Ht;++sr){let cs=sr*J-Nt,jr=Re*et+De*$n+Oe*sr,br=C*(L-1-yn)+I*(B-1-cs)+D*je;for(let ir=0;ir<ee;++ir){let oo=y[jr+We*ir],Hn=x[br+ir];Dt+=oo*Hn}}}let or=xe*et+be*tt+Te*pn+Se*je;m[or]=Dt}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}var nz={kernelName:_c,backendName:"cpu",kernelFunc:kde};function Ade(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,filter:s}=n,{strides:i,pad:a,dilations:l}=r;he([o,s],"conv3d");let c=_.computeConv3DInfo(o.shape,s.shape,i,l,a),{filterDepth:u,filterHeight:p,filterWidth:f,dilationDepth:d,dilationHeight:h,dilationWidth:g,padInfo:m}=c,y=m.front,x=m.left,C=m.top,I=new $t(c.outShape,o.dtype),D=e.data.get(o.dataId).values,O=e.data.get(s.dataId).values,L=I.values,B=b.computeStrides(o.shape),V=b.computeStrides(s.shape);for(let F=0;F<c.batchSize;++F){let G=F*B[0],ee=F*I.strides[0];for(let Q=0;Q<c.outDepth;++Q){let oe=ee+Q*I.strides[1],ae=Q*c.strideDepth-y;for(let J=0;J<u;++J){let re=ae+J*d;if(re<0||re>=c.inDepth)continue;let se=J*V[0],pe=G+re*B[1];for(let xe=0;xe<c.outHeight;++xe){let be=oe+xe*I.strides[2],Te=xe*c.strideHeight-C;for(let Se=0;Se<p;++Se){let Re=Te+Se*h;if(Re<0||Re>=c.inHeight)continue;let De=se+Se*V[1],Oe=pe+Re*B[2];for(let We=0;We<c.outWidth;++We){let et=be+We*c.outChannels,je=We*c.strideWidth-x;for(let tt=0;tt<f;++tt){let qe=je+tt*g;if(qe<0||qe>=c.inWidth)continue;let Rt=De+tt*V[2],Bt=Oe+qe*c.inChannels,pn=Rt;for(let Nt=0;Nt<c.inChannels;++Nt){let St=D[Bt+Nt];for(let Ht=0;Ht<c.outChannels;++Ht)L[et+Ht]+=St*O[pn+Ht];pn+=c.outChannels}}}}}}}}return e.makeTensorInfo(I.shape,I.dtype,I.values)}var rz={kernelName:Rc,backendName:"cpu",kernelFunc:Ade};function _de(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,dy:s}=n,{strides:i,pad:a,filterShape:l}=r;he([o,s],"conv3dBackpropFilterV2");let c=b.computeStrides(o.shape),u=b.computeStrides(s.shape),p=_.computeConv3DInfo(o.shape,l,i,1,a),f=p.strideDepth,d=p.strideHeight,h=p.strideWidth,g=p.filterDepth,m=p.filterHeight,y=p.filterWidth,x=new $t(p.filterShape,"float32"),C=x.values,[I,D,O,L]=x.strides,B=e.data.get(s.dataId).values,[V,F,G,ee]=u,Q=e.data.get(o.dataId).values,[oe,ae,J,re]=c,se=p.padInfo.front,pe=p.padInfo.left,xe=p.padInfo.top;for(let be=0;be<g;++be){let Te=Math.max(0,Math.ceil((se-be)/f)),Se=Math.min(p.outDepth,(p.inDepth+se-be)/f),Re=be*I;for(let De=0;De<m;++De){let Oe=Math.max(0,Math.ceil((xe-De)/d)),We=Math.min(p.outHeight,(p.inHeight+xe-De)/d),et=De*D+Re;for(let je=0;je<y;++je){let tt=Math.max(0,Math.ceil((pe-je)/h)),qe=Math.min(p.outWidth,(p.inWidth+pe-je)/h),Rt=je*O+et;for(let Bt=0;Bt<p.inChannels;++Bt){let pn=Bt*L+Rt;for(let Nt=0;Nt<p.outChannels;++Nt){let St=0;for(let Ht=0;Ht<p.batchSize;++Ht){let Dt=Ht*oe,or=Ht*V;for(let $n=Te;$n<Se;++$n){let sr=(be+$n*f-se)*ae+Dt,cs=$n*F+or;for(let jr=Oe;jr<We;++jr){let ir=(De+jr*d-xe)*J+sr,oo=jr*G+cs;for(let Hn=tt;Hn<qe;++Hn){let ga=(je+Hn*h-pe)*re+ir,ya=Hn*ee+oo;St+=Q[ga+Bt]*B[ya+Nt]}}}}C[pn+Nt]=St}}}}}return e.makeTensorInfo(x.shape,x.dtype,x.values)}var oz={kernelName:oh,backendName:"cpu",kernelFunc:_de};function Rde(t){let{inputs:n,backend:e,attrs:r}=t,{dy:o,filter:s}=n,{pad:i,strides:a,inputShape:l}=r;he([o],"conv3dBackpropInputV2");let c=b.computeStrides(o.shape),u=b.computeStrides(s.shape),p=_.computeConv3DInfo(l,s.shape,a,1,i),f=new $t(p.inShape,"float32"),d=f.values,[h,g,m,y]=f.strides,x=e.data.get(o.dataId).values,[C,I,D,O]=c,L=e.data.get(s.dataId).values,[B,V,F,G]=u,{batchSize:ee,filterDepth:Q,filterHeight:oe,filterWidth:ae,inChannels:J,inDepth:re,inHeight:se,inWidth:pe,outChannels:xe,outDepth:be,outHeight:Te,outWidth:Se,strideDepth:Re,strideHeight:De,strideWidth:Oe}=p,We=Q-1-p.padInfo.front,et=oe-1-p.padInfo.top,je=ae-1-p.padInfo.left;for(let tt=0;tt<ee;++tt)for(let qe=0;qe<J;++qe)for(let Rt=0;Rt<re;++Rt){let Bt=Rt-We,pn=Math.max(0,Math.ceil(Bt/Re)),Nt=Math.min(be,(Q+Bt)/Re);for(let St=0;St<se;++St){let Ht=St-et,Dt=Math.max(0,Math.ceil(Ht/De)),or=Math.min(Te,(oe+Ht)/De);for(let $n=0;$n<pe;++$n){let yn=$n-je,sr=Math.max(0,Math.ceil(yn/Oe)),cs=Math.min(Se,(ae+yn)/Oe),jr=0;for(let br=pn;br<Nt;++br){let ir=br*Re-Bt;for(let oo=Dt;oo<or;++oo){let Hn=oo*De-Ht;for(let us=sr;us<cs;++us){let ga=us*Oe-yn,ya=C*tt+I*br+D*oo+O*us,Vf=B*(Q-1-ir)+V*(oe-1-Hn)+F*(ae-1-ga)+G*qe;for(let xa=0;xa<xe;++xa){let wr=x[ya+xa],Un=L[Vf+xa];jr+=wr*Un}}}}d[h*tt+g*Rt+m*St+y*$n+qe]=jr}}}return e.makeTensorInfo(f.shape,f.dtype,f.values)}var sz={kernelName:sh,backendName:"cpu",kernelFunc:Rde};var Mde=Je("Cos",t=>Math.cos(t)),iz={kernelName:"Cos",backendName:"cpu",kernelFunc:Mde};var Ode=Je(Ja,t=>Math.cosh(t)),az={kernelName:Ja,backendName:"cpu",kernelFunc:Ode};function Fde(t){let{inputs:n,backend:e,attrs:r}=t,{image:o,boxes:s,boxInd:i}=n,{cropSize:a,method:l,extrapolationValue:c}=r,[u,p,f,d]=o.shape,h=s.shape[0],[g,m]=a,y=Be([h,g,m,d],"float32"),x=e.data.get(s.dataId).values,C=e.data.get(i.dataId).values,I=e.data.get(o.dataId).values,D=b.computeStrides(o.shape),O=b.computeStrides(y.shape);for(let L=0;L<h;L++){let B=L*4,V=x[B],F=x[B+1],G=x[B+2],ee=x[B+3],Q=C[L];if(Q>=u)continue;let oe=g>1?(G-V)*(p-1)/(g-1):0,ae=m>1?(ee-F)*(f-1)/(m-1):0;for(let J=0;J<g;J++){let re=g>1?V*(p-1)+J*oe:.5*(V+G)*(p-1);if(re<0||re>p-1){for(let se=0;se<m;se++)for(let pe=0;pe<d;pe++){let xe=pe+se*O[2]+J*O[1]+L*O[0];y.values[xe]=c}continue}if(l==="bilinear"){let se=Math.floor(re),pe=Math.ceil(re),xe=re-se;for(let be=0;be<m;be++){let Te=m>1?F*(f-1)+be*ae:.5*(F+ee)*(f-1);if(Te<0||Te>f-1){for(let Oe=0;Oe<d;Oe++){let We=Oe+be*O[2]+J*O[1]+L*O[0];y.values[We]=c}continue}let Se=Math.floor(Te),Re=Math.ceil(Te),De=Te-Se;for(let Oe=0;Oe<d;Oe++){let We=Oe+Se*D[2]+se*D[1]+Q*D[0],et=I[We];We=Oe+Re*D[2]+se*D[1]+Q*D[0];let je=I[We];We=Oe+Se*D[2]+pe*D[1]+Q*D[0];let tt=I[We];We=Oe+Re*D[2]+pe*D[1]+Q*D[0];let qe=I[We],Rt=et+(je-et)*De,Bt=tt+(qe-tt)*De;We=Oe+be*O[2]+J*O[1]+L*O[0],y.values[We]=Rt+(Bt-Rt)*xe}}}else for(let se=0;se<m;++se){let pe=m>1?F*(f-1)+se*ae:.5*(F+ee)*(f-1);if(pe<0||pe>f-1){for(let Te=0;Te<d;Te++){let Se=Te+se*O[2]+J*O[1]+L*O[0];y.values[Se]=c}continue}let xe=Math.round(pe),be=Math.round(re);for(let Te=0;Te<d;Te++){let Se=Te+xe*D[2]+be*D[1]+Q*D[0],Re=Te+se*O[2]+J*O[1]+L*O[0];y.values[Re]=I[Se]}}}}return e.makeTensorInfo(y.shape,y.dtype,y.values)}var lz={kernelName:ah,backendName:"cpu",kernelFunc:Fde};function $de(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,exclusive:i,reverse:a}=r;he(o,"cumprod");let l=_.getAxesPermutation([s],o.shape.length),c=o;l!=null&&(c=An({inputs:{x:o},backend:e,attrs:{perm:l}}));let u=_.getInnerMostAxes(1,o.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);let p=Wn(c.dtype,"int32"),f=b.makeOnesTypedArray(b.sizeFromShape(c.shape),p),d=e.data.get(c.dataId).values,h=c.shape[c.shape.length-1],g=a?(y,x)=>y+h-x-1:(y,x)=>y+x;for(let y=0;y<d.length;y+=h)for(let x=0;x<h;x++){let C=g(y,x);if(x===0)f[C]=i?1:d[C];else{let I=g(y,x-1);f[C]=i?d[I]*f[I]:d[C]*f[I]}}let m=e.makeTensorInfo(c.shape,p,f);if(l!=null){let y=_.getUndoAxesPermutation(l),x=An({inputs:{x:m},backend:e,attrs:{perm:y}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(c),x}return m}var cz={kernelName:ih,backendName:"cpu",kernelFunc:$de};function Lde(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,exclusive:i,reverse:a}=r;he(o,"cumsum");let l=_.getAxesPermutation([s],o.shape.length),c=o;l!=null&&(c=An({inputs:{x:o},backend:e,attrs:{perm:l}}));let u=_.getInnerMostAxes(1,o.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);let p=Wn(c.dtype,"int32"),f=b.makeZerosTypedArray(b.sizeFromShape(c.shape),p),d=e.data.get(c.dataId).values,h=c.shape[c.shape.length-1],g=a?(y,x)=>y+h-x-1:(y,x)=>y+x;for(let y=0;y<d.length;y+=h)for(let x=0;x<h;x++){let C=g(y,x);if(x===0)f[C]=i?0:d[C];else{let I=g(y,x-1);f[C]=i?d[I]+f[I]:d[C]+f[I]}}let m=e.makeTensorInfo(c.shape,p,f);if(l!=null){let y=_.getUndoAxesPermutation(l),x=An({inputs:{x:m},backend:e,attrs:{perm:y}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(c),x}return m}var uz={kernelName:Mc,backendName:"cpu",kernelFunc:Lde};function Pde(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,weights:s}=n,{size:i,binaryOutput:a}=r;if(o.shape.length===1){let l=e.data.get(o.dataId).values,c=e.data.get(s.dataId).values,u=hg(l,c,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,u)}else if(o.shape.length===2){let l=e.bufferSync(o),c=e.bufferSync(s),u=eC(l,c,i,a);return e.makeTensorInfo(u.shape,s.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var pz={kernelName:lh,backendName:"cpu",kernelFunc:Pde};function Bde(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{blockSize:s,dataFormat:i}=r;b.assert(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let a=o.shape[0],l=o.shape[1],c=o.shape[2],u=o.shape[3],p=l*s,f=c*s,d=u/(s*s),h=e.data.get(o.dataId).values,g=new Float32Array(a*p*f*d),m=0;for(let y=0;y<a;++y)for(let x=0;x<p;++x){let C=Math.floor(x/s),I=x%s;for(let D=0;D<f;++D){let O=Math.floor(D/s),L=D%s,B=(I*s+L)*d;for(let V=0;V<d;++V){let G=V+B+u*(O+c*(C+l*y));g[m++]=h[G]}}}return e.makeTensorInfo([a,p,f,d],o.dtype,g)}var fz={kernelName:ch,backendName:"cpu",kernelFunc:Bde};function q4(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,filter:s}=n,{strides:i,pad:a,dilations:l,dimRoundingMode:c}=r;he([o,s],"depthwiseConv2DNative");let u=b.computeStrides(o.shape),p=b.computeStrides(s.shape),f=l;f==null&&(f=[1,1]),b.assert(_.eitherStridesOrDilationsAreOne(i,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${f}'`);let d=_.computeConv2DInfo(o.shape,s.shape,i,f,a,c,!0),{filterHeight:h,filterWidth:g,dilationHeight:m,dilationWidth:y,padInfo:x}=d,C=x.left,I=x.top,D=d.outChannels/d.inChannels,O=new $t(d.outShape,o.dtype),L=e.data.get(o.dataId).values,B=e.data.get(s.dataId).values,V=O.values;for(let F=0;F<d.batchSize;++F){let G=F*u[0],ee=F*O.strides[0];for(let Q=0;Q<d.outHeight;++Q){let oe=ee+Q*O.strides[1],ae=Q*d.strideHeight-I;for(let J=0;J<h;++J){let re=ae+J*m;if(re<0||re>=d.inHeight)continue;let se=J*p[0],pe=G+re*u[1];for(let xe=0;xe<d.outWidth;++xe){let be=oe+xe*O.strides[2],Te=xe*d.strideWidth-C;for(let Se=0;Se<g;++Se){let Re=Te+Se*y;if(Re<0||Re>=d.inWidth)continue;let De=se+Se*p[1],Oe=pe+Re*d.inChannels,We=be,et=De;for(let je=0;je<d.inChannels;++je){let tt=L[Oe+je];for(let qe=0;qe<D;++qe)V[We+qe]+=tt*B[et+qe];We+=D,et+=D}}}}}}return e.makeTensorInfo(O.shape,O.dtype,O.values)}var dz={kernelName:Oc,backendName:"cpu",kernelFunc:q4};function zde(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,dy:s}=n,{strides:i,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=r;he([o,s],"depthwiseConv2dNativeBackpropFilter");let p=_.computeConv2DInfo(o.shape,u,i,a,l,c,!0),{strideHeight:f,strideWidth:d,filterHeight:h,filterWidth:g}=p,m=new $t(p.filterShape,"float32"),y=p.padInfo.left,x=p.padInfo.top,C=p.outChannels/p.inChannels,I=e.data.get(o.dataId).values,D=new $t(o.shape,o.dtype,I),O=e.data.get(s.dataId).values,L=new $t(s.shape,s.dtype,O);for(let B=0;B<h;++B){let V=Math.max(0,Math.ceil((x-B)/f)),F=Math.min(p.outHeight,(p.inHeight+x-B)/f);for(let G=0;G<g;++G){let ee=Math.max(0,Math.ceil((y-G)/d)),Q=Math.min(p.outWidth,(p.inWidth+y-G)/d);for(let oe=0;oe<p.outChannels;++oe){let ae=Math.trunc(oe/C),J=oe%C,re=0;for(let se=0;se<p.batchSize;++se)for(let pe=V;pe<F;++pe){let xe=B+pe*f-x;for(let be=ee;be<Q;++be){let Te=G+be*d-y;re+=D.get(se,xe,Te,ae)*L.get(se,pe,be,oe)}}m.set(re,B,G,ae,J)}}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}var hz={kernelName:uh,backendName:"cpu",kernelFunc:zde};function Vde(t){let{inputs:n,backend:e,attrs:r}=t,{dy:o,filter:s}=n,{strides:i,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=r;he([o,s],"depthwiseConv2DNativeBackpropInput");let p=b.computeStrides(o.shape),f=b.computeStrides(s.shape),d=_.computeConv2DInfo(u,s.shape,i,a,l,c,!0),h=new $t(d.inShape,"float32"),g=h.values,[m,y,x]=h.strides,C=e.data.get(o.dataId).values,[I,D,O]=p,L=e.data.get(s.dataId).values,[B,V,F]=f,{batchSize:G,filterHeight:ee,filterWidth:Q,inChannels:oe,inHeight:ae,inWidth:J,outChannels:re,outHeight:se,outWidth:pe,strideHeight:xe,strideWidth:be}=d,Te=ee-1-d.padInfo.top,Se=Q-1-d.padInfo.left,Re=re/oe;for(let De=0;De<G;++De)for(let Oe=0;Oe<oe;++Oe)for(let We=0;We<ae;++We){let et=We-Te,je=Math.max(0,Math.ceil(et/xe)),tt=Math.min(se,(ee+et)/xe);for(let qe=0;qe<J;++qe){let Rt=qe-Se,Bt=Math.max(0,Math.ceil(Rt/be)),pn=Math.min(pe,(Q+Rt)/be),Nt=0;for(let St=je;St<tt;++St){let Ht=St*xe-et;for(let Dt=Bt;Dt<pn;++Dt){let or=Dt*be-Rt,$n=I*De+D*St+O*Dt,yn=B*(ee-1-Ht)+V*(Q-1-or)+F*Oe;for(let sr=0;sr<Re;++sr){let cs=Oe*Re+sr,jr=C[$n+cs],br=L[yn+sr];Nt+=jr*br}}}g[m*De+y*We+x*qe+Oe]=Nt}}return e.makeTensorInfo(h.shape,h.dtype,h.values)}var mz={kernelName:ph,backendName:"cpu",kernelFunc:Vde};function Ude(t){let{inputs:n,backend:e}=t,{x:r}=n,o=b.sizeFromShape(r.shape),s=e.data.get(r.dataId).values,i=Be([o,o],r.dtype),a=i.values;for(let c=0;c<s.length;c++)a[c*o+c]=s[c];let l=[...r.shape,...r.shape];return e.makeTensorInfo(l,i.dtype,i.values)}var gz={kernelName:fh,backendName:"cpu",kernelFunc:Ude};var yz={kernelName:Fc,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{let{x:r,filter:o}=t,{strides:s,pad:i,dilations:a}=e,l=n,c=l.data.get(r.dataId).values,u=r.shape.length,p=l.data.get(o.dataId).values,f=o.shape.length,{batchSize:d,inHeight:h,inWidth:g,inChannels:m,outHeight:y,outWidth:x,padInfo:C,strideHeight:I,strideWidth:D,filterHeight:O,filterWidth:L,dilationHeight:B,dilationWidth:V,outShape:F}=_.computeDilation2DInfo(r.shape,o.shape,s,i,"NHWC",a),G=b.sizeFromShape(F),ee=F.length,Q=b.getArrayFromDType(r.dtype,G);for(let ae=0;ae<d;++ae)for(let J=0;J<y;++J){let re=J*I-C.top;for(let se=0;se<x;++se){let pe=se*D-C.left;for(let xe=0;xe<m;++xe){let be=Number.MIN_SAFE_INTEGER;for(let Se=0;Se<O;++Se){let Re=re+Se*B;if(Re>=0&&Re<h)for(let De=0;De<L;++De){let Oe=pe+De*V;if(Oe>=0&&Oe<g){let We=b.locToIndex([ae,Re,Oe,xe],u,b.computeStrides(r.shape)),et=b.locToIndex([Se,De,xe],f,b.computeStrides(o.shape)),je=c[We]+p[et];je>be&&(be=je)}}}let Te=b.locToIndex([ae,J,se,xe],ee,b.computeStrides(F));Q[Te]=be}}}return{dataId:l.write(b.toTypedArray(Q,r.dtype),F,r.dtype),shape:F,dtype:r.dtype}}};var xz={kernelName:c1,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{let{x:r,filter:o,dy:s}=t,{strides:i,pad:a,dilations:l}=e,c=n,u=b.toNestedArray(r.shape,c.data.get(r.dataId).values),p=b.toNestedArray(o.shape,c.data.get(o.dataId).values),{batchSize:f,inHeight:d,inWidth:h,inChannels:g,outHeight:m,outWidth:y,padInfo:x,strideHeight:C,strideWidth:I,filterHeight:D,filterWidth:O,dilationHeight:L,dilationWidth:B,outShape:V}=_.computeDilation2DInfo(r.shape,o.shape,i,a,"NHWC",l);b.assert(s.rank===V.length,()=>`Error in ${c1}, dy must have the same rank as output ${V.length}, but got ${s.rank}`);let F=b.toNestedArray(V,c.data.get(s.dataId).values),G=b.makeZerosNestedTypedArray(o.shape,o.dtype);for(let Q=0;Q<f;++Q)for(let oe=0;oe<m;++oe){let ae=oe*C-x.top;for(let J=0;J<y;++J){let re=J*I-x.left;for(let se=0;se<g;++se){let pe=Number.MIN_SAFE_INTEGER,xe=0,be=0;for(let Te=0;Te<D;++Te){let Se=ae+Te*L;if(Se>=0&&Se<d)for(let Re=0;Re<O;++Re){let De=re+Re*B;if(De>=0&&De<h){let Oe=u[Q][Se][De][se]+p[Te][Re][se];Oe>pe&&(pe=Oe,xe=Te,be=Re)}}}G[xe][be][se]+=F[Q][oe][J][se]}}}return{dataId:c.write(b.toTypedArray(G,r.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};var vz={kernelName:l1,backendName:"cpu",kernelFunc:({inputs:t,backend:n,attrs:e})=>{let{x:r,filter:o,dy:s}=t,{strides:i,pad:a,dilations:l}=e,c=n,u=b.toNestedArray(r.shape,c.data.get(r.dataId).values),p=b.toNestedArray(o.shape,c.data.get(o.dataId).values),{batchSize:f,inHeight:d,inWidth:h,inChannels:g,outHeight:m,outWidth:y,padInfo:x,strideHeight:C,strideWidth:I,filterHeight:D,filterWidth:O,dilationHeight:L,dilationWidth:B,outShape:V}=_.computeDilation2DInfo(r.shape,o.shape,i,a,"NHWC",l);b.assert(s.rank===V.length,()=>`Error in ${l1}, dy must have the same rank as output ${V.length}, but got ${s.rank}`);let F=b.toNestedArray(V,c.data.get(s.dataId).values),G=b.makeZerosNestedTypedArray(r.shape,r.dtype);for(let Q=0;Q<f;++Q)for(let oe=0;oe<m;++oe){let ae=oe*C-x.top;for(let J=0;J<y;++J){let re=J*I-x.left;for(let se=0;se<g;++se){let pe=Number.MIN_SAFE_INTEGER,xe=ae<0?0:ae,be=re<0?0:re;for(let Te=0;Te<D;++Te){let Se=ae+Te*L;if(Se>=0&&Se<d)for(let Re=0;Re<O;++Re){let De=re+Re*B;if(De>=0&&De<h){let Oe=u[Q][Se][De][se]+p[Te][Re][se];Oe>pe&&(pe=Oe,xe=Se,be=De)}}}G[Q][xe][be][se]+=F[Q][oe][J][se]}}}return{dataId:c.write(b.toTypedArray(G,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function Gde(t){let{inputs:n,backend:e,attrs:r}=t,{image:o}=n,{canvas:s,options:i}=r,{contextOptions:a,imageOptions:l}=i||{},c=l?.alpha||1,u=a?.contextType||"2d";if(u!=="2d")throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);let p=s.getContext(u,a?.contextAttributes||{});if(p==null)throw new Error(`Could not get the context with ${u} type.`);let[f,d]=o.shape.slice(0,2),h=o.shape.length===2?1:o.shape[2],g=e.data.get(o.dataId).values,m=o.dtype==="float32"?255:1,y=new Uint8ClampedArray(d*f*4);for(let C=0;C<f*d;++C){let I=[0,0,0,255*c];for(let O=0;O<h;O++){let L=g[C*h+O];if(o.dtype==="float32"){if(L<0||L>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${L}.`)}else if(o.dtype==="int32"&&(L<0||L>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${L}.`);h===1?(I[0]=L*m,I[1]=L*m,I[2]=L*m):I[O]=L*m}let D=C*4;y[D+0]=Math.round(I[0]),y[D+1]=Math.round(I[1]),y[D+2]=Math.round(I[2]),y[D+3]=Math.round(I[3])}s.width=d,s.height=f;let x=new ImageData(y,d,f);return p.putImageData(x,0,0),o}var bz={kernelName:u1,backendName:"cpu",kernelFunc:Gde};function jl(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,keepDims:i}=r;he(o,"sum");let a;o.dtype==="bool"?a=Zs({inputs:{x:o},backend:e,attrs:{dtype:"int32"}}):a=Ur({inputs:{x:o},backend:e});let l=a.shape.length,c=b.parseAxisParam(s,a.shape),u=_.getAxesPermutation(c,l),p=c,f=a;u!=null&&(f=An({inputs:{x:a},backend:e,attrs:{perm:u}}),p=_.getInnerMostAxes(p.length,l)),_.assertAxesAreInnerMostDims("sum",p,f.shape.length);let[d,h]=_.computeOutAndReduceShapes(f.shape,p),g=_.upcastType(f.dtype,"int32"),m=fg(e,d,g),y=b.sizeFromShape(h),x=e.data.get(m.dataId).values,C=e.data.get(f.dataId).values;for(let I=0;I<x.length;++I){let D=I*y,O=0;for(let L=0;L<y;++L)O+=C[D+L];x[I]=O}if(i){let I=_.expandShapeToKeepDim(m.shape,c),D=m;m=wt({inputs:{x:m},backend:e,attrs:{shape:I}}),e.disposeIntermediateTensorInfo(D)}return e.disposeIntermediateTensorInfo(a),u!=null&&e.disposeIntermediateTensorInfo(f),m}var wz={kernelName:"Sum",backendName:"cpu",kernelFunc:jl};function jde(t){let{inputs:n,backend:e,attrs:r}=t,{equation:o}=r,s=n,{allDims:i,summedDims:a,idDims:l}=_.decodeEinsumEquation(o,s.length);_.checkEinsumDimSizes(i.length,l,s);let{path:c,steps:u}=_.getEinsumComputePath(a,l),p=u.length,f=null,d=i.length,h=[];for(let g=0;g<p;++g){for(let m of u[g]){let{permutationIndices:y,expandDims:x}=_.getEinsumPermutation(d,l[m]),C;_.isIdentityPermutation(y)?C=s[m]:(C=An({inputs:{x:s[m]},backend:e,attrs:{perm:y}}),h.push(C));let I=C.shape.slice();for(let D=0;D<x.length;++D)I.splice(x[D],0,1);b.arraysEqual(C.shape,I)||(C=wt({inputs:{x:C},backend:e,attrs:{shape:I}}),h.push(C)),f===null?f=C:(f=Tf({inputs:{a:C,b:f},backend:e}),h.push(f))}g<p-1&&(c[g]>=0&&(f=jl({inputs:{x:f},backend:e,attrs:{axis:c[g]-(i.length-d),keepDims:!1}}),h.push(f)),d--)}for(let g of h)g!==f&&e.disposeIntermediateTensorInfo(g);return f}var Cz={kernelName:dh,backendName:"cpu",kernelFunc:jde};function Hde(t){let{inputs:n,backend:e}=t,{dy:r,y:o}=n;he([r,o],"eluGrad");let s=new Float32Array(b.sizeFromShape(o.shape)),i=e.data.get(o.dataId).values,a=e.data.get(r.dataId).values;for(let l=0;l<i.length;++l){let c=i[l];c>=0?s[l]=a[l]:s[l]=a[l]*(c+1)}return e.makeTensorInfo(o.shape,"float32",s)}var Iz={kernelName:hh,backendName:"cpu",kernelFunc:Hde};var Wde=_.ERF_P,qde=_.ERF_A1,Kde=_.ERF_A2,Xde=_.ERF_A3,Yde=_.ERF_A4,Zde=_.ERF_A5,Qde=Je("Erf",t=>{let n=Math.sign(t),e=Math.abs(t),r=1/(1+Wde*e);return n*(1-((((Zde*r+Yde)*r+Xde)*r+Kde)*r+qde)*r*Math.exp(-e*e))}),Sz={kernelName:"Erf",backendName:"cpu",kernelFunc:Qde};function xg(t){let{inputs:n,backend:e,attrs:r}=t,{input:o}=n,{dim:s}=r,i=o.shape.length,a=o.shape.slice(),l=s;return s<0&&(b.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),a.splice(l,0,1),wt({inputs:{x:o},backend:e,attrs:{shape:a}})}var Tz={kernelName:$c,backendName:"cpu",kernelFunc:xg};var Jde=bt((t,n)=>t/n),ix=_t(el,Jde),ax={kernelName:el,backendName:"cpu",kernelFunc:ix};function wC(t,n,e){let r=t.shape,o=r[0],s=r[1],i=e.data.get(t.dataId),a=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,c=[o,s],u=b.sizeFromShape(c),p=b.getTypedArrayFromDType("float32",u),f=b.getTypedArrayFromDType("float32",u);for(let m=0;m<o;m++){let y=Js({inputs:{x:a},backend:e,attrs:{begin:[m,0],size:[1,s]}}),x=Js({inputs:{x:l},backend:e,attrs:{begin:[m,0],size:[1,s]}}),C=ur({inputs:{real:y,imag:x},backend:e}),{real:I,imag:D}=ehe(C,n,e),O=_.mergeRealAndImagArrays(I,D);for(let L=0;L<s;L++){let B=_.getComplexWithIndex(O,L);p[m*s+L]=B.real,f[m*s+L]=B.imag}e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(C)}let d=e.makeTensorInfo(c,"float32",p),h=e.makeTensorInfo(c,"float32",f),g=ur({inputs:{real:d,imag:h},backend:e});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),g}function ehe(t,n,e){let r=b.sizeFromShape(t.shape),o=e.data.get(t.dataId),s=e.data.get(o.complexTensorInfos.real.dataId).values,i=e.data.get(o.complexTensorInfos.imag.dataId).values;if(the(r)){let a=K4(s,i,r,n,e),l=[t.shape[0],t.shape[1]];if(n){let c=e.makeTensorInfo(l,"float32",a.real),u=e.makeTensorInfo(l,"float32",a.imag),p=e.makeTensorInfo([],"float32",b.createScalarValue(r,"float32")),f=Ur({inputs:{x:p},backend:e}),d=ax.kernelFunc({inputs:{a:c,b:p},backend:e}),h=ax.kernelFunc({inputs:{a:u,b:f},backend:e}),g=e.data.get(d.dataId).values,m=e.data.get(h.dataId).values;return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),{real:g,imag:m}}return a}else{let a=_.mergeRealAndImagArrays(s,i),l=nhe(a,r,n);return _.splitRealAndImagArrays(l)}}function the(t){return(t&t-1)===0}function K4(t,n,e,r,o){if(e===1)return{real:t,imag:n};let s=_.mergeRealAndImagArrays(t,n),i=e/2,a=_.complexWithEvenIndex(s),l=a.real,c=a.imag,u=[l.length],p=o.makeTensorInfo(u,"float32",l),f=o.makeTensorInfo(u,"float32",c),d=ur({inputs:{real:p,imag:f},backend:o}),h=_.complexWithOddIndex(s),g=h.real,m=h.imag,y=[g.length],x=o.makeTensorInfo(y,"float32",g),C=o.makeTensorInfo(y,"float32",m),I=ur({inputs:{real:x,imag:C},backend:o}),D=K4(l,c,i,r,o),O=D.real,L=D.imag,B=[O.length],V=o.makeTensorInfo(B,"float32",O),F=o.makeTensorInfo(B,"float32",L),G=ur({inputs:{real:V,imag:F},backend:o}),ee=K4(g,m,i,r,o),Q=ee.real,oe=ee.imag,ae=[Q.length],J=o.makeTensorInfo(ae,"float32",Q),re=o.makeTensorInfo(ae,"float32",oe),se=ur({inputs:{real:J,imag:re},backend:o}),pe=_.exponents(e,r),xe=[pe.real.length],be=o.makeTensorInfo(xe,"float32",pe.real),Te=o.makeTensorInfo(xe,"float32",pe.imag),Se=ur({inputs:{real:be,imag:Te},backend:o}),Re=Tf({inputs:{a:Se,b:se},backend:o}),De=pa({inputs:{a:G,b:Re},backend:o}),Oe=ox({inputs:{a:G,b:Re},backend:o}),We=Ys({inputs:{input:De},backend:o}),et=Ys({inputs:{input:Oe},backend:o}),je=fa({inputs:{input:De},backend:o}),tt=fa({inputs:{input:Oe},backend:o}),qe=Pu({inputs:[We,et],backend:o,attrs:{axis:0}}),Rt=Pu({inputs:[je,tt],backend:o,attrs:{axis:0}}),Bt=o.data.get(qe.dataId).values,pn=o.data.get(Rt.dataId).values;return o.disposeIntermediateTensorInfo(p),o.disposeIntermediateTensorInfo(f),o.disposeIntermediateTensorInfo(d),o.disposeIntermediateTensorInfo(x),o.disposeIntermediateTensorInfo(C),o.disposeIntermediateTensorInfo(I),o.disposeIntermediateTensorInfo(V),o.disposeIntermediateTensorInfo(F),o.disposeIntermediateTensorInfo(G),o.disposeIntermediateTensorInfo(J),o.disposeIntermediateTensorInfo(re),o.disposeIntermediateTensorInfo(se),o.disposeIntermediateTensorInfo(be),o.disposeIntermediateTensorInfo(Te),o.disposeIntermediateTensorInfo(Se),o.disposeIntermediateTensorInfo(Re),o.disposeIntermediateTensorInfo(De),o.disposeIntermediateTensorInfo(Oe),o.disposeIntermediateTensorInfo(We),o.disposeIntermediateTensorInfo(je),o.disposeIntermediateTensorInfo(et),o.disposeIntermediateTensorInfo(tt),o.disposeIntermediateTensorInfo(qe),o.disposeIntermediateTensorInfo(Rt),{real:Bt,imag:pn}}function nhe(t,n,e){let r=new Float32Array(n*2);for(let o=0;o<n;o++){let s=0,i=0;for(let a=0;a<n;a++){let l=_.exponent(o*a,n,e),c=_.getComplexWithIndex(t,a);s+=c.real*l.real-c.imag*l.imag,i+=c.real*l.imag+c.imag*l.real}e&&(s/=n,i/=n),_.assignToTypedArray(r,s,i,o)}return r}function rhe(t){let{inputs:n,backend:e}=t,{input:r}=n,o=b.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=o/s,a=wt({inputs:{x:r},backend:e,attrs:{shape:[i,s]}}),l=wC(a,!1,e),c=wt({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),c}var Ez={kernelName:"FFT",backendName:"cpu",kernelFunc:rhe};function lx(t){let{backend:n,attrs:e}=t,{shape:r,value:o,dtype:s}=e,i=s||b.inferDtype(o),a=b.getArrayFromDType(i,b.sizeFromShape(r));return ohe(a,o,i),n.makeTensorInfo(r,i,a)}var Nz={kernelName:mh,backendName:"cpu",kernelFunc:lx};function ohe(t,n,e){t.fill(n)}var Dz={kernelName:gh,backendName:"cpu",kernelFunc:({inputs:t,attrs:n,backend:e})=>{let{image:r}=t,o=e,s=b.getTypedArrayFromDType(r.dtype,b.sizeFromShape(r.shape)),[i,a,l,c]=r.shape,u=o.data.get(r.dataId).values;for(let f=0;f<i;f++){let d=f*l*a*c;for(let h=0;h<a;h++){let g=h*(l*c);for(let m=0;m<l;m++){let y=m*c;for(let x=0;x<c;x++){let C=Math.round(l-m-1),I=d+g+y+x,D=u[I];if(C>=0&&C<l){let O=C*c,L=d+g+O+x;D=u[L]}s[I]=D}}}}return{dataId:o.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function she(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,filter:s,bias:i,preluActivationWeights:a}=n,{strides:l,pad:c,dataFormat:u,dilations:p,dimRoundingMode:f,activation:d,leakyreluAlpha:h}=r,g=W4({inputs:{x:o,filter:s},backend:e,attrs:{strides:l,pad:c,dataFormat:u,dilations:p,dimRoundingMode:f}});if(i){let m=g;if(u==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){let y=wt({inputs:{x:i},backend:e,attrs:{shape:[i.shape[0],1,1]}});g=pa({inputs:{a:g,b:y},backend:e}),e.disposeIntermediateTensorInfo(y)}else g=pa({inputs:{a:g,b:i},backend:e});e.disposeIntermediateTensorInfo(m)}if(d){let m=g;if(u==="NCHW"&&d==="prelu"&&a.shape.length===1&&a.shape[0]!==1){let y=wt({inputs:{x:a},backend:e,attrs:{shape:[a.shape[0],1,1]}});g=Ef(e,g,d,y,h),e.disposeIntermediateTensorInfo(y)}else g=Ef(e,g,d,a,h);e.disposeIntermediateTensorInfo(m)}return g}var kz={kernelName:Vp,backendName:"cpu",kernelFunc:she};function ihe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,filter:s,bias:i,preluActivationWeights:a}=n,{strides:l,pad:c,dataFormat:u,dilations:p,dimRoundingMode:f,activation:d,leakyreluAlpha:h}=r,g=q4({inputs:{x:o,filter:s},backend:e,attrs:{strides:l,pad:c,dataFormat:u,dilations:p,dimRoundingMode:f}});if(i){let m=g;g=pa({inputs:{a:g,b:i},backend:e}),e.disposeIntermediateTensorInfo(m)}if(d){let m=g;g=Ef(e,g,d,a,h),e.disposeIntermediateTensorInfo(m)}return g}var Az={kernelName:Up,backendName:"cpu",kernelFunc:ihe};function ahe(t){let{inputs:n,backend:e}=t,{params:r,indices:o}=n,s=b.sizeFromShape(r.shape),i=o.shape,a=i[i.length-1],[l,c,u,p]=_.prepareAndValidate(r,o);if(c===0)return e.makeTensorInfo(l,r.dtype,[]);let f=e.data.get(o.dataId).values,d=e.bufferSync(r),h=nC(f,d,r.dtype,c,a,u,p,r.shape,s);return e.makeTensorInfo(l,r.dtype,h.values)}var _z={kernelName:yh,backendName:"cpu",kernelFunc:ahe};function lhe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,indices:s}=n,{axis:i,batchDims:a}=r;he([o,s],"gatherV2");let l=b.parseAxisParam(i,o.shape)[0],c=e.data.get(s.dataId).values,u=o.shape[l];for(let I=0;I<c.length;++I){let D=c[I];b.assert(D<=u-1&&D>=0,()=>`GatherV2: the index value ${D} is not in [0, ${u-1}]`)}let p=a;a==null&&(p=0);let f=b.sizeFromShape(s.shape),d=_.segment_util.collectGatherOpShapeInfo(o,s,l,p),h=wt({inputs:{x:o},backend:e,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),g=wt({inputs:{x:s},backend:e,attrs:{shape:[d.batchSize,f/d.batchSize]}}),m=[d.batchSize,d.outerSize,f/d.batchSize,d.sliceSize],y=e.bufferSync(g),x=e.bufferSync(h),C=rC(x,y,m);return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(g),e.makeTensorInfo(d.outputShape,C.dtype,C.values)}var Rz={kernelName:Pc,backendName:"cpu",kernelFunc:lhe};function che(t){let{inputs:n,backend:e}=t,{input:r}=n,o=b.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=o/s,a=wt({inputs:{x:r},backend:e,attrs:{shape:[i,s]}}),l=wC(a,!0,e),c=wt({inputs:{x:l},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),c}var Mz={kernelName:xh,backendName:"cpu",kernelFunc:che};var uhe=Je(sl,t=>Number.isFinite(t)?1:0,"bool"),Oz={kernelName:sl,backendName:"cpu",kernelFunc:uhe};var phe=Je(il,t=>Math.abs(t)===1/0?1:0,"bool"),Fz={kernelName:il,backendName:"cpu",kernelFunc:phe};var fhe=Je(al,t=>Number.isNaN(t)?1:0,"bool"),$z={kernelName:al,backendName:"cpu",kernelFunc:fhe};function dhe(t){let{backend:n,attrs:e}=t,{start:r,stop:o,num:s}=e,i=oC(r,o,s);return n.makeTensorInfo([i.length],"float32",i)}var Lz={kernelName:bh,backendName:"cpu",kernelFunc:dhe};var hhe=Je(ll,t=>Math.log1p(t)),Pz={kernelName:ll,backendName:"cpu",kernelFunc:hhe};var mhe=bt((t,n)=>t&&n),ghe=_t(Fp,mhe,null,"bool"),Bz={kernelName:Fp,backendName:"cpu",kernelFunc:ghe};var yhe=Je($p,t=>t?0:1,"bool"),zz={kernelName:$p,backendName:"cpu",kernelFunc:yhe};var xhe=bt((t,n)=>t||n),vhe=_t(Lp,xhe,null,"bool"),Vz={kernelName:Lp,backendName:"cpu",kernelFunc:vhe};function bhe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{depthRadius:s,bias:i,alpha:a,beta:l}=r;he(o,"LRN");let c=o.shape[3],u=c-1,p=e.data.get(o.dataId).values,f=b.sizeFromShape(o.shape),d=new Float32Array(f);function h(g){let m=g%c,y=g-m+Math.max(0,m-s),x=g-m+Math.min(m+s,u),C=0;for(;y<=x;y++){let I=p[y];C+=I*I}return C}for(let g=0;g<f;g++){let m=h(g),y=p[g]*Math.pow(i+a*m,-l);d[g]=y}return e.makeTensorInfo(o.shape,o.dtype,d)}var Uz={kernelName:"LRN",backendName:"cpu",kernelFunc:bhe};function whe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,y:s,dy:i}=n,{depthRadius:a,bias:l,alpha:c,beta:u}=r;he(i,"LRNGrad");let p=b.sizeFromShape(i.shape),f=i.shape[3],d=e.data.get(i.dataId).values,h=e.data.get(o.dataId).values,g=e.data.get(s.dataId).values,m=new Float32Array(p),y=p;for(let x=0;x<y;x++){let C=x%f,I=x-C+Math.max(0,C-a),D=x-C+Math.min(f,C+a+1),O=0;for(let L=I;L<D;L++)O+=Math.pow(h[L],2);O=c*O+l;for(let L=I;L<D;L++){let B=-2*c*u*h[L]*g[x]/O;x===L&&(B+=Math.pow(O,-u)),B*=d[x],m[L]+=B}}return e.makeTensorInfo(i.shape,o.dtype,m)}var Gz={kernelName:wh,backendName:"cpu",kernelFunc:whe};function X4(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{reductionIndices:s,keepDims:i}=r,a=e,l=o.shape,c=l.length,u=b.parseAxisParam(s,l),p=u,f=_.getAxesPermutation(p,c),d=a.data.get(o.dataId).values;if(f!=null){let I=new Array(c);for(let D=0;D<I.length;D++)I[D]=l[f[D]];d=mg(d,l,o.dtype,f,I),p=_.getInnerMostAxes(p.length,c),l=I}he(o,"max"),_.assertAxesAreInnerMostDims("max",p,c);let[h,g]=_.computeOutAndReduceShapes(l,p),m=b.sizeFromShape(g),y=sC(d,m,h,o.dtype),x=a.write(y,h,o.dtype),C=h;return i&&(C=_.expandShapeToKeepDim(h,u)),{dataId:x,shape:C,dtype:o.dtype}}var jz={kernelName:"Max",backendName:"cpu",kernelFunc:X4};function Che(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n;he(o,"maxPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:l}=r,c=1;b.assert(_.eitherStridesOrDilationsAreOne(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let u=_.computePool2DInfo(o.shape,s,i,c,a,l),p;if(u.filterWidth===1&&u.filterHeight===1&&b.arraysEqual(u.inShape,u.outShape))p=Ur({inputs:{x:o},backend:e});else{let f=e.data.get(o.dataId).values,d=b.computeStrides(o.shape),h=yg(f,o.shape,o.dtype,d,u,"max");p=e.makeTensorInfo(u.outShape,o.dtype,h.values)}return p}var Hz={kernelName:zc,backendName:"cpu",kernelFunc:Che};function Ihe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{filterSize:s,strides:i,pad:a,dimRoundingMode:l,dataFormat:c}=r;he(o,"maxPool3d");let u=_.computePool3DInfo(o.shape,s,i,1,a,l,c),p=e.data.get(o.dataId).values,f=bC(p,o.shape,o.dtype,b.computeStrides(o.shape),u,"max");return e.makeTensorInfo(f.shape,"float32",f.values)}var Wz={kernelName:Vc,backendName:"cpu",kernelFunc:Ihe};function She(t){let{inputs:n,backend:e,attrs:r}=t,{dy:o,input:s}=n,{filterSize:i,strides:a,pad:l,dimRoundingMode:c}=r;he([o,s],"maxPool3DGrad");let u=_.computePool3DInfo(s.shape,i,a,1,l,c),p=e.bufferSync(s),f=VB(p,u),d=u.strideDepth,h=u.strideHeight,g=u.strideWidth,m=u.dilationDepth,y=u.dilationHeight,x=u.dilationWidth,C=u.effectiveFilterDepth,I=u.effectiveFilterHeight,D=u.effectiveFilterWidth,O=C-1-u.padInfo.front,L=D-1-u.padInfo.left,B=I-1-u.padInfo.top,V=Be(s.shape,"float32"),F=e.bufferSync(o);for(let G=0;G<u.batchSize;++G)for(let ee=0;ee<u.inChannels;++ee)for(let Q=0;Q<u.inDepth;++Q)for(let oe=0;oe<u.inHeight;++oe)for(let ae=0;ae<u.inWidth;++ae){let J=Q-O,re=oe-B,se=ae-L,pe=0;for(let xe=0;xe<C;xe+=m){let be=(J+xe)/d;if(!(be<0||be>=u.outDepth||Math.floor(be)!==be))for(let Te=0;Te<I;Te+=y){let Se=(re+Te)/h;if(!(Se<0||Se>=u.outHeight||Math.floor(Se)!==Se))for(let Re=0;Re<D;Re+=x){let De=(se+Re)/g;if(De<0||De>=u.outWidth||Math.floor(De)!==De)continue;let Oe=C*I*D-1-f.get(G,be,Se,De,ee),We=xe*I*D+Te*D+Re,et=Oe===We?1:0;if(et===0)continue;let je=F.get(G,be,Se,De,ee);pe+=je*et}}}V.set(pe,G,Q,oe,ae,ee)}return e.makeTensorInfo(V.shape,V.dtype,V.values)}var qz={kernelName:Ih,backendName:"cpu",kernelFunc:She};function The(t){let{inputs:n,backend:e,attrs:r}=t,{dy:o,input:s,output:i}=n,a=s;he([s,i],"maxPoolGrad");let{filterSize:l,strides:c,pad:u,dimRoundingMode:p}=r,f=_.computePool2DInfo(a.shape,l,c,1,u,p),d=e.data.get(a.dataId).values,h=Be(f.outShape,a.dtype,vC(d,a.shape,a.dtype,f).values),g=f.strideHeight,m=f.strideWidth,y=f.dilationHeight,x=f.dilationWidth,C=f.effectiveFilterHeight,I=f.effectiveFilterWidth,D=I-1-f.padInfo.left,O=C-1-f.padInfo.top,L=Be(a.shape,"float32"),B=e.data.get(o.dataId).values,V=Be(o.shape,"float32",B);for(let F=0;F<f.batchSize;++F)for(let G=0;G<f.inChannels;++G)for(let ee=0;ee<f.inHeight;++ee)for(let Q=0;Q<f.inWidth;++Q){let oe=ee-O,ae=Q-D,J=0;for(let re=0;re<C;re+=y){let se=(oe+re)/g;if(!(se<0||se>=f.outHeight||Math.floor(se)!==se))for(let pe=0;pe<I;pe+=x){let xe=(ae+pe)/m;if(xe<0||xe>=f.outWidth||Math.floor(xe)!==xe)continue;let be=C*I-1-h.get(F,se,xe,G),Te=re*I+pe,Se=be===Te?1:0;if(Se===0)continue;let Re=V.get(F,se,xe,G);J+=Re*Se}}L.set(J,F,ee,Q,G)}return e.makeTensorInfo(L.shape,L.dtype,L.values)}var Kz={kernelName:Ch,backendName:"cpu",kernelFunc:The};function Xz(t,n,e,r,o){let s=b.computeStrides(n),i=yg(t,n,e,s,o,"max"),a=vC(t,n,e,o,!0,r);return[i.values,a.values]}var Yz={kernelName:Sh,backendName:"cpu",kernelFunc:({inputs:t,attrs:n,backend:e})=>{let{x:r}=t,{filterSize:o,strides:s,pad:i,includeBatchInIndex:a}=n,l=e;he(r,"MaxPoolWithArgmax");let c=l.data.get(r.dataId).values,u=_.computePool2DInfo(r.shape,o,s,[1,1],i),[p,f]=Xz(c,r.shape,r.dtype,a,u),d=l.write(p,u.outShape,r.dtype),h=l.write(f,u.outShape,r.dtype);return[{dataId:d,shape:u.outShape,dtype:r.dtype},{dataId:h,shape:u.outShape,dtype:"int32"}]}};function Ehe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,keepDims:i}=r,a=b.parseAxisParam(s,o.shape),c=_.computeOutAndReduceShapes(o.shape,a)[1],u=b.sizeFromShape(c),p=[],f=e.makeTensorInfo([],"float32",new Float32Array([u]));p.push(f);let d=Zs({inputs:{x:o},backend:e,attrs:{dtype:"float32"}});p.push(d);let h=ix({inputs:{a:d,b:f},backend:e});p.push(h);let g=jl({inputs:{x:h},backend:e,attrs:{axis:s,keepDims:i}});return p.forEach(m=>e.disposeIntermediateTensorInfo(m)),g}var Zz={kernelName:Uc,backendName:"cpu",kernelFunc:Ehe};function Nhe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,keepDims:i}=r;he(o,"min");let a=b.parseAxisParam(s,o.shape),l=a,c=_.getAxesPermutation(l,o.shape.length),u=o;c!=null&&(u=An({inputs:{x:o},backend:e,attrs:{perm:c}}),l=_.getInnerMostAxes(l.length,o.shape.length)),_.assertAxesAreInnerMostDims("min",l,u.shape.length);let[p,f]=_.computeOutAndReduceShapes(u.shape,l),d=b.sizeFromShape(f),h=b.makeZerosTypedArray(b.sizeFromShape(p),u.dtype),g=e.data.get(u.dataId).values;for(let y=0;y<h.length;++y){let x=y*d,C=g[x];for(let I=0;I<d;++I){let D=g[x+I];(Number.isNaN(D)||D<C)&&(C=D)}h[y]=C}c!=null&&e.disposeIntermediateTensorInfo(u);let m=e.makeTensorInfo(p,u.dtype,h);if(i){let y=_.expandShapeToKeepDim(p,a),x=wt({inputs:{x:m},backend:e,attrs:{shape:y}});return e.disposeIntermediateTensorInfo(m),x}return m}var Qz={kernelName:"Min",backendName:"cpu",kernelFunc:Nhe};function Dhe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{paddings:s,mode:i}=r;he(o,"mirrorPad");let a=s.map((C,I)=>C[0]+o.shape[I]+C[1]),l=s.map(C=>C[0]),c=s.map((C,I)=>C[0]+o.shape[I]),u=i==="reflect"?0:1,p=e.data.get(o.dataId).values,f=o.shape.length,d=b.computeStrides(o.shape),h=b.sizeFromShape(a),g=a.length,m=b.computeStrides(a),y=b.getTypedArrayFromDType(o.dtype,h);for(let C=0;C<h;C++){let I=b.indexToLoc(C,g,m);for(let O=0;O<g;O++)I[O]<l[O]?I[O]=l[O]*2-I[O]-u:I[O]>=c[O]&&(I[O]=(c[O]-1)*2-I[O]+u);I=I.map((O,L)=>O-l[L]);let D=b.locToIndex(I,f,d);y[C]=p[D]}return{dataId:e.write(y,a,o.dtype),shape:a,dtype:o.dtype}}var Jz={kernelName:Gc,backendName:"cpu",kernelFunc:Dhe};var khe=bt((t,n)=>{let e=t%n;return t<0&&n<0||t>=0&&n>=0?e:(e+n)%n}),Ahe=_t("Mod",khe),eV={kernelName:"Mod",backendName:"cpu",kernelFunc:Ahe};var nV=wa(D1());function Y4(t){let{inputs:n,backend:e,attrs:r}=t,{logits:o}=n,{dim:s}=r,i=o.shape.length,a=s;if(a===-1&&(a=i-1),a!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${a}`);let l=b.parseAxisParam([a],o.shape),c=X4({inputs:{x:o},backend:e,attrs:{reductionIndices:l,keepDims:!1}}),u=_.expandShapeToKeepDim(c.shape,l),p=wt({inputs:{x:c},backend:e,attrs:{shape:u}}),f=ox({inputs:{a:o,b:p},backend:e}),d=y4({inputs:{x:f},backend:e}),h=jl({inputs:{x:d},backend:e,attrs:{axis:l,keepDims:!1}}),g=wt({inputs:{x:h},backend:e,attrs:{shape:u}}),m=ix({inputs:{a:d,b:g},backend:e});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(g),m}var tV={kernelName:ou,backendName:"cpu",kernelFunc:Y4};function _he(t){let{inputs:n,backend:e,attrs:r}=t,{logits:o}=n,{numSamples:s,seed:i,normalized:a}=r;he(o,"multinomial");let l=a?o:Y4({inputs:{logits:o},backend:e,attrs:{dim:-1}}),c=l.shape[0],u=l.shape[1],p=e.data.get(l.dataId).values,f=[c,s],d=b.makeZerosTypedArray(b.sizeFromShape(f),"int32");for(let h=0;h<c;++h){let g=h*u,m=new Float32Array(u-1);m[0]=p[g];for(let C=1;C<m.length;++C)m[C]=m[C-1]+p[g+C];let y=nV.alea(i.toString()),x=h*s;for(let C=0;C<s;++C){let I=y();d[x+C]=m.length;for(let D=0;D<m.length;D++)if(I<m[D]){d[x+C]=D;break}}}return a||e.disposeIntermediateTensorInfo(l),e.makeTensorInfo(f,"int32",d)}var rV={kernelName:Th,backendName:"cpu",kernelFunc:_he};var Rhe=Vr.nonMaxSuppressionV3Impl;function Mhe(t){let{inputs:n,backend:e,attrs:r}=t,{boxes:o,scores:s}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=r;he(o,"NonMaxSuppression");let c=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,{selectedIndices:p}=Rhe(c,u,i,a,l);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}var oV={kernelName:Eh,backendName:"cpu",kernelFunc:Mhe};var Ohe=Vr.nonMaxSuppressionV4Impl;function Fhe(t){let{inputs:n,backend:e,attrs:r}=t,{boxes:o,scores:s}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=r;he(o,"NonMaxSuppressionPadded");let u=e.data.get(o.dataId).values,p=e.data.get(s.dataId).values,{selectedIndices:f,validOutputs:d}=Ohe(u,p,i,a,l,c);return[e.makeTensorInfo([f.length],"int32",new Int32Array(f)),e.makeTensorInfo([],"int32",new Int32Array([d]))]}var sV={kernelName:Nh,backendName:"cpu",kernelFunc:Fhe};var $he=Vr.nonMaxSuppressionV5Impl;function Lhe(t){let{inputs:n,backend:e,attrs:r}=t,{boxes:o,scores:s}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r;he(o,"NonMaxSuppressionWithScore");let u=e.data.get(o.dataId).values,p=e.data.get(s.dataId).values,f=i,d=a,h=l,g=c,{selectedIndices:m,selectedScores:y}=$he(u,p,f,d,h,g);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var iV={kernelName:Dh,backendName:"cpu",kernelFunc:Lhe};function Phe(t){let{inputs:n,backend:e,attrs:r}=t,{indices:o}=n,{dtype:s,depth:i,onValue:a,offValue:l}=r;he(o,"oneHot");let c=b.sizeFromShape(o.shape),u=new Float32Array(c*i);u.fill(l);let p=e.data.get(o.dataId).values;for(let f=0;f<c;++f)p[f]>=0&&p[f]<i&&(u[f*i+p[f]]=a);return e.makeTensorInfo([...o.shape,i],s,u)}var aV={kernelName:Hc,backendName:"cpu",kernelFunc:Phe};function cx(t){let{inputs:n,backend:e}=t,{x:r}=n;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){let o=Ys({inputs:{input:r},backend:e}),s=cx({inputs:{x:o},backend:e}),i=fa({inputs:{input:r},backend:e}),a=cx({inputs:{x:i},backend:e}),l=ur({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}else return lx({backend:e,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var lV={kernelName:au,backendName:"cpu",kernelFunc:cx};function cV(t){let{inputs:n,backend:e}=t,{x:r}=n;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){let o=Ys({inputs:{input:r},backend:e}),s=cV({inputs:{x:o},backend:e}),i=fa({inputs:{input:r},backend:e}),a=cx({inputs:{x:i},backend:e}),l=ur({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}else return lx({backend:e,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}var uV={kernelName:jc,backendName:"cpu",kernelFunc:cV};function Z4(t){let{inputs:n,backend:e,attrs:r}=t,{axis:o}=r;if(n.length===1)return xg({inputs:{input:n[0]},backend:e,attrs:{dim:o}});let s=n[0].shape,i=n[0].dtype;n.forEach(u=>{b.assertShapesMatch(s,u.shape,"All tensors passed to stack must have matching shapes"),b.assert(i===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],l=n.map(u=>{let p=xg({inputs:{input:u},backend:e,attrs:{dim:o}});return a.push(p),p}),c=Pu({inputs:l,backend:e,attrs:{axis:o}});return a.forEach(u=>e.disposeIntermediateTensorInfo(u)),c}var pV={kernelName:Wc,backendName:"cpu",kernelFunc:Z4};function Bhe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{paddings:s,constantValue:i}=r;he(o,"pad");let a=s.map((x,C)=>x[0]+o.shape[C]+x[1]),l=s.map(x=>x[0]),c=e.data.get(o.dataId).values,u=b.sizeFromShape(o.shape),p=o.shape.length,f=b.computeStrides(o.shape),d=b.sizeFromShape(a),h=a.length,g=b.computeStrides(a),m=b.getTypedArrayFromDType(o.dtype,d);i!==0&&m.fill(i);for(let x=0;x<u;x++){let I=b.indexToLoc(x,p,f).map((O,L)=>O+l[L]),D=b.locToIndex(I,h,g);m[D]=c[x]}return{dataId:e.write(m,a,o.dtype),shape:a,dtype:o.dtype}}var CC={kernelName:qc,backendName:"cpu",kernelFunc:Bhe};var zhe=bt((t,n)=>Math.pow(t,n)),Vhe=_t("Pow",zhe),fV={kernelName:"Pow",backendName:"cpu",kernelFunc:Vhe};function Uhe(t){let{inputs:n,backend:e,attrs:r}=t,{paramsNestedSplits:o,paramsDenseValues:s,indices:i}=n,{outputRaggedRank:a}=r,l=o.map(y=>e.data.get(y.dataId).values),c=o.map(y=>y.shape),u=e.data.get(s.dataId).values,p=e.data.get(i.dataId).values,[f,d,h]=iC(l,c,u,s.shape,s.dtype,p,i.shape,a),g=f.map(y=>e.makeTensorInfo([y.length],"int32",y)),m=e.makeTensorInfo(h,s.dtype,d);return g.concat([m])}var dV={kernelName:kh,backendName:"cpu",kernelFunc:Uhe};function Ghe(t){let{inputs:n,backend:e}=t,{starts:r,limits:o,deltas:s}=n,i=e.data.get(r.dataId).values,a=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,[c,u]=aC(i,r.shape,r.dtype,a,o.shape,l,s.shape),p=e.makeTensorInfo([c.length],"int32",c),f=e.makeTensorInfo([u.length],r.dtype,u);return[p,f]}var hV={kernelName:Ah,backendName:"cpu",kernelFunc:Ghe};function jhe(t){let{inputs:n,backend:e,attrs:r}=t,{shape:o,values:s,defaultValue:i,rowPartitionTensors:a}=n,{rowPartitionTypes:l}=r,c=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,p=e.data.get(i.dataId).values,f=a.map(m=>e.data.get(m.dataId).values),d=a.map(m=>m.shape),[h,g]=lC(c,o.shape,u,s.shape,s.dtype,p,i.shape,f,d,l);return e.makeTensorInfo(h,s.dtype,g)}var mV={kernelName:_h,backendName:"cpu",kernelFunc:jhe};function Hhe(t){let{backend:n,attrs:e}=t,{start:r,stop:o,dtype:s,step:i}=e,a=cC(r,o,i,s);return n.makeTensorInfo([a.length],s,a)}var gV={kernelName:Rh,backendName:"cpu",kernelFunc:Hhe};var Whe=Je(fl,t=>1/t),yV={kernelName:fl,backendName:"cpu",kernelFunc:Whe};function qhe(t){let{inputs:n,backend:e,attrs:r}=t,{images:o}=n,{alignCorners:s,halfPixelCenters:i,size:a}=r;he(o,"resizeBilinear");let l=b.computeStrides(o.shape),[c,u]=a,[p,f,d,h]=o.shape,g=e.data.get(o.dataId).values,m=new Float32Array(b.sizeFromShape([p,c,u,h])),y=[s&&c>1?f-1:f,s&&u>1?d-1:d],x=[s&&c>1?c-1:c,s&&u>1?u-1:u],C=0,I=y[0]/x[0],D=y[1]/x[1];for(let O=0;O<p;O++)for(let L=0;L<c;L++){let B;i?B=I*(L+.5)-.5:B=I*L;let V=Math.max(0,Math.floor(B)),F=B-V,G=Math.min(f-1,Math.ceil(B)),ee=O*l[0]+V*l[1],Q=O*l[0]+G*l[1];for(let oe=0;oe<u;oe++){let ae;i?ae=D*(oe+.5)-.5:ae=D*oe;let J=Math.max(0,Math.floor(ae)),re=ae-J,se=Math.min(d-1,Math.ceil(ae)),pe=ee+J*l[2],xe=Q+J*l[2],be=ee+se*l[2],Te=Q+se*l[2];for(let Se=0;Se<h;Se++){let Re=g[pe+Se],De=g[xe+Se],Oe=g[be+Se],We=g[Te+Se],et=Re+(Oe-Re)*re,je=De+(We-De)*re,tt=et+(je-et)*F;m[C++]=tt}}}return e.makeTensorInfo([p,c,u,h],"float32",m)}var xV={kernelName:Qc,backendName:"cpu",kernelFunc:qhe};function Khe(t){let{inputs:n,backend:e,attrs:r}=t,{images:o,dy:s}=n,{alignCorners:i}=r;he([s,o],"resizeBilinearGrad");let a=b.computeStrides(o.shape),[l,c,u,p]=o.shape,[,f,d]=s.shape,h=new Float32Array(l*c*u*p),g=[i&&f>1?c-1:c,i&&d>1?u-1:u],m=[i&&f>1?f-1:f,i&&d>1?d-1:d],y=g[0]/m[0],x=g[1]/m[1],C=e.data.get(s.dataId).values,I=0;for(let D=0;D<l;D++){let O=D*a[0];for(let L=0;L<f;L++){let B=L*y,V=Math.floor(B),F=Math.min(Math.ceil(B),c-1),G=O+V*a[1],ee=O+F*a[1],Q=B-V,oe=1-Q;for(let ae=0;ae<d;ae++){let J=ae*x,re=Math.floor(J),se=Math.min(Math.ceil(J),u-1),pe=J-re,xe=1-pe,be=G+re*a[2],Te=G+se*a[2],Se=ee+re*a[2],Re=ee+se*a[2],De=oe*xe,Oe=oe*pe,We=Q*xe,et=Q*pe;for(let je=0;je<p;je++){let tt=C[I++];h[be+je]+=tt*De,h[Te+je]+=tt*Oe,h[Se+je]+=tt*We,h[Re+je]+=tt*et}}}}return e.makeTensorInfo([l,u,c,p],"float32",h)}var vV={kernelName:Fh,backendName:"cpu",kernelFunc:Khe};function Xhe(t){let{inputs:n,backend:e,attrs:r}=t,{images:o}=n,{alignCorners:s,halfPixelCenters:i,size:a}=r;he(o,"resizeNearestNeighbor");let l=b.computeStrides(o.shape),[c,u]=a,[p,f,d,h]=o.shape,g=e.data.get(o.dataId).values,m=new Float32Array(p*c*u*h),y=[s&&c>1?f-1:f,s&&u>1?d-1:d],x=[s&&c>1?c-1:c,s&&u>1?u-1:u],C=y[0]/x[0],I=y[1]/x[1],D=0;for(let O=0;O<p;O++){let L=O*l[0];for(let B=0;B<c;B++){let V=i?C*(B+.5):C*B,F=Math.min(f-1,s?Math.round(V):Math.floor(V));i&&(F=Math.max(0,F));let G=L+F*l[1];for(let ee=0;ee<u;ee++){let Q=i?I*(ee+.5):I*ee,oe=Math.min(d-1,s?Math.round(Q):Math.floor(Q));i&&(oe=Math.max(0,oe));let ae=G+oe*l[2];for(let J=0;J<h;J++){let re=g[ae+J];m[D++]=re}}}}return e.makeTensorInfo([p,c,u,h],o.dtype,m)}var bV={kernelName:Zc,backendName:"cpu",kernelFunc:Xhe};function Yhe(t){let{inputs:n,backend:e,attrs:r}=t,{images:o,dy:s}=n,{alignCorners:i}=r;he([s,o],"resizeNearestNeighborGrad");let a=b.computeStrides(o.shape),l=b.computeStrides(s.shape),[c,u,p,f]=o.shape,[,d,h]=s.shape,g=new Float32Array(c*u*p*f),m=e.data.get(s.dataId).values,y=[i&&d>1?u-1:u,i&&h>1?p-1:p],x=[i&&d>1?d-1:d,i&&h>1?h-1:h],C=y[0]/x[0],I=y[1]/x[1],D=1/C,O=1/I,L=Math.ceil(D)*2+2,B=Math.ceil(O)*2+2;for(let V=0;V<c;V++){let F=V*a[0];for(let G=0;G<u;G++){let ee=F+G*a[1],Q=Math.floor(G*D),oe=Math.floor(Q-L/2);for(let ae=0;ae<p;ae++){let J=ee+ae*a[2],re=Math.floor(ae*O),se=Math.floor(re-B/2);for(let pe=0;pe<f;pe++){let xe=0;for(let be=0;be<L;be++){let Te=be+oe;if(Te<0||Te>=d)continue;let Se=F+Te*l[1],Re=Te*C,De=Math.min(u-1,i?Math.round(Re):Math.floor(Re));if(G===De)for(let Oe=0;Oe<B;Oe++){let We=Oe+se;if(We<0||We>=h)continue;let et=Se+We*l[2],je=We*I,tt=Math.min(p-1,i?Math.round(je):Math.floor(je));ae===tt&&(xe+=m[et+pe])}}g[J+pe]=xe}}}}return e.makeTensorInfo(o.shape,o.dtype,g)}var wV={kernelName:Oh,backendName:"cpu",kernelFunc:Yhe};function Zhe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{dims:s}=r;he(o,"reverse");let i=o.shape.length,a=b.parseAxisParam(s,o.shape);if(i===0)return Ur({inputs:{x:o},backend:e});let l=new $t(o.shape,o.dtype),c=e.bufferSync(o);for(let u=0;u<l.size;u++){let p=l.indexToLoc(u),f=p.slice();a.forEach(d=>f[d]=o.shape[d]-1-f[d]),l.set(c.get(...f),...p)}return e.makeTensorInfo(l.shape,l.dtype,l.values)}var CV={kernelName:Jc,backendName:"cpu",kernelFunc:Zhe};var IV={kernelName:Qh,backendName:"cpu",kernelFunc:({inputs:t,attrs:n,backend:e})=>{let{image:r}=t,{radians:o,fillValue:s,center:i}=n,a=e,l=b.getTypedArrayFromDType(r.dtype,b.sizeFromShape(r.shape)),[c,u,p,f]=r.shape,[d,h]=_.getImageCenter(i,u,p),g=255,m=Math.sin(o),y=Math.cos(o),x=a.data.get(r.dataId).values;for(let I=0;I<c;I++){let D=I*p*u*f;for(let O=0;O<u;O++){let L=O*(p*f);for(let B=0;B<p;B++){let V=B*f;for(let F=0;F<f;F++){let G=[c,O,B,F],ee=G[2],Q=G[1],oe=(ee-d)*y-(Q-h)*m,ae=(ee-d)*m+(Q-h)*y;oe=Math.round(oe+d),ae=Math.round(ae+h);let J=s;if(typeof s!="number"&&(F===3?J=g:J=s[F]),oe>=0&&oe<p&&ae>=0&&ae<u){let se=ae*(p*f),pe=oe*f,xe=D+se+pe+F;J=x[xe]}let re=D+L+V+F;l[re]=J}}}}return{dataId:a.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};var Qhe=Je(ml,t=>{let n=Math.floor(t);return t-n<.5?Math.floor(t):t-n>.5?Math.ceil(t):n%2===0?n:n+1}),SV={kernelName:ml,backendName:"cpu",kernelFunc:Qhe};function Jhe(t){let{inputs:n,backend:e,attrs:r}=t,{indices:o,updates:s}=n,{shape:i}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:p}=_.calculateShapes(s,o,i),f=!0,d=e.bufferSync(o),h=e.bufferSync(s),g=Ei(d,h,i,p,c,l,a,u,0,f);return e.makeTensorInfo(i,g.dtype,g.values)}var TV={kernelName:$h,backendName:"cpu",kernelFunc:Jhe};function eme(t,n){let e=0,r=t.length,o=0;for(;e<r;)o=Math.floor((e+r)/2),t[o]<n?e=o+1:r=o;return r}function tme(t,n){let e=0,r=t.length,o=0;for(;e<r;)o=Math.floor((e+r)/2),t[o]<=n?e=o+1:r=o;return r}function EV(t,n,e,r,o,s){let i=b.getArrayFromDType("int32",e*o);for(let a=0;a<e;++a){let l=t.slice(a*r,(a+1)*r),c=a*o;for(let u=0;u<o;++u)i[c+u]=s==="left"?eme(l,n[u+c]):tme(l,n[u+c])}return i}function nme(t){let{inputs:n,backend:e,attrs:r}=t,{sortedSequence:o,values:s}=n,{side:i}=r,a=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,c=EV(a,l,o.shape[0],o.shape[1],s.shape[1],i);return e.makeTensorInfo(s.shape,"int32",c)}var NV={kernelName:Ph,backendName:"cpu",kernelFunc:nme};function rme(t){let{inputs:n,backend:e}=t,{condition:r,t:o,e:s}=n;he([r,o,s],"select");let i=r.shape.length,a=e.data.get(r.dataId).values,l=e.data.get(o.dataId).values,c=e.data.get(s.dataId).values,u=Wn(o.dtype,s.dtype),p=b.makeZerosTypedArray(b.sizeFromShape(o.shape),u),f=0,d=i===0||i>1||o.shape.length===1?1:b.sizeFromShape(o.shape.slice(1));for(let h=0;h<a.length;h++)for(let g=0;g<d;g++)a[h]===1?p[f++]=l[h]:p[f++]=c[h];return e.makeTensorInfo(o.shape,u,p)}var DV={kernelName:eu,backendName:"cpu",kernelFunc:rme};var ome=_.SELU_SCALEALPHA,sme=_.SELU_SCALE,ime=Je(yl,t=>t>=0?sme*t:ome*(Math.exp(t)-1)),kV={kernelName:yl,backendName:"cpu",kernelFunc:ime};var ame=Je(vl,t=>t<0?-1:t>0?1:0),AV={kernelName:vl,backendName:"cpu",kernelFunc:ame};var lme=Je("Sin",t=>Math.sin(t)),_V={kernelName:"Sin",backendName:"cpu",kernelFunc:lme};var cme=Je(xl,t=>Math.sinh(t)),RV={kernelName:xl,backendName:"cpu",kernelFunc:cme};var ume=11920928955078125e-23,MV=Math.log(ume)+2,pme=Je(wl,t=>{let n=t>-MV,e=t<MV,r=Math.exp(t),o;return e?o=r:n?o=t:o=Math.log(1+r),o}),OV={kernelName:wl,backendName:"cpu",kernelFunc:pme};function fme(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{blockShape:s,paddings:i}=r;he([o],"spaceToBatchND");let a=b.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let O=1+s.length;O<o.shape.length;++O)l.push([0,0]);let c=CC.kernelFunc({inputs:{x:o},backend:e,attrs:{paddings:l,constantValue:0}}),u=_.getReshaped(c.shape,s,a,!1),p=_.getPermuted(u.length,s.length,!1),f=_.getReshapedPermuted(c.shape,s,a,!1),g=wt({inputs:{x:c},backend:e,attrs:{shape:u}}),x=An({inputs:{x:g},backend:e,attrs:{perm:p}}),D=wt({inputs:{x},backend:e,attrs:{shape:f}});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(x),D}var FV={kernelName:nu,backendName:"cpu",kernelFunc:fme};function dme(t){let{inputs:n,backend:e}=t,{indices:r,values:o,denseShape:s,defaultValue:i}=n;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${o.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let a=e.data.get(r.dataId).values,l=e.data.get(o.dataId).values,c=e.data.get(s.dataId).values,u=e.data.get(i.dataId).values[0],[p,f,d,h,g]=uC(a,r.shape,r.dtype,l,o.dtype,c,u);return[e.makeTensorInfo(f,r.dtype,p),e.makeTensorInfo([f[0]],o.dtype,d),e.makeTensorInfo([h.length],"bool",new Uint8Array(h.map(m=>Number(m)))),e.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}var $V={kernelName:Bh,backendName:"cpu",kernelFunc:dme};function hme(t){let{inputs:n,backend:e}=t,{inputIndices:r,inputShape:o,newShape:s}=n;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(e.data.get(o.dataId).values),a=e.data.get(r.dataId).values,l=Array.from(e.data.get(s.dataId).values),[c,u,p]=pC(a,r.shape,r.dtype,i,l);return[e.makeTensorInfo(u,r.dtype,c),e.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var LV={kernelName:zh,backendName:"cpu",kernelFunc:hme};function mme(t){let{inputs:n,backend:e}=t,{data:r,indices:o,segmentIds:s}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=e.data.get(r.dataId).values,a=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,[c,u]=gg(i,r.shape,r.dtype,a,l,!0);return e.makeTensorInfo(u,r.dtype,c)}var PV={kernelName:Vh,backendName:"cpu",kernelFunc:mme};function gme(t){let{inputs:n,backend:e}=t,{data:r,indices:o,segmentIds:s}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=e.data.get(r.dataId).values,a=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,[c,u]=gg(i,r.shape,r.dtype,a,l);return e.makeTensorInfo(u,r.dtype,c)}var BV={kernelName:Uh,backendName:"cpu",kernelFunc:gme};function yme(t){let{inputs:n,backend:e,attrs:r}=t,{sparseIndices:o,sparseValues:s,defaultValue:i}=n,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:p,outputSize:f}=_.calculateShapes(s,o,a),d=!1,h=e.bufferSync(o),g;switch(s.dtype){case"bool":{let m=e.bufferSync(s),y=!!e.data.get(i.dataId).values[0];g=Ei(h,m,a,f,u,c,l,p,y,d);break}case"float32":{let m=e.bufferSync(s),y=e.data.get(i.dataId).values[0];g=Ei(h,m,a,f,u,c,l,p,y,d);break}case"int32":{let m=e.bufferSync(s),y=e.data.get(i.dataId).values[0];g=Ei(h,m,a,f,u,c,l,p,y,d);break}case"string":{let m=e.bufferSync(s),y=b.decodeString(e.data.get(i.dataId).values[0]);g=Ei(h,m,a,f,u,c,l,p,y,d);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return e.makeTensorInfo(a,g.dtype,g.values)}var zV={kernelName:Gh,backendName:"cpu",kernelFunc:yme};function xme(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{numOrSizeSplits:s,axis:i}=r,a=b.parseAxisParam(i,o.shape)[0],l=_.prepareSplitSize(o,s,a),c=new Array(o.shape.length).fill(0),u=o.shape.slice();return l.map(p=>{let f=[...u];f[a]=p;let d=Js({inputs:{x:o},backend:e,attrs:{begin:c,size:f}});return c[a]+=p,d})}var VV={kernelName:ru,backendName:"cpu",kernelFunc:xme};var UV={kernelName:jh,backendName:"cpu",kernelFunc:({inputs:t,backend:n})=>{let{x:e}=t,r=n;he(e,"square");let o=r.data.get(e.dataId).values,s=new Float32Array(o.length);for(let a=0;a<o.length;++a){let l=o[a];s[a]=l*l}return{dataId:r.write(s,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}};var vme=Je(Tl,(t,n)=>{let e=n;return isNaN(t)?NaN:t>0?1:e.alpha}),GV={kernelName:Tl,backendName:"cpu",kernelFunc:vme};function bme(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{begin:s,end:i,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:p,shrinkAxisMask:f}=r;he(o,"stridedSlice");let{finalShapeSparse:d,finalShape:h,isIdentity:g,sliceDim0:m,isSimpleSlice:y,begin:x,end:C,strides:I}=gr.sliceInfo(o.shape,s,i,a,l,c,u,p,f),D;if(g)D=wt({inputs:{x:o},backend:e,attrs:{shape:h}});else if(m||y){b.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let O=gr.computeOutShape(x,C,I),L=Js({inputs:{x:o},backend:e,attrs:{begin:x,size:O}});D=wt({inputs:{x:L},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(L)}else{let O=e.bufferSync(o),L=fC(d,O,I,x);D=e.makeTensorInfo(h,L.dtype,L.values)}return D}var jV={kernelName:Hh,backendName:"cpu",kernelFunc:bme};function wme(t){let{inputs:n,backend:e,attrs:r}=t,{separator:o,nGramWidths:s,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:p}=n,f=e.data.get(u.dataId).values,d=e.data.get(p.dataId).values,[h,g]=dC(f,d,o,s,i,a,l,c);return[e.makeTensorInfo([h.length],"string",h),e.makeTensorInfo(p.shape,"int32",g)]}var HV={kernelName:Wh,backendName:"cpu",kernelFunc:wme};function Cme(t){let{inputs:n,backend:e,attrs:r}=t,{skipEmpty:o}=r,{input:s,delimiter:i}=n;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let a=e.data.get(s.dataId).values,l=e.data.get(i.dataId).values[0],[c,u,p]=hC(a,l,o),f=u.length;return[e.makeTensorInfo([f,2],"int32",c),e.makeTensorInfo([f],"string",u),e.makeTensorInfo([2],"int32",new Int32Array(p))]}var WV={kernelName:qh,backendName:"cpu",kernelFunc:Cme};function Ime(t){let{inputs:n,backend:e,attrs:r}=t,{numBuckets:o}=r,{input:s}=n;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let i=e.data.get(s.dataId).values,a=mC(i,o);return e.makeTensorInfo(s.shape,"int32",a)}var qV={kernelName:Kh,backendName:"cpu",kernelFunc:Ime};var Sme=Je("Tan",t=>Math.tan(t)),KV={kernelName:"Tan",backendName:"cpu",kernelFunc:Sme};var Tme=Je(Sl,t=>Math.tanh(t)),XV={kernelName:Sl,backendName:"cpu",kernelFunc:Tme};function Eme(t){let{inputs:n,backend:e}=t,{tensor:r,indices:o,updates:s}=n,{sliceRank:i,numUpdates:a,sliceSize:l,strides:c,outputSize:u}=_.calculateShapes(s,o,r.shape),p=!1,f=e.bufferSync(o),d=e.bufferSync(s),h=e.bufferSync(r),g=Ei(f,d,r.shape,u,l,a,i,c,h,p);return e.makeTensorInfo(r.shape,g.dtype,g.values)}var YV={kernelName:Lh,backendName:"cpu",kernelFunc:Eme};function Nme(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{reps:s}=r;he(o,"tile");let i=gC(e.bufferSync(o),s);return e.makeTensorInfo(i.shape,i.dtype,i.values)}var ZV={kernelName:Xi,backendName:"cpu",kernelFunc:Nme};function Dme(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{k:s,sorted:i}=r;he(o,"topk");let a=e.data.get(o.dataId).values,[l,c]=yC(a,o.shape,o.dtype,s,i);return[e.makeTensorInfo(l.shape,l.dtype,l.values),e.makeTensorInfo(c.shape,c.dtype,c.values)]}var QV={kernelName:Xh,backendName:"cpu",kernelFunc:Dme};function kme(t){let{inputs:n,attrs:e,backend:r}=t,{image:o,transforms:s}=n,{interpolation:i,fillMode:a,fillValue:l,outputShape:c}=e,[u,p,f,d]=o.shape,[h,g]=c??[p,f],m=[u,h,g,d],y=b.computeStrides(o.shape),x=y[0],C=y[1],I=y[2],D=b.computeStrides(m),O=D[0],L=D[1],B=D[2],V=b.getTypedArrayFromDType(o.dtype,b.sizeFromShape(m));V.fill(l);let F=r.data.get(o.dataId).values,G=r.data.get(s.dataId).values;for(let Q=0;Q<u;++Q){let oe=s.shape[0]===1?G:G.subarray(Q*8,Q*8+8);for(let ae=0;ae<h;++ae)for(let J=0;J<g;++J)for(let re=0;re<d;++re){let se,pe=oe[6]*J+oe[7]*ae+1;if(pe===0)continue;let xe=(oe[0]*J+oe[1]*ae+oe[2])/pe,be=(oe[3]*J+oe[4]*ae+oe[5])/pe,Te=JV(xe,f,a),Se=JV(be,p,a);switch(i){case"nearest":se=Ome(F,p,f,x,C,I,Q,Se,Te,re,l);break;case"bilinear":se=Fme(F,p,f,x,C,I,Q,Se,Te,re,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let Re=Q*O+ae*L+J*B+re;V[Re]=se}return r.makeTensorInfo(m,o.dtype,V)}return{dataId:r.write(V,m,o.dtype),shape:o.shape,dtype:o.dtype}}var eU={kernelName:Yh,backendName:"cpu",kernelFunc:kme};function JV(t,n,e){switch(e){case"reflect":return Ame(t,n);case"wrap":return _me(t,n);case"nearest":return Mme(t,n);default:return Rme(t,n)}}function Ame(t,n){let e=t;if(e<0)if(n<=1)e=0;else{let r=2*n;e<r&&(e=r*Math.trunc(-e/r)+e),e=e<-n?e+r:-e-1}else if(e>n-1)if(n<=1)e=0;else{let r=2*n;e-=r*Math.trunc(e/r),e>=n&&(e=r-e-1)}return b.clamp(0,e,n-1)}function _me(t,n){let e=t;if(e<0)if(n<=1)e=0;else{let r=n-1;e+=n*(Math.trunc(-e/r)+1)}else if(e>n-1)if(n<=1)e=0;else{let r=n-1;e-=n*Math.trunc(e/r)}return b.clamp(0,e,n-1)}function Rme(t,n){return t}function Mme(t,n){return b.clamp(0,t,n-1)}function ux(t,n,e,r,o,s,i,a,l,c,u){let p=i*r+a*o+l*s+c;return 0<=a&&a<n&&0<=l&&l<e?t[p]:u}function Ome(t,n,e,r,o,s,i,a,l,c,u){let p=Math.round(a),f=Math.round(l);return ux(t,n,e,r,o,s,i,p,f,c,u)}function Fme(t,n,e,r,o,s,i,a,l,c,u){let p=Math.floor(a),f=Math.floor(l),d=p+1,h=f+1,g=(h-l)*ux(t,n,e,r,o,s,i,p,f,c,u)+(l-f)*ux(t,n,e,r,o,s,i,p,h,c,u),m=(h-l)*ux(t,n,e,r,o,s,i,d,f,c,u)+(l-f)*ux(t,n,e,r,o,s,i,d,h,c,u);return(d-a)*g+(a-p)*m}function $me(t){let{inputs:n,attrs:e,backend:r}=t,{axis:o}=e,{x:s}=n;he(s,"unique");let i=r.data.get(s.dataId).values,{outputValues:a,outputShape:l,indices:c}=xC(i,o,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}var tU={kernelName:Zh,backendName:"cpu",kernelFunc:$me};function Lme(t){let{inputs:n,backend:e,attrs:r}=t,{value:o}=n,{axis:s}=r;s<0&&(s+=o.shape.length);let i=o.shape.length,a=o.shape[s],l=new Array(i-1),c=0;for(let d=0;d<i;d++)d!==s&&(l[c++]=o.shape[d]);let u=new Array(i).fill(0),p=o.shape.slice();p[s]=1;let f=new Array(a);for(let d=0;d<f.length;d++){u[s]=d;let h=Js({inputs:{x:o},backend:e,attrs:{begin:u,size:p}});f[d]=wt({inputs:{x:h},backend:e,attrs:{shape:l}}),e.disposeIntermediateTensorInfo(h)}return f}var nU={kernelName:su,backendName:"cpu",kernelFunc:Lme};function Pme(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,segmentIds:s}=n,{numSegments:i}=r;he(o,"unsortedSegmentSum");let a=o.shape.length,l=s.shape.length,c=[],u=[],p=a-l,f=s;for(let h=0;h<p;++h){let g=xg({inputs:{input:f},backend:e,attrs:{dim:h+1}});f=g,u.push(g)}for(let h=0;h<i;++h){let g=b.createScalarValue(h,"int32"),m=e.makeTensorInfo([],"int32",g),y=m4({inputs:{a:m,b:f},backend:e}),x=Zs({inputs:{x:y},backend:e,attrs:{dtype:"float32"}}),C=Tf({inputs:{a:x,b:o},backend:e}),I=jl({inputs:{x:C},backend:e,attrs:{axis:0,keepDims:!1}});c.push(I),u.push(m),u.push(y),u.push(x),u.push(C),u.push(I)}let d=Z4({inputs:c,backend:e,attrs:{axis:0}});return u.forEach(h=>e.disposeIntermediateTensorInfo(h)),d}var rU={kernelName:iu,backendName:"cpu",kernelFunc:Pme};var Bme=[DB,$9,kB,AB,V9,_B,RB,MB,OB,FB,$B,LB,PB,BB,zB,UB,GB,jB,HB,NB,WB,qB,KB,U9,XB,z9,G9,YB,L9,ZB,JB,ez,tz,nz,rz,oz,sz,iz,az,lz,cz,uz,pz,fz,dz,hz,mz,gz,yz,xz,vz,bz,Cz,wB,Iz,j9,Sz,H9,Tz,W9,Ez,Nz,Dz,q9,K9,kz,Az,_z,Rz,X9,Y9,P9,Mz,QB,Oz,Fz,$z,CB,Z9,Q9,Lz,J9,Pz,Bz,zz,Vz,Uz,Gz,jz,eB,Hz,Wz,qz,Kz,Yz,Zz,Qz,tB,Jz,eV,rV,nB,rB,oV,sV,iV,oB,aV,uV,pV,CC,fV,IB,iB,dV,hV,mV,gV,B9,ax,yV,SB,TB,EB,xV,vV,bV,wV,CV,IV,SV,pB,TV,NV,DV,kV,dB,AV,_V,RV,hB,tV,OV,FV,$V,LV,PV,BV,zV,VV,gB,UV,yB,xB,GV,jV,HV,WV,qV,vB,wz,KV,XV,YV,ZV,QV,eU,sB,tU,nU,rU,lV];for(let t of Bme)cv(t);var Nf={},IC={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function oU(t,n){Nf[t]=n}function ss(t,n){if(!(t in Nf)||n!=null){let r=Vme(t,n);if(r!==null)Nf[t]=r;else return console.log("Could not get context for WebGL version",t),null}let e=Nf[t];return e==null||e.isContextLost()?(delete Nf[t],ss(t)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),Nf[t])}function zme(t){if(!Z().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&t===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function Vme(t,n){if(t!==1&&t!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let e=n??zme(t);return e.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete Nf[t]},!1),Z().getBool("SOFTWARE_WEBGL_ENABLED")&&(IC.failIfMajorPerformanceCaveat=!1),t===1?e.getContext("webgl",IC)||e.getContext("experimental-webgl",IC):e.getContext("webgl2",IC)}var Df=(function(t){return t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH",t})(Df||{}),ro=(function(t){return t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD",t})(ro||{}),Gr=(function(t){return t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",t})(Gr||{});function kf(t,n){return[n,t]}function sU(t,n){return t*n}function px(t){let n=b.sizeFromShape(t),e=Math.ceil(n/4);return b.sizeToSquarishShape(e)}function da(t,n){return[Math.max(1,Math.ceil(n/2)),Math.max(1,Math.ceil(t/2))]}function iU(t,n){let[e,r]=da(t,n);return e*r*4}function fx(t,n){let e=t,r,o,s,i,a,l,c,u,p,f;return Z().getNumber("WEBGL_VERSION")===2?(r=e.R32F,o=e.R16F,s=e.RGBA16F,i=e.RGBA32F,a=e.RED,c=4,u=1,p=e.HALF_FLOAT,f=e.FLOAT,l=e.RGBA8):(r=t.RGBA,o=t.RGBA,s=t.RGBA,i=e.RGBA,a=t.RGBA,c=4,u=4,p=n!=null?n.HALF_FLOAT_OES:null,f=t.FLOAT,l=t.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:p,textureTypeFloat:f}}function $e(t,n){let e=n();return Z().getBool("DEBUG")&&Ume(t),e}function Ume(t){let n=t.getError();if(n!==t.NO_ERROR)throw new Error("WebGL Error: "+Hme(t,n))}var Gme=596e-10,jme=65504;function aU(t){return!!(Z().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||t===0||Gme<Math.abs(t)&&Math.abs(t)<jme)}function Hme(t,n){switch(n){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${n}`}}function dx(t,n){return Hl(t,()=>t.getExtension(n),'Extension "'+n+'" not supported on this browser.')}function lU(t,n){let e=Hl(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if($e(t,()=>t.shaderSource(e,n)),$e(t,()=>t.compileShader(e)),t.getShaderParameter(e,t.COMPILE_STATUS)===!1)throw console.log(t.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}function cU(t,n){let e=Hl(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if($e(t,()=>t.shaderSource(e,n)),$e(t,()=>t.compileShader(e)),Z().get("ENGINE_COMPILE_ONLY"))return e;if(t.getShaderParameter(e,t.COMPILE_STATUS)===!1)throw nk(n,t.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}var Wme=/ERROR: [0-9]+:([0-9]+):/g;function nk(t,n){let e=Wme.exec(n);if(e==null){console.log(`Couldn't parse line number in error: ${n}`),console.log(t);return}let r=+e[1],o=t.split(`
`),s=o.length.toString().length+2,i=o.map((p,f)=>b.rightPad((f+1).toString(),s)+p),a=0;for(let p=0;p<i.length;p++)a=Math.max(i[p].length,a);let l=i.slice(0,r-1),c=i.slice(r-1,r),u=i.slice(r);console.log(l.join(`
`)),console.log(n.split(`
`)[0]),console.log(`%c ${b.rightPad(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join(`
`))}function uU(t){return Hl(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}function pU(t,n){if($e(t,()=>t.linkProgram(n)),!Z().get("ENGINE_COMPILE_ONLY")&&t.getProgramParameter(n,t.LINK_STATUS)===!1)throw console.log(t.getProgramInfoLog(n)),new Error("Failed to link vertex and fragment shaders.")}function TC(t,n){if($e(t,()=>t.validateProgram(n)),t.getProgramParameter(n,t.VALIDATE_STATUS)===!1)throw console.log(t.getProgramInfoLog(n)),new Error("Shader program validation failed.")}function fU(t,n){let e=Hl(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return $e(t,()=>t.bindBuffer(t.ARRAY_BUFFER,e)),$e(t,()=>t.bufferData(t.ARRAY_BUFFER,n,t.STATIC_DRAW)),e}function dU(t,n){let e=Hl(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return $e(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,e)),$e(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,n,t.STATIC_DRAW)),e}function hU(t){return Hl(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}function mU(t,n){let e=Z().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||n<=0){let r=`[${t}x${n}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(t>e||n>e){let r=`[${t}x${n}]`,o=`[${e}x${e}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+o+".")}}function gU(t){return Hl(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function rk(t,n,e,r,o,s,i){let a=t.getAttribLocation(n,e);return a===-1?!1:($e(t,()=>t.bindBuffer(t.ARRAY_BUFFER,r)),$e(t,()=>t.vertexAttribPointer(a,o,t.FLOAT,!1,s,i)),$e(t,()=>t.enableVertexAttribArray(a)),!0)}function qme(t,n,e){Xme(t,e),$e(t,()=>t.activeTexture(t.TEXTURE0+e)),$e(t,()=>t.bindTexture(t.TEXTURE_2D,n))}function yU(t,n,e){return Hl(t,()=>t.getUniformLocation(n,e),'uniform "'+e+'" not present in program.')}function xU(t,n,e){return t.getUniformLocation(n,e)}function vU(t,n,e,r){$e(t,()=>qme(t,n,r)),$e(t,()=>t.uniform1i(e,r))}function EC(t,n,e){$e(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),$e(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0))}function ok(t,n){$e(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),$e(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function hx(t){let n=t.checkFramebufferStatus(t.FRAMEBUFFER);if(n!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Kme(t,n))}function Kme(t,n){switch(n){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${n}`}}function Hl(t,n,e){let r=$e(t,()=>n());if(r==null)throw new Error(e);return r}function Xme(t,n){let e=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=n+t.TEXTURE0;if(r<t.TEXTURE0||r>e){let o=`[gl.TEXTURE0, gl.TEXTURE${e}]`;throw new Error(`textureUnit must be in ${o}.`)}}function Bu(t,n=2){return b.sizeFromShape(t.slice(0,t.length-n))}function zu(t){if(t.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function mx(t){let n=[1,1,1];return t.length===0||t.length===1&&t[0]===1||(n=[Bu(t),...zu(t)]),n}function bU(t,n=!1){let e=Z().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=Z().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&Z().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=e/2),n&&(e=e*2,r=r*2,t=t.map((a,l)=>l>=t.length-2?b.nearestLargerEven(t[l]):t[l]),t.length===1&&(t=[2,t[0]])),t.length!==2&&(t=b.squeezeShape(t).newShape);let o=b.sizeFromShape(t),s=null;t.length<=1&&o<=e?s=[1,o]:t.length===2&&t[0]<=e&&t[1]<=e?s=t:t.length===3&&t[0]*t[1]<=e&&t[2]<=e?s=[t[0]*t[1],t[2]]:t.length===3&&t[0]<=e&&t[1]*t[2]<=e?s=[t[0],t[1]*t[2]]:t.length===4&&t[0]*t[1]*t[2]<=e&&t[3]<=e?s=[t[0]*t[1]*t[2],t[3]]:t.length===4&&t[0]<=e&&t[1]*t[2]*t[3]<=e&&(s=[t[0],t[1]*t[2]*t[3]]);let i=s!=null&&Math.max(...s)>r&&Math.min(...s)<=(n?2:1)&&Math.min(...s)>0;if(s==null||i)if(n){let a=Bu(t),l=2,c=2;t.length&&([l,c]=zu(t)),o=a*(l/2)*(c/2),s=b.sizeToSquarishShape(o).map(u=>u*2)}else s=b.sizeToSquarishShape(o);return s}function SC(t){return t%2===0}function Af(t,n){if(t=t.slice(-2),n=n.slice(-2),b.arraysEqual(t,n)||!t.length||!n.length||t[0]===0||t[1]===0||n[0]===0||n[1]===0)return!0;if(t.length!==n.length){let e=t[t.length-1],r=n[n.length-1];if(e===r||SC(e)&&SC(r)&&(t[0]===1||n[0]===1))return!0}return t[1]===n[1]&&SC(t[0])&&SC(n[0])}var J4,ek;function wU(t){if(J4==null){let n=ss(t);J4=n.getParameter(n.MAX_TEXTURE_SIZE)}return J4}function CU(t){if(ek==null){let n=ss(t);ek=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,ek)}function IU(t){if(t===0)return 0;let n,e=ss(t);return Es(e,"EXT_disjoint_timer_query_webgl2")&&t===2?n=2:Es(e,"EXT_disjoint_timer_query")?n=1:n=0,n}function Es(t,n){return t.getExtension(n)!=null}function sk(t){try{if(ss(t)!=null)return!0}catch(n){return console.log("Error when getting WebGL context: ",n),!1}return!1}function SU(t){if(t===0)return!1;let n=ss(t);if(t===1){if(!Es(n,"OES_texture_float"))return!1}else if(!Es(n,"EXT_color_buffer_float"))return!1;return tk(n)}function TU(t){if(t===0)return!1;let n=ss(t);if(t===1){if(!Es(n,"OES_texture_float")||!Es(n,"WEBGL_color_buffer_float"))return!1}else{if(Es(n,"EXT_color_buffer_float"))return tk(n);let r="EXT_color_buffer_half_float";if(Es(n,r)){let o=n.getExtension(r);return Yme(n,o)}return!1}return tk(n)}function tk(t){let n=fx(t),e=t.createTexture();t.bindTexture(t.TEXTURE_2D,e),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatFloat,1,1,0,n.textureFormatFloat,n.textureTypeFloat,null);let s=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,s),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0);let i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(e),t.deleteFramebuffer(s),i}function Yme(t,n){let e=fx(t,n),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);let i=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,i),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);let a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(i),a}function EU(t){return t!==2?!1:ss(t).fenceSync!=null}function ha(t,n){Array.isArray(t)||(t=[t]),t.forEach(e=>{e!=null&&b.assert(e.dtype!=="complex64",()=>`${n} does not support complex64 tensors in the WebGL backend.`)})}var Ke=Z();Ke.registerFlag("HAS_WEBGL",()=>Ke.getNumber("WEBGL_VERSION")>0);Ke.registerFlag("WEBGL_VERSION",()=>sk(2)?2:sk(1)?1:0);Ke.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Ke.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Ke.get("WEBGL_VERSION")===2);Ke.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Ke.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Ke.registerFlag("WEBGL_PACK",()=>Ke.getBool("HAS_WEBGL"));Ke.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Ke.getBool("WEBGL_PACK"));Ke.registerFlag("WEBGL_PACK_CLIP",()=>Ke.getBool("WEBGL_PACK"));Ke.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Ke.getBool("WEBGL_PACK"));Ke.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Ke.getBool("WEBGL_PACK"));Ke.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Ke.getBool("WEBGL_PACK"));Ke.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Ke.getBool("WEBGL_PACK"));Ke.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Ke.getBool("WEBGL_PACK"));Ke.registerFlag("WEBGL_PACK_REDUCE",()=>Ke.getBool("WEBGL_PACK"));Ke.registerFlag("WEBGL_LAZILY_UNPACK",()=>Ke.getBool("WEBGL_PACK"));Ke.registerFlag("WEBGL_CONV_IM2COL",()=>Ke.getBool("WEBGL_PACK"));Ke.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Ke.getBool("WEBGL_PACK"));Ke.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>wU(Ke.getNumber("WEBGL_VERSION")));Ke.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>CU(Ke.getNumber("WEBGL_VERSION")));Ke.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let t=Ke.getNumber("WEBGL_VERSION");return t===0?0:IU(t)});Ke.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Ke.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!pu.isMobile());Ke.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>SU(Ke.getNumber("WEBGL_VERSION")));Ke.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Ke.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Ke.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Ke.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>TU(Ke.getNumber("WEBGL_VERSION")));Ke.registerFlag("WEBGL_FENCE_API_ENABLED",()=>EU(Ke.getNumber("WEBGL_VERSION")));Ke.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Ke.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Ke.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(typeof t!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${t}.`);if(t<0&&t!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)});Ke.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>pu.isMobile()?1:-1,t=>{if(typeof t!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${t}.`);if(t<0&&t!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)});Ke.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Ke.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Ke.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Ke.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Ke.registerFlag("WEBGL_EXP_CONV",()=>!1);Ke.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Ke.getBool("IS_TEST"));Ke.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Ke.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Ke.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Ke.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function _n(){let t,n,e,r,o,s,i,a,l,c;return Z().getNumber("WEBGL_VERSION")===2?(t="#version 300 es",n="in",e="out",r="in",o="texture",s="outputColor",i="out vec4 outputColor;",a=Z().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(t="",n="attribute",e="varying",r="varying",o="texture2D",s="gl_FragColor",i="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:t,attribute:n,varyingVs:e,varyingFs:r,texture2D:o,output:s,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:l,defineRound:c}}function Ni(t,n,e="index"){let r=b.computeStrides(n);return r.map((o,s)=>{let i=`int ${t[s]} = ${e} / ${o}`,a=s===r.length-1?`int ${t[s+1]} = ${e} - ${t[s]} * ${o}`:`index -= ${t[s]} * ${o}`;return`${i}; ${a};`}).join("")}function _f(t,n,e="index"){let r=b.computeStrides(n);return r.map((o,s)=>{let i=`int ${t[s]} = ${e} / outShapeStrides[${s}]`,a=s===r.length-1?`int ${t[s+1]} = ${e} - ${t[s]} * outShapeStrides[${s}]`:`index -= ${t[s]} * outShapeStrides[${s}]`;return`${i}; ${a};`}).join("")}function Zme(t,n){let e=t.length,r=t.map(s=>`${n}[${s}]`),o=new Array(e-1);o[e-2]=r[e-1];for(let s=e-3;s>=0;--s)o[s]=`(${o[s+1]} * ${r[s+1]})`;return o}function NU(t,n,e="index"){let r=t.map((s,i)=>i),o=Zme(r,n);return o.map((s,i)=>{let a=`int ${t[i]} = ${e} / ${o[i]}`,l=i===o.length-1?`int ${t[i+1]} = ${e} - ${t[i]} * ${o[i]}`:`index -= ${t[i]} * ${o[i]}`;return`${a}; ${l};`}).join("")}function vg(t){let n=b.computeStrides(t).map(e=>e.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${n[0]} + coords.y * ${n[1]} + coords.z;
  }
`}function bg(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var DC=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;var{getBroadcastDims:DU}=_;function kU(t,n,e){let r=[];if(t.forEach(d=>{let h=b.sizeFromShape(d.shapeInfo.logicalShape);if(d.shapeInfo.isUniform?r.push(`uniform float ${d.name}${h>1?`[${h}]`:""};`):(r.push(`uniform sampler2D ${d.name};`),r.push(`uniform int offset${d.name};`)),e.enableShapeUniforms){let{uniformShape:g}=kC(e.packedInputs,d.shapeInfo.logicalShape,d.shapeInfo.texShape);switch(g.length){case 1:r.push(`uniform int ${d.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${d.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${d.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${d.name}Shape;`);break;default:break}r.push(`uniform ivec2 ${d.name}TexShape;`)}}),e.enableShapeUniforms){switch(n.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break;default:break}r.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(d=>{r.push(`uniform ${d.type} ${d.name}${d.arrayIndex?`[${d.arrayIndex}]`:""};`)});let o=r.join(`
`),s=t.map(d=>Qme(d,n,e.packedInputs,e.enableShapeUniforms)).join(`
`),i=n.texShape,a=_n(),l=tge(a),c,u,p=oge(a);return n.isPacked?(c=Jme(n.logicalShape,i,e.enableShapeUniforms),u=rge(a)):(c=ege(n.logicalShape,i,e.enableShapeUniforms),u=nge(a)),e.packedInputs&&(p+=lge),[p,l,u,o,c,s,e.userCode].join(`
`)}function Cg(t,n=!1){let e=t.shapeInfo.logicalShape;switch(e.length){case 0:return bge(t,n);case 1:return Cge(t,n);case 2:return Sge(t,n);case 3:return Ege(t,n);case 4:return Dge(t,n);case 5:return kge(t);case 6:return Age(t);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function AU(t,n){switch(t.shapeInfo.logicalShape.length){case 0:return vge(t);case 1:return wge(t,n);case 2:return Ige(t,n);case 3:return Tge(t,n);default:return Nge(t,n)}}function Qme(t,n,e=!1,r){let o="";e?o+=AU(t,r):o+=Cg(t,r);let s=t.shapeInfo.logicalShape,i=n.logicalShape;return s.length<=i.length&&(e?o+=_ge(t,n):o+=Rge(t,n)),o}function Jme(t,n,e){switch(t.length){case 0:return _U();case 1:return cge(t,n,e);case 2:return yge(t,n,e);case 3:return pge(t,n,e);default:return dge(t,n,e)}}function ege(t,n,e){switch(t.length){case 0:return _U();case 1:return uge(t,n,e);case 2:return xge(t,n,e);case 3:return fge(t,n,e);case 4:return hge(t,n,e);case 5:return mge(t,n);case 6:return gge(t,n);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}function tge(t){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${t.texture2D}(textureSampler, uv).r;
    }
  `}function nge(t){return`
    void setOutput(float val) {
      ${t.output} = vec4(val, 0, 0, 0);
    }
  `}function rge(t){return`
    void setOutput(vec4 val) {
      ${t.output} = val;
    }
  `}function oge(t){return`${t.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${t.varyingFs} vec2 resultUV;
    ${t.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${t.defineSpecialNaN}
    ${t.defineSpecialInf}
    ${t.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${sge}
    ${ige}
    ${age}
  `}var sge=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,ige=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,age=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,lge=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function _U(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function cge(t,n,e){let r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];return r[0]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function uge(t,n,e){return n[0]===1?e?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${n[1]}.0);
      }
    `:n[1]===1?e?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${n[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      return resTexRC.x * ${n[1]} + resTexRC.y;
    }
  `}function pge(t,n,e){if(e)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],o=Math.ceil(t[2]/2),s=o*Math.ceil(t[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec3(b, r, c);
    }
  `}function fge(t,n,e){if(e)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${_f(["r","c","d"],t)}
    return ivec3(r, c, d);
  }
`;let r=Ni(["r","c","d"],t);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function dge(t,n,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],o=Math.ceil(t[t.length-1]/2),s=o*Math.ceil(t[t.length-2]/2),i=s,a="",l="b, r, c";for(let c=2;c<t.length-1;c++)i*=t[t.length-c-1],a=`
      int b${c} = index / ${i};
      index -= b${c} * ${i};
    `+a,l=`b${c}, `+l;return`
    ivec${t.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${a}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec${t.length}(${l});
    }
  `}function hge(t,n,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${_f(["r","c","d","d2"],t)}
      return ivec4(r, c, d, d2);
    }
  `;let r=Ni(["r","c","d","d2"],t);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function mge(t,n){let e=Ni(["r","c","d","d2","d3"],t);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${n[0]},
                             ${n[1]}));

      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      ${e}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function gge(t,n){let e=Ni(["r","c","d","d2","d3","d4"],t);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      ${e}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function yge(t,n,e){let r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(b.arraysEqual(t,n))return e?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;let o=Math.ceil(t[1]/2);return e?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec2(r, c);
    }
  `}function xge(t,n,e){return b.arraysEqual(t,n)?e?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));
      }
    `:t[1]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${n[0]}, ${n[1]}));
        int index = resTexRC.x * ${n[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:t[0]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${n[0]}, ${n[1]}));
        int index = resTexRC.x * ${n[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:e?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;
      int r = index / ${t[1]};
      int c = index - r * ${t[1]};
      return ivec2(r, c);
    }
  `}function Rf(t){return`offset${t}`}function vge(t){let n=t.name,e="get"+n.charAt(0).toUpperCase()+n.slice(1),r=_n();return`
    vec4 ${e}() {
      return ${r.texture2D}(${n}, halfCR);
    }
  `}function bge(t,n){let e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`float ${r}() {return ${e};}`;let[o,s]=t.shapeInfo.texShape;if(o===1&&s===1)return`
      float ${r}() {
        return sampleTexture(${e}, halfCR);
      }
    `;let i=Rf(e);if(n)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${i});
      return sampleTexture(${e}, uv);
    }
  `;let[a,l]=t.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${i});
      return sampleTexture(${e}, uv);
    }
  `}function wge(t,n){let e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),o=t.shapeInfo.texShape,s=_n();if(n)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${e}, uv);
    }
  `;let i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${s.texture2D}(${e}, uv);
    }
  `}function Cge(t,n){let e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(t.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${Ig(t)}
      }
    `;let o=t.shapeInfo.texShape,s=o[0],i=o[1];if(i===1&&s===1)return`
      float ${r}(int index) {
        return sampleTexture(${e}, halfCR);
      }
    `;let a=Rf(e);return i===1?n?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${e}TexShape[0]));
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${s}.0);
        return sampleTexture(${e}, uv);
      }
    `:s===1?n?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${e}TexShape[1]), 0.5);
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${e}, uv);
      }
    `:n?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${a});
      return sampleTexture(${e}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${s}, ${i}, index + ${a});
      return sampleTexture(${e}, uv);
    }
  `}function Ige(t,n){let e=t.shapeInfo.logicalShape,r=t.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape,i=s[0],a=s[1],l=_n();if(s!=null&&b.arraysEqual(e,s))return n?`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(n)return`
    vec4 ${o}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;let c=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],u=Math.ceil(e[1]/2);return`
    vec4 ${o}(int row, int col) {
      vec2 uv = packedUVfrom2D(${u}, ${c[0]}, ${c[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function Sge(t,n){let e=t.shapeInfo.logicalShape,r=t.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape;if(s!=null&&b.arraysEqual(e,s)){if(n)return`
      float ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;let f=s[0],d=s[1];return`
    float ${o}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${d}.0, ${f}.0);
      return sampleTexture(${r}, uv);
    }
  `}let{newShape:i,keptDims:a}=b.squeezeShape(e),l=i;if(l.length<e.length){let f=Sg(t,l),d=["row","col"];return`
      ${Cg(f,n)}
      float ${o}(int row, int col) {
        return ${o}(${Tg(d,a)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${o}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));
        ${Ig(t)}
      }
    `;let c=s[0],u=s[1],p=Rf(r);return u===1?n?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${r}, uv);
    }
  `:c===1?n?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:n?`
      float ${o}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${p};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${o}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${e[1]} + col + ${p};
    vec2 uv = uvFromFlat(${c}, ${u}, index);
    return sampleTexture(${r}, uv);
  }
`}function Tge(t,n){let e=t.shapeInfo.logicalShape,r=t.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(e[0]===1){let f=e.slice(1),d=[1,2],h=Sg(t,f),g=["b","row","col"];return`
        ${AU(h,n)}
        vec4 ${o}(int b, int row, int col) {
          return ${o}(${Tg(g,d)});
        }
      `}let a=_n();if(n)return`
    vec4 ${o}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `;let l=i[0],c=i[1],u=Math.ceil(e[2]/2),p=u*Math.ceil(e[1]/2);return`
    vec4 ${o}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${c}, ${p}, ${u}, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `}function Ege(t,n){let e=t.shapeInfo.logicalShape,r=t.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e[1]*e[2],i=e[2],{newShape:a,keptDims:l}=b.squeezeShape(e),c=a;if(c.length<e.length){let g=Sg(t,c),m=["row","col","depth"];return`
        ${Cg(g,n)}
        float ${o}(int row, int col, int depth) {
          return ${o}(${Tg(m,l)});
        }
      `}if(t.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${i}, 1)));
        ${Ig(t)}
      }
    `;let u=t.shapeInfo.texShape,p=u[0],f=u[1],d=t.shapeInfo.flatOffset;if(f===s&&d==null)return n?`
      float ${o}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${o}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${f}.0, ${p}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(f===i&&d==null)return n?`
      float ${o}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${o}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${f}.0, ${p}.0);
      return sampleTexture(${r}, uv);
    }
  `;let h=Rf(r);return n?`
    float ${o}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${h};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${o}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${i} + depth + ${h};
        vec2 uv = uvFromFlat(${p}, ${f}, index);
        return sampleTexture(${r}, uv);
      }
  `}function Nge(t,n){let e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),o=_n();if(n)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${e}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${e}, uv);
    }
  `;let s=t.shapeInfo.logicalShape,i=s.length,a=t.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=l[0],u=l[1],p=Math.ceil(s[i-1]/2),f=p*Math.ceil(s[i-2]/2),d="int b, int row, int col",h=`b * ${f} + (row / 2) * ${p} + (col / 2)`;for(let g=2;g<i-1;g++)d=`int b${g}, `+d,f*=s[i-g-1],h=`b${g} * ${f} + `+h;return`
    vec4 ${r}(${d}) {
      int index = ${h};
      int texR = index / ${u};
      int texC = index - texR * ${u};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${c});
      return ${o.texture2D}(${e}, uv);
    }
  `}function Dge(t,n){let e=t.shapeInfo.logicalShape,r=t.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e[3],i=e[2]*s,a=e[1]*i,{newShape:l,keptDims:c}=b.squeezeShape(e);if(l.length<e.length){let x=Sg(t,l),C=["row","col","depth","depth2"];return`
      ${Cg(x,n)}
      float ${o}(int row, int col, int depth, int depth2) {
        return ${o}(${Tg(C,c)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${i}, ${s}, 1)));
        ${Ig(t)}
      }
    `;let u=t.shapeInfo.flatOffset,p=t.shapeInfo.texShape,f=p[0],d=p[1],h=`int stride2 = ${r}Shape[3];`,g=`int stride1 = ${r}Shape[2] * stride2;`,m=`int stride0 = ${r}Shape[1] * stride1;`;if(d===a&&u==null)return n?`
      float ${o}(int row, int col, int depth, int depth2) {
        ${h}
        ${g}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(d===s&&u==null)return n?`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${e[1]*e[2]}, ${e[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;let y=Rf(r);return n?`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${h}
      ${g}
      ${m}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${f}, ${d}, index + ${y});
      return sampleTexture(${r}, uv);
    }
  `}function kge(t){let n=t.shapeInfo.logicalShape,e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),o=n[4],s=n[3]*o,i=n[2]*s,a=n[1]*i,{newShape:l,keptDims:c}=b.squeezeShape(n);if(l.length<n.length){let g=Sg(t,l),m=["row","col","depth","depth2","depth3"];return`
      ${Cg(g)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${Tg(m,c)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${i}, ${s}, ${o})) +
          depth3;
        ${Ig(t)}
      }
    `;let u=t.shapeInfo.flatOffset,p=t.shapeInfo.texShape,f=p[0],d=p[1];if(d===a&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${s}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${f}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(d===o&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${n[1]*n[2]*n[3]},
               ${n[2]*n[3]}, ${n[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${f}.0);
        return sampleTexture(${e}, uv);
      }
    `;let h=Rf(e);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} + depth * ${s} +
          depth2 * ${o} + depth3 + ${h};
      vec2 uv = uvFromFlat(${f}, ${d}, index);
      return sampleTexture(${e}, uv);
    }
  `}function Age(t){let n=t.shapeInfo.logicalShape,e=t.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:o,keptDims:s}=b.squeezeShape(n);if(o.length<n.length){let m=Sg(t,o),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${Cg(m)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${Tg(y,s)});
      }
    `}let i=n[5],a=n[4]*i,l=n[3]*a,c=n[2]*l,u=n[1]*c;if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${c}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${Ig(t)}
      }
    `;let p=t.shapeInfo.flatOffset,f=t.shapeInfo.texShape,d=f[0],h=f[1];if(h===u&&p==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${a}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${d}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(h===i&&p==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${n[1]*n[2]*n[3]*n[4]},
               ${n[2]*n[3]*n[4]},
               ${n[3]*n[4]},
               ${n[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${d}.0);
        return sampleTexture(${e}, uv);
      }
    `;let g=Rf(e);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${c} + depth * ${l} +
          depth2 * ${a} + depth3 * ${i} + depth4 + ${g};
      vec2 uv = uvFromFlat(${d}, ${h}, index);
      return sampleTexture(${e}, uv);
    }
  `}function Ig(t){let n=t.name,e=b.sizeFromShape(t.shapeInfo.logicalShape);return e<2?`return ${n};`:`
    for (int i = 0; i < ${e}; i++) {
      if (i == index) {
        return ${n}[i];
      }
    }
  `}function _ge(t,n){let e=t.name,r=e.charAt(0).toUpperCase()+e.slice(1),o="get"+r+"AtOutCoords",s=t.shapeInfo.logicalShape.length,i=n.logicalShape.length,a=DU(t.shapeInfo.logicalShape,n.logicalShape),l=st(i),c=i-s,u,p=["x","y","z","w","u","v"];s===0?u="":i<2&&a.length>=1?u="coords = 0;":u=a.map(x=>`coords.${p[x+c]} = 0;`).join(`
`);let f="";i<2&&s>0?f="coords":f=t.shapeInfo.logicalShape.map((x,C)=>`coords.${p[C+c]}`).join(", ");let d="return outputValue;",g=b.sizeFromShape(t.shapeInfo.logicalShape)===1,y=b.sizeFromShape(n.logicalShape)===1;if(s===1&&!g&&!y)d=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(g&&!y)i===1?d=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:d=`
        return vec4(outputValue.x);
      `;else if(a.length){let x=s-2,C=s-1;a.indexOf(x)>-1&&a.indexOf(C)>-1?d="return vec4(outputValue.x);":a.indexOf(x)>-1?d="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(C)>-1&&(d="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${o}() {
      ${l} coords = getOutputCoords();
      ${u}
      vec4 outputValue = get${r}(${f});
      ${d}
    }
  `}function Rge(t,n){let e=t.name,r=e.charAt(0).toUpperCase()+e.slice(1),o="get"+r+"AtOutCoords",s=n.texShape,i=t.shapeInfo.texShape,a=t.shapeInfo.logicalShape.length,l=n.logicalShape.length;if(!t.shapeInfo.isUniform&&a===l&&t.shapeInfo.flatOffset==null&&b.arraysEqual(i,s))return`
      float ${o}() {
        return sampleTexture(${e}, resultUV);
      }
    `;let c=st(l),u=DU(t.shapeInfo.logicalShape,n.logicalShape),p=l-a,f,d=["x","y","z","w","u","v"];a===0?f="":l<2&&u.length>=1?f="coords = 0;":f=u.map(g=>`coords.${d[g+p]} = 0;`).join(`
`);let h="";return l<2&&a>0?h="coords":h=t.shapeInfo.logicalShape.map((g,m)=>`coords.${d[m+p]}`).join(", "),`
    float ${o}() {
      ${c} coords = getOutputCoords();
      ${f}
      return get${r}(${h});
    }
  `}function st(t){if(t<=1)return"int";if(t===2)return"ivec2";if(t===3)return"ivec3";if(t===4)return"ivec4";if(t===5)return"ivec5";if(t===6)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function kC(t,n,e){let{newShape:r,keptDims:o}=b.squeezeShape(n),s=n.length,i=t&&s===3&&n[0]===1,a=i?n.slice(1):r,l=!t&&s>1&&!b.arraysEqual(n,e)&&r.length<s||i;return{useSqueezeShape:l,uniformShape:l?a:n,keptDims:o}}function Sg(t,n){let e=JSON.parse(JSON.stringify(t));return e.shapeInfo.logicalShape=n,e}function Tg(t,n){return n.map(e=>t[e]).join(", ")}function MU(t,n,e,r){let o=e.map((u,p)=>{let f={logicalShape:u.shape,texShape:u.isUniform?null:u.texData.texShape,isUniform:u.isUniform,isPacked:u.isUniform?!1:u.texData.isPacked,flatOffset:null};return u.texData!=null&&u.texData.slice!=null&&u.texData.slice.flatOffset>0&&(f.flatOffset=u.texData.slice.flatOffset),{name:n.variableNames[p],shapeInfo:f}}),s=o.map(u=>u.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=kU(o,i,n),l=cU(t.gl,a),c=t.createProgram(l);return Z().get("ENGINE_COMPILE_ONLY")?{program:n,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:s,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(t.buildVao(c),Object.assign({program:n,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:s,outShapeInfo:i},ik(t,n,c)))}function ik(t,n,e){let r=[],o=[],s,i,a,l=null,c=null;c=t.getUniformLocation(e,"NAN",!1),Z().getNumber("WEBGL_VERSION")===1&&(l=t.getUniformLocation(e,"INFINITY",!1));let u=!1;for(let p of n.variableNames){let f={name:p,uniform:t.getUniformLocation(e,p,u),offset:t.getUniformLocation(e,`offset${p}`,u)};n.enableShapeUniforms&&(f.shape=t.getUniformLocation(e,`${p}Shape`,u),f.texShape=t.getUniformLocation(e,`${p}TexShape`,u)),r.push(f)}if(n.enableShapeUniforms&&(s=t.getUniformLocation(e,"outShape",u),a=t.getUniformLocation(e,"outShapeStrides",u),i=t.getUniformLocation(e,"outTexShape",u)),n.customUniforms)for(let p of n.customUniforms)o.push(t.getUniformLocation(e,p.name,u));return{variablesLocations:r,customUniformLocations:o,infLoc:l,nanLoc:c,outShapeLocation:s,outShapeStridesLocation:a,outTexShapeLocation:i}}function RU(t,n){if(t.length!==n.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${n.length} inputs`);t.forEach((e,r)=>{let o=e.logicalShape,s=n[r],i=s.shape;if(!b.arraysEqual(o,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${o} and ${i} must match`);if(e.isUniform&&s.isUniform)return;let a=e.texShape,l=s.isUniform?null:s.texData.texShape;if(!b.arraysEqual(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function OU(t,n,e,r,o){n.program.enableShapeUniforms||(RU(n.inShapeInfos,e),RU([n.outShapeInfo],[r]));let s=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):t.setOutputMatrixTexture(s.texture,i[0],i[1]),t.setProgram(n.webGLProgram),t.bindVertexArray(n.webGLProgram.vao),Z().getNumber("WEBGL_VERSION")===1&&n.infLoc!==null&&t.gl.uniform1f(n.infLoc,1/0),n.nanLoc!==null&&t.gl.uniform1f(n.nanLoc,NaN);for(let l=0;l<e.length;++l){let c=e[l],{uniform:u,offset:p,shape:f,texShape:d}=n.variablesLocations[l];if(f){let{uniformShape:h}=kC(n.program.packedInputs,c.shape,c.texData.texShape);switch(h.length){case 1:t.gl.uniform1iv(f,new Int32Array(h));break;case 2:t.gl.uniform2iv(f,new Int32Array(h));break;case 3:t.gl.uniform3iv(f,new Int32Array(h));break;case 4:t.gl.uniform4iv(f,new Int32Array(h));break;default:break}}if(d&&t.gl.uniform2i(d,c.texData.texShape[0],c.texData.texShape[1]),u!=null){if(c.isUniform){if(b.sizeFromShape(c.shape)<2)t.gl.uniform1f(u,c.uniformValues[0]);else{let h=c.uniformValues;h instanceof Float32Array||(h=new Float32Array(h)),t.gl.uniform1fv(u,h)}continue}c.texData.slice!=null&&p!=null&&t.gl.uniform1i(p,c.texData.slice.flatOffset),t.setInputMatrixTexture(c.texData.texture.texture,u,l)}}let a=n.outShapeLocation;if(a)switch(r.shape.length){case 1:t.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:t.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:t.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:t.gl.uniform4iv(a,new Int32Array(r.shape));break;default:break}if(n.outShapeStridesLocation){let l=b.computeStrides(r.shape);switch(r.shape.length){case 2:t.gl.uniform1iv(n.outShapeStridesLocation,new Int32Array(l));break;case 3:t.gl.uniform2iv(n.outShapeStridesLocation,new Int32Array(l));break;case 4:t.gl.uniform3iv(n.outShapeStridesLocation,new Int32Array(l));break;default:break}}if(n.outTexShapeLocation&&t.gl.uniform2i(n.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),n.program.customUniforms&&o)for(let l=0;l<n.program.customUniforms.length;++l){let c=n.program.customUniforms[l],u=n.customUniformLocations[l],p=o[l];if(c.type==="float")t.gl.uniform1fv(u,p);else if(c.type==="vec2")t.gl.uniform2fv(u,p);else if(c.type==="vec3")t.gl.uniform3fv(u,p);else if(c.type==="vec4")t.gl.uniform4fv(u,p);else if(c.type==="int")t.gl.uniform1iv(u,p);else if(c.type==="ivec2")t.gl.uniform2iv(u,p);else if(c.type==="ivec3")t.gl.uniform3iv(u,p);else if(c.type==="ivec4")t.gl.uniform4iv(u,p);else throw Error(`uniform type ${c.type} is not supported yet.`)}t.executeProgram()}function FU(t,n,e){let r="";n.concat(e).forEach(i=>{let a=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!i.isUniform){let l=i.texData.texShape,{useSqueezeShape:c,uniformShape:u,keptDims:p}=kC(t.packedInputs,i.shape,l),f="",d="",h="";if(u.length===1&&t.packedInputs){let D=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];f=`${D[0]>1}_${D[1]>1}`}else if(u.length===2&&!t.packedInputs)d=`${u[0]>1}_${u[1]>1}`;else if(u.length>2&&!t.packedInputs){let D=b.computeStrides(u);h=`${D[0]===l[1]}_${D[D.length-1]===l[1]}`}let g=i.shape.length,m=u.length===2&&b.arraysEqual(i.shape,l),y=b.sizeFromShape(i.shape)===1,x=_.getBroadcastDims(i.shape,e.shape),C=!t.packedInputs&&g===e.shape.length&&b.arraysEqual(l,e.texData.texShape),I=t.packedInputs||u.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${g}_${C}_${c?p:""}_${u.length}_${y}_${x}_${m}_${f}_${d}_${h}_${I}_${a}`}else{let l=i.isUniform?"uniform":i.texData.texShape;r+=`${i.shape}_${l}_${a}`}});let o=t.userCode,s=t.constructor.name;return s+="_"+r+"_"+o+`${Z().getNumber("WEBGL_VERSION")}`,s}function jt(t){return Z().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}var AC=class{constructor(n){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Df.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let e=_n();this.outputShape=n,this.enableShapeUniforms=jt(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?_f(["r","c","d"],n):Ni(["r","c","d"],n)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${e.output} = result;
      }
    `}};var _C=class{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Df.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let e=_n();this.outputShape=n,this.enableShapeUniforms=jt(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?_f(["r","c","d"],n):Ni(["r","c","d"],n)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${e.output} = result;
      }
    `}};var RC=class{constructor(n){this.variableNames=["A"],this.outTexUsage=ro.DOWNLOAD;let e=_n();this.outputShape=n,this.userCode=`
      ${DC}

      void main() {
        float x = getAAtOutCoords();
        ${e.output} = encode_float(x);
      }
    `}};var MC=class{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=ro.DOWNLOAD;let e=_n();this.outputShape=n,this.userCode=`
      ${DC}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${e.output} = encode_float(x);
      }
    `}};var Fge={R:0,G:1,B:2,A:3},gx=class{constructor(n,e=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let o=_n();this.outputShape=n,this.enableShapeUniforms=jt(this.outputShape.length);let s="result";e&&(s="floor(result * 255. + 0.5)");let i="";for(let a=0;a<r.length;a++){let l=r[a];i+=`
          if(offset == ${a}) {
            result = values[${Fge[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?bg():vg(n)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${r.length});

        flatIndex = idiv(flatIndex, ${r.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${o.texture2D}(A, uv);
          ${i}
        }
        ${o.output} = vec4(${s}, 0., 0., 0.);
      }
    `}};var OC=class{constructor(n,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=_n();this.outputShape=n,this.enableShapeUniforms=jt(this.outputShape.length);let o="",s="result";e&&(s="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){let l=i*2+a;o+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${n[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${n[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?bg():vg(n)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${o}

          ${r.output} = ${s};
        }
    `}};function $U(t){let n=_n(),e=`${n.version}
    precision highp float;
    ${n.attribute} vec3 clipSpacePos;
    ${n.attribute} vec2 uv;
    ${n.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return lU(t,e)}function LU(t){let n=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return fU(t,n)}function PU(t){let n=new Uint16Array([0,1,2,2,1,3]);return dU(t,n)}function yx(t,n,e,r,o,s){mU(n,e);let i=hU(t),a=t.TEXTURE_2D;return $e(t,()=>t.bindTexture(a,i)),$e(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),$e(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),$e(t,()=>t.texParameteri(a,t.TEXTURE_MIN_FILTER,t.NEAREST)),$e(t,()=>t.texParameteri(a,t.TEXTURE_MAG_FILTER,t.NEAREST)),Z().getNumber("WEBGL_VERSION")===1?$e(t,()=>t.texImage2D(a,0,r,n,e,0,o,s,null)):$e(t,()=>t.texStorage2D(a,1,r,n,e)),$e(t,()=>t.bindTexture(t.TEXTURE_2D,null)),{texture:i,texShape:[e,n]}}function ak(t){return t.internalFormatFloat}function BU(t,n,e,r){let[o,s]=kf(n,e);return yx(t,o,s,ak(r),r.textureFormatFloat,t.FLOAT)}function lk(t){return t.internalFormatHalfFloat}function zU(t,n,e,r){let[o,s]=kf(n,e);return yx(t,o,s,lk(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function ck(t){return t.downloadTextureFormat}function VU(t,n,e,r){let[o,s]=kf(n,e);return yx(t,o,s,ck(r),t.RGBA,t.UNSIGNED_BYTE)}function uk(t){return t.internalFormatPackedFloat}function UU(t,n,e,r){let[o,s]=da(n,e);return yx(t,o,s,uk(r),t.RGBA,t.FLOAT)}function pk(t){return t.internalFormatPackedHalfFloat}function GU(t,n,e,r){let[o,s]=da(n,e);return yx(t,o,s,pk(r),t.RGBA,r.textureTypeHalfFloat)}function jU(t,n,e){return $e(t,()=>t.bindBuffer(t.ARRAY_BUFFER,e)),rk(t,n,"clipSpacePos",e,3,20,0)&&rk(t,n,"uv",e,2,20,12)}function HU(t,n,e,r,o,s){$e(t,()=>t.bindTexture(t.TEXTURE_2D,n));let i,a,l;o instanceof Uint8Array?(i=new Uint8Array(e*r*4),a=t.UNSIGNED_BYTE,l=t.RGBA):(i=new Float32Array(e*r*4),a=t.FLOAT,l=s.internalFormatPackedFloat),i.set(o),Z().getNumber("WEBGL_VERSION")===2?$e(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,e,r,t.RGBA,a,i)):$e(t,()=>t.texImage2D(t.TEXTURE_2D,0,l,e,r,0,t.RGBA,a,i)),$e(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function WU(t,n,e){$e(t,()=>t.bindTexture(t.TEXTURE_2D,n)),e.data instanceof Uint8Array?Z().getNumber("WEBGL_VERSION")===2?$e(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,e.width,e.height,t.RGBA,t.UNSIGNED_BYTE,e.data)):$e(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,e.width,e.height,0,t.RGBA,t.UNSIGNED_BYTE,e.data)):Z().getNumber("WEBGL_VERSION")===2?$e(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,e)):$e(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,e)),$e(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function qU(t,n,e,r){let o=t.createBuffer();$e(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,o));let a=4*4*n*e;return $e(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,a,t.STREAM_READ)),$e(t,()=>t.readPixels(0,0,e,n,t.RGBA,t.FLOAT,0)),$e(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),o}function KU(t,n,e){let r=t,o=new Float32Array(e);return r.bindBuffer(r.PIXEL_PACK_BUFFER,n),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,o),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),o}function XU(t,n,e,r){let[o,s]=kf(n,e),i=4,a=new Uint8Array(sU(n*e,i));return $e(t,()=>t.readPixels(0,0,o,s,r.downloadTextureFormat,t.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function YU(t,n,e,r,o,s,i,a){let l=t,c=new Float32Array(iU(s,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,n),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function ZU(t,n,e){let r=new Float32Array(n*e*4);return $e(t,()=>t.readPixels(0,0,e,n,t.RGBA,t.FLOAT,r)),r}var Eg=class{constructor(n){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let e=Z().getNumber("WEBGL_VERSION");if(n!=null?(this.gl=n,oU(e,n)):this.gl=ss(e),n=this.gl,Z().getNumber("WEBGL_VERSION")===2){let s=n;this.createVertexArray=()=>$e(s,()=>s.createVertexArray()),this.bindVertexArray=i=>$e(s,()=>s.bindVertexArray(i)),this.deleteVertexArray=i=>$e(s,()=>s.deleteVertexArray(i)),this.getVertexArray=()=>$e(s,()=>s.getParameter(s.VERTEX_ARRAY_BINDING))}else if(n!=null){let s=n.getExtension("OES_vertex_array_object");if(s==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>$e(n,()=>s.createVertexArrayOES()),this.bindVertexArray=i=>$e(n,()=>s.bindVertexArrayOES(i)),this.deleteVertexArray=i=>$e(n,()=>s.deleteVertexArrayOES(i)),this.getVertexArray=()=>$e(n,()=>n.getParameter(s.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float",o="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),Z().getNumber("WEBGL_VERSION")===1){let s="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=dx(this.gl,s),Es(this.gl,i))this.textureHalfFloatExtension=dx(this.gl,i);else if(Z().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),Es(this.gl,o))this.colorBufferHalfFloatExtension=dx(this.gl,o);else if(Z().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",Es(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(Es(this.gl,o))this.colorBufferHalfFloatExtension=this.gl.getExtension(o);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=LU(this.gl),this.indexBuffer=PU(this.gl),this.framebuffer=gU(this.gl),this.textureConfig=fx(this.gl,this.textureHalfFloatExtension)}get debug(){return Z().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let n=this.gl;$e(n,()=>n.finish()),$e(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,null)),$e(n,()=>n.deleteFramebuffer(this.framebuffer)),$e(n,()=>n.bindBuffer(n.ARRAY_BUFFER,null)),$e(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,null)),$e(n,()=>n.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(n,e){return this.throwIfDisposed(),BU(this.gl,n,e,this.textureConfig)}createFloat16MatrixTexture(n,e){return this.throwIfDisposed(),zU(this.gl,n,e,this.textureConfig)}createUnsignedBytesMatrixTexture(n,e){return this.throwIfDisposed(),VU(this.gl,n,e,this.textureConfig)}uploadPixelDataToTexture(n,e){this.throwIfDisposed(),WU(this.gl,n,e)}uploadDenseMatrixToTexture(n,e,r,o){this.throwIfDisposed(),HU(this.gl,n,e,r,o,this.textureConfig)}createFloat16PackedMatrixTexture(n,e){return this.throwIfDisposed(),GU(this.gl,n,e,this.textureConfig)}createPackedMatrixTexture(n,e){return this.throwIfDisposed(),UU(this.gl,n,e,this.textureConfig)}deleteMatrixTexture(n){this.throwIfDisposed(),this.outputTexture===n&&(ok(this.gl,this.framebuffer),this.outputTexture=null),$e(this.gl,()=>this.gl.deleteTexture(n))}downloadByteEncodedFloatMatrixFromOutputTexture(n,e,r){return this.downloadMatrixDriver(n,()=>XU(this.gl,e,r,this.textureConfig))}downloadPackedMatrixFromBuffer(n,e,r,o,s,i){return YU(this.gl,n,e,r,o,s,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(n,e){return KU(this.gl,n,e)}createBufferFromTexture(n,e,r){this.bindTextureToFrameBuffer(n);let o=qU(this.gl,e,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),o}createAndWaitForFence(){let n=this.createFence(this.gl);return this.pollFence(n)}createFence(n){let e,r;if(Z().getBool("WEBGL_FENCE_API_ENABLED")){let o=n,s=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);n.flush(),r=()=>{let i=o.clientWaitSync(s,0,0);return i===o.ALREADY_SIGNALED||i===o.CONDITION_SATISFIED},e=s}else Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(e,Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:e,isFencePassed:r}}downloadMatrixFromPackedTexture(n,e,r){return this.downloadMatrixDriver(n,()=>ZU(this.gl,e,r))}createProgram(n){this.throwIfDisposed();let e=this.gl;this.vertexShader==null&&(this.vertexShader=$U(e));let r=uU(e);$e(e,()=>e.attachShader(r,this.vertexShader)),$e(e,()=>e.attachShader(r,n)),pU(e,r);let o=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&TC(e,o),o}buildVao(n){this.setProgram(n),this.bindVertexArray(n.vao);let e=this.gl;$e(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),jU(e,n,this.vertexBuffer)}deleteProgram(n){this.throwIfDisposed(),n===this.program&&(this.program=null),n!=null&&($e(this.gl,()=>this.gl.deleteProgram(n)),this.deleteVertexArray(n.vao))}setProgram(n){this.throwIfDisposed(),this.program=n,this.program!=null&&this.debug&&TC(this.gl,this.program),$e(this.gl,()=>this.gl.useProgram(n))}getUniformLocation(n,e,r=!0){return this.throwIfDisposed(),r?yU(this.gl,n,e):xU(this.gl,n,e)}getAttributeLocation(n,e){return this.throwIfDisposed(),$e(this.gl,()=>this.gl.getAttribLocation(n,e))}getUniformLocationNoThrow(n,e){return this.throwIfDisposed(),this.gl.getUniformLocation(n,e)}setInputMatrixTexture(n,e,r){this.throwIfDisposed(),this.throwIfNoProgram(),vU(this.gl,n,e,r)}setOutputMatrixTexture(n,e,r){this.setOutputMatrixTextureDriver(n,r,e)}setOutputPackedMatrixTexture(n,e,r){this.throwIfDisposed();let[o,s]=da(e,r);this.setOutputMatrixTextureDriver(n,o,s)}setOutputMatrixWriteRegion(n,e,r,o){this.setOutputMatrixWriteRegionDriver(r,n,o,e)}setOutputPackedMatrixWriteRegion(n,e,r,o){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&TC(this.gl,this.program),hx(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let n=this.gl;if(this.debug){let e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}$e(n,()=>n.drawElements(n.TRIANGLES,6,n.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),$e(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=dx(this.gl,Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let r=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=r.createQuery();return r.beginQuery(o.TIME_ELAPSED_EXT,s),s}let n=this.getQueryTimerExtensionWebGL1(),e=n.createQueryEXT();return n.beginQueryEXT(n.TIME_ELAPSED_EXT,e),e}endQuery(){if(Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let e=this.gl,r=this.getQueryTimerExtensionWebGL2();e.endQuery(r.TIME_ELAPSED_EXT);return}let n=this.getQueryTimerExtensionWebGL1();n.endQueryEXT(n.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(n){return te(this,null,function*(){return yield b.repeatedTry(()=>this.disposed||this.isQueryAvailable(n,Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(n,Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})}getQueryTime(n,e){if(e===0)return null;if(e===2){let r=this.gl;return r.getQueryParameter(n,r.QUERY_RESULT)/1e6}else{let r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(n,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(n,e){if(e===0)return!0;if(e===2){let r=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=r.getQueryParameter(n,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(o.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{let r=this.getQueryTimerExtensionWebGL1(),o=r.getQueryObjectEXT(n,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint}}pollFence(n){return new Promise(e=>{this.addItemToPoll(()=>n.isFencePassed(),()=>e())})}pollItems(){let n=Lge(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=n;++e){let{resolveFn:r}=this.itemsToPoll[e];r()}this.itemsToPoll=this.itemsToPoll.slice(n+1)}addItemToPoll(n,e){if(this.itemsToPoll.push({isDoneFn:n,resolveFn:e}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in Z().platform&&(r=Z().platform.setTimeoutCustom.bind(Z().platform)),b.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,r)}bindTextureToFrameBuffer(n){this.throwIfDisposed(),EC(this.gl,n,this.framebuffer),this.debug&&hx(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(EC(this.gl,this.outputTexture,this.framebuffer),this.debug&&hx(this.gl)):ok(this.gl,this.framebuffer)}downloadMatrixDriver(n,e){this.bindTextureToFrameBuffer(n);let r=e();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(n,e,r){this.throwIfDisposed();let o=this.gl;EC(o,n,this.framebuffer),this.debug&&hx(o),this.outputTexture=n,$e(o,()=>o.viewport(0,0,e,r)),$e(o,()=>o.scissor(0,0,e,r))}setOutputMatrixWriteRegionDriver(n,e,r,o){this.throwIfDisposed(),$e(this.gl,()=>this.gl.scissor(n,e,r,o))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function Lge(t){let n=0;for(;n<t.length&&t[n]();++n);return n-1}var{addImpl:QU,bincountImpl:FC,bincountReduceImpl:JU,bitwiseAndImpl:eG,castImpl:tG,ceilImpl:nG,concatImpl:rG,equalImpl:oG,expImpl:sG,expm1Impl:iG,floorImpl:aG,gatherNdImpl:lG,gatherV2Impl:cG,greaterImpl:uG,greaterEqualImpl:pG,lessImpl:fG,lessEqualImpl:dG,linSpaceImpl:hG,logImpl:mG,maxImpl:gG,maximumImpl:yG,minimumImpl:xG,multiplyImpl:vG,negImpl:bG,notEqualImpl:wG,prodImpl:CG,raggedGatherImpl:IG,raggedRangeImpl:SG,raggedTensorToTensorImpl:TG,rangeImpl:EG,rsqrtImpl:NG,scatterImpl:DG,sigmoidImpl:kG,simpleAbsImpl:$C,sliceImpl:AG,sparseFillEmptyRowsImpl:_G,sparseReshapeImpl:RG,sparseSegmentReductionImpl:LC,sqrtImpl:MG,staticRegexReplaceImpl:OG,stridedSliceImpl:FG,stringNGramsImpl:$G,stringSplitImpl:LG,stringToHashBucketFastImpl:PG,subImpl:BG,tileImpl:zG,topKImpl:VG,transposeImpl:Mf,uniqueImpl:UG}=B4;function fk(t,n){return["x","y","z","w","u","v"].slice(0,n).map(e=>`${t}.${e}`)}function zn(t,n){return n===1?[t]:fk(t,n)}function GG(t,n){if(t===1)return"rc";let e="";for(let r=0;r<t;r++)e+=n[r],r<t-1&&(e+=",");return e}var PC=class{constructor(n){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=n,this.rank=n.length,this.enableShapeUniforms=jt(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let e=zn("rc",this.rank),r=st(this.rank),o=this.getOutOfBoundsCondition(e),s=this.getSetup(e),i=this.getOutput(e);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${o}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(n){let e=[];for(let r=0;r<=1;r++)for(let o=0;o<=1;o++){let s=`${r===0?"r":"rp1"}, ${o===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)s=`${n[n.length-1-i]},`+s;e.push(s)}return e}getOutOfBoundsCondition(n){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let r=this.rank-2;r<this.rank;r++)e+=`${n[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(e+="||");return e}getSetup(n){if(this.rank===1)return"";let e=n.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],o=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${e[0]};
      int c = ${e[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${o};
    `}getOutput(n){let e=this.getSourceCoordsArr(n);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),
            cEdge ? 0. : getA(${e[1]}),
            rEdge ? 0. : getA(${e[2]}),
            rEdge || cEdge ? 0. : getA(${e[3]})`}};var Ng=class{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=n,this.enableShapeUniforms=jt(this.outputShape.length);let r="";for(let o=0;o<4;o++){let s="thisRC = rc;";o%2===1&&(s+="thisRC.z += 1;"),o>1&&(s+="thisRC.y += 1;"),r+=`
        ${s}
        ${o>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${o}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${o>0?"}":""}
      `}this.userCode=`
      ${Pge(e,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?bg():vg(n)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":n[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":n[2]};

        ${r}

        setOutput(result);
      }
    `}};function Pge(t,n){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${n?NU(["r","c","d"],"inputShape"):Ni(["r","c","d"],t)}
      return ivec3(r, c, d);
    }
  `}var BC=class{constructor(n){this.gpgpu=n,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(n,e,r){let o=HG(e,r),s=WG(n,o,r);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let i=jG(n,o,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();let l=this.freeTextures[s].pop();return this.usedTextures[s].push(l),l}let a;return o===Gr.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(n[0],n[1]):o===Gr.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(n[0],n[1]):o===Gr.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(n[0],n[1]):o===Gr.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(n[0],n[1]):o===Gr.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(n[0],n[1])),this.usedTextures[s].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(n,e,r,o){if(this.freeTextures==null)return;let s=HG(r,o),i=WG(e,s,o);i in this.freeTextures||(this.freeTextures[i]=[]);let a=jG(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,o),l=Z().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(n.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(n),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;let c=this.usedTextures[i],u=c&&c.indexOf(n);if(u==null||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[u]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;let n=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${n})`);let e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let n in this.freeTextures)this.freeTextures[n].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(let n in this.usedTextures)this.usedTextures[n].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function Bge(t,n){let e=t;if(n===e.R32F)return 4;if(n===e.R16F)return 2;if(n===e.RGBA32F)return 16;if(n===t.RGBA)return 16;if(n===e.RGBA16F)return 8;if(n===e.RGBA8)return 4;throw new Error(`Unknown internal format ${n}`)}function jG(t,n,e,r,o){let s=zge(n,r),i;if(o){let[l,c]=da(t[0],t[1]);i=l*c}else{let[l,c]=kf(t[0],t[1]);i=l*c}let a=Bge(e,s);return i*a}function zge(t,n){switch(t){case Gr.PACKED_2X2_FLOAT32:return uk(n);case Gr.PACKED_2X2_FLOAT16:return pk(n);case Gr.UNPACKED_FLOAT32:return ak(n);case Gr.UNPACKED_FLOAT16:return lk(n);case Gr.PACKED_4X1_UNSIGNED_BYTE:return ck(n);default:throw new Error(`Unknown physical texture type ${t}`)}}function Vge(t){return Z().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?Gr.PACKED_2X2_FLOAT32:Gr.UNPACKED_FLOAT32:t?Gr.PACKED_2X2_FLOAT16:Gr.UNPACKED_FLOAT16}function HG(t,n){if(t===ro.UPLOAD)return Gr.PACKED_2X2_FLOAT32;if(t===ro.RENDER||t==null)return Vge(n);if(t===ro.DOWNLOAD||t===ro.PIXELS)return Gr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function WG(t,n,e){return`${t[0]}_${t[1]}_${n}_${e}`}var kr=class{constructor(n,e){this.variableNames=["A"],this.outputShape=n,this.enableShapeUniforms=jt(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${e}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},rr="if (isnan(x)) return x;",qG="return x;",dk="return abs(x);";var KG="return (x >= 0.0) ? x : (exp(x) - 1.0);",XG=rr+`
  return (x < 0.0) ? 0.0 : x;
`,YG=rr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,ma="return x;",ZG="return 1.0 / (1.0 + exp(-1.0 * x));";var JG="return x;",ej=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,tj=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,nj=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,rj="return 1.0 / (1.0 + exp(-1.0 * x));",Po=class{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=jt(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${e}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}};var zC=class{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=n,this.enableShapeUniforms=jt(this.outputShape.length);let e=n.length,r=zn("rc",e),o=st(e),s=GG(e,r),i=r.slice(-2),a=e<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${o} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}};var Gge=Vr.whereImpl,jge=1e-7,Hge=1e-4,VC={};function Wge(t){return t in VC||(VC[t]={}),VC[t]}var qge=Z().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),Kge=600;function Xge(){return Z().global.screen==null?1024:Z().global.screen.height*Z().global.screen.width*window.devicePixelRatio*Kge/1024/1024}var oj=(()=>{class t extends Ua{nextDataId(){return t.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Z().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let r;if(e!=null){if(e instanceof Eg)r=e;else{let o=ss(Z().getNumber("WEBGL_VERSION"),e);r=new Eg(o)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let o=ss(Z().getNumber("WEBGL_VERSION"));r=new Eg(o),this.binaryCache=Wge(Z().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=r,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new BC(this.gpgpu),this.numMBBeforeWarning=Xge(),this.texData=new Ep(this,Ps())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,r,o,s,i,a){let l=this.makeTensorInfo(r,o),c=this.texData.get(l.dataId);c.isPacked=!1,c.texture={texture:e,texShape:[s,i]},c.texShape=[s,i];let u=mx(r),p=new gx(u,!1,a),f=this.runWebGLProgram(p,[l],o,[[s,i]]);return f.shape=r,c.texture=null,this.disposeIntermediateTensorInfo(l),f.dataId}write(e,r,o){if((Z().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Z().getBool("DEBUG"))&&this.checkNumericalProblems(e),o==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let s={id:this.nextDataId()};return this.texData.set(s,{shape:r,dtype:o,values:e,usage:ro.UPLOAD,refCount:1}),s}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){let r=this.texData.get(e);r.refCount++}decRef(e){if(this.texData.has(e)){let r=this.texData.get(e);r.refCount--}}move(e,r,o,s,i){if(Z().getBool("DEBUG")&&this.checkNumericalProblems(r),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:o,dtype:s,values:r,usage:ro.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let r=this.texData.get(e),{values:o,dtype:s,complexTensorInfos:i,slice:a,shape:l,isPacked:c}=r;if(a!=null){let d;c?d=new Po(l,ma):d=new kr(l,ma);let h=this.runWebGLProgram(d,[{dataId:e,shape:l,dtype:s}],s),g=this.readSync(h.dataId);return this.disposeIntermediateTensorInfo(h),g}if(o!=null)return this.convertAndCacheOnCPU(e);if(s==="string")return o;let u=this.activeTimers!=null,p;u&&(p=b.now());let f;if(s==="complex64"){let d=this.readSync(i.real.dataId),h=this.readSync(i.imag.dataId);f=_.mergeRealAndImagArrays(d,h)}else f=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=b.now()-p),this.convertAndCacheOnCPU(e,f)}read(e){return te(this,null,function*(){if(this.pendingRead.has(e)){let g=this.pendingRead.get(e);return new Promise(m=>g.push(m))}let r=this.texData.get(e),{values:o,shape:s,slice:i,dtype:a,complexTensorInfos:l,isPacked:c}=r;if(i!=null){let g;c?g=new Po(s,ma):g=new kr(s,ma);let m=this.runWebGLProgram(g,[{dataId:e,shape:s,dtype:a}],a),y=this.read(m.dataId);return this.disposeIntermediateTensorInfo(m),y}if(o!=null)return this.convertAndCacheOnCPU(e);if(Z().getBool("DEBUG")&&!Z().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&Z().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,p;if(a!=="complex64"&&Z().get("WEBGL_BUFFER_SUPPORTED")){p=this.decode(e);let g=this.texData.get(p.dataId);u=this.gpgpu.createBufferFromTexture(g.texture.texture,...px(s))}this.pendingRead.set(e,[]),a!=="complex64"&&(yield this.gpgpu.createAndWaitForFence());let f;if(a==="complex64"){let g=yield Promise.all([this.read(l.real.dataId),this.read(l.imag.dataId)]),m=g[0],y=g[1];f=_.mergeRealAndImagArrays(m,y)}else if(u==null)f=this.getValuesFromTexture(e);else{let g=b.sizeFromShape(s);f=this.gpgpu.downloadFloat32MatrixFromBuffer(u,g)}if(p!=null&&this.disposeIntermediateTensorInfo(p),u!=null){let g=this.gpgpu.gl;$e(g,()=>g.deleteBuffer(u))}let d=this.convertAndCacheOnCPU(e,f),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach(g=>g(d)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Ps().removeDataId(e,this),this.pendingDeletes--),d})}readToGPU(e,r={}){let o=this.texData.get(e),{values:s,shape:i,slice:a,dtype:l,isPacked:c,texture:u}=o;if(l==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let h;c?h=new Po(i,ma):h=new kr(i,ma);let g=this.runWebGLProgram(h,[{dataId:e,shape:i,dtype:l}],l),m=this.readToGPU(g,r);return this.disposeIntermediateTensorInfo(g),m}if(u==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let p=this.decode(e,r.customTexShape),f=Ps().makeTensorFromTensorInfo(p),d=this.texData.get(p.dataId);return Object.assign({tensorRef:f},d.texture)}bufferSync(e){let r=this.readSync(e.dataId);if(e.dtype==="string")try{let o=r.map(s=>b.decodeString(s));return Be(e.shape,e.dtype,o)}catch(o){throw new Error("Failed to decode encoded string bytes into utf-8")}return Be(e.shape,e.dtype,r)}checkNumericalProblems(e){if(e!=null)for(let r=0;r<e.length;r++){let o=e[r];if(!aU(o))throw Z().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${o} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${o} cannot be represented on this device.`)}}getValuesFromTexture(e){let{shape:r,dtype:o,isPacked:s}=this.texData.get(e),i=b.sizeFromShape(r);if(Z().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let d=this.decode(e),h=this.texData.get(d.dataId),g=this.gpgpu.downloadMatrixFromPackedTexture(h.texture.texture,...px(r)).subarray(0,i);return this.disposeIntermediateTensorInfo(d),g}let a=Z().getBool("WEBGL_PACK")&&s===!0,l=a?mx(r):r,c=a?new MC(l):new RC(l),u=this.runWebGLProgram(c,[{shape:l,dtype:o,dataId:e}],"float32"),p=this.texData.get(u.dataId),f=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(p.texture.texture,p.texShape[0],p.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(u),f}timerAvailable(){return Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){let r=this.activeTimers,o=[],s=!1;this.programTimersStack==null?(this.programTimersStack=o,s=!0):this.activeTimers.push(o),this.activeTimers=o,e();let i=b.flatten(this.activeTimers.map(c=>c.query)).filter(c=>c!=null),a=b.flatten(this.activeTimers.map(c=>c.name)).filter(c=>c!=null);this.activeTimers=r,s&&(this.programTimersStack=null);let l={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return te(this,null,function*(){if(Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let c=yield Promise.all(i);l.kernelMs=b.sum(c),l.getExtraProfileInfo=()=>c.map((u,p)=>({name:a[p],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else l.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,l})}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:b.now(),endMs:null}}endTimer(e){return Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=b.now(),e)}getQueryTime(e){return te(this,null,function*(){if(Z().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);let r=e;return r.endMs-r.startMs})}disposeData(e,r=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(r?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!r&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:o}=this.texData.get(e);return o!=null&&(this.disposeData(o.real.dataId,r),this.disposeData(o.imag.dataId,r)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:r,dtype:o,texShape:s,usage:i,isPacked:a,slice:l}=this.texData.get(e),c=l&&l.origDataId||e,u=this.dataRefCount.get(c);u>1?this.dataRefCount.set(c,u-1):(this.dataRefCount.delete(c),r!=null&&(this.numBytesInGPU-=this.computeBytes(s,o),this.textureManager.releaseTexture(r,s,i,a)));let p=this.texData.get(e);p.texture=null,p.texShape=null,p.isPacked=!1,p.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,r=qge){return Z().getBool("WEBGL_CPU_FORWARD")&&e.every(o=>this.texData.get(o.dataId).texture==null&&b.sizeFromShape(o.shape)<r)}getGPGPUContext(){return this.gpgpu}where(e){_.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let r=e.dataSync();return Gge(e.shape,r)}packedUnaryOp(e,r,o){let s=new Po(e.shape,r),i=this.compileAndRun(s,[e],o);return Ps().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){let s=$C(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,s)}if(Z().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,dk,e.dtype);let r=new kr(e.shape,dk),o=this.compileAndRun(r,[e]);return Ps().makeTensorFromTensorInfo(o)}makeTensorInfo(e,r,o){let s;if(r==="string"&&o!=null&&o.length>0&&b.isString(o[0])){let i=o.map(a=>b.encodeString(a));s=this.write(i,e,r)}else s=this.write(o,e,r);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:r}}makeOutput(e,r,o){return Ps().makeTensorFromTensorInfo(this.makeTensorInfo(e,r,o),this)}unpackTensor(e){let r=new zC(e.shape);return this.runWebGLProgram(r,[e],e.dtype)}packTensor(e){let r=new PC(e.shape);return this.runWebGLProgram(r,[e],e.dtype,null,!0)}packedReshape(e,r){let o=[Bu(e.shape),...zu(e.shape)],s={dtype:e.dtype,shape:o,dataId:e.dataId},i=[Bu(r),...zu(r)],a=new Ng(i,o),l=!0,c=[o],u=this.runWebGLProgram(a,[s],e.dtype,c,l);return{dataId:u.dataId,shape:r,dtype:u.dtype}}decode(e,r){let o=this.texData.get(e),{isPacked:s,shape:i,dtype:a}=o;if(r!=null){let d=b.sizeFromShape(i),h=r[0]*r[1]*4;b.assert(d<=h,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let l=mx(i),c;s?c=new _C(l):c=new AC(l);let u=!0,p=[r??px(l)],f=this.runWebGLProgram(c,[{shape:l,dtype:a,dataId:e}],a,p,u,r);return{dtype:a,shape:i,dataId:f.dataId}}runWebGLProgram(e,r,o,s,i=!1,a){let l=this.makeTensorInfo(e.outputShape,o),c=this.texData.get(l.dataId);if(e.packedOutput&&(c.isPacked=!0),e.outPackingScheme===Df.DENSE){let x=a??px(e.outputShape);c.texShape=x.map(C=>C*2)}if(e.outTexUsage!=null&&(c.usage=e.outTexUsage),b.sizeFromShape(l.shape)===0)return c.values=b.getTypedArrayFromDType(l.dtype,0),l;let u=[],p=r.map(x=>{if(x.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let C=this.texData.get(x.dataId);if(C.texture==null){if(!e.packedInputs&&b.sizeFromShape(x.shape)<=Z().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:x.shape,texData:null,isUniform:!0,uniformValues:C.values};e.packedInputs&&(C.isPacked=!0,C.shape=x.shape)}if(this.uploadToGPU(x.dataId),!!C.isPacked!=!!e.packedInputs)x=C.isPacked?this.unpackTensor(x):this.packTensor(x),u.push(x),C=this.texData.get(x.dataId);else if(C.isPacked&&!Af(C.shape,x.shape)){let I=x,D=x.shape;x.shape=C.shape,x=this.packedReshape(x,D),u.push(x),C=this.texData.get(x.dataId),I.shape=D}return{shape:x.shape,texData:C,isUniform:!1}});this.uploadToGPU(l.dataId);let f={shape:l.shape,texData:c,isUniform:!1},d=FU(e,p,f),h=this.getAndSaveBinary(d,()=>MU(this.gpgpu,e,p,f)),g=this.activeTimers!=null,m;g&&(m=this.startTimer()),Z().get("ENGINE_COMPILE_ONLY")||OU(this.gpgpu,h,p,f,s),u.forEach(x=>this.disposeIntermediateTensorInfo(x)),g&&(m=this.endTimer(m),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(m)}));let y=Z().getNumber("WEBGL_FLUSH_THRESHOLD");if(y>0){let x=b.now();x-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=x)}if(!Z().getBool("WEBGL_LAZILY_UNPACK")&&c.isPacked&&i===!1){let x=this.unpackTensor(l);return this.disposeIntermediateTensorInfo(l),x}return l}compileAndRun(e,r,o,s,i=!1){return o=o||r[0].dtype,this.runWebGLProgram(e,r,o,s,i)}getAndSaveBinary(e,r){return e in this.binaryCache||(this.binaryCache[e]=r()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Z().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(r=>{this.gpgpu.deleteProgram(this.binaryCache[r].webGLProgram),delete this.binaryCache[r]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=X(()=>{if(!Z().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=Z().getBool("DEBUG");Z().set("DEBUG",!1);let r=this.abs(Ee(1e-8)).dataSync()[0];if(Z().set("DEBUG",e),r>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?jge:Hge}uploadToGPU(e){let r=this.texData.get(e),{shape:o,dtype:s,values:i,texture:a,usage:l,isPacked:c}=r;if(a!=null)return;let u=this.activeTimers!=null,p;u&&(p=b.now());let f=r.texShape;if(f==null&&(f=bU(o,c),r.texShape=f),i!=null){let d=mx(o),h,g=f[1],m=f[0],y=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(c||!y)&&([g,m]=da(f[0],f[1])),c?h=new OC(d,y):h=new gx(d,y);let x=y?[m,g]:f,C=this.makeTensorInfo(x,s),I=this.texData.get(C.dataId);y?I.usage=ro.PIXELS:I.usage=ro.UPLOAD,I.texShape=x,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(C.dataId),g,m,i);let D=[[m,g]],L=this.runWebGLProgram(h,[C],s,D,!0),B=this.texData.get(L.dataId);r.texShape=B.texShape,r.isPacked=B.isPacked,r.usage=B.usage,Z().get("ENGINE_COMPILE_ONLY")?this.disposeData(L.dataId):(r.texture=B.texture,r.values=null,this.texData.delete(L.dataId)),this.disposeIntermediateTensorInfo(C),u&&(this.uploadWaitMs+=b.now()-p)}else{let d=this.acquireTexture(f,l,s,c);r.texture=d}}convertAndCacheOnCPU(e,r){let o=this.texData.get(e),{dtype:s}=o;return r!=null&&(o.values=Yge(r,s)),o.values}acquireTexture(e,r,o,s){if(this.numBytesInGPU+=this.computeBytes(e,o),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,r,s)}computeBytes(e,r){return e[0]*e[1]*b.bytesPerElement(r)}checkCompileCompletion(){for(let[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}checkCompileCompletionAsync(){return te(this,null,function*(){let e=[];if(this.gpgpu.parallelCompilationExtension){for(let[,r]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(r));return Promise.all(e)}else{for(let[,r]of Object.entries(this.binaryCache)){let o=new Promise(s=>{try{this.checkCompletion_(r),s(!0)}catch(i){throw i}});e.push(o)}return Promise.all(e)}})}checkCompletionAsync_(e){return te(this,null,function*(){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(yield O1(),this.checkCompletionAsync_(e))})}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(nk(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);let{variablesLocations:r,customUniformLocations:o,infLoc:s,nanLoc:i,outShapeLocation:a,outShapeStridesLocation:l,outTexShapeLocation:c}=ik(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=r,e.customUniformLocations=o,e.infLoc=s,e.nanLoc=i,e.outShapeLocation=a,e.outShapeStridesLocation=l,e.outTexShapeLocation=c}}createTensorFromGPUData(e,r,o){e.channels=e.channels||"RGBA";let{texture:s,height:i,width:a,channels:l}=e,c=Ps().backend;if(!c.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let u=c.writeTexture(s,r,o,i,a,l);return Ps().makeTensorFromDataId(u,r,o,c)}}return t.nextDataId=0,t})();function Yge(t,n){if(n==="float32"||n==="complex64")return t;if(n==="int32"||n==="bool"){let e=n==="int32"?new Int32Array(t.length):new Uint8Array(t.length);for(let r=0;r<e.length;++r)e[r]=Math.round(t[r]);return e}else throw new Error(`Unknown dtype ${n}`)}pu.isBrowser()&&vv("webgl",()=>new oj,2);var Dg=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;var Bo=class{constructor(n,e,r){this.variableNames=["A","B"],this.outputShape=_.assertAndGetBroadcastShape(e,r),this.enableShapeUniforms=jt(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${n}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};var as=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;var is=class{constructor(n,e,r,o=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=_.assertAndGetBroadcastShape(e,r);let s=this.outputShape.length;this.enableShapeUniforms=jt(s);let i="";if(o)if(s===0||b.sizeFromShape(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${st(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let l=zn("coords",s);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${l[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${l[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${l[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${l[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${n}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}};function Vn(t){let{inputs:n,backend:e}=t,{x:r}=n;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var sj={kernelName:Ki,backendName:"webgl",kernelFunc:Vn};function zo(t){let{inputs:n,backend:e}=t,{real:r,imag:o}=n,s=e.makeTensorInfo(r.shape,"complex64"),i=e.texData.get(s.dataId),a=Vn({inputs:{x:r},backend:e}),l=Vn({inputs:{x:o},backend:e});return i.complexTensorInfos={real:a,imag:l},s}var ij={kernelName:nh,backendName:"webgl",kernelFunc:zo};var hk="return (a < 0.) ? b * a : a;",mk=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Zge(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{alpha:s}=r,i=e.makeTensorInfo([],"float32",b.createScalarValue(s,"float32")),a=Z().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new is(mk,o.shape,i.shape):new Bo(hk,o.shape,i.shape),l=e.runWebGLProgram(a,[o,i],"float32");return e.disposeIntermediateTensorInfo(i),l}var aj={kernelName:Bc,backendName:"webgl",kernelFunc:Zge};var gk="return (a < 0.) ? b * a : a;",yk=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Qge(t){let{inputs:n,backend:e}=t,{x:r,alpha:o}=n,s=Z().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new is(yk,r.shape,o.shape):new Bo(gk,r.shape,o.shape);return e.runWebGLProgram(s,[r,o],"float32")}var lj={kernelName:Kc,backendName:"webgl",kernelFunc:Qge};var ei="if (isnan(x)) return x;";function ze({opSnippet:t,packedOpSnippet:n,cpuKernelImpl:e,dtype:r}){return({inputs:o,backend:s})=>{let{x:i}=o,a=s,l=r||i.dtype;if(a.shouldExecuteOnCPU([i])&&e!=null){let p=a.texData.get(i.dataId),f=e(p.values,l);return a.makeTensorInfo(i.shape,l,f)}let c=Z().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&n!=null,u;return c?u=new Po(i.shape,n):u=new kr(i.shape,t),a.runWebGLProgram(u,[i],l)}}function Pt({opSnippet:t,packedOpSnippet:n,checkOutOfBounds:e=!1,supportsComplex:r=!1,cpuKernelImpl:o,dtype:s}){return({inputs:i,backend:a})=>{let{a:l,b:c}=i,u=a;if(r&&l.dtype==="complex64"){let h=u.texData.get(l.dataId),g=u.texData.get(c.dataId),[m,y]=[[h.complexTensorInfos.real,g.complexTensorInfos.real],[h.complexTensorInfos.imag,g.complexTensorInfos.imag]].map(C=>{let[I,D]=C,O={dataId:I.dataId,dtype:I.dtype,shape:l.shape},L={dataId:D.dataId,dtype:D.dtype,shape:c.shape},B=new Bo(t,l.shape,c.shape);return u.runWebGLProgram(B,[O,L],Wn(I.dtype,D.dtype))}),x=zo({inputs:{real:m,imag:y},backend:u});return u.disposeIntermediateTensorInfo(m),u.disposeIntermediateTensorInfo(y),x}let p=s||Wn(l.dtype,c.dtype);if((l.dtype==="string"||c.dtype==="string"||u.shouldExecuteOnCPU([l,c]))&&o!=null){let h=u.texData.get(l.dataId).values,g=u.texData.get(c.dataId).values,m=l.dtype==="string"?_.fromUint8ToStringArray(h):h,y=l.dtype==="string"?_.fromUint8ToStringArray(g):g,[x,C]=o(l.shape,c.shape,m,y,p),I=u.makeTensorInfo(C,p),D=u.texData.get(I.dataId);return D.values=x,I}let f=Z().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&n!=null,d;return f?d=new is(n,l.shape,c.shape,e):d=new Bo(t,l.shape,c.shape),u.runWebGLProgram(d,[l,c],p)}}function Wl(t,n=!1){if(t==="linear")return n?JG:qG;if(t==="relu")return n?tj:XG;if(t==="elu")return n?ej:KG;if(t==="relu6")return n?nj:YG;if(t==="prelu")return n?yk:gk;if(t==="leakyrelu")return n?mk:hk;if(t==="sigmoid")return n?rj:ZG;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}var kg=class{constructor(n,e,r,o=!1,s=!1,i=!1,a=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=jt(this.outputShape.length);let u=o?n[1]:n[2],p=Math.ceil(u/2),f=o?"i * 2, rc.y":"rc.y, i * 2",d=s?"rc.z, i * 2":"i * 2, rc.z",h=o?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],g=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],m="",y="";a&&(l?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:c?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:m=`vec4 activation(vec4 x) {
          ${a}
        }`,y="result = activation(result);");let x=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let C="rc.x",I="rc.x";n[0]<e[0]?C=`imod(rc.x, ${n[0]})`:e[0]<n[0]&&(I=`imod(rc.x, ${e[0]})`),this.userCode=`
      ${m}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${p}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${C};
        int batchB = ${I};
        for (int i = 0; i < ${p}; i++) {
          vec4 a = getMatrixA(batchA, ${f});
          vec4 b = getMatrixB(batchB, ${d});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${h[0]} * ${g[0]});
          result += (${h[1]} * ${g[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${x}

        ${y}

        setOutput(result);
      }
    `}};var xk={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},xx=class{constructor(n,e,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=_.assertAndGetBroadcastShape(e,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${n}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};var cj="return a * b;";function vx(t){let{inputs:n,backend:e}=t,{a:r,b:o}=n,s=_.upcastType(r.dtype,o.dtype);if(r.dtype==="complex64"){let a=e.texData.get(r.dataId),l=e.texData.get(o.dataId),c=new xx(xk.REAL,r.shape,o.shape),u=new xx(xk.IMAG,r.shape,o.shape),p=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:o.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:o.shape}],f=e.runWebGLProgram(c,p,"float32"),d=e.runWebGLProgram(u,p,"float32"),h=zo({inputs:{real:f,imag:d},backend:e});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),h}if(e.shouldExecuteOnCPU([r,o])){let a=e.texData.get(r.dataId),l=e.texData.get(o.dataId),[c,u]=vG(r.shape,o.shape,a.values,l.values,s),p=e.makeTensorInfo(u,s),f=e.texData.get(p.dataId);return f.values=c,p}let i;return Z().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new is(cj,r.shape,o.shape):i=new Bo(cj,r.shape,o.shape),e.runWebGLProgram(i,[r,o],s)}var uj={kernelName:pl,backendName:"webgl",kernelFunc:vx};function pj(t,n,e){let r=[Bu(t.shape),...zu(t.shape)],o={dtype:t.dtype,shape:r,dataId:t.dataId},s=[Bu(n),...zu(n)],i=new Ng(s,r),a=!0,l=[r],c=e.runWebGLProgram(i,[o],t.dtype,l,a);return{dataId:c.dataId,shape:n,dtype:c.dtype}}function we(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{shape:s}=r,i=e,a=b.sizeFromShape(o.shape),l=b.inferFromImplicitShape(s,a),c=b.sizeFromShape(l);b.assert(a===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${o.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);let u=i.texData.get(o.dataId);return u.isPacked&&!Af(o.shape,l)&&!(u.texture!==null&&Af(u.shape,l))?pj(o,l,i):(i.incRef(o.dataId),{dataId:o.dataId,shape:l,dtype:o.dtype})}var fj={kernelName:Yc,backendName:"webgl",kernelFunc:we};var bx=class{constructor(n,e){this.variableNames=["x"];let{windowSize:r,batchSize:o,inSize:s,outSize:i}=n;this.outputShape=[o,i];let a=Math.floor(r/4)*4,l=r%4,c="sumValue += dot(values, ones);";if(e!=null){let p=1/e;c=`sumValue += dot(values * ${b.isInt(p)?p.toPrecision(2):p}, ones);`}let u="";s%r>0&&(u=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${a};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}};var UC=class{constructor(n,e){this.variableNames=["x"];let{windowSize:r,batchSize:o,inSize:s,outSize:i}=n;this.outputShape=[o,i];let a="0.0",l="";e==="prod"?a="1.0":e==="min"?(a="1.0 / 1e-20",l="min"):e==="max"&&(a="-1.0 / 1e-20",l="max");let c=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="sum"?c="sumValue":e==="prod"?c="prodValue":e==="all"?c="allValue":e==="any"&&(c="anyValue");let u=Math.floor(r/4)*4,p=r%4,f=`
      if (${e==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${e==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${e==="min"} || ${e==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,d="vec4";e==="all"?(a="1.0",f=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,d="bvec4"):e==="any"&&(a="0.0",f=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,d="bvec4");let h="";s%r>0&&(h=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${f}
        }

        int inIdx = inOffset + ${u};
        if (${p===1}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${p===2}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${p===3}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${f}
        }
        setOutput(${c});
      }
    `}};function eye(t){let n=[];for(;n.length===0||n[n.length-1].outSize!==1;){let e=n.length?n[n.length-1].outSize:t[1],r=_.computeOptimalWindowSize(e);n.push({inSize:e,windowSize:r,outSize:Math.ceil(e/r)})}return n}function ls(t,n,e,r){let o=eye(t.shape),s=t;for(let i=0;i<o.length;i++){let{inSize:a,windowSize:l,outSize:c}=o[i],u,p;e==="mean"?u=i===0?new bx({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:c},a):new bx({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:c}):u=new UC({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:c},e),p=s,s=r.runWebGLProgram(u,[s],n),p.dataId!==t.dataId&&r.disposeIntermediateTensorInfo(p)}return s}var GC=class{constructor(n,e){this.variableNames=["A"];let r=new Array(n.length);for(let i=0;i<r.length;i++)r[i]=n[e[i]];this.outputShape=r,this.rank=r.length;let o=st(this.rank),s=tye(e);this.userCode=`
    void main() {
      ${o} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function tye(t){let n=t.length;if(n>6)throw Error(`Transpose for rank ${n} is not yet supported`);let e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(n);for(let o=0;o<t.length;o++)r[t[o]]=e[o];return r.join()}var jC=class{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let r=new Array(n.length);for(let u=0;u<r.length;u++)r[u]=n[e[u]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let o=st(this.rank),s=fk("rc",this.rank),i=new Array(this.rank);for(let u=0;u<e.length;u++)i[e[u]]=s[u];let a=`vec2(${i.slice(-2).join()})`,l=`++${s[this.rank-1]} < ${r[this.rank-1]}`,c=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`
    void main() {
      ${o} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${l}) {
        result[1] = ${c};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${c};
        if(${l}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}};function Vu(t,n,e){let r=Z().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new jC(t.shape,n):new GC(t.shape,n);return e.runWebGLProgram(r,[t],t.dtype)}function dj(t,n,e,r){let o=n,s=t.shape.length,i=b.parseAxisParam(o,t.shape),a=i,l=_.getAxesPermutation(a,s),c=l!=null,u=t;c&&(u=Vu(t,l,r),a=_.getInnerMostAxes(a.length,s)),_.assertAxesAreInnerMostDims("sum",a,s);let[p,f]=_.computeOutAndReduceShapes(u.shape,a),d=p;e&&(d=_.expandShapeToKeepDim(p,i));let h=b.sizeFromShape(f),m=b.sizeFromShape(t.shape)/h,y=we({inputs:{x:u},attrs:{shape:[m,h]},backend:r}),x=Kp(t.dtype),C=ls(y,x,"sum",r),I=we({inputs:{x:C},attrs:{shape:d},backend:r});return r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(C),c&&r.disposeIntermediateTensorInfo(u),I}function Of(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,keepDims:i}=r;return dj(o,s,i,e)}var hj={kernelName:"Sum",backendName:"webgl",kernelFunc:Of};function Cn(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{perm:s}=r,i=e,a=o.shape.length,l=new Array(a);for(let u=0;u<l.length;u++)l[u]=o.shape[s[u]];let c;if(i.shouldExecuteOnCPU([o])){let p=i.texData.get(o.dataId).values,f=Mf(p,o.shape,o.dtype,s,l);c=i.makeTensorInfo(l,o.dtype);let d=i.texData.get(c.dataId);d.values=f}else c=Vu(o,s,i);return c}var mj={kernelName:Yi,backendName:"webgl",kernelFunc:Cn};var vk=1e3;function Ff({a:t,b:n,transposeA:e,transposeB:r,backend:o,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:l=null}){let c=t.shape.length,u=n.shape.length,p=e?t.shape[c-2]:t.shape[c-1],f=r?n.shape[u-1]:n.shape[u-2],d=e?t.shape[c-1]:t.shape[c-2],h=r?n.shape[u-2]:n.shape[u-1],g=t.shape.slice(0,-2),m=n.shape.slice(0,-2),y=b.sizeFromShape(g),x=b.sizeFromShape(m),I=Zo.assertAndGetBroadcastShape(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([d,h]);b.assert(p===f,()=>`Error in matMul: inner shapes (${p}) and (${f}) of Tensors with shapes ${t.shape} and ${n.shape} and transposeA=${e} and transposeB=${r} must match.`);let D=e?[y,p,d]:[y,d,p],O=r?[x,h,f]:[x,f,h],L=we({inputs:{x:t},backend:o,attrs:{shape:D}}),B=we({inputs:{x:n},backend:o,attrs:{shape:O}}),V=[L,B],F=Math.max(y,x),G=e?L.shape[1]:L.shape[2],ee=s!=null,Q=i!=null,oe=l==="leakyrelu",ae=l!=null?Wl(l,!0):null,J=ee||Q||oe||ae!=null,re;if((d===1||h===1)&&G>vk&&J===!1){let pe=L,xe=B;e&&(pe=Cn({inputs:{x:L},backend:o,attrs:{perm:[0,2,1]}}),V.push(pe)),r&&(xe=Cn({inputs:{x:B},backend:o,attrs:{perm:[0,2,1]}}),V.push(xe));let be=h!==1,Te=h===1,Se=pe;be&&(Se=we({inputs:{x:pe},backend:o,attrs:{shape:[F,G,1]}}),V.push(Se));let Re=h===1?2:1,De=xe;Te&&(De=we({inputs:{x:xe},backend:o,attrs:{shape:[F,1,G]}}),V.push(De));let Oe=vx({inputs:{a:Se,b:De},backend:o});re=Of({inputs:{x:Oe},backend:o,attrs:{axis:Re,keepDims:!0}}),V.push(Oe)}else{let pe=Wn(t.dtype,n.dtype),xe=new kg(D,O,[F,d,h],e,r,ee,ae,Q,oe),be=[L,B];if(s!=null&&be.push(s),Q&&be.push(i),oe){let Te=o.makeTensorInfo([],"float32",b.createScalarValue(a,"float32"));be.push(Te),V.push(Te)}re=o.runWebGLProgram(xe,be,pe)}let se=we({inputs:{x:re},backend:o,attrs:{shape:I}});V.push(re);for(let pe of V)o.disposeIntermediateTensorInfo(pe);return se}function nye(t){let{inputs:n,backend:e,attrs:r}=t,{a:o,b:s,bias:i,preluActivationWeights:a}=n,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:p}=r;return Ff({a:o,b:s,transposeA:l,transposeB:c,backend:e,bias:i,preluActivationWeights:a,leakyreluAlpha:p,activation:u})}var gj={kernelName:zp,backendName:"webgl",kernelFunc:nye};var yj="return abs(x);";function rye(t){let{inputs:n,backend:e}=t,{x:r}=n;if(e.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){let s=e.texData.get(r.dataId),i=$C(s.values);return e.makeTensorInfo(r.shape,r.dtype,i)}let o;return Z().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new Po(r.shape,yj):o=new kr(r.shape,yj),e.runWebGLProgram(o,[r],r.dtype)}var xj={kernelName:"Abs",backendName:"webgl",kernelFunc:rye};var oye=rr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,sye=ze({opSnippet:oye}),vj={kernelName:ja,backendName:"webgl",kernelFunc:sye};var iye=rr+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,aye=ze({opSnippet:iye}),bj={kernelName:Ha,backendName:"webgl",kernelFunc:aye};var wj="return a + b;",lye=Pt({opSnippet:wj,packedOpSnippet:wj,supportsComplex:!0,cpuKernelImpl:QU}),Cj={kernelName:"Add",backendName:"webgl",kernelFunc:lye};var HC=class{constructor(n,e){this.outputShape=[],this.outputShape=n,this.variableNames=e.map((s,i)=>`T${i}`);let r=[];this.variableNames.forEach(s=>{r.push(`float v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${o};
        setOutput(result);
      }
    `}};var WC=class{constructor(n,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.variableNames=e.map((s,i)=>`T${i}`);let r=[];this.variableNames.forEach(s=>{r.push(`vec4 v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${o};
        setOutput(result);
      }
    `}};function qC(t){let{inputs:n,backend:e}=t,r=n;if(r.length===1)return Vn({inputs:{x:r[0]},backend:e});if(r.length>Z().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let l=Math.floor(r.length/2),c=qC({inputs:r.slice(0,l),backend:e}),u=qC({inputs:r.slice(l),backend:e});return qC({inputs:[c,u],backend:e})}let o=r.map(l=>l.dtype).reduce((l,c)=>Wn(l,c)),s=r.map(l=>l.shape),a=Z().getBool("WEBGL_PACK")?new WC(r[0].shape,s):new HC(r[0].shape,s);return e.runWebGLProgram(a,r,o)}var Ij={kernelName:wc,backendName:"webgl",kernelFunc:qC};function cye(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,keepDims:i}=r,a=o.shape.length,l=b.parseAxisParam(s,o.shape),c=l,u=_.getAxesPermutation(c,a),p=o;u!=null&&(p=Cn({inputs:{x:o},backend:e,attrs:{perm:u}}),c=_.getInnerMostAxes(c.length,a)),_.assertAxesAreInnerMostDims("all",c,a);let[f,d]=_.computeOutAndReduceShapes(p.shape,c),h=b.sizeFromShape(d),g=we({inputs:{x:p},backend:e,attrs:{shape:[-1,h]}}),m=ls(g,g.dtype,"all",e),y;if(i){let x=_.expandShapeToKeepDim(f,l);y=we({inputs:{x:m},backend:e,attrs:{shape:x}})}else y=we({inputs:{x:m},backend:e,attrs:{shape:f}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),u!=null&&e.disposeIntermediateTensorInfo(p),y}var Sj={kernelName:"All",backendName:"webgl",kernelFunc:cye};function uye(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,keepDims:i}=r,a=o.shape.length,l=b.parseAxisParam(s,o.shape),c=l,u=_.getAxesPermutation(c,a),p=o;u!=null&&(p=Cn({inputs:{x:o},backend:e,attrs:{perm:u}}),c=_.getInnerMostAxes(c.length,a)),_.assertAxesAreInnerMostDims("any",c,a);let[f,d]=_.computeOutAndReduceShapes(p.shape,c),h=b.sizeFromShape(d),g=we({inputs:{x:p},backend:e,attrs:{shape:[-1,h]}}),m=ls(g,g.dtype,"any",e),y;if(i){let x=_.expandShapeToKeepDim(f,l);y=we({inputs:{x:m},backend:e,attrs:{shape:x}})}else y=we({inputs:{x:m},backend:e,attrs:{shape:f}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),u!=null&&e.disposeIntermediateTensorInfo(p),y}var Tj={kernelName:"Any",backendName:"webgl",kernelFunc:uye};var KC=class{constructor(n,e,r){this.variableNames=["A"];let{windowSize:o,batchSize:s,outSize:i}=n;r||this.variableNames.push("bestIndicesA"),this.outputShape=[s,i];let a=e==="max"?">":"<",l=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${o}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};var XC=class{constructor(n,e,r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,b.assert(n.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);let s=n[n.length-1],i=Math.ceil(s/e);this.outputShape=n.slice(0,-1),i>1&&this.outputShape.push(i),o||this.variableNames.push("bestIndicesA");let a=this.outputShape,l=a.length,c=st(l),u=zn("coords",l),p,f;if(i===1){f=l+1;let B=st(f);p=`
        ${B} sourceLocR = ${B}(${u.join()}, 0);
        ++${u[l-1]};
        ${B} sourceLocG = ${B}(${u.join()}, 0);
        ++${u[l-2]};
        ${B} sourceLocA = ${B}(${u.join()}, 0);
        --${u[l-1]};
        ${B} sourceLocB = ${B}(${u.join()}, 0);
        --${u[l-2]};`}else f=l,p=`
        ${c} sourceLocR = coords;
        ++${u[l-1]};
        ${c} sourceLocG = coords;
        ++${u[l-2]};
        ${c} sourceLocA = coords;
        --${u[l-1]};
        ${c} sourceLocB = coords;
        --${u[l-2]};`;let d=["x","y","z","w","u","v"].slice(0,f),h="."+d[f-1],g=d.map(B=>"int "+B),m=zn("sourceLocR",f-1).concat("inIdx.r"),y=zn("sourceLocG",f-1).concat("inIdx.g"),x=zn("sourceLocB",f-1).concat("inIdx.b"),C=zn("sourceLocA",f-1).concat("inIdx.a"),I=r==="max"?"greaterThan":"lessThan",D=o?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${C.join()})));`,O=`vec4(
            getAChannel(${m.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${x.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${C.join()}) : 0.)`,L=o?"":`
      float getBestIndicesAChannel(${g.join()}) {
        return getChannel(getBestIndicesA(${d.join()}),
                                          vec2(${d.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${g.join()}) {
        return getChannel(getA(${d.join()}),
                               vec2(${d.slice(-2).join()}));
      }
      ${L}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${u[l-1]} < ${a[l-1]-1};
        bool hasNextRow = ${u[l-2]} < ${a[l-2]-1};
        ${p}
        ivec4 srcIdx = ivec4(sourceLocR${h}, sourceLocG${h},
          sourceLocB${h}, sourceLocA${h}) * ${e};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${O};

        for (int i = 0; i < ${e}; i++) {
          inIdx = srcIdx;
          ${D}
          vec4 candidate = ${O};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${I}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function Ej(t,n,e,r=null){let o=n.shape[0],s=n.shape[1];r!=null&&(o=r.shape[0],s=r.shape[1]);let i=_.computeOptimalWindowSize(s),a={windowSize:i,inSize:s,batchSize:o,outSize:Math.ceil(s/i)},l=new KC(a,e,r==null),c=[n];r!=null&&c.push(r);let u=t.runWebGLProgram(l,c,"int32");if(u.shape[1]===1)return u;let p=Ej(t,n,e,u);return t.disposeIntermediateTensorInfo(u),p}function Nj(t,n,e,r=null){let o=r!=null?r.shape:n.shape,s=o[o.length-1],i=_.computeOptimalWindowSize(s),a=new XC(o,i,e,r==null),l=r==null?[n]:[n,r],c=t.runWebGLProgram(a,l,"int32");if(c.shape.length===n.shape.length){let u=Nj(t,n,e,c);return t.disposeIntermediateTensorInfo(c),u}return c}function YC(t,n,e,r){let o=[e];if(_.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),o,n.shape.length),!Z().getBool("WEBGL_PACK_REDUCE")||n.shape.length<=2){let s=[],i=t.texData.get(n.dataId),a=i!==null&&i.isPacked,l=n;a&&(l=t.unpackTensor(n),s.push(l));let[c,u]=_.computeOutAndReduceShapes(l.shape,o),p=b.sizeFromShape(u),f=we({inputs:{x:l},backend:t,attrs:{shape:[-1,p]}});s.push(f);let d=Ej(t,f,r);s.push(d);let h=we({inputs:{x:d},backend:t,attrs:{shape:c}});return s.forEach(g=>t.disposeIntermediateTensorInfo(g)),h}return Nj(t,n,r)}function pye(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s}=r,i=b.parseAxisParam(s,o.shape),a=_.getAxesPermutation(i,o.shape.length),l=o,c=[];a!=null&&(l=Cn({inputs:{x:o},backend:e,attrs:{perm:a}}),c.push(l),i=_.getInnerMostAxes(i.length,l.shape.length)),_.assertAxesAreInnerMostDims("argMax",[i[0]],l.shape.length);let u=YC(e,l,i[0],"max");return c.forEach(p=>e.disposeIntermediateTensorInfo(p)),u}var Dj={kernelName:Cc,backendName:"webgl",kernelFunc:pye};function fye(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s}=r,i=b.parseAxisParam(s,o.shape),a=_.getAxesPermutation(i,o.shape.length),l=o,c=[];a!=null&&(l=Cn({inputs:{x:o},backend:e,attrs:{perm:a}}),c.push(l),i=_.getInnerMostAxes(i.length,l.shape.length)),_.assertAxesAreInnerMostDims("argMin",[i[0]],l.shape.length);let u=YC(e,l,i[0],"min");return c.forEach(p=>e.disposeIntermediateTensorInfo(p)),u}var kj={kernelName:Ic,backendName:"webgl",kernelFunc:fye};var dye=rr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,hye=ze({opSnippet:dye}),Aj={kernelName:Wa,backendName:"webgl",kernelFunc:hye};var mye=rr+"return log(x + sqrt(x * x + 1.0));",gye=ze({opSnippet:mye}),_j={kernelName:qa,backendName:"webgl",kernelFunc:gye};var yye=rr+`
  return atan(x);
`,xye=ze({opSnippet:yye}),Rj={kernelName:Ka,backendName:"webgl",kernelFunc:xye};var vye=Dg+`
  return atan(a, b);
`,bye=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+as+`
  return result;
`,wye=Pt({opSnippet:vye,packedOpSnippet:bye}),Mj={kernelName:Ya,backendName:"webgl",kernelFunc:wye};var Cye=rr+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,Iye=ze({opSnippet:Cye}),Oj={kernelName:Xa,backendName:"webgl",kernelFunc:Iye};var Di=class{constructor(n,e,r,o=!1,s=!1){if(this.variableNames=["x"],e==="avg"&&r)throw new Error("Cannot compute positions for average pool.");let i=n.filterWidth,a=n.strideHeight,l=n.strideWidth,c=n.dilationHeight,u=n.dilationWidth,p=n.effectiveFilterHeight,f=n.effectiveFilterWidth,d=n.padInfo.top,h=n.padInfo.left;this.outputShape=n.outShape;let g=e==="avg",m=`((batch  * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + d`,y=`(xR * ${n.inWidth} + xC) * ${n.inChannels} + d`,x="0.0";if(g||(x="-1.0 / 1e-20"),r){this.userCode=`
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${d}, ${h});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${p};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${n.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${n.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${o?s?m:y:`wR * ${f} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let C="max",I=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(I="avgValue / max(count, 1.0)");let D=Math.floor(i/4)*4,O=i%4,L=`
      if (${g}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${C}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${d}, ${h});
      const float initializationValue = ${x};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${n.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${x});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${p};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${n.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${D}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${L}
          }

          int xC = xCCorner + ${D};
          if (${O===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${L}
          } else if (${O===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${L}
          } else if (${O===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${L}
          }
        }
        setOutput(${I});
      }
    `}},Uu=class{constructor(n,e,r,o=!1,s=!1){if(this.variableNames=["x"],e==="avg"&&r)throw new Error("Cannot compute positions for average pool.");let i=n.filterWidth,a=n.strideDepth,l=n.strideHeight,c=n.strideWidth,u=n.dilationDepth,p=n.dilationHeight,f=n.dilationWidth,d=n.effectiveFilterDepth,h=n.effectiveFilterHeight,g=n.effectiveFilterWidth,m=n.padInfo.front,y=n.padInfo.top,x=n.padInfo.left;this.outputShape=n.outShape;let C=e==="avg",I="0.0";if(C||(I="-1.0 / 1e-20"),r){this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${l}, ${c});
        const ivec3 pads = ivec3(${m}, ${y}, ${x});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${d};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${n.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${h};
                wR += ${p}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${n.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${g};
                  wC += ${f}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${n.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${o?s?`(((batch * ${n.inDepth} + xD) * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`((xD * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`wD * ${h} * ${g} +
                      wR * ${g} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let D="max",O=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(O="avgValue / max(count, 1.0)");let L=Math.floor(i/4)*4,B=i%4,V=`
      if (${C}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${D}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${l}, ${c});
      const ivec3 pads = ivec3(${m}, ${y}, ${x});
      const float initializationValue = ${I};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${n.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${I});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${n.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${h};
            wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${n.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${L}; wC += 4) {
              int xC = xCCorner + wC * ${f};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                getValue(batch, xD, xR, xC + 3 * ${f}, ch)
              );

              ${V}
            }

            int xC = xCCorner + ${L};
            if (${B===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${V}
            } else if (${B===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                initializationValue,
                initializationValue
              );

              ${V}
            } else if (${B===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                initializationValue
              );

              ${V}
            }
          }
        }
        setOutput(${O});
      }
    `}};function Sye(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n;ha(o,"avgPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:l}=r,c=1;b.assert(_.eitherStridesOrDilationsAreOne(i,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let u=_.computePool2DInfo(o.shape,s,i,c,a,l);if(u.filterWidth===1&&u.filterHeight===1&&b.arraysEqual(u.inShape,u.outShape))return Vn({inputs:{x:o},backend:e});let p=new Di(u,"avg",!1);return e.runWebGLProgram(p,[o],"float32")}var Fj={kernelName:Sc,backendName:"webgl",kernelFunc:Sye};function Tye(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{filterSize:s,strides:i,pad:a,dimRoundingMode:l,dataFormat:c}=r,u=[1,1,1],p=_.computePool3DInfo(o.shape,s,i,u,a,l,c),f=new Uu(p,"avg",!1);return e.runWebGLProgram(f,[o],"float32")}var $j={kernelName:Tc,backendName:"webgl",kernelFunc:Tye};var ZC=class{constructor(n){this.variableNames=["dy"],this.outputShape=n.inShape;let e=n.filterHeight,r=n.filterWidth,o=n.strideHeight,s=n.strideWidth,i=n.dilationHeight,a=n.dilationWidth,l=n.effectiveFilterHeight,c=n.effectiveFilterWidth,u=l-1-n.padInfo.top,p=c-1-n.padInfo.left,f=1/(e*r);this.userCode=`
      const ivec2 pads = ivec2(${u}, ${p});
      const float avgMultiplier = float(${f});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},QC=class{constructor(n){this.variableNames=["dy"],this.outputShape=n.inShape;let e=n.filterDepth,r=n.filterHeight,o=n.filterWidth,s=n.strideDepth,i=n.strideHeight,a=n.strideWidth,l=n.dilationDepth,c=n.dilationHeight,u=n.dilationWidth,p=n.effectiveFilterDepth,f=n.effectiveFilterHeight,d=n.effectiveFilterWidth,h=p-1-n.padInfo.front,g=f-1-n.padInfo.top,m=d-1-n.padInfo.left,y=1/(e*r*o);this.userCode=`
      const ivec3 pads = ivec3(${h}, ${g}, ${m});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${n.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${f};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Eye(t){let{inputs:n,backend:e,attrs:r}=t,{dy:o,input:s}=n,i=s,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,p=[1,1,1],f=_.computePool3DInfo(i.shape,a,l,p,c,u),d=new QC(f);return e.runWebGLProgram(d,[o],i.dtype)}var Lj={kernelName:Jd,backendName:"webgl",kernelFunc:Eye};function Nye(t){let{inputs:n,backend:e,attrs:r}=t,{dy:o,input:s}=n,i=s;ha([o,s],"avgPoolGrad");let{filterSize:a,strides:l,pad:c}=r,u=_.computePool2DInfo(i.shape,a,l,1,c),p=new ZC(u);return e.runWebGLProgram(p,[o],i.dtype)}var Pj={kernelName:Qd,backendName:"webgl",kernelFunc:Nye};function Dye(t){let{inputs:n,backend:e,attrs:r}=t,{a:o,b:s}=n,{transposeA:i,transposeB:a}=r;return Ff({a:o,b:s,transposeA:i,transposeB:a,backend:e})}var Bj={kernelName:Ec,backendName:"webgl",kernelFunc:Dye};var JC=class{constructor(n,e,r,o,s,i){this.outputShape=[],this.variableNames=["x","mean","variance"],_.assertAndGetBroadcastShape(n,e),_.assertAndGetBroadcastShape(n,r);let a="0.0";o!=null&&(_.assertAndGetBroadcastShape(n,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";s!=null&&(_.assertAndGetBroadcastShape(n,s),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=n,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};var e3=class{constructor(n,e,r,o,s,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],_.assertAndGetBroadcastShape(n,e),_.assertAndGetBroadcastShape(n,r);let a="vec4(0.0)";o!=null&&(_.assertAndGetBroadcastShape(n,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";s!=null&&(_.assertAndGetBroadcastShape(n,s),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=n,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}};var kye=({inputs:t,backend:n,attrs:e})=>{let{x:r,mean:o,variance:s,offset:i,scale:a}=t;b.assert(o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),b.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),b.assert(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=e;l==null&&(l=.001);let c=[r,o,s],u=null;i!=null&&(u=i.shape,c.push(i));let p=null;a!=null&&(p=a.shape,c.push(a));let f=Z().getBool("WEBGL_PACK_NORMALIZATION")?new e3(r.shape,o.shape,s.shape,u,p,l):new JC(r.shape,o.shape,s.shape,u,p,l);return n.runWebGLProgram(f,c,c[0].dtype)},zj={kernelName:Lc,backendName:"webgl",kernelFunc:kye};var t3=class{constructor(n){this.variableNames=["source"],this.outputShape=n,this.rank=n.length;let e=st(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let r=Aye(this.rank),o,s=n.map((i,a)=>`sourceLoc.${bk[a]} = start[${a}] + coords.${bk[a]};`);o=`
        ${e} sourceLoc;
        ${e} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${o}
        setOutput(getSource(${r}));
      }
    `}},bk=["x","y","z","w","u","v"];function Aye(t){if(t===1)return"sourceLoc";if(t<=6)return bk.slice(0,t).map(n=>"sourceLoc."+n).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}var n3=class{constructor(n){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.rank=n.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let e=st(this.rank),r=zn("coords",this.rank),o=zn("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${o.slice(-2).join()})`,i=`getChannel(getSource(${o.join()}), ${s})`,a=`
      result.x = ${i};
      if (++${r[this.rank-1]} < ${n[this.rank-1]}) {
        ++${o[this.rank-1]};
        result.y = ${i};
        --${o[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${n[this.rank-2]}) {
        ++${o[this.rank-2]};
        result.z = ${i};
        if (++${r[this.rank-1]} < ${n[this.rank-1]}) {
          ++${o[this.rank-1]};
          result.w = ${i};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${e}(${n.map((u,p)=>`start[${p}]`).join()});`:n.map((u,p)=>`${o[p]} = ${r[p]} + start[${p}];`).join(`
`);this.userCode=`
      void main() {
        ${e} coords = getOutputCoords();
        ${e} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `}};function _ye(t,n,e,r){let o=r.texData.get(t.dataId),s=r.makeTensorInfo(e,t.dtype),i=r.texData.get(s.dataId);Object.assign(i,o),i.refCount=1,i.shape=e,i.dtype=t.dtype;let a=gr.computeFlatOffset(n,b.computeStrides(t.shape));o.slice&&(a+=o.slice.flatOffset),i.slice={flatOffset:a,origDataId:o.slice&&o.slice.origDataId||t.dataId};let l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),s}function ki(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{begin:s,size:i}=r,[a,l]=gr.parseSliceParams(o,s,i);if(gr.assertParamsValid(o,a,l),b.sizeFromShape(l)===0)return e.makeTensorInfo(l,o.dtype,[]);if(e.shouldExecuteOnCPU([o])||o.dtype==="string"){let p=e.texData.get(o.dataId),f=AG(p.values,a,l,o.shape,o.dtype);return e.makeTensorInfo(l,o.dtype,f)}let{isPacked:c}=e.texData.get(o.dataId),u=gr.isSliceContinous(o.shape,a,l);if(c||!u){let p=Z().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new n3(l):new t3(l),f=[a];return e.runWebGLProgram(p,[o],o.dtype,f)}return e.uploadToGPU(o.dataId),_ye(o,a,l,e)}var Vj={kernelName:tu,backendName:"webgl",kernelFunc:ki};var Rye=t=>{let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{blockShape:s,crops:i}=r;b.assert(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((x,C)=>x*C),l=_.getReshaped(o.shape,s,a),c=_.getPermuted(l.length,s.length),u=_.getReshapedPermuted(o.shape,s,a),p=_.getSliceBeginCoords(i,s.length),f=_.getSliceSize(u,i,s.length),d=[],h=we({inputs:{x:o},backend:e,attrs:{shape:l}}),g=Cn({inputs:{x:h},backend:e,attrs:{perm:c}}),m=we({inputs:{x:g},backend:e,attrs:{shape:u}}),y=ki({inputs:{x:m},backend:e,attrs:{begin:p,size:f}});return d.push(h),d.push(g),d.push(m),d.forEach(x=>e.disposeIntermediateTensorInfo(x)),y},Uj={kernelName:Nc,backendName:"webgl",kernelFunc:Rye};function Mye(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,weights:s}=n,{size:i}=r,a=e.readSync(o.dataId),l=e.readSync(s.dataId),c=FC(a,l,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,c)}var Gj={kernelName:eh,backendName:"webgl",kernelFunc:Mye};var Oye=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,Fye=`
  return float(int(a.r) & int(b.r));
`;function $ye(t){let{inputs:n,backend:e}=t,{a:r,b:o}=n,s=Z().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=Z().getNumber("WEBGL_VERSION");if(e.shouldExecuteOnCPU([r,o])||i===1){let l=e.texData.get(r.dataId).values,c=e.texData.get(o.dataId).values,[u,p]=eG(r.shape,o.shape,l,c,r.dtype),f=e.makeTensorInfo(p,r.dtype),d=e.texData.get(f.dataId);return d.values=u,f}let a;return s?a=new is(Oye,r.shape,o.shape,!1):a=new Bo(Fye,r.shape,o.shape),e.runWebGLProgram(a,[r,o],r.dtype)}var jj={kernelName:Ap,backendName:"webgl",kernelFunc:$ye};function Lye(t){let{inputs:n,backend:e}=t,{s0:r,s1:o}=n,s=e.readSync(r.dataId),i=e.readSync(o.dataId),a=_.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return e.makeTensorInfo([a.length],"int32",Int32Array.from(a))}var Hj={kernelName:th,backendName:"webgl",kernelFunc:Lye};var Pye="return float(a != b);",wk=Pt({opSnippet:Pye,cpuKernelImpl:wG,dtype:"bool"}),Wj={kernelName:Pp,backendName:"webgl",kernelFunc:wk};function ql(t){let{inputs:n,backend:e}=t,{input:r}=n,o=e.texData.get(r.dataId);return Vn({inputs:{x:o.complexTensorInfos.real},backend:e})}var qj={kernelName:Mh,backendName:"webgl",kernelFunc:ql};var Bye="return float(int(x));";function Kj(t,n){let e=new kr(t.shape,Bye),r=n.runWebGLProgram(e,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function Ck(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{dtype:s}=r;if(s==="complex64"){if(o.dtype==="complex64")return Vn({inputs:{x:o},backend:e});let i=cn(o.shape),a=Ck({inputs:{x:o},backend:e,attrs:{dtype:"float32"}}),l=zo({inputs:{real:a,imag:i},backend:e});return i.dispose(),e.disposeIntermediateTensorInfo(a),l}if(o.dtype==="complex64"){let i=ql({inputs:{input:o},backend:e}),a=Ck({inputs:{x:i},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(i),a}if(!b.hasEncodingLoss(o.dtype,s)){let i=Vn({inputs:{x:o},backend:e});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(e.shouldExecuteOnCPU([o])){let i=e.texData.get(o.dataId).values,[a,l,c]=tG(i,o.shape,o.dtype,s);return e.makeTensorInfo(a,l,c)}if(s==="int32")return Kj(o,e);if(s==="bool"){let i=e.makeTensorInfo([],"bool",b.getTypedArrayFromDType("bool",1)),l=wk({inputs:{a:o,b:i},backend:e});return e.disposeIntermediateTensorInfo(i),l}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var Xj={kernelName:qi,backendName:"webgl",kernelFunc:Ck};var Yj="return ceil(x);",zye=ze({opSnippet:Yj,packedOpSnippet:Yj,cpuKernelImpl:nG}),Zj={kernelName:Za,backendName:"webgl",kernelFunc:zye};var r3=class{constructor(n){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=n,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};var o3=class{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=n,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function Vye(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{clipValueMin:s,clipValueMax:i}=r,a;Z().getBool("WEBGL_PACK_CLIP")?a=new o3(o.shape):a=new r3(o.shape);let l=[[s],[i]];return e.runWebGLProgram(a,[o],o.dtype,l)}var Qj={kernelName:Qa,backendName:"webgl",kernelFunc:Vye};var s3=class{constructor(n){this.variableNames=["real","imag"],this.outputShape=n,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function Jj(t,n){return{dataId:n.dataId,dtype:n.dtype,shape:t.shape}}function Uye(t){let{inputs:n,backend:e}=t,{x:r}=n,o=e.texData.get(r.dataId),s=new s3(r.shape),i=[Jj(r,o.complexTensorInfos.real),Jj(r,o.complexTensorInfos.imag)];return e.runWebGLProgram(s,i,i[0].dtype)}var eH={kernelName:Dc,backendName:"webgl",kernelFunc:Uye};var i3=class{constructor(n){this.outputShape=[],this.outputShape=_.computeOutShape(n,1),this.variableNames=n.map((i,a)=>`T${a}`);let e=new Array(n.length-1);e[0]=n[0][1];for(let i=1;i<e.length;i++)e[i]=e[i-1]+n[i][1];let r=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<e.length;i++){let a=e[i-1];r.push(`else if (yC < ${e[i]}) setOutput(getT${i}(yR, yC-${a}));`)}let o=e.length,s=e[e.length-1];r.push(`else setOutput(getT${o}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}};var l3=class{constructor(n,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=_.computeOutShape(n,e);let r=this.outputShape,o=r.length,s=st(o),i=zn("coords",o),a=["x","y","z","w","u","v"].slice(0,o);this.variableNames=n.map((g,m)=>`T${m}`);let l=new Array(n.length-1);l[0]=n[0][e];for(let g=1;g<l.length;g++)l[g]=l[g-1]+n[g][e];let c=a[e],u=a.slice(-2),p=a.join(),f=`if (${c} < ${l[0]}) {
        return getChannel(
            getT0(${p}), vec2(${u.join()}));
        }`;for(let g=1;g<l.length;g++){let m=l[g-1];f+=`
        if (${c} < ${l[g]}  && ${c} >= ${l[g-1]}) {
          return getChannel(
            getT${g}(${a3(a,c,m)}),
            vec2(${a3(u,c,m)}));
        }`}let d=l.length,h=l[l.length-1];f+=`
        return getChannel(
          getT${d}(${a3(a,c,h)}),
          vec2(${a3(u,c,h)}));`,this.userCode=`
      float getValue(${a.map(g=>"int "+g)}) {
        ${f}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[o-1]} = ${i[o-1]} + 1;
        if (${i[o-1]} < ${r[o-1]}) {
          result.g = getValue(${i});
        }

        ${i[o-2]} = ${i[o-2]} + 1;
        if (${i[o-2]} < ${r[o-2]}) {
          result.a = getValue(${i});
        }

        ${i[o-1]} = ${i[o-1]} - 1;
        if (${i[o-2]} < ${r[o-2]} &&
            ${i[o-1]} < ${r[o-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}};function a3(t,n,e){let r=t.indexOf(n);return t.map((s,i)=>i===r?`${s} - ${e}`:s).join()}function $f(t){let{inputs:n,backend:e}=t,{input:r}=n,o=e.texData.get(r.dataId);return Vn({inputs:{x:o.complexTensorInfos.imag},backend:e})}var tH={kernelName:vh,backendName:"webgl",kernelFunc:$f};function Ag(t,n,e){let r=t[0].dtype;if(r==="complex64"){let d=t.map(x=>ql({inputs:{input:x},backend:e})),h=t.map(x=>$f({inputs:{input:x},backend:e})),g=Ag(d,n,e),m=Ag(h,n,e),y=zo({inputs:{real:g,imag:m},backend:e});return d.forEach(x=>e.disposeIntermediateTensorInfo(x)),h.forEach(x=>e.disposeIntermediateTensorInfo(x)),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),y}let o=e.shouldExecuteOnCPU(t);if(r==="string"&&(o=!0),o){let d=t.map(I=>{let O=[-1,b.sizeFromShape(I.shape.slice(n))];return we({inputs:{x:I},backend:e,attrs:{shape:O}})}),h=d.map(I=>({vals:e.readSync(I.dataId),shape:I.shape})),g=_.computeOutShape(d.map(I=>I.shape),1),m=d[0].shape[0]===1,y=rG(h,g,r,m),x=_.computeOutShape(t.map(I=>I.shape),n),C=e.makeTensorInfo(x,r,y);return d.forEach(I=>e.disposeIntermediateTensorInfo(I)),C}let s=t.filter(d=>b.sizeFromShape(d.shape)>0),i=Z().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(s.length===1){let d=i?new kr(t[0].shape,ma):new Po(t[0].shape,ma);return e.runWebGLProgram(d,t,r)}let a=Z().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>a){let d=[];for(let g=0;g<s.length;g+=a){let m=s.slice(g,g+a);d.push(Ag(m,n,e))}let h=Ag(d,n,e);for(let g of d)e.disposeIntermediateTensorInfo(g);return h}if(i){let d=new l3(s.map(h=>h.shape),n);return e.runWebGLProgram(d,s,r)}let{tensors2D:l,outShape:c}=Gye(s,n,e),u=new i3(l.map(d=>d.shape)),p=e.runWebGLProgram(u,l,r);l.forEach(d=>e.disposeIntermediateTensorInfo(d));let f=we({inputs:{x:p},attrs:{shape:c},backend:e});return e.disposeIntermediateTensorInfo(p),f}function Gye(t,n,e){let r=_.computeOutShape(t.map(s=>s.shape),n);return{tensors2D:t.map(s=>we({inputs:{x:s},attrs:{shape:[-1,b.sizeFromShape(s.shape.slice(n))]},backend:e})),outShape:r}}function Ik(t){let{inputs:n,backend:e,attrs:r}=t,{axis:o}=r,s=b.parseAxisParam(o,n[0].shape)[0],i=n.map(c=>c.shape);_.assertParamsConsistent(i,s);let a=_.computeOutShape(n.map(c=>c.shape),s);if(b.sizeFromShape(a)===0)return e.makeTensorInfo(a,n[0].dtype,[]);let l=n.filter(c=>b.sizeFromShape(c.shape)>0);return l.length===1?Vn({inputs:{x:l[0]},backend:e}):Ag(l,s,e)}var nH={kernelName:kc,backendName:"webgl",kernelFunc:Ik};var _g=class{constructor(n,e=!1,r=null,o=!1,s=!1){this.variableNames=["x","W"],this.outputShape=n.outShape;let i=n.padInfo.top,a=n.padInfo.left,l=n.strideHeight,c=n.strideWidth,u=n.dilationHeight,p=n.dilationWidth,f=n.filterHeight,d=n.filterWidth,h=Math.floor(n.inChannels/4)*4,g=n.inChannels%4,m=n.dataFormat==="channelsLast",y=m?1:2,x=m?2:3,C=m?3:1,I="",D="";r&&(o?I=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?I=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:I=`
          float activation(float x) {
            ${r}
          }
        `,D="result = activation(result);");let O=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${I}

      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${C}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${x}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${f}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${n.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${d}; wC++) {
            int xC = xCCorner + wC * ${p};

            if (xC < 0 || xC >= ${n.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${h}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${m}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${g===1}) {

              if (${m}) {
                dotProd +=
                    getX(batch, xR, xC, ${h}) *
                    getW(wR, wC, ${h}, d2);
              } else {
                dotProd +=
                    getX(batch, ${h}, xR, xC) *
                    getW(wR, wC, ${h}, d2);
              }

            } else if (${g===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${h}, d2),
                getW(wR, wC, ${h} + 1, d2)
              );

              if (${m}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${h}),
                  getX(batch, xR, xC, ${h} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${h}, xR, xC),
                  getX(batch, ${h} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${g===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${h}, d2),
                getW(wR, wC, ${h} + 1, d2),
                getW(wR, wC, ${h} + 2, d2)
              );

              if (${m}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${h}),
                  getX(batch, xR, xC, ${h} + 1),
                  getX(batch, xR, xC, ${h} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${h}, xR, xC),
                  getX(batch, ${h} + 1, xR, xC),
                  getX(batch, ${h} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${O}
        ${D}
        setOutput(result);
      }
    `}},c3=class{constructor(n){this.variableNames=["x","W"],this.outputShape=n.outShape;let e=n.padInfo.front,r=n.padInfo.top,o=n.padInfo.left,s=n.strideDepth,i=n.strideHeight,a=n.strideWidth,l=n.dilationDepth,c=n.dilationHeight,u=n.dilationWidth,p=n.filterDepth,f=n.filterHeight,d=n.filterWidth,h=Math.floor(n.inChannels/4)*4,g=n.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${i}, ${a});
      const ivec3 pads = ivec3(${e}, ${r}, ${o});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${p}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${n.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${n.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${n.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${h}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${g===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${h}) *
                  getW(wF, wR, wC, ${h}, d2);
              } else if (${g===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${h}),
                  getX(batch, xF, xR, xC, ${h} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${h}, d2),
                  getW(wF, wR, wC, ${h} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${g===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${h}),
                  getX(batch, xF, xR, xC, ${h} + 1),
                  getX(batch, xF, xR, xC, ${h} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${h}, d2),
                  getW(wF, wR, wC, ${h} + 1, d2),
                  getW(wF, wR, wC, ${h} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};var Rg=class{constructor(n,e=!1,r=null,o=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=jt(this.outputShape.length);let i=n.padInfo.left,a=n.strideWidth,l=n.dilationWidth,c=n.filterHeight,u=n.filterWidth,p=u,f=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let m=0;m<u;m++)f+=`
           vec4 xTexelC${m*2};
           int xTexelC${m*2}Ready;
           vec4 xTexelC${m*2+1};
           int xTexelC${m*2+1}Ready;
           vec4 xC${m};`;f+=`
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${n.inChannels}; d1 += 2) {
       `;for(let m=0;m<u;m++)f+=`
           xTexelC${m*2} = vec4(0.0);
           xTexelC${m*2}Ready = 0;
           xTexelC${m*2+1} = vec4(0.0);
           xTexelC${m*2+1}Ready = 0;
           xC${m} = vec4(0.0);`;f+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let m=0;m<(p+1)/2;m++){let y=m*2;if(f+=`
           xC = xCCorner + ${y*l};
           `,a===1){if(y<u&&(i%2===1?(f+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }
               `,l===1&&y>0?f+=`
                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                 `:f+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                   } else {
                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                   }
                   `):f+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xC${y} = xTexelC${y};
                 `,y+1<u)){let x=i%2===0?b.nearestLargerEven(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(f+=`
                   xCOffset = xC + imod(pads[1], 2) + ${x};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${y+1}.zw = vec2(0.0);
                     }
                     xTexelC${y+1}Ready = 1;
                   }
                   `,l>1?f+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                     } else {
                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                     }
                     `:f+=`
                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                     `):x===1?f+=`
                     xC${y+1} = xTexelC${y};
                     `:f+=`
                     xCOffset = xC + ${x};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${y+1}.zw = vec2(0.0);
                       }
                       xTexelC${y+1}Ready = 1;
                     }

                     xC${y+1} = xTexelC${y+1};
                     `}}else y<u&&(i%2===1?(f+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.0);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
               `,y+1<u&&(f+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                 `)):(f+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(
                   xTexelC${y}.xy, xTexelC${y+1}.xy);
               `,y+1<u&&(f+=`
                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                 `)));y<u&&(f+=`
             wTexel = getW(r, ${y}, d1, d2);
             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${n.inChannels}) {
               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,y+1<u&&(f+=`
               wTexel = getW(r, ${y+1}, d1, d2);
               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${n.inChannels}) {
                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}f+=`
     }
   `,f+=`
     }
   `,f+=`
     }
   `;let d="",h="";r&&(o?d=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }`:s?d=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }`:d=`vec4 activation(vec4 x) {
           ${r}
         }`,h="result = activation(result);");let g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${d}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${f}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${g}
         ${h}
         setOutput(result);
       }
     `}};var u3=class{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=n,this.enableShapeUniforms=jt(this.outputShape.length);let{dataFormat:r}=e,o=_n(),s=r==="channelsLast",i=s?1:2,a=s?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${n[2]} && pos < ${n[1]}) {`,c="";for(let u=0;u<=1;u++)for(let p=0;p<=1;p++)c+=`
          blockIndex = rc.z + ${p};
          pos = rc.y + ${u};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${u*2+p}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${u*2+p}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${o.output} = result;
      }
    `}};function p3(t,n){let e=t.length;return e>=3?n?[...t.slice(0,-3),t[e-3]*t[e-2],t[e-1]]:[...t.slice(0,-3),t[e-3],t[e-2]*t[e-1]]:!n&&e===1&&t[0]>1?[t[0],1]:null}function f3({x:t,filter:n,convInfo:e,backend:r,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let l=t.shape,c=r.texData.get(t.dataId),u=e.inChannels,p=l[0]*l[1]*l[2],f=e.outChannels,d=e.dataFormat==="channelsLast",h=!1,g=!1,m,y=[];if(s!=null){let I=p3(s.shape,d);I!=null&&(s=we({inputs:{x:s},backend:r,attrs:{shape:I}}),y.push(s))}if(o!=null){let I=p3(o.shape,d);I!=null&&(o=we({inputs:{x:o},backend:r,attrs:{shape:I}}),y.push(o))}if(!((p===1||f===1)&&u>vk)&&c.isPacked&&d&&c.texture!=null&&l[2]%2!==0&&b.arraysEqual(c.shape.slice(-3),l.slice(-3))){let I=l[0]*l[1]*(l[2]+1),D={dataId:t.dataId,shape:[1,I,e.inChannels],dtype:t.dtype},O=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,b.assert(Af(c.shape,D.shape),()=>`packed reshape ${c.shape} to ${D.shape} isn't free`);let L=we({inputs:{x:n},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}});y.push(L);let B=Ff({a:D,b:L,backend:r,transposeA:h,transposeB:g,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i}),V=r.texData.get(B.dataId);b.assert(V.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=O,V.shape=e.outShape,m=Vn({inputs:{x:B},backend:r}),m.shape=e.outShape,y.push(B)}else{let I=e.outHeight*e.outWidth,D=we({inputs:{x:t},backend:r,attrs:{shape:d?[e.batchSize,I,e.inChannels]:[e.batchSize,e.inChannels,I]}}),O=we({inputs:{x:n},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}}),L=Ff({a:d?D:O,b:d?O:D,transposeA:!d,transposeB:g,backend:r,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i});m=we({inputs:{x:L},backend:r,attrs:{shape:e.outShape}}),y.push(D),y.push(O),y.push(L)}for(let I of y)r.disposeIntermediateTensorInfo(I);return m}function d3({x:t,filter:n,convInfo:e,backend:r,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let{filterWidth:l,filterHeight:c,inChannels:u,outWidth:p,outHeight:f,dataFormat:d}=e,h=d==="channelsLast",g=l*c*u,m=f*p,y=[e.batchSize,g,m],x=!0,C=!1,I=[];if(s!=null){let se=p3(s.shape,h);se!=null&&(s=we({inputs:{x:s},backend:r,attrs:{shape:se}}),I.push(s))}if(o!=null){let se=p3(o.shape,h);se!=null&&(o=we({inputs:{x:o},backend:r,attrs:{shape:se}}),I.push(o))}let D=we({inputs:{x:n},backend:r,attrs:{shape:[1,g,b.sizeFromShape(n.shape)/g]}});I.push(D);let O=new u3(y,e),L=[t.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]],B=r.runWebGLProgram(O,[t],"float32",L),V=we({inputs:{x:B},backend:r,attrs:{shape:y}});I.push(B),I.push(V);let F=o!=null,G=s!=null,ee=a==="leakyrelu",Q=a?Wl(a,!0):null,oe=new kg(h?V.shape:D.shape,h?D.shape:V.shape,h?[e.batchSize,m,e.outChannels]:[e.batchSize,e.outChannels,m],x,C,F,Q,G,ee),ae=h?[V,D]:[D,V];if(o&&ae.push(o),G&&ae.push(s),ee){let se=r.makeTensorInfo([],"float32",b.createScalarValue(i,"float32"));ae.push(se),I.push(se)}let J=r.runWebGLProgram(oe,ae,"float32"),re=we({inputs:{x:J},backend:r,attrs:{shape:e.outShape}});I.push(J);for(let se of I)r.disposeIntermediateTensorInfo(se);return re}function jye(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,filter:s}=n,{strides:i,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=r,p=_.convertConv2DDataFormat(l),f=_.computeConv2DInfo(o.shape,s.shape,i,c,a,u,!1,p),d;if(f.filterHeight===1&&f.filterWidth===1&&f.dilationHeight===1&&f.dilationWidth===1&&f.strideHeight===1&&f.strideWidth===1&&(f.padInfo.type==="SAME"||f.padInfo.type==="VALID"))d=f3({x:o,filter:s,convInfo:f,backend:e});else if(f.strideWidth<=2&&p==="channelsLast"&&Z().getBool("WEBGL_EXP_CONV")){let g=new Rg(f),m=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];d=e.runWebGLProgram(g,[o,s],"float32",m)}else if(Z().getBool("WEBGL_CONV_IM2COL"))d=d3({x:o,filter:s,convInfo:f,backend:e});else{let g=new _g(f);d=e.runWebGLProgram(g,[o,s],"float32")}let h=we({inputs:{x:d},backend:e,attrs:{shape:f.outShape}});return e.disposeIntermediateTensorInfo(d),h}var rH={kernelName:Ac,backendName:"webgl",kernelFunc:jye};var h3=class{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape;let e=n.strideHeight,r=n.strideWidth,o=n.padInfo.top,s=n.padInfo.left,i=n.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${n.batchSize}; b++) {
          for (int yR = 0; yR < ${n.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${o};

            if (xR < 0 || xR >= ${n.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${n.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${s};

              if (xC < 0 || xC >= ${n.inWidth}) {
                continue;
              }

              ${i?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},m3=class{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;let e=n.filterHeight,r=n.filterWidth,o=n.strideHeight,s=n.strideWidth,i=n.dataFormat==="channelsLast",a=e-1-n.padInfo.top,l=r-1-n.padInfo.left,c=i?1:2,u=i?2:3,p=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${p}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${n.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},g3=class{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape;let e=n.strideDepth,r=n.strideHeight,o=n.strideWidth,s=n.padInfo.front,i=n.padInfo.top,a=n.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${n.batchSize}; b++) {
          for (int yF = 0; yF < ${n.outDepth}; yF++) {
            int xF = wF + yF * ${e} - ${s};

            if (xF < 0 || xF >= ${n.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${n.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${i};

              if (xR < 0 || xR >= ${n.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${n.outWidth}; yC++) {
                int xC = wC + yC * ${o} - ${a};

                if (xC < 0 || xC >= ${n.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},y3=class{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;let e=n.filterDepth,r=n.filterHeight,o=n.filterWidth,s=n.strideDepth,i=n.strideHeight,a=n.strideWidth,l=e-1-n.padInfo.front,c=r-1-n.padInfo.top,u=o-1-n.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${c}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${e}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${n.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${e} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${o}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${o} - 1 - wC;

              for (int d2 = 0; d2 < ${n.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Hye(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,dy:s}=n,{strides:i,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=r,p=_.convertConv2DDataFormat(l),f=_.computeConv2DInfo(o.shape,u,i,1,a,c,!1,p),d=new h3(f);return e.runWebGLProgram(d,[o,s],"float32")}var oH={kernelName:rh,backendName:"webgl",kernelFunc:Hye};var x3=class{constructor(n){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=n.inShape,this.enableShapeUniforms=jt(this.outputShape.length);let e=n.filterHeight,r=n.filterWidth,o=e-1-n.padInfo.top,s=r-1-n.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${s});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            int wCPerm = ${r} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${n.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${n.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${n.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${n.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${n.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}};function Wye(t){let{inputs:n,backend:e,attrs:r}=t,{dy:o,filter:s}=n,{inputShape:i,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=r,p=_.convertConv2DDataFormat(c),f=_.computeConv2DInfo(i,s.shape,a,1,l,u,!1,p);if(Z().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&p==="channelsLast"){let d=[[f.strideHeight,f.strideWidth]],h=new x3(f);return e.runWebGLProgram(h,[o,s],"float32",d)}else{let d=new m3(f);return e.runWebGLProgram(d,[o,s],"float32")}}var sH={kernelName:_c,backendName:"webgl",kernelFunc:Wye};function qye(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,filter:s}=n,{strides:i,pad:a,dilations:l}=r,c=_.computeConv3DInfo(o.shape,s.shape,i,l,a),u=new c3(c);return e.runWebGLProgram(u,[o,s],"float32")}var iH={kernelName:Rc,backendName:"webgl",kernelFunc:qye};function Kye(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,dy:s}=n,{strides:i,pad:a,filterShape:l}=r,c=_.computeConv3DInfo(o.shape,l,i,1,a),u=new g3(c);return e.runWebGLProgram(u,[o,s],"float32")}var aH={kernelName:oh,backendName:"webgl",kernelFunc:Kye};function Xye(t){let{inputs:n,backend:e,attrs:r}=t,{dy:o,filter:s}=n,{pad:i,strides:a,inputShape:l}=r,c=_.computeConv3DInfo(l,s.shape,a,1,i),u=new y3(c);return e.runWebGLProgram(u,[o,s],"float32")}var lH={kernelName:sh,backendName:"webgl",kernelFunc:Xye};var Yye=ei+`
  return cos(x);
`,Zye=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${as}
  return result;
`,Qye=ze({opSnippet:Yye,packedOpSnippet:Zye}),cH={kernelName:"Cos",backendName:"webgl",kernelFunc:Qye};var Jye=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,e1e=ze({opSnippet:Jye}),uH={kernelName:Ja,backendName:"webgl",kernelFunc:e1e};var v3=class{constructor(n,e,r,o,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[i,a,l,c]=n,[u]=e,[p,f]=r;this.outputShape=[u,p,f,c];let d=o==="bilinear"?1:0,[h,g]=[`${a-1}.0`,`${l-1}.0`],[m,y,x]=p>1?[`${(a-1)/(p-1)}`,"(y2-y1) * height_ratio",`y1*${h} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${h}`],[C,I,D]=f>1?[`${(l-1)/(f-1)}`,"(x2-x1) * width_ratio",`x1*${g} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${g}`];this.userCode=`
      const float height_ratio = float(${m});
      const float width_ratio = float(${C});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${I};

        float in_y = ${x};
        if( in_y < 0.0 || in_y > ${h} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${D};
        if( in_x < 0.0 || in_x > ${g} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${d} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};var t1e=t=>{let{inputs:n,backend:e,attrs:r}=t,{image:o,boxes:s,boxInd:i}=n,{cropSize:a,method:l,extrapolationValue:c}=r,u=new v3(o.shape,s.shape,a,l,c);return e.runWebGLProgram(u,[o,s,i],"float32")},pH={kernelName:ah,backendName:"webgl",kernelFunc:t1e};var Mg=(function(t){return t.Prod="*",t.Sum="+",t})(Mg||{}),wx=class{constructor(n,e,r,o){this.op=n,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let s=this.outputShape.length,i=this.op===Mg.Prod?"1.0":"0.0",a=r?i:`getX(${fH(s,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1],c="",u="";r?(c=o?`end != ${l-1}`:"end != 0",u=o?"end + 1":"end - 1"):(c=o?`end + pow2 < ${l}`:"end >= pow2",u=o?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${st(s)} coords = getOutputCoords();
        int end = ${dH(s,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${u};
          ${dH(s,"coords",this.op)} = idx;
          val ${this.op}= getX(${fH(s,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function fH(t,n,e){if(t===1)return`${n}`;if(t===2)return`${n}.x, ${n}.y`;if(t===3)return`${n}.x, ${n}.y, ${n}.z`;if(t===4)return`${n}.x, ${n}.y, ${n}.z, ${n}.w`;throw new Error(`Cumulative ${e} for rank ${t} is not yet supported`)}function dH(t,n,e){if(t===1)return`${n}`;if(t===2)return`${n}.y`;if(t===3)return`${n}.z`;if(t===4)return`${n}.w`;throw new Error(`Cumulative ${e} for rank ${t} is not yet supported`)}function b3(t,n,e,r,o,s){let i=n.shape.length,a=_.getAxesPermutation([r],i),l=n;a!=null&&(l=Cn({inputs:{x:n},backend:e,attrs:{perm:a}}));let c=_.getInnerMostAxes(1,i)[0];if(c!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${n.shape.length-1} but got axis=${r}`);let u=l.shape[c],p=Vn({inputs:{x:l},backend:e});for(let f=0;f<=Math.ceil(Math.log2(u))-1;f++){let d=new wx(t,l.shape,!1,s),h=[[f]],g=p;p=e.runWebGLProgram(d,[p],p.dtype,h),e.disposeIntermediateTensorInfo(g)}if(o){let f=new wx(t,l.shape,o,s),d=p;p=e.runWebGLProgram(f,[p],p.dtype),e.disposeIntermediateTensorInfo(d)}if(a!=null){let f=_.getUndoAxesPermutation(a),d=Cn({inputs:{x:p},backend:e,attrs:{perm:f}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(l),d}return p}function n1e(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,exclusive:i,reverse:a}=r;return b3(Mg.Prod,o,e,s,i,a)}var hH={kernelName:ih,backendName:"webgl",kernelFunc:n1e};function r1e(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,exclusive:i,reverse:a}=r;return b3(Mg.Sum,o,e,s,i,a)}var mH={kernelName:Mc,backendName:"webgl",kernelFunc:r1e};function o1e(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,weights:s}=n,{size:i,binaryOutput:a}=r;if(o.shape.length===1){let l=e.readSync(o.dataId),c=e.readSync(s.dataId),u=FC(l,c,s.dtype,s.shape,i);return e.makeTensorInfo([i],s.dtype,u)}else if(o.shape.length===2){let l=e.bufferSync(o),c=e.bufferSync(s),u=JU(l,c,i,a);return e.makeTensorInfo(u.shape,s.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var gH={kernelName:lh,backendName:"webgl",kernelFunc:o1e};var w3=class{constructor(n,e,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=n,this.blockSize=e,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${e};
      int offset_h = imod(h, ${e});
      int in_w = w / ${e};
      int offset_w = imod(w, ${e});
      int offset_d = (offset_h * ${e} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function s1e(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{blockSize:s,dataFormat:i}=r,a=o.shape[0],l=i==="NHWC"?o.shape[1]:o.shape[2],c=i==="NHWC"?o.shape[2]:o.shape[3],u=i==="NHWC"?o.shape[3]:o.shape[1],p=l*s,f=c*s,d=u/(s*s),h=i==="NHWC"?[a,p,f,d]:[a,d,p,f],g=new w3(h,s,i);return e.runWebGLProgram(g,[o],o.dtype)}var yH={kernelName:ch,backendName:"webgl",kernelFunc:s1e};var Og=class{constructor(n,e=!1,r=null,o=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=jt(this.outputShape.length);let i=n.filterHeight,a=n.filterWidth,l=n.outChannels/n.inChannels,c="",u="";r&&(o?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:c=`
          float activation(float x) {
            ${r}
          }
        `,u="result = activation(result);");let p=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${p}
        ${u}
        setOutput(result);
      }
    `}};var Fg=class{constructor(n,e=!1,r=null,o=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=jt(this.outputShape.length);let i=n.outChannels/n.inChannels,a=n.padInfo.left,l=n.strideWidth,c=n.dilationWidth,u=n.filterHeight,p=n.filterWidth,f=p,d=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<p;y++)d+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;d+=`
    for (int r = 0; r < ${u}; r++) {
      `;for(let y=0;y<p;y++)d+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;d+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(f+1)/2;y++){let x=y*2;if(d+=`
          xC = xCCorner + ${x*c};
          `,l===1){if(x<p&&(a%2===1?(d+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }
              `,c===1&&x>0?d+=`
                xC${x} = vec4(xTexelC${x-2}.zw, xTexelC${x}.xy);
                `:d+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${x} = vec4(previous.zw, xTexelC${x}.xy);
                  } else {
                    xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);
                  }
                  `):d+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                xC${x} = xTexelC${x};
                `,x+1<p)){let C=a%2===0?b.nearestLargerEven(c):c;c%2===0&&a%2===1||c%2!==0&&a%2!==1?(d+=`
                  xCOffset = xC + imod(pads[1], 2) + ${C};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                    xTexelC${x+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${x+1}.zw = vec2(0.0);
                    }
                    xTexelC${x+1}Ready = 1;
                  }
                  `,c>1?d+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${x+1} = vec4(previous.zw, xTexelC${x+1}.xy);
                    } else {
                     xC${x+1} = vec4(0.0, 0.0, xTexelC${x+1}.xy);
                    }
                    `:d+=`
                    xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.xy);
                    `):C===1?d+=`
                    xC${x+1} = xTexelC${x};
                    `:d+=`
                    xCOffset = xC + ${C};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                      xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${x+1}.zw = vec2(0.0);
                      }
                      xTexelC${x+1}Ready = 1;
                    }

                    xC${x+1} = xTexelC${x+1};
                    `}}else x<p&&(a%2===1?(d+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x+1}Ready == 0) {
                  xTexelC${x+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${x+1}.zw = vec2(0.0);
                  }
                  xTexelC${x+1}Ready = 1;
                }

                xC${x} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
              `,x+1<p&&(d+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${x+1} = vec4(xTexelC${x+1}.xy, final.xy);
                `)):(d+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                  xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x+1}.zw = vec2(0.);
                  }
                  xTexelC${x+1}Ready = 1;
                }

                xC${x} = vec4(
                  xTexelC${x}.xy, xTexelC${x+1}.xy);
              `,x+1<p&&(d+=`
                  xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
                `)));x<p&&(d+=`
            wTexel = getW(r, ${x}, d1, q);
            dotProd += xC${x} * vec4(wTexel.xz, wTexel.xz);
          `,x+1<p&&(d+=`
              wTexel = getW(r, ${x+1}, d1, q);
              dotProd += xC${x+1} * vec4(wTexel.xz, wTexel.xz);
            `))}d+=`
    }
  `,d+=`
      }
    `;let h="",g="";r&&(o?h=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?h=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:h=`vec4 activation(vec4 x) {
          ${r}
        }`,g="result = activation(result);");let m=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${h}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${d}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${m}
        ${g}
        setOutput(result);
      }
    `}};function i1e(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,filter:s}=n,{strides:i,pad:a,dilations:l,dimRoundingMode:c}=r,u=l;u==null&&(u=[1,1]),b.assert(_.eitherStridesOrDilationsAreOne(i,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let p=_.computeConv2DInfo(o.shape,s.shape,i,u,a,c,!0),f;Z().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels===1?f=new Fg(p):f=new Og(p);let d=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return e.runWebGLProgram(f,[o,s],"float32",d)}var xH={kernelName:Oc,backendName:"webgl",kernelFunc:i1e};var C3=class{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape;let e=n.strideHeight,r=n.strideWidth,o=n.padInfo.top,s=n.padInfo.left,i=n.outChannels/n.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${n.batchSize}; b++) {
          for (int yR = 0; yR < ${n.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${o};

            if (xR < 0 || xR >= ${n.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${n.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${s};

              if (xC < 0 || xC >= ${n.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},I3=class{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;let e=n.filterHeight,r=n.filterWidth,o=n.strideHeight,s=n.strideWidth,i=e-1-n.padInfo.top,a=r-1-n.padInfo.left,l=n.outChannels/n.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function a1e(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,dy:s}=n,{strides:i,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=r,p=_.computeConv2DInfo(o.shape,u,i,a,l,c,!0),f=new C3(p);return e.runWebGLProgram(f,[o,s],"float32")}var vH={kernelName:uh,backendName:"webgl",kernelFunc:a1e};function l1e(t){let{inputs:n,backend:e,attrs:r}=t,{dy:o,filter:s}=n,{strides:i,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=r,p=_.computeConv2DInfo(u,s.shape,i,a,l,c,!0),f=new I3(p);return e.runWebGLProgram(f,[o,s],"float32")}var bH={kernelName:ph,backendName:"webgl",kernelFunc:l1e};var S3=class{constructor(n){this.variableNames=["X"],this.outputShape=[n,n],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function c1e(t){let{inputs:n,backend:e}=t,{x:r}=n,o=[...r.shape,...r.shape],s=b.sizeFromShape(r.shape),i=we({inputs:{x:r},backend:e,attrs:{shape:[s]}}),a=new S3(s),l=e.runWebGLProgram(a,[i],i.dtype),c=we({inputs:{x:l},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(l),c}var wH={kernelName:fh,backendName:"webgl",kernelFunc:c1e};var T3=class{constructor(n){this.variableNames=["x","W"],this.outputShape=n.outShape;let{inHeight:e,inWidth:r,padInfo:o,strideHeight:s,strideWidth:i,filterHeight:a,filterWidth:l,dilationHeight:c,dilationWidth:u}=n,{top:p,left:f}=o;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${i});
      const ivec2 pads = ivec2(${p}, ${f});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${e}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function u1e(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,filter:s}=n,{strides:i,pad:a,dilations:l}=r,c=_.computeDilation2DInfo(o.shape,s.shape,i,a,"NHWC",l),u,p=new T3(c);u=e.runWebGLProgram(p,[o,s],"float32");let f=we({inputs:{x:u},backend:e,attrs:{shape:c.outShape}});return e.disposeIntermediateTensorInfo(u),f}var CH={kernelName:Fc,backendName:"webgl",kernelFunc:u1e};function p1e(t){let{inputs:n,backend:e,attrs:r}=t,{equation:o}=r,s=n,{allDims:i,summedDims:a,idDims:l}=_.decodeEinsumEquation(o,s.length);_.checkEinsumDimSizes(i.length,l,s);let{path:c,steps:u}=_.getEinsumComputePath(a,l),p=u.length,f=null,d=i.length,h=[];for(let g=0;g<p;++g){for(let m of u[g]){let{permutationIndices:y,expandDims:x}=_.getEinsumPermutation(d,l[m]),C;_.isIdentityPermutation(y)?C=s[m]:(C=Cn({inputs:{x:s[m]},backend:e,attrs:{perm:y}}),h.push(C));let I=C.shape.slice();for(let D=0;D<x.length;++D)I.splice(x[D],0,1);b.arraysEqual(C.shape,I)||(C=we({inputs:{x:C},backend:e,attrs:{shape:I}}),h.push(C)),f===null?f=C:(f=vx({inputs:{a:C,b:f},backend:e}),h.push(f))}g<p-1&&(c[g]>=0&&(f=Of({inputs:{x:f},backend:e,attrs:{axis:c[g]-(i.length-d),keepDims:!1}}),h.push(f)),d--)}for(let g of h)g!==f&&e.disposeIntermediateTensorInfo(g);return f}var IH={kernelName:dh,backendName:"webgl",kernelFunc:p1e};var f1e="return (x >= 0.0) ? x : (exp(x) - 1.0);",d1e=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,h1e=ze({opSnippet:f1e,packedOpSnippet:d1e}),SH={kernelName:"Elu",backendName:"webgl",kernelFunc:h1e};var m1e="return (b >= 0.0) ? a : a * (b + 1.0);",g1e=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,y1e=t=>{let{inputs:n,backend:e}=t,{dy:r,y:o}=n,s=Z().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new is(g1e,r.shape,o.shape):new Bo(m1e,r.shape,o.shape);return e.runWebGLProgram(s,[r,o],r.dtype)},TH={kernelName:hh,backendName:"webgl",kernelFunc:y1e};var x1e=`
  return vec4(equal(a, b));
`,v1e="return float(a == b);",b1e=Pt({opSnippet:v1e,packedOpSnippet:x1e,dtype:"bool",cpuKernelImpl:oG}),EH={kernelName:_p,backendName:"webgl",kernelFunc:b1e};var w1e=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${_.ERF_P};
  float a1 = ${_.ERF_A1};
  float a2 = ${_.ERF_A2};
  float a3 = ${_.ERF_A3};
  float a4 = ${_.ERF_A4};
  float a5 = ${_.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,C1e=ze({opSnippet:w1e}),NH={kernelName:"Erf",backendName:"webgl",kernelFunc:C1e};var I1e=ei+`
  return exp(x);
`,S1e=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Sk=ze({opSnippet:I1e,packedOpSnippet:S1e,cpuKernelImpl:sG,dtype:"float32"}),DH={kernelName:"Exp",backendName:"webgl",kernelFunc:Sk};function E3(t){let{inputs:n,attrs:e,backend:r}=t,{dim:o}=e,{input:s}=n,i=s.shape.length,a=s.shape.slice(),l=o;return o<0&&(b.assert(-(i+1)<=o,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+o+1),a.splice(l,0,1),we({inputs:{x:s},backend:r,attrs:{shape:a}})}var kH={kernelName:$c,backendName:"webgl",kernelFunc:E3};var AH="return exp(x) - 1.0;",T1e=ze({opSnippet:AH,packedOpSnippet:AH,cpuKernelImpl:iG}),_H={kernelName:tl,backendName:"webgl",kernelFunc:T1e};var Cx=class{constructor(n,e,r){this.variableNames=["real","imag"];let o=e[1];this.outputShape=e;let s=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=r?`${o}.0`:"1.0",a;if(n==="real")a="return real * expR - imag * expI;";else if(n==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${n}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${o});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${o}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function N3(t,n,e){let r=e.texData.get(t.dataId),o=b.sizeFromShape(t.shape),s=t.shape[t.shape.length-1],i=o/s,a=we({inputs:{x:t},backend:e,attrs:{shape:[i,s]}}),l=a.shape,c=new Cx("real",l,n),u=new Cx("imag",l,n),p=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],f=e.runWebGLProgram(c,p,"float32"),d=e.runWebGLProgram(u,p,"float32"),h=zo({inputs:{real:f,imag:d},backend:e});e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d);let g=we({inputs:{x:h},backend:e,attrs:{shape:t.shape}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(h),g}function E1e(t){let{inputs:n,backend:e}=t,{input:r}=n;return N3(r,!1,e)}var RH={kernelName:"FFT",backendName:"webgl",kernelFunc:E1e};var D3=class{constructor(n,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=n,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function Kl(t){let{backend:n,attrs:e}=t,{shape:r,value:o}=e,{dtype:s}=e;if(s=s||b.inferDtype(o),s==="string"){let i=b.getArrayFromDType(s,b.sizeFromShape(r));return i.fill(o),n.makeTensorInfo(r,s,i)}else{let i=new D3(r,o),a=[[o]];return n.runWebGLProgram(i,[],s,a)}}var MH={kernelName:mh,backendName:"webgl",kernelFunc:Kl};var k3=class{constructor(n){this.variableNames=["Image"],this.outputShape=[];let e=n[2];this.outputShape=n,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${e} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${e}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var OH={kernelName:gh,backendName:"webgl",kernelFunc:({inputs:t,backend:n})=>{let{image:e}=t,r=n,o=new k3(e.shape);return r.runWebGLProgram(o,[e],e.dtype)}};var FH="return floor(x);",N1e=ze({opSnippet:FH,packedOpSnippet:FH,cpuKernelImpl:aG}),$H={kernelName:nl,backendName:"webgl",kernelFunc:N1e};var D1e=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,k1e=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,A1e=Pt({opSnippet:D1e,packedOpSnippet:k1e,dtype:"int32"}),LH={kernelName:rl,backendName:"webgl",kernelFunc:A1e};var A3=class{constructor(n){this.variableNames=["A"];let e=_n(),[r,o]=n;this.outputShape=n,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}.0, ${r}.0);

        vec4 values = ${e.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};var _3=class{constructor(n){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let e=_n(),[r,o]=n;this.outputShape=n,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${o}.0, ${r}.0);
            vec4 values = ${e.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${e.output} = result;
      }
    `}};var PH={kernelName:p1,backendName:"webgl",kernelFunc:_1e},$g,Tk=Z().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function _1e(t){let{inputs:n,backend:e,attrs:r}=t,{pixels:o}=n,{numChannels:s}=r,i=typeof HTMLVideoElement<"u"&&o instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&o instanceof HTMLImageElement,[l,c]=i?[o.videoWidth,o.videoHeight]:[o.width,o.height],u=[c,l],p=[c,l,s];if(a||i){let g=Z().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");($g==null||g!==Tk)&&(Tk=g,$g=document.createElement("canvas").getContext("2d",{willReadFrequently:Tk})),$g.canvas.width=l,$g.canvas.height=c,$g.drawImage(o,0,0,l,c),o=$g.canvas}let f=e.makeTensorInfo(u,"int32");e.texData.get(f.dataId).usage=ro.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(f.dataId),o);let d=Z().getBool("WEBGL_PACK")?new _3(p):new A3(p),h=e.runWebGLProgram(d,[f],"int32");return e.disposeData(f.dataId),h}function R1e(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,filter:s,bias:i,preluActivationWeights:a}=n,{strides:l,pad:c,dataFormat:u,dilations:p,dimRoundingMode:f,activation:d,leakyreluAlpha:h}=r,g=_.convertConv2DDataFormat(u),m=_.computeConv2DInfo(o.shape,s.shape,l,p,c,f,!1,g),y,x=[],C=i!=null,I=a!=null,D=d==="leakyrelu",O=()=>{let B=[o,s],V=(F,G)=>{if(G==="NCHW"&&F.shape.length===1&&F.shape[0]!==1){let ee=we({inputs:{x:F},backend:e,attrs:{shape:[F.shape[0],1,1]}});return x.push(ee),ee}return F};if(C&&B.push(V(i,u)),I&&B.push(V(a,u)),D){let F=e.makeTensorInfo([],"float32",b.createScalarValue(h,"float32"));B.push(F),x.push(F)}return B};if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))y=f3({x:o,filter:s,convInfo:m,backend:e,bias:i,activation:d,preluActivationWeights:a,leakyreluAlpha:h});else if(m.strideWidth<=2&&g==="channelsLast"&&Z().getBool("WEBGL_EXP_CONV")){let B=d?Wl(d,!0):null,V=new Rg(m,C,B,I,D),F=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],G=O();y=e.runWebGLProgram(V,G,"float32",F)}else if(Z().getBool("WEBGL_CONV_IM2COL"))y=d3({x:o,filter:s,convInfo:m,backend:e,bias:i,activation:d,preluActivationWeights:a,leakyreluAlpha:h});else{let B=d?Wl(d,!1):null,V=new _g(m,C,B,I,D),F=O();y=e.runWebGLProgram(V,F,"float32")}let L=we({inputs:{x:y},backend:e,attrs:{shape:m.outShape}});return x.push(y),x.forEach(B=>e.disposeIntermediateTensorInfo(B)),L}var BH={kernelName:Vp,backendName:"webgl",kernelFunc:R1e};function M1e(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,filter:s,bias:i,preluActivationWeights:a}=n,{strides:l,pad:c,dilations:u,dimRoundingMode:p,activation:f,leakyreluAlpha:d}=r,h=[],g=u;g==null&&(g=[1,1]),b.assert(_.eitherStridesOrDilationsAreOne(l,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`);let m=_.computeConv2DInfo(o.shape,s.shape,l,g,c,p,!0),y=Z().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels===1,x=f?Wl(f,y):null,C=[o,s],I=i!=null,D=a!=null,O=f==="leakyrelu";if(I&&C.push(i),D&&C.push(a),O){let F=e.makeTensorInfo([],"float32",b.createScalarValue(d,"float32"));C.push(F),h.push(F)}let L;y?L=new Fg(m,I,x,D,O):L=new Og(m,I,x,D,O);let B=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],V=e.runWebGLProgram(L,C,"float32",B);return h.forEach(F=>e.disposeIntermediateTensorInfo(F)),V}var zH={kernelName:Up,backendName:"webgl",kernelFunc:M1e};var R3=class{constructor(n,e,r,o){this.sliceDim=n,this.strides=e,this.paramsShape=o,this.variableNames=["x","indices"],this.outputShape=r;let s=st(r.length),i=`
    int index;`;for(let a=0;a<this.sliceDim;a++)i+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function O1e(t){let{inputs:n,backend:e}=t,{params:r,indices:o}=n,s=o.shape,i=s[s.length-1],a=b.sizeFromShape(r.shape),[l,c,u,p]=_.prepareAndValidate(r,o),f=we({inputs:{x:o},backend:e,attrs:{shape:[c,i]}}),d=we({inputs:{x:r},backend:e,attrs:{shape:[b.sizeFromShape(r.shape)/u,u]}});if(e.shouldExecuteOnCPU([r,o])||r.dtype==="string"){let y=e.readSync(o.dataId),x=e.bufferSync(r),C=lG(y,x,r.dtype,c,i,u,p,r.shape,a);return e.makeTensorInfo(l,r.dtype,C.values)}let h=new R3(i,p,[c,u],r.shape),g=e.runWebGLProgram(h,[d,f],d.dtype),m=we({inputs:{x:g},backend:e,attrs:{shape:l}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(g),m}var VH={kernelName:yh,backendName:"webgl",kernelFunc:O1e};var M3=class{constructor(n,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;let r=st(this.rank),o=F1e(n,2);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${n[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${o}));
      }
    `}};function F1e(t,n){let e=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let o=0;o<t.length;o++)o===2?r.push("index"):r.push(`${e[o]}`);return r.join()}function Ek(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,indices:s}=n,{axis:i,batchDims:a}=r,l=b.parseAxisParam(i,o.shape)[0];if(Z().get("DEBUG")){let x=e.readSync(s.dataId),C=o.shape[l];for(let I=0;I<x.length;++I){let D=x[I];b.assert(D<=C-1&&D>=0,()=>`GatherV2: the index value ${D} is not in [0, ${C-1}]`)}}let c=_.segment_util.collectGatherOpShapeInfo(o,s,l,a),u=b.sizeFromShape(s.shape),p=[],f=we({inputs:{x:o},backend:e,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),d=we({inputs:{x:s},backend:e,attrs:{shape:[c.batchSize,u/c.batchSize]}});p.push(f),p.push(d);let h=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(e.shouldExecuteOnCPU([o,s])||o.dtype==="string"){let x=e.bufferSync(d),C=e.bufferSync(f),I=cG(C,x,h);return p.forEach(D=>e.disposeIntermediateTensorInfo(D)),e.makeTensorInfo(c.outputShape,I.dtype,I.values)}let g=new M3(f.shape,h),m=e.runWebGLProgram(g,[f,d],f.dtype);p.push(m);let y=we({inputs:{x:m},backend:e,attrs:{shape:c.outputShape}});return p.forEach(x=>e.disposeIntermediateTensorInfo(x)),y}var UH={kernelName:Pc,backendName:"webgl",kernelFunc:Ek};var $1e="return float(a > b);",L1e=`
  return vec4(greaterThan(a, b));
`,P1e=Pt({opSnippet:$1e,packedOpSnippet:L1e,cpuKernelImpl:uG,dtype:"bool"}),GH={kernelName:Rp,backendName:"webgl",kernelFunc:P1e};var B1e="return float(a >= b);",z1e=`
  return vec4(greaterThanEqual(a, b));
`,V1e=Pt({opSnippet:B1e,packedOpSnippet:z1e,dtype:"bool",cpuKernelImpl:pG}),jH={kernelName:ol,backendName:"webgl",kernelFunc:V1e};function U1e(t){let{inputs:n,backend:e}=t,{input:r}=n;return N3(r,!0,e)}var HH={kernelName:xh,backendName:"webgl",kernelFunc:U1e};var G1e="return float(!isnan(x) && !isinf(x));",j1e=ze({opSnippet:G1e,dtype:"bool"}),WH={kernelName:sl,backendName:"webgl",kernelFunc:j1e};var H1e="return float(isinf(x));",W1e=ze({opSnippet:H1e,dtype:"bool"}),qH={kernelName:il,backendName:"webgl",kernelFunc:W1e};var q1e="return float(isnan(x));",K1e=ze({opSnippet:q1e,dtype:"bool"}),KH={kernelName:al,backendName:"webgl",kernelFunc:K1e};var X1e="return float(a < b);",Y1e=`
  return vec4(lessThan(a, b));
`,Z1e=Pt({opSnippet:X1e,packedOpSnippet:Y1e,cpuKernelImpl:fG,dtype:"bool"}),XH={kernelName:Mp,backendName:"webgl",kernelFunc:Z1e};var Q1e="return float(a <= b);",J1e=`
  return vec4(lessThanEqual(a, b));
`,exe=Pt({opSnippet:Q1e,packedOpSnippet:J1e,cpuKernelImpl:dG,dtype:"bool"}),YH={kernelName:Op,backendName:"webgl",kernelFunc:exe};function txe(t){let{backend:n,attrs:e}=t,{start:r,stop:o,num:s}=e,i=hG(r,o,s);return n.makeTensorInfo([i.length],"float32",i)}var ZH={kernelName:bh,backendName:"webgl",kernelFunc:txe};var nxe=ei+`
  return x < 0.0 ? 0./0. : log(x);
`,rxe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,oxe=ze({opSnippet:nxe,packedOpSnippet:rxe,cpuKernelImpl:mG}),QH={kernelName:"Log",backendName:"webgl",kernelFunc:oxe};var sxe=ei+`
  return log(1.0 + x);
`,ixe=ze({opSnippet:sxe}),JH={kernelName:ll,backendName:"webgl",kernelFunc:ixe};var axe="return float(a >= 1.0 && b >= 1.0);",lxe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,cxe=Pt({opSnippet:axe,packedOpSnippet:lxe,dtype:"bool"}),eW={kernelName:Fp,backendName:"webgl",kernelFunc:cxe};var uxe="return float(!(x >= 1.0));",pxe=ze({opSnippet:uxe}),tW={kernelName:$p,backendName:"webgl",kernelFunc:pxe};var fxe="return float(a >= 1.0 || b >= 1.0);",dxe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,hxe=Pt({opSnippet:fxe,packedOpSnippet:dxe,dtype:"bool"}),nW={kernelName:Lp,backendName:"webgl",kernelFunc:hxe};var O3=class{constructor(n,e,r,o,s){this.variableNames=["x"],this.outputShape=[];let i=e,a=n[3]-1;this.outputShape=n;let l,c=`float(${r}) + float(${o}) * sum`;s===.5?l=`inversesqrt(${c})`:s===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}};var F3=class{constructor(n,e,r,o,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let i=e,a=n[3]-1;this.outputShape=n;let l,c=`float(${r}) + float(${o}) * sum`;s===.5?l=`inversesqrt(${c})`:s===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}};var mxe=t=>{let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{depthRadius:s,bias:i,alpha:a,beta:l}=r,c=Z().getBool("WEBGL_PACK_NORMALIZATION")?new F3(o.shape,s,i,a,l):new O3(o.shape,s,i,a,l);return e.runWebGLProgram(c,[o],o.dtype)},rW={kernelName:"LRN",backendName:"webgl",kernelFunc:mxe};var $3=class{constructor(n,e,r,o,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=n,this.depth=n[3],this.depthRadius=e,this.bias=r,this.alpha=o,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${e})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${e} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${o}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${o})
                * float(${s})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};var gxe=t=>{let{inputs:n,backend:e,attrs:r}=t,{x:o,y:s,dy:i}=n,{depthRadius:a,bias:l,alpha:c,beta:u}=r,p=new $3(o.shape,a,l,c,u);return e.runWebGLProgram(p,[o,s,i],o.dtype)},oW={kernelName:wh,backendName:"webgl",kernelFunc:gxe};function sW(t,n,e,r){let o=b.sizeFromShape(n),i=b.sizeFromShape(t.shape)/o,a=we({inputs:{x:t},attrs:{shape:[i,o]},backend:r}),l=ls(a,t.dtype,"max",r),c=we({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),c}function Nk(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{reductionIndices:s,keepDims:i}=r,a=o.shape.length,l=b.parseAxisParam(s,o.shape),c=l,u=_.getAxesPermutation(c,a),p=u!=null,f=e.shouldExecuteOnCPU([o]),d=o;if(p){if(f){let C=e.texData.get(d.dataId).values,I=new Array(a);for(let L=0;L<I.length;L++)I[L]=o.shape[u[L]];let D=Mf(C,o.shape,o.dtype,u,I);d=e.makeTensorInfo(I,o.dtype);let O=e.texData.get(d.dataId);O.values=D}else d=Vu(o,u,e);c=_.getInnerMostAxes(c.length,a)}_.assertAxesAreInnerMostDims("max",c,a);let[h,g]=_.computeOutAndReduceShapes(d.shape,c),m=h;i&&(m=_.expandShapeToKeepDim(h,l));let y;if(f){let C=e.texData.get(d.dataId).values,I=gG(C,b.sizeFromShape(g),m,o.dtype);y=e.makeTensorInfo(m,o.dtype);let D=e.texData.get(y.dataId);D.values=I}else y=sW(d,g,m,e);return p&&e.disposeIntermediateTensorInfo(d),y}var iW={kernelName:"Max",backendName:"webgl",kernelFunc:Nk};var yxe=Dg+`
  return max(a, b);
`,xxe=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+as+`
  return result;
`,vxe=Pt({opSnippet:yxe,packedOpSnippet:xxe,cpuKernelImpl:yG}),aW={kernelName:cl,backendName:"webgl",kernelFunc:vxe};function bxe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n;ha(o,"maxPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:l}=r,c=1;b.assert(_.eitherStridesOrDilationsAreOne(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let u=_.computePool2DInfo(o.shape,s,i,c,a,l);if(u.filterWidth===1&&u.filterHeight===1&&b.arraysEqual(u.inShape,u.outShape))return Vn({inputs:{x:o},backend:e});let p=new Di(u,"max",!1);return e.runWebGLProgram(p,[o],o.dtype)}var lW={kernelName:zc,backendName:"webgl",kernelFunc:bxe};function wxe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{filterSize:s,strides:i,pad:a,dataFormat:l,dimRoundingMode:c}=r,u=[1,1,1],p=_.computePool3DInfo(o.shape,s,i,u,a,c,l),f=new Uu(p,"max",!1);return e.runWebGLProgram(f,[o],o.dtype)}var cW={kernelName:Vc,backendName:"webgl",kernelFunc:wxe};var L3=class{constructor(n){this.variableNames=["dy","maxPos"],this.outputShape=n.inShape;let e=n.strideHeight,r=n.strideWidth,o=n.dilationHeight,s=n.effectiveFilterHeight,i=n.effectiveFilterWidth,a=s-1-n.padInfo.top,l=i-1-n.padInfo.left,c=s*i-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${e}.0;

          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},P3=class{constructor(n){this.variableNames=["dy","maxPos"],this.outputShape=n.inShape;let e=n.strideDepth,r=n.strideHeight,o=n.strideWidth,s=n.dilationDepth,i=n.dilationHeight,a=n.dilationWidth,l=n.effectiveFilterDepth,c=n.effectiveFilterHeight,u=n.effectiveFilterWidth,p=l-1-n.padInfo.front,f=c-1-n.padInfo.top,d=u-1-n.padInfo.left,h=l*c*u-1;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${f}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${e}.0;

          if (dyD < 0.0 || dyD >= ${n.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${h} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Cxe(t){let{inputs:n,backend:e,attrs:r}=t,{dy:o,input:s}=n,i=s,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,p=[1,1,1],f=_.computePool3DInfo(i.shape,a,l,p,c,u),d=new Uu(f,"max",!0),h=e.runWebGLProgram(d,[i],i.dtype),g=new P3(f),m=e.runWebGLProgram(g,[o,h],i.dtype);return e.disposeIntermediateTensorInfo(h),m}var uW={kernelName:Ih,backendName:"webgl",kernelFunc:Cxe};function Ixe(t){let{inputs:n,backend:e,attrs:r}=t,{dy:o,input:s,output:i}=n,a=s;ha([s,i],"maxPoolGrad");let{filterSize:l,strides:c,pad:u,dimRoundingMode:p}=r,f=_.computePool2DInfo(a.shape,l,c,1,u,p),d=!0,h=new Di(f,"max",d),g=e.runWebGLProgram(h,[a],a.dtype),m=new L3(f),y=e.runWebGLProgram(m,[o,g],a.dtype);return e.disposeIntermediateTensorInfo(g),y}var pW={kernelName:Ch,backendName:"webgl",kernelFunc:Ixe};function fW(t,n,e,r){let o=new Di(e,"max",!1),s=r.runWebGLProgram(o,[t],"float32");o=new Di(e,"max",!0,!0,n);let i=r.runWebGLProgram(o,[t],"float32");return[s,i]}var dW={kernelName:Sh,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{let{x:r}=t,{filterSize:o,strides:s,pad:i,includeBatchInIndex:a}=n,l=e;b.assert(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let c=[1,1];b.assert(_.eitherStridesOrDilationsAreOne(s,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${c}'`);let u=_.computePool2DInfo(r.shape,o,s,c,i),[p,f]=fW(r,a,u,l);return[p,f]}};function hW(t,n,e,r){let o=b.sizeFromShape(n),i=b.sizeFromShape(t.shape)/o,a=we({inputs:{x:t},attrs:{shape:[i,o]},backend:r}),l=ls(a,"float32","mean",r),c=we({inputs:{x:l},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),c}var mW={kernelName:Uc,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{let{x:r}=t,{keepDims:o,axis:s}=n,i=e,a=r.shape.length,l=b.parseAxisParam(s,r.shape),c=l,u=_.getAxesPermutation(c,a),p=u!=null,f=i.shouldExecuteOnCPU([r]),d=[],h=r;if(p){if(f){let I=i.texData.get(h.dataId).values,D=new Array(a);for(let B=0;B<D.length;B++)D[B]=r.shape[u[B]];let O=Mf(I,r.shape,r.dtype,u,D);h=i.makeTensorInfo(D,r.dtype);let L=i.texData.get(h.dataId);L.values=O}else h=Vu(r,u,i);d.push(h),c=_.getInnerMostAxes(c.length,a)}_.assertAxesAreInnerMostDims("sum",c,a);let[g,m]=_.computeOutAndReduceShapes(h.shape,c),y=g;o&&(y=_.expandShapeToKeepDim(g,l));let x=hW(h,m,y,i);for(let C of d)i.disposeIntermediateTensorInfo(C);return x}};function Sxe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,keepDims:i}=r,a=o.shape.length,l=b.parseAxisParam(s,o.shape),c=l,u=_.getAxesPermutation(c,a),p=o;u!=null&&(p=Cn({inputs:{x:o},backend:e,attrs:{perm:u}}),c=_.getInnerMostAxes(c.length,o.shape.length)),_.assertAxesAreInnerMostDims("min",c,a);let[f,d]=_.computeOutAndReduceShapes(p.shape,c),h=b.sizeFromShape(d),g=we({inputs:{x:p},backend:e,attrs:{shape:[-1,h]}}),m=ls(g,g.dtype,"min",e),y;if(i){let x=_.expandShapeToKeepDim(f,l);y=we({inputs:{x:m},backend:e,attrs:{shape:x}})}else y=we({inputs:{x:m},backend:e,attrs:{shape:f}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),u!=null&&e.disposeIntermediateTensorInfo(p),y}var gW={kernelName:"Min",backendName:"webgl",kernelFunc:Sxe};var Txe=Dg+`
  return min(a, b);
`,Exe=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+as+`
  return result;
`,Nxe=Pt({opSnippet:Txe,packedOpSnippet:Exe,cpuKernelImpl:xG}),yW={kernelName:ul,backendName:"webgl",kernelFunc:Nxe};var B3=class{constructor(n,e,r){this.variableNames=["x"],this.outputShape=e.map((u,p)=>u[0]+n[p]+u[1]);let o=n.length,s=st(o),i=e.map(u=>u[0]).join(","),a=e.map((u,p)=>u[0]+n[p]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o),c=r==="reflect"?0:1;if(o===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${o}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}};var z3=class{constructor(n,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((h,g)=>h[0]+n[g]+h[1]);let o=n.length,s=st(o),i=e.map(h=>h[0]).join(","),a=e.map((h,g)=>h[0]+n[g]).join(","),l=zn("rc",o),c=zn("source",o),u=`${l[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${c.slice(-2).join()})`,f=r==="reflect"?0:1,d="";if(o===1){let h=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${f};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${f};
        }
        source -= start;
      `;d=`
        ${s} rc = outputLoc;
        ${h}
        result[0] = getChannel(getX(${c.join()}), ${p});
        ${l[o-1]} += 1;
        if(${u}) {
          ${h}
          result[1] = getChannel(getX(${c.join()}), ${p});
        }
      `}else{let h=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${f}) +
                gte * ((end - 1) * 2 - source + ${f});
        source -= start;
      `;d=`
        ${s} rc = outputLoc;
        ${h}
        result[0] = getChannel(getX(${c.join()}), ${p});
        ${l[o-1]} += 1;
        if(${u}) {
          ${h}
          result[1] = getChannel(getX(${c.join()}), ${p});
        }
        rc = outputLoc;
        ${l[o-2]} += 1;
        if(${l[o-2]} < ${this.outputShape[o-2]}) {
          ${h}
          result[2] = getChannel(getX(${c.join()}), ${p});
          ${l[o-1]} += 1;
          if(${u}) {
            ${h}
            result[3] = getChannel(getX(${c.join()}), ${p});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}};var Dxe=({inputs:t,backend:n,attrs:e})=>{let{x:r}=t,{paddings:o,mode:s}=e,i=Z().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new z3(r.shape,o,s):new B3(r.shape,o,s);return n.runWebGLProgram(i,[r],r.dtype)},xW={kernelName:Gc,backendName:"webgl",kernelFunc:Dxe};var kxe=`if (b == 0.0) return NAN;
  return mod(a, b);`,Axe=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+as+`
  return result;
`,_xe=Pt({opSnippet:kxe,packedOpSnippet:Axe}),vW={kernelName:"Mod",backendName:"webgl",kernelFunc:_xe};var V3=class{constructor(n,e,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[n,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${e-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${e-1}));
      }
    `}};var Rxe=`
if (a == b) {
  return 1.0;
};
return a / b;`,Mxe=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,Dk=Pt({opSnippet:Rxe,packedOpSnippet:Mxe,checkOutOfBounds:!0}),bW={kernelName:el,backendName:"webgl",kernelFunc:Dk};var wW="return a - b;",kk=Pt({opSnippet:wW,packedOpSnippet:wW,supportsComplex:!0,cpuKernelImpl:BG}),CW={kernelName:"Sub",backendName:"webgl",kernelFunc:kk};function Ak(t){let{inputs:n,backend:e,attrs:r}=t,{logits:o}=n,{dim:s}=r,i=b.parseAxisParam([s],o.shape),a=Nk({inputs:{x:o},backend:e,attrs:{reductionIndices:i,keepDims:!1}}),l=_.expandShapeToKeepDim(a.shape,i),c=we({inputs:{x:a},backend:e,attrs:{shape:l}}),u=kk({inputs:{a:o,b:c},backend:e}),p=Sk({inputs:{x:u},backend:e}),f=Of({inputs:{x:p},backend:e,attrs:{axis:i,keepDims:!1}}),d=we({inputs:{x:f},backend:e,attrs:{shape:l}}),h=Dk({inputs:{a:p,b:d},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(d),h}var IW={kernelName:ou,backendName:"webgl",kernelFunc:Ak};function Oxe(t){let{inputs:n,backend:e,attrs:r}=t,{logits:o}=n,{numSamples:s,seed:i,normalized:a}=r,l=a?o:Ak({inputs:{logits:o},backend:e,attrs:{dim:o.shape.length-1}}),c=l.shape[0],u=l.shape[1],p=new V3(c,u,s),f=[[i]],d=e.runWebGLProgram(p,[l],"int32",f);return a||e.disposeIntermediateTensorInfo(l),d}var SW={kernelName:Th,backendName:"webgl",kernelFunc:Oxe};var Fxe=rr+`
  return -x;
`,$xe=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Lxe(t){let{inputs:n,backend:e}=t,{x:r}=n;if(e.shouldExecuteOnCPU([r])){let s=e.texData.get(r.dataId),[i,a]=bG(s.values,r.shape,r.dtype);return e.makeTensorInfo(a,r.dtype,i)}let o;return Z().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new Po(r.shape,$xe):o=new kr(r.shape,Fxe),e.runWebGLProgram(o,[r],r.dtype)}var TW={kernelName:"Neg",backendName:"webgl",kernelFunc:Lxe};var Pxe=Vr.nonMaxSuppressionV3Impl;function Bxe(t){_.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:n,backend:e,attrs:r}=t,{boxes:o,scores:s}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=r,c=e.readSync(o.dataId),u=e.readSync(s.dataId),{selectedIndices:p}=Pxe(c,u,i,a,l);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}var EW={kernelName:Eh,backendName:"webgl",kernelFunc:Bxe};var zxe=Vr.nonMaxSuppressionV4Impl;function Vxe(t){_.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:n,backend:e,attrs:r}=t,{boxes:o,scores:s}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=r,u=e.readSync(o.dataId),p=e.readSync(s.dataId),{selectedIndices:f,validOutputs:d}=zxe(u,p,i,a,l,c);return[e.makeTensorInfo([f.length],"int32",new Int32Array(f)),e.makeTensorInfo([],"int32",new Int32Array([d]))]}var NW={kernelName:Nh,backendName:"webgl",kernelFunc:Vxe};var Uxe=Vr.nonMaxSuppressionV5Impl;function Gxe(t){_.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:n,backend:e,attrs:r}=t,{boxes:o,scores:s}=n,{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r,u=e.readSync(o.dataId),p=e.readSync(s.dataId),f=i,d=a,h=l,g=c,{selectedIndices:m,selectedScores:y}=Uxe(u,p,f,d,h,g);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var DW={kernelName:Dh,backendName:"webgl",kernelFunc:Gxe};var U3=class{constructor(n,e,r,o){this.variableNames=["indices"],this.outputShape=[n,e],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${o}), float(${r}),
                      float(index == coords.y)));
      }
    `}};var jxe=t=>{let{inputs:n,backend:e,attrs:r}=t,{indices:o}=n,{dtype:s,depth:i,onValue:a,offValue:l}=r,c=b.sizeFromShape(o.shape),u=new U3(c,i,a,l),p=we({inputs:{x:o},backend:e,attrs:{shape:[c]}}),f=e.runWebGLProgram(u,[p],s);e.disposeIntermediateTensorInfo(p);let d=[...o.shape,i],h=we({inputs:{x:f},backend:e,attrs:{shape:d}});return e.disposeIntermediateTensorInfo(f),h},kW={kernelName:Hc,backendName:"webgl",kernelFunc:jxe};function Ix(t){let{inputs:n,backend:e}=t,{x:r}=n;if(r.dtype==="complex64"){let o=ql({inputs:{input:r},backend:e}),s=Ix({inputs:{x:o},backend:e}),i=$f({inputs:{input:r},backend:e}),a=Ix({inputs:{x:i},backend:e}),l=zo({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}else return Kl({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:e})}var AW={kernelName:au,backendName:"webgl",kernelFunc:Ix};function _W(t){let{inputs:n,backend:e}=t,{x:r}=n;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){let o=ql({inputs:{input:r},backend:e}),s=_W({inputs:{x:o},backend:e}),i=$f({inputs:{input:r},backend:e}),a=Ix({inputs:{x:i},backend:e}),l=zo({inputs:{real:s,imag:a},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(a),l}else return Kl({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:e})}var RW={kernelName:jc,backendName:"webgl",kernelFunc:_W};function Hxe(t){let{inputs:n,backend:e,attrs:r}=t,{axis:o}=r;if(n.length===1)return E3({inputs:{input:n[0]},backend:e,attrs:{dim:o}});let s=n[0].shape,i=n[0].dtype;n.forEach(u=>{b.assertShapesMatch(s,u.shape,"All tensors passed to stack must have matching shapes"),b.assert(i===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],l=n.map(u=>{let p=E3({inputs:{input:u},backend:e,attrs:{dim:o}});return a.push(p),p}),c=Ik({inputs:l,backend:e,attrs:{axis:o}});return a.forEach(u=>e.disposeIntermediateTensorInfo(u)),c}var MW={kernelName:Wc,backendName:"webgl",kernelFunc:Hxe};var G3=class{constructor(n,e,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((c,u)=>c[0]+n[u]+c[1]);let o=n.length,s=st(o),i=e.map(c=>c[0]).join(","),a=e.map((c,u)=>c[0]+n[u]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o);if(o===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}};var j3=class{constructor(n,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((g,m)=>g[0]+n[m]+g[1]);let o=n.length,s=st(o),i=e.map(g=>g[0]).join(","),a=e.map((g,m)=>g[0]+n[m]).join(","),l=zn("rc",o),c=zn("source",o),u=`${l[o-1]} < ${this.outputShape[o-1]}`,p=o===1?"source":`vec2(${c.slice(-2).join()})`,f=[`${s} rc = outputLoc;`,`${l[o-1]} += 1;
       if(${u}) {
      `,o===1?"":`}
       rc = outputLoc;
       ${l[o-2]} += 1;
       if(${l[o-2]} < ${this.outputShape[o-2]}) {`,o===1?"":`  ${l[o-1]} += 1;
         if(${u}) {`],d=o===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",h="";for(let g=0,m=o===1?2:4;g<m;g++)h+=`
        ${f[g]}
        if (${d}) {
          result[${g}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${g}] = getChannel(getX(${c.join()}), ${p});
        }
      `;h+=o===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${h}
        setOutput(result);
      }
    `}};var _k=t=>{let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{paddings:s,constantValue:i}=r;if(b.sizeFromShape(o.shape)===0){let c=s.map((u,p)=>u[0]+o.shape[p]+u[1]);return Kl({backend:e,attrs:{shape:c,value:i,dtype:o.dtype}})}let a=Z().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new j3(o.shape,s,i):new G3(o.shape,s,i),l=[[i]];return e.runWebGLProgram(a,[o],o.dtype,l)},OW={kernelName:qc,backendName:"webgl",kernelFunc:_k};var Wxe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,qxe=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+as+`
  return result;
`,Kxe=Pt({opSnippet:Wxe,packedOpSnippet:qxe}),FW={kernelName:"Pow",backendName:"webgl",kernelFunc:Kxe};function Xxe(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{axis:s,keepDims:i}=r,a=o.shape.length,l=[],c=b.parseAxisParam(s,o.shape),u=c,p=_.getAxesPermutation(u,a),f=o;p!=null&&(f=Cn({inputs:{x:o},backend:e,attrs:{perm:p}}),u=_.getInnerMostAxes(u.length,a),l.push(f)),_.assertAxesAreInnerMostDims("prod",u,a);let d;if(e.shouldExecuteOnCPU([f])){let h=e.texData.get(f.dataId).values,{outVals:g,outShape:m,outDtype:y}=CG(f.shape,f.dtype,h,u);d=e.makeTensorInfo(m,y,g)}else{let[h,g]=_.computeOutAndReduceShapes(f.shape,u),m=b.sizeFromShape(g),y=we({inputs:{x:f},backend:e,attrs:{shape:[-1,m]}}),x=Kp(o.dtype),C=ls(y,x,"prod",e);d=we({inputs:{x:C},backend:e,attrs:{shape:h}}),l.push(y),l.push(C)}if(i){l.push(d);let h=_.expandShapeToKeepDim(d.shape,c);d=we({inputs:{x:d},backend:e,attrs:{shape:h}})}return l.forEach(h=>e.disposeIntermediateTensorInfo(h)),d}var $W={kernelName:Xc,backendName:"webgl",kernelFunc:Xxe};function Yxe(t){let{inputs:n,backend:e,attrs:r}=t,{paramsNestedSplits:o,paramsDenseValues:s,indices:i}=n,{outputRaggedRank:a}=r,l=o.map(y=>e.readSync(y.dataId)),c=o.map(y=>y.shape),u=e.readSync(s.dataId),p=e.readSync(i.dataId),[f,d,h]=IG(l,c,u,s.shape,s.dtype,p,i.shape,a),g=f.map(y=>e.makeTensorInfo([y.length],"int32",y)),m=e.makeTensorInfo(h,s.dtype,d);return g.concat([m])}var LW={kernelName:kh,backendName:"webgl",kernelFunc:Yxe};function Zxe(t){let{inputs:n,backend:e}=t,{starts:r,limits:o,deltas:s}=n,i=e.readSync(r.dataId),a=e.readSync(o.dataId),l=e.readSync(s.dataId),[c,u]=SG(i,r.shape,r.dtype,a,o.shape,l,s.shape),p=e.makeTensorInfo([c.length],"int32",c),f=e.makeTensorInfo([u.length],r.dtype,u);return[p,f]}var PW={kernelName:Ah,backendName:"webgl",kernelFunc:Zxe};function Qxe(t){let{inputs:n,backend:e,attrs:r}=t,{shape:o,values:s,defaultValue:i,rowPartitionTensors:a}=n,{rowPartitionTypes:l}=r,c=e.readSync(o.dataId),u=e.readSync(s.dataId),p=e.readSync(i.dataId),f=a.map(m=>e.readSync(m.dataId)),d=a.map(m=>m.shape),[h,g]=TG(c,o.shape,u,s.shape,s.dtype,p,i.shape,f,d,l);return e.makeTensorInfo(h,s.dtype,g)}var BW={kernelName:_h,backendName:"webgl",kernelFunc:Qxe};var Rk=t=>{let{backend:n,attrs:e}=t,{start:r,stop:o,step:s,dtype:i}=e,a=EG(r,o,s,i);return n.makeTensorInfo([a.length],i,a)},zW={kernelName:Rh,backendName:"webgl",kernelFunc:Rk};var Jxe="return 1.0 / x;",e0e=ze({opSnippet:Jxe}),VW={kernelName:fl,backendName:"webgl",kernelFunc:e0e};var t0e=rr+`
  return (x < 0.0) ? 0.0 : x;
`,n0e=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,r0e=ze({opSnippet:t0e,packedOpSnippet:n0e}),UW={kernelName:dl,backendName:"webgl",kernelFunc:r0e};var o0e=rr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,s0e=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,i0e=ze({opSnippet:o0e,packedOpSnippet:s0e}),GW={kernelName:hl,backendName:"webgl",kernelFunc:i0e};var H3=class{constructor(n,e,r,o,s){this.variableNames=["A"],this.outputShape=[];let[i,a,l,c]=n;this.outputShape=[i,e,r,c];let u=[o&&e>1?a-1:a,o&&r>1?l-1:l],p=[o&&e>1?e-1:e,o&&r>1?r-1:r],f;s?f="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/p[0]},
          ${u[1]/p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};var W3=class{constructor(n,e,r,o,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,a,l,c]=n;this.outputShape=[i,e,r,c];let u=[o&&e>1?a-1:a,o&&r>1?l-1:l],p=[o&&e>1?e-1:e,o&&r>1?r-1:r],f;s?f="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/p[0]},
          ${u[1]/p[1]},
          ${u[1]/p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function a0e(t){let{inputs:n,backend:e,attrs:r}=t,{images:o}=n,{alignCorners:s,halfPixelCenters:i,size:a}=r,[l,c]=a,u=Z().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new W3(o.shape,l,c,s,i):new H3(o.shape,l,c,s,i);return e.runWebGLProgram(u,[o],"float32")}var jW={kernelName:Qc,backendName:"webgl",kernelFunc:a0e};var q3=class{constructor(n,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;let[,o,s]=e,[,i,a]=n,l=[r&&i>1?o-1:o,r&&a>1?s-1:s],c=[r&&i>1?i-1:i,r&&a>1?a-1:a],u=l[0]/c[0],p=l[1]/c[1],f=1/u,d=1/p,h=Math.ceil(f)*2+2,g=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${p});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${d});

        const int winHeight = int(${h});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${o-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function l0e(t){let{inputs:n,backend:e,attrs:r}=t,{images:o,dy:s}=n,{alignCorners:i}=r,a=new q3(s.shape,o.shape,i);return e.runWebGLProgram(a,[s],s.dtype)}var HW={kernelName:Fh,backendName:"webgl",kernelFunc:l0e};var K3=class{constructor(n,e,r,o,s){this.variableNames=["A"],this.outputShape=[];let[i,a,l,c]=n;this.outputShape=[i,e,r,c];let u=[o&&e>1?a-1:a,o&&r>1?l-1:l],p=[o&&e>1?e-1:e,o&&r>1?r-1:r],f=o?"0.5":"0.0",d;s?d="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/p[0]},
          ${u[1]/p[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};var X3=class{constructor(n,e,r,o,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,a,l,c]=n;this.outputShape=[i,e,r,c];let u=[o&&e>1?a-1:a,o&&r>1?l-1:l],p=[o&&e>1?e-1:e,o&&r>1?r-1:r],f=o?"0.5":"0.0",d;s?d="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/p[0]},
          ${u[1]/p[1]},
          ${u[1]/p[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function c0e(t){let{inputs:n,backend:e,attrs:r}=t,{images:o}=n,{alignCorners:s,halfPixelCenters:i,size:a}=r,[l,c]=a,u=Z().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new X3(o.shape,l,c,s,i):new K3(o.shape,l,c,s,i);return e.runWebGLProgram(u,[o],o.dtype)}var WW={kernelName:Zc,backendName:"webgl",kernelFunc:c0e};var Y3=class{constructor(n,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;let[,o,s]=e,[,i,a]=n,l=[r&&i>1?o-1:o,r&&a>1?s-1:s],c=[r&&i>1?i-1:i,r&&a>1?a-1:a],u=l[0]/c[0],p=l[1]/c[1],f=1/u,d=1/p,h=Math.ceil(f)*2+2,g=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${p});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${d});

        const int winHeight = int(${h});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${o}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function u0e(t){let{inputs:n,backend:e,attrs:r}=t,{images:o,dy:s}=n,{alignCorners:i}=r,a=new Y3(s.shape,o.shape,i);return e.runWebGLProgram(a,[s],s.dtype)}var qW={kernelName:Oh,backendName:"webgl",kernelFunc:u0e};var Z3=class{constructor(n,e){this.variableNames=["x"];let r=n.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=n,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${n[0]} - coord - 1));
        }
      `;return}let o=a=>e.indexOf(a)!==-1&&n[a]!==1?`${n[a]} - coords[${a}] - 1`:`coords[${a}]`,s=n.map((a,l)=>o(l)).join(","),i=st(r);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}};var Q3=class{constructor(n,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let r=n.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=n;let o=zn("rc",r),s=`${o[r-1]} + 1 < ${this.outputShape[r-1]}`,i=`${o[r-2]} + 1 < ${this.outputShape[r-2]}`,a=st(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${n[0]} - rc - 1),
            ${n[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${n[0]} - (rc  + 1) - 1),
                ${n[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(o.slice())};
          if(${s}){
            result.g = ${c(o.slice())};
          }
          if(${i}) {
            result.b = ${u(o.slice())};
            if(${s}) {
              result.a = ${p(o.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(h){return f(h)}function c(h){return h[r-1]="("+h[r-1]+" + 1)",f(h)}function u(h){return h[r-2]="("+h[r-2]+" + 1)",f(h)}function p(h){return h[r-1]="("+h[r-1]+" + 1)",h[r-2]="("+h[r-2]+" + 1)",f(h)}function f(h){let g=n.map((x,C)=>d(C,h)),m=g.join(","),y=g.slice(-2).join(",");return`getChannel(getX(${m}), vec2(${y}))`}function d(h,g){return e.indexOf(h)!==-1&&n[h]!==1?`${n[h]} - ${g[h]} - 1`:`${g[h]}`}}};function p0e(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{dims:s}=r,i=o.shape.length,a=b.parseAxisParam(s,o.shape);if(i===0)return Vn({inputs:{x:o},backend:e});let l=Z().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Q3(o.shape,a):new Z3(o.shape,a);return e.runWebGLProgram(l,[o],o.dtype)}var KW={kernelName:Jc,backendName:"webgl",kernelFunc:p0e};var J3=class{constructor(n,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let r=n[1],o=n[2];this.outputShape=n;let s="";typeof e=="number"?s=`float outputValue = ${e.toFixed(2)};`:s=`
        vec3 fill = vec3(${e.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${o} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var XW={kernelName:Qh,backendName:"webgl",kernelFunc:({inputs:t,attrs:n,backend:e})=>{let{image:r}=t,{radians:o,fillValue:s,center:i}=n,a=e,l=new J3(r.shape,s),[c,u]=_.getImageCenter(i,r.shape[1],r.shape[2]),p=[[c,u,Math.sin(o),Math.cos(o)]];return a.runWebGLProgram(l,[r],r.dtype,p)}};var f0e=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,d0e=ze({opSnippet:f0e}),YW={kernelName:ml,backendName:"webgl",kernelFunc:d0e};var h0e="return inversesqrt(x);",m0e=ze({opSnippet:h0e,cpuKernelImpl:NG}),ZW={kernelName:gl,backendName:"webgl",kernelFunc:m0e};var Gu=class{constructor(n,e,r,o,s,i,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;let c=st(s.length),u=st(i.length),p="";r===1?p="i":r===2&&(p="i, j");let f=`getIndices(${p})`,d="";o===1?d="i":o===2&&(d="i, coords[1]");let h=`getUpdates(${d})`,g="";l&&(g="coords[0], coords[1]");let m=`getDefaultValue(${g})`,y=e>1?"strides[j]":"strides";this.userCode=`
        ${c} strides = ${c}(${s});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${n}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${e}; j++) {
              int index = round(${f});
              flattenedIndex += index * ${y};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${h};
              found = true;
            }
          }
          setOutput(mix(${m}, sum, float(found)));
        }
      `}};var eI=class{constructor(n,e,r,o,s,i,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;let c=st(s.length),u=st(i.length),p="";r===1?p="i":r===2&&(p="i, j");let f=`getIndices(${p})`,d="";o===1?d="i":o===2&&(d="i, coords[1]");let h=`getUpdates(${d})`,g="";l&&(g="coords[0], coords[1]");let m=`getDefaultValue(${g})`,y=e>1?"strides[j]":"strides",x=e>1?"strides[j + 1]":"strides";this.userCode=`
        ${c} strides = ${c}(${s});

        void main() {
          ${u} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${n}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${e}; j+=2) {
              ivec4 index = round(${f});
              flattenedIndex += index.xz * ${y};
              if (j + 1 < ${e}) {
                flattenedIndex += index.yw * ${x};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${h};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${m}, sum, found));
        }
      `}};function g0e(t){let{inputs:n,backend:e,attrs:r}=t,{indices:o,updates:s}=n,{shape:i}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:p}=_.calculateShapes(s,o,i),f=[p/c,c];if(p===0)return e.makeTensorInfo(i,o.dtype);let d=we({inputs:{x:o},backend:e,attrs:{shape:[l,a]}}),h=we({inputs:{x:s},backend:e,attrs:{shape:[l,c]}}),g=e.makeTensorInfo([],"float32",new Float32Array([0])),m;Z().getBool("WEBGL_PACK")?m=new eI(l,a,d.shape.length,h.shape.length,u,f):m=new Gu(l,a,d.shape.length,h.shape.length,u,f);let y=e.runWebGLProgram(m,[h,d,g],h.dtype),x=we({inputs:{x:y},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(g),x}var QW={kernelName:$h,backendName:"webgl",kernelFunc:g0e};var tI=class{constructor(n,e,r,o){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[n,r];let s="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,a=Z().getNumber("WEBGL_VERSION")===2?s:i,l=o==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function y0e(t){let{inputs:n,backend:e,attrs:r}=t,{sortedSequence:o,values:s}=n,{side:i}=r,a=new tI(o.shape[0],o.shape[1],s.shape[1],i),l=[[o.shape[1]]];return e.runWebGLProgram(a,[o,s],"int32",l)}var JW={kernelName:Ph,backendName:"webgl",kernelFunc:y0e};var nI=class{constructor(n,e,r){this.variableNames=["c","a","b"],this.outputShape=e;let o,s;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)s="resRC",o="resRC";else{let a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let u=0;u<e.length;u++)c.push(`${a[u]}`),u<n&&l.push(`${a[u]}`);o=l.join(),s=c.join()}let i=st(r);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${o});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};function x0e(t){let{inputs:n,backend:e}=t,{condition:r,t:o,e:s}=n,i=new nI(r.shape.length,o.shape,o.shape.length);return e.runWebGLProgram(i,[r,o,s],Wn(o.dtype,s.dtype))}var eq={kernelName:eu,backendName:"webgl",kernelFunc:x0e};var v0e=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${_.SELU_SCALEALPHA};
  float scale = ${_.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,b0e=ze({opSnippet:v0e}),tq={kernelName:yl,backendName:"webgl",kernelFunc:b0e};var w0e=ei+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,C0e=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,I0e=ze({opSnippet:w0e,packedOpSnippet:C0e,cpuKernelImpl:kG}),nq={kernelName:bl,backendName:"webgl",kernelFunc:I0e};var S0e=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,T0e=ze({opSnippet:S0e}),rq={kernelName:vl,backendName:"webgl",kernelFunc:T0e};var E0e=ei+`
  return sin(x);
`,N0e=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${as}
  return result;
`,D0e=ze({opSnippet:E0e,packedOpSnippet:N0e}),oq={kernelName:"Sin",backendName:"webgl",kernelFunc:D0e};var k0e=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,A0e=ze({opSnippet:k0e}),sq={kernelName:xl,backendName:"webgl",kernelFunc:A0e};var _0e=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,R0e=ze({opSnippet:_0e}),iq={kernelName:wl,backendName:"webgl",kernelFunc:R0e};var M0e=t=>{let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{blockShape:s,paddings:i}=r;b.assert(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((y,x)=>y*x),l=[[0,0]];l.push(...i);for(let y=1+s.length;y<o.shape.length;++y)l.push([0,0]);let c=[],u=_k({inputs:{x:o},backend:e,attrs:{paddings:l,constantValue:0}}),p=_.getReshaped(u.shape,s,a,!1),f=_.getPermuted(p.length,s.length,!1),d=_.getReshapedPermuted(u.shape,s,a,!1),h=we({inputs:{x:u},backend:e,attrs:{shape:p}}),g=Cn({inputs:{x:h},backend:e,attrs:{perm:f}}),m=we({inputs:{x:g},backend:e,attrs:{shape:d}});return c.push(u),c.push(h),c.push(g),c.forEach(y=>e.disposeIntermediateTensorInfo(y)),m},aq={kernelName:nu,backendName:"webgl",kernelFunc:M0e};function O0e(t){let{inputs:n,backend:e}=t,{indices:r,values:o,denseShape:s,defaultValue:i}=n;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${o.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let a=e.readSync(r.dataId),l=e.readSync(o.dataId),c=e.readSync(s.dataId),u=e.readSync(i.dataId)[0],[p,f,d,h,g]=_G(a,r.shape,r.dtype,l,o.dtype,c,u);return[e.makeTensorInfo(f,r.dtype,p),e.makeTensorInfo([f[0]],o.dtype,d),e.makeTensorInfo([h.length],"bool",new Uint8Array(h.map(m=>Number(m)))),e.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}var lq={kernelName:Bh,backendName:"webgl",kernelFunc:O0e};function F0e(t){let{inputs:n,backend:e}=t,{inputIndices:r,inputShape:o,newShape:s}=n;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(e.readSync(o.dataId)),a=e.readSync(r.dataId),l=Array.from(e.readSync(s.dataId)),[c,u,p]=RG(a,r.shape,r.dtype,i,l);return[e.makeTensorInfo(u,r.dtype,c),e.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var cq={kernelName:zh,backendName:"webgl",kernelFunc:F0e};function $0e(t){let{inputs:n,backend:e}=t,{data:r,indices:o,segmentIds:s}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let i=e.readSync(r.dataId),a=e.readSync(o.dataId),l=e.readSync(s.dataId),[c,u]=LC(i,r.shape,r.dtype,a,l,!0);return e.makeTensorInfo(u,r.dtype,c)}var uq={kernelName:Vh,backendName:"webgl",kernelFunc:$0e};function L0e(t){let{inputs:n,backend:e}=t,{data:r,indices:o,segmentIds:s}=n;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let i=e.readSync(r.dataId),a=e.readSync(o.dataId),l=e.readSync(s.dataId),[c,u]=LC(i,r.shape,r.dtype,a,l);return e.makeTensorInfo(u,r.dtype,c)}var pq={kernelName:Uh,backendName:"webgl",kernelFunc:L0e};function P0e(t){let{inputs:n,backend:e,attrs:r}=t,{sparseIndices:o,sparseValues:s,defaultValue:i}=n,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:p,outputSize:f}=_.calculateShapes(s,o,a),d=!1;if(s.dtype==="string"){let y=e.bufferSync(o),x=e.bufferSync(s),C=b.decodeString(e.readSync(i.dataId)[0]),I=DG(y,x,a,f,u,c,l,p,C,d);return e.makeTensorInfo(a,I.dtype,I.values)}let h=new Gu(c,l,o.shape.length,s.shape.length,p,[f,1],d),g=e.runWebGLProgram(h,[s,o,i],s.dtype),m=we({inputs:{x:g},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(g),m}var fq={kernelName:Gh,backendName:"webgl",kernelFunc:P0e};function B0e(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{numOrSizeSplits:s,axis:i}=r,a=b.parseAxisParam(i,o.shape)[0],l=_.prepareSplitSize(o,s,a),c=o.shape.length,u=new Array(c).fill(0),p=o.shape.slice();return l.map(f=>{let d=[...p];d[a]=f;let h=ki({inputs:{x:o},backend:e,attrs:{begin:u,size:d}});return u[a]+=f,h})}var dq={kernelName:ru,backendName:"webgl",kernelFunc:B0e};var hq="return sqrt(x);",z0e=ze({opSnippet:hq,packedOpSnippet:hq,cpuKernelImpl:MG}),mq={kernelName:Cl,backendName:"webgl",kernelFunc:z0e};var V0e="return x * x;",U0e=ze({opSnippet:V0e}),gq={kernelName:jh,backendName:"webgl",kernelFunc:U0e};var yq="return (a - b) * (a - b);",G0e=Pt({opSnippet:yq,packedOpSnippet:yq}),xq={kernelName:Il,backendName:"webgl",kernelFunc:G0e};function j0e(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n;if(o.dtype!=="string")throw new Error("Input must be of datatype string");let s=e.readSync(o.dataId),i=_.fromUint8ToStringArray(s),a=OG(i,"string",r);return e.makeTensorInfo(o.shape,"string",a)}var vq={kernelName:Bp,backendName:"webgl",kernelFunc:j0e};function H0e({inputs:t,attrs:n,backend:e}){let{x:r}=t,o=rr+`
    return x > 0.0 ? 1.0 : float(${n.alpha});
  `,s=new kr(r.shape,o);return e.runWebGLProgram(s,[r],r.dtype)}var bq={kernelName:Tl,backendName:"webgl",kernelFunc:H0e};var rI=class{constructor(n,e,r){this.variableNames=["x"],this.outputShape=r;let o=r.length,s=st(r.length),i=st(r.length),a="";if(o===1)a="coords * strides + begin";else{let l=0;a=r.map((c,u)=>(l++,r.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${l-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${n});
      ${s} strides = ${s}(${e});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}};function W0e(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{begin:s,end:i,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:p,shrinkAxisMask:f}=r,{finalShapeSparse:d,finalShape:h,isIdentity:g,sliceDim0:m,isSimpleSlice:y,begin:x,end:C,strides:I}=gr.sliceInfo(o.shape,s,i,a,l,c,u,p,f),D;if(g)D=we({inputs:{x:o},backend:e,attrs:{shape:h}});else if(m||y){b.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let L=gr.computeOutShape(x,C,I),B=ki({inputs:{x:o},backend:e,attrs:{begin:x,size:L}});D=we({inputs:{x:B},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(B)}else if(e.shouldExecuteOnCPU([o])){let B=e.readSync(o.dataId),V=Be(o.shape,o.dtype,B),F=FG(d,V,I,x);D=e.makeTensorInfo(h,o.dtype,F.values)}else{let B=new rI(x,I,d);D=e.runWebGLProgram(B,[o],o.dtype)}let O=we({inputs:{x:D},backend:e,attrs:{shape:h}});return e.disposeIntermediateTensorInfo(D),O}var wq={kernelName:Hh,backendName:"webgl",kernelFunc:W0e};function q0e(t){let{inputs:n,backend:e,attrs:r}=t,{separator:o,nGramWidths:s,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:p}=n,f=e.readSync(u.dataId),d=e.readSync(p.dataId),[h,g]=$G(f,d,o,s,i,a,l,c);return[e.makeTensorInfo([h.length],"string",h),e.makeTensorInfo(p.shape,"int32",g)]}var Cq={kernelName:Wh,backendName:"webgl",kernelFunc:q0e};function K0e(t){let{inputs:n,backend:e,attrs:r}=t,{skipEmpty:o}=r,{input:s,delimiter:i}=n;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let a=e.readSync(s.dataId),l=e.readSync(i.dataId)[0],[c,u,p]=LG(a,l,o),f=u.length;return[e.makeTensorInfo([f,2],"int32",c),e.makeTensorInfo([f],"string",u),e.makeTensorInfo([2],"int32",new Int32Array(p))]}var Iq={kernelName:qh,backendName:"webgl",kernelFunc:K0e};function X0e(t){let{inputs:n,backend:e,attrs:r}=t,{numBuckets:o}=r,{input:s}=n;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let i=e.readSync(s.dataId),a=PG(i,o);return e.makeTensorInfo(s.shape,"int32",a)}var Sq={kernelName:Kh,backendName:"webgl",kernelFunc:X0e};var Y0e="return tan(x);",Z0e=ze({opSnippet:Y0e}),Tq={kernelName:"Tan",backendName:"webgl",kernelFunc:Z0e};var Q0e=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,J0e=ze({opSnippet:Q0e}),Eq={kernelName:Sl,backendName:"webgl",kernelFunc:J0e};function e2e(t){let{inputs:n,backend:e,attrs:r}=t,{tensor:o,indices:s,updates:i}=n,{}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:p}=_.calculateShapes(i,s,o.shape),f=[p/c,c];if(p===0)return e.makeTensorInfo(o.shape,s.dtype);let d=we({inputs:{x:s},backend:e,attrs:{shape:[l,a]}}),h=we({inputs:{x:i},backend:e,attrs:{shape:[l,c]}}),g=we({inputs:{x:o},backend:e,attrs:{shape:f}}),m=new Gu(l,a,d.shape.length,h.shape.length,u,f,!1,!0),y=e.runWebGLProgram(m,[h,d,g],g.dtype),x=we({inputs:{x:y},backend:e,attrs:{shape:o.shape}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(y),x}var Nq={kernelName:Lh,backendName:"webgl",kernelFunc:e2e};var oI=class{constructor(n,e){this.variableNames=["A"];let r=new Array(n.length);for(let i=0;i<r.length;i++)r[i]=n[i]*e[i];this.outputShape=r,this.rank=r.length;let o=st(this.rank),s=t2e(n);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function t2e(t){let n=t.length;if(n>5)throw Error(`Tile for rank ${n} is not yet supported`);if(n===1)return`imod(resRC, ${t[0]})`;let e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let o=0;o<t.length;o++)r.push(`imod(${e[o]}, ${t[o]})`);return r.join()}function Mk(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{reps:s}=r;if(o.dtype==="string"||o.shape.length>5){let l=e.readSync(o.dataId),c=o.dtype==="string"?l.map(f=>b.decodeString(f)):l,u=Be(o.shape,o.dtype,c),p=zG(u,s);return e.makeTensorInfo(p.shape,p.dtype,p.values)}let i=new oI(o.shape,s);return e.runWebGLProgram(i,[o],o.dtype)}var Dq={kernelName:Xi,backendName:"webgl",kernelFunc:Mk};var sI=class{constructor(n){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=n,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},iI=class{constructor(n){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=n,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function Lf(t,n){n!==null&&t.disposeIntermediateTensorInfo(n)}function kq(t){let n=1;for(;n<t;)n*=2;return n}function n2e(t){let{inputs:n,backend:e,attrs:r}=t,{x:o}=n,{k:s,sorted:i}=r,a=Z().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Z().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=o.shape,u=c[c.length-1];if(e.shouldExecuteOnCPU([o])||u<a||s>l){let F=e.readSync(o.dataId),[G,ee]=VG(F,c,o.dtype,s,i);return[e.makeTensorInfo(G.shape,G.dtype,G.values),e.makeTensorInfo(ee.shape,ee.dtype,ee.values)]}if(s===0)return c[c.length-1]=0,[e.makeTensorInfo(c,o.dtype,[]),e.makeTensorInfo(c,"int32",[])];if(u===1)return[o,Kl({attrs:{shape:c,dtype:"int32",value:0},backend:e})];let p=e.texData.get(o.dataId),f=p!==null&&p.isPacked,d=f?e.unpackTensor(o):o,g=b.sizeFromShape(c)/u,m=we({inputs:{x:d},attrs:{shape:[g,u]},backend:e});f&&Lf(e,d);let y=kq(s),x=kq(u),C=null,I=()=>C===null?[m,m]:[m,C],D=(F,G,ee)=>{let Q=I(),oe=new sI(ee),J=[[u],[C===null?1:0],[Number.NEGATIVE_INFINITY],[F],[G]],re=C;C=e.runWebGLProgram(oe,Q,"int32",J),Lf(e,re)};for(let F=1;F<y;F*=2){let G=F*2;for(let ee=F;ee>=1;ee/=2)D(G,ee,[g,x])}for(let F=x;F>y;F/=2){let G=I(),ee=new iI([g,F/2]),oe=[[u],[C===null?1:0],[y]],ae=C;C=e.runWebGLProgram(ee,G,"int32",oe),Lf(e,ae);let J=y/2,re=J*2;for(let se=J;se>=1;se/=2)D(re,se,C.shape)}let O=C;C=ki({inputs:{x:C},backend:e,attrs:{begin:0,size:[g,s]}}),Lf(e,O);let L=Ek({inputs:{x:m,indices:C},backend:e,attrs:{axis:1,batchDims:1}});Lf(e,m);let B=c.slice(0,-1);B.push(s),O=C,C=we({inputs:{x:C},attrs:{shape:B},backend:e}),Lf(e,O);let V=L;return L=we({inputs:{x:L},attrs:{shape:B},backend:e}),Lf(e,V),[L,C]}var Aq={kernelName:Xh,backendName:"webgl",kernelFunc:n2e};var aI=class{constructor(n,e,r,o,s,i){this.variableNames=["Image","Transforms"],this.outputShape=i;let a=r==="nearest"?1:2,l;switch(o){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${n} && 0 <= coordX && coordX < ${e}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${e}));
                float mapY = mapCoord(inY, float(${n}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function r2e(t){let{inputs:n,backend:e,attrs:r}=t,{image:o,transforms:s}=n,{interpolation:i,fillMode:a,fillValue:l,outputShape:c}=r,[u,p,f,d]=o.shape,[h,g]=c??[p,f],m=[u,h,g,d],y=new aI(p,f,i,a,l,m);return e.runWebGLProgram(y,[o,s],"float32")}var _q={kernelName:Yh,backendName:"webgl",kernelFunc:r2e};function o2e(t){let{inputs:n,attrs:e,backend:r}=t,{axis:o}=e,{x:s}=n;ha(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=r.readSync(s.dataId),{outputValues:a,outputShape:l,indices:c}=UG(i,o,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}var Rq={kernelName:Zh,backendName:"webgl",kernelFunc:o2e};function s2e(t){let{inputs:n,backend:e,attrs:r}=t,{value:o}=n,{axis:s}=r;s<0&&(s+=o.shape.length);let i=o,a=i.shape.length,l=o.shape[s],c=new Array(a-1),u=0;for(let g=0;g<a;g++)g!==s&&(c[u++]=i.shape[g]);let p=[],f=new Array(a).fill(0),d=i.shape.slice();d[s]=1;let h=new Array(l);for(let g=0;g<h.length;g++){f[s]=g;let m=ki({inputs:{x:i},backend:e,attrs:{begin:f,size:d}}),y=we({inputs:{x:m},backend:e,attrs:{shape:c}});h[g]=y,p.push(m)}return p.forEach(g=>e.disposeIntermediateTensorInfo(g)),h}var Mq={kernelName:su,backendName:"webgl",kernelFunc:s2e};var lI=class{constructor(n,e){this.variableNames=["x","segmentIds"];let r=n.windowSize,o=n.batchSize,s=n.inSize,i=n.numSegments,a=i*Math.ceil(s/r);this.outputShape=[o,a];let l="0.0",c="sumValue",u=Math.floor(r/4)*4,p=r%4,f=`
        sumValue += dot(values, segFilter);
    `,d="";s%r>0&&(d=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let h="";s%r>0&&(h=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${h}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${f}
        }

        int inIdx = inOffset + ${u};
        if (${p===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${f}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${f}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${f}
        }
        setOutput(${c});
      }
    `}};function i2e(t){let{inputs:n,backend:e,attrs:r}=t,{x:o,segmentIds:s}=n,{numSegments:i}=r,a=o.shape.length,l=[],c=0,u=_.getAxesPermutation([c],a),p=o;u!=null&&(p=Cn({inputs:{x:o},backend:e,attrs:{perm:u}}),l.push(p),c=_.getInnerMostAxes(1,a)[0]);let f=_.segment_util.computeOutShape(p.shape,c,i),d=b.sizeFromShape([p.shape[c]]),h=we({inputs:{x:p},backend:e,attrs:{shape:[-1,d]}});l.push(h);let g=Kp(o.dtype),m=(I,D,O,L,B)=>{let V=I.shape[0],F=I.shape[1],G=_.segment_util.segOpComputeOptimalWindowSize(F,B),ee={windowSize:G,inSize:F,batchSize:V,numSegments:B},Q=new lI(ee,D),oe=e.compileAndRun(Q,[I,O],L);if(l.push(oe),oe.shape[1]===B)return oe;let ae=Rk({backend:e,attrs:{start:0,stop:B,step:1,dtype:"float32"}}),J=Mk({inputs:{x:ae},backend:e,attrs:{reps:[F/G]}});return l.push(ae),l.push(J),m(oe,D,J,L,B)},y=m(h,"unsortedSegmentSum",s,g,i),x=we({inputs:{x:y},backend:e,attrs:{shape:f}}),C=x;if(u!=null){l.push(x);let I=_.getUndoAxesPermutation(u);C=Cn({inputs:{x:C},backend:e,attrs:{perm:I}})}return l.forEach(I=>e.disposeIntermediateTensorInfo(I)),C}var Oq={kernelName:iu,backendName:"webgl",kernelFunc:i2e};var a2e=[gj,xj,vj,bj,Cj,Ij,Sj,Tj,Dj,kj,Aj,_j,Rj,Mj,Oj,Fj,$j,Lj,Pj,Bj,zj,Uj,Gj,jj,Hj,Xj,Zj,Qj,ij,eH,nH,rH,oH,sH,iH,aH,lH,cH,uH,pH,hH,mH,gH,yH,xH,vH,bH,wH,CH,IH,SH,TH,EH,NH,DH,kH,_H,RH,MH,OH,$H,LH,PH,BH,zH,VH,UH,GH,jH,sj,HH,tH,WH,qH,KH,aj,XH,YH,ZH,QH,JH,eW,tW,nW,rW,oW,iW,aW,lW,cW,uW,pW,dW,mW,gW,yW,xW,vW,SW,uj,TW,EW,NW,DW,Wj,kW,RW,MW,OW,FW,lj,$W,LW,PW,BW,zW,qj,bW,VW,UW,GW,fj,jW,HW,WW,qW,KW,XW,YW,ZW,QW,JW,eq,tq,nq,rq,oq,sq,Vj,IW,iq,aq,lq,cq,uq,pq,fq,dq,mq,gq,xq,vq,bq,wq,Cq,Iq,Sq,CW,hj,Tq,Eq,Nq,Dq,Aq,_q,mj,Rq,Mq,Oq,AW];for(let t of a2e)cv(t);var qq=wa(PE());var Ai=function(){return Ai=Object.assign||function(t){for(var n,e=1,r=arguments.length;e<r;e++)for(var o in n=arguments[e])Object.prototype.hasOwnProperty.call(n,o)&&(t[o]=n[o]);return t},Ai.apply(this,arguments)};function Xl(t,n,e,r){return new(e||(e=Promise))(function(o,s){function i(c){try{l(r.next(c))}catch(u){s(u)}}function a(c){try{l(r.throw(c))}catch(u){s(u)}}function l(c){var u;c.done?o(c.value):(u=c.value,u instanceof e?u:new e(function(p){p(u)})).then(i,a)}l((r=r.apply(t,n||[])).next())})}function Yl(t,n){var e,r,o,s,i={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return s={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(s[Symbol.iterator]=function(){return this}),s;function a(l){return function(c){return(function(u){if(e)throw new TypeError("Generator is already executing.");for(;i;)try{if(e=1,r&&(o=2&u[0]?r.return:u[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,u[1])).done)return o;switch(r=0,o&&(u=[2&u[0],o.value]),u[0]){case 0:case 1:o=u;break;case 4:return i.label++,{value:u[1],done:!1};case 5:i.label++,r=u[1],u=[0];continue;case 7:u=i.ops.pop(),i.trys.pop();continue;default:if(o=i.trys,!((o=o.length>0&&o[o.length-1])||u[0]!==6&&u[0]!==2)){i=0;continue}if(u[0]===3&&(!o||u[1]>o[0]&&u[1]<o[3])){i.label=u[1];break}if(u[0]===6&&i.label<o[1]){i.label=o[1],o=u;break}if(o&&i.label<o[2]){i.label=o[2],i.ops.push(u);break}o[2]&&i.ops.pop(),i.trys.pop();continue}u=n.call(t,i)}catch(p){u=[6,p],r=0}finally{e=o=0}if(5&u[0])throw u[1];return{value:u[0]?u[1]:void 0,done:!0}})([l,c])}}}function ju(t){var n=t.map(function(e){return e[0]});return n.push(t[t.length-1][1]),n}var Kq={lips:ju([[61,146],[146,91],[91,181],[181,84],[84,17],[17,314],[314,405],[405,321],[321,375],[375,291],[61,185],[185,40],[40,39],[39,37],[37,0],[0,267],[267,269],[269,270],[270,409],[409,291],[78,95],[95,88],[88,178],[178,87],[87,14],[14,317],[317,402],[402,318],[318,324],[324,308],[78,191],[191,80],[80,81],[81,82],[82,13],[13,312],[312,311],[311,310],[310,415],[415,308]]),leftEye:ju([[263,249],[249,390],[390,373],[373,374],[374,380],[380,381],[381,382],[382,362],[263,466],[466,388],[388,387],[387,386],[386,385],[385,384],[384,398],[398,362]]),leftEyebrow:ju([[276,283],[283,282],[282,295],[295,285],[300,293],[293,334],[334,296],[296,336]]),leftIris:ju([[474,475],[475,476],[476,477],[477,474]]),rightEye:ju([[33,7],[7,163],[163,144],[144,145],[145,153],[153,154],[154,155],[155,133],[33,246],[246,161],[161,160],[160,159],[159,158],[158,157],[157,173],[173,133]]),rightEyebrow:ju([[46,53],[53,52],[52,65],[65,55],[70,63],[63,105],[105,66],[66,107]]),rightIris:ju([[469,470],[470,471],[471,472],[472,469]]),faceOval:ju([[10,338],[338,297],[297,332],[332,284],[284,251],[251,389],[389,356],[356,454],[454,323],[323,361],[361,288],[288,397],[397,365],[365,379],[379,378],[378,400],[400,377],[377,152],[152,148],[148,176],[176,149],[149,150],[150,136],[136,172],[172,58],[58,132],[132,93],[93,234],[234,127],[127,162],[162,21],[21,54],[54,103],[103,67],[67,109],[109,10]])},c2e=[[127,34],[34,139],[139,127],[11,0],[0,37],[37,11],[232,231],[231,120],[120,232],[72,37],[37,39],[39,72],[128,121],[121,47],[47,128],[232,121],[121,128],[128,232],[104,69],[69,67],[67,104],[175,171],[171,148],[148,175],[118,50],[50,101],[101,118],[73,39],[39,40],[40,73],[9,151],[151,108],[108,9],[48,115],[115,131],[131,48],[194,204],[204,211],[211,194],[74,40],[40,185],[185,74],[80,42],[42,183],[183,80],[40,92],[92,186],[186,40],[230,229],[229,118],[118,230],[202,212],[212,214],[214,202],[83,18],[18,17],[17,83],[76,61],[61,146],[146,76],[160,29],[29,30],[30,160],[56,157],[157,173],[173,56],[106,204],[204,194],[194,106],[135,214],[214,192],[192,135],[203,165],[165,98],[98,203],[21,71],[71,68],[68,21],[51,45],[45,4],[4,51],[144,24],[24,23],[23,144],[77,146],[146,91],[91,77],[205,50],[50,187],[187,205],[201,200],[200,18],[18,201],[91,106],[106,182],[182,91],[90,91],[91,181],[181,90],[85,84],[84,17],[17,85],[206,203],[203,36],[36,206],[148,171],[171,140],[140,148],[92,40],[40,39],[39,92],[193,189],[189,244],[244,193],[159,158],[158,28],[28,159],[247,246],[246,161],[161,247],[236,3],[3,196],[196,236],[54,68],[68,104],[104,54],[193,168],[168,8],[8,193],[117,228],[228,31],[31,117],[189,193],[193,55],[55,189],[98,97],[97,99],[99,98],[126,47],[47,100],[100,126],[166,79],[79,218],[218,166],[155,154],[154,26],[26,155],[209,49],[49,131],[131,209],[135,136],[136,150],[150,135],[47,126],[126,217],[217,47],[223,52],[52,53],[53,223],[45,51],[51,134],[134,45],[211,170],[170,140],[140,211],[67,69],[69,108],[108,67],[43,106],[106,91],[91,43],[230,119],[119,120],[120,230],[226,130],[130,247],[247,226],[63,53],[53,52],[52,63],[238,20],[20,242],[242,238],[46,70],[70,156],[156,46],[78,62],[62,96],[96,78],[46,53],[53,63],[63,46],[143,34],[34,227],[227,143],[123,117],[117,111],[111,123],[44,125],[125,19],[19,44],[236,134],[134,51],[51,236],[216,206],[206,205],[205,216],[154,153],[153,22],[22,154],[39,37],[37,167],[167,39],[200,201],[201,208],[208,200],[36,142],[142,100],[100,36],[57,212],[212,202],[202,57],[20,60],[60,99],[99,20],[28,158],[158,157],[157,28],[35,226],[226,113],[113,35],[160,159],[159,27],[27,160],[204,202],[202,210],[210,204],[113,225],[225,46],[46,113],[43,202],[202,204],[204,43],[62,76],[76,77],[77,62],[137,123],[123,116],[116,137],[41,38],[38,72],[72,41],[203,129],[129,142],[142,203],[64,98],[98,240],[240,64],[49,102],[102,64],[64,49],[41,73],[73,74],[74,41],[212,216],[216,207],[207,212],[42,74],[74,184],[184,42],[169,170],[170,211],[211,169],[170,149],[149,176],[176,170],[105,66],[66,69],[69,105],[122,6],[6,168],[168,122],[123,147],[147,187],[187,123],[96,77],[77,90],[90,96],[65,55],[55,107],[107,65],[89,90],[90,180],[180,89],[101,100],[100,120],[120,101],[63,105],[105,104],[104,63],[93,137],[137,227],[227,93],[15,86],[86,85],[85,15],[129,102],[102,49],[49,129],[14,87],[87,86],[86,14],[55,8],[8,9],[9,55],[100,47],[47,121],[121,100],[145,23],[23,22],[22,145],[88,89],[89,179],[179,88],[6,122],[122,196],[196,6],[88,95],[95,96],[96,88],[138,172],[172,136],[136,138],[215,58],[58,172],[172,215],[115,48],[48,219],[219,115],[42,80],[80,81],[81,42],[195,3],[3,51],[51,195],[43,146],[146,61],[61,43],[171,175],[175,199],[199,171],[81,82],[82,38],[38,81],[53,46],[46,225],[225,53],[144,163],[163,110],[110,144],[52,65],[65,66],[66,52],[229,228],[228,117],[117,229],[34,127],[127,234],[234,34],[107,108],[108,69],[69,107],[109,108],[108,151],[151,109],[48,64],[64,235],[235,48],[62,78],[78,191],[191,62],[129,209],[209,126],[126,129],[111,35],[35,143],[143,111],[117,123],[123,50],[50,117],[222,65],[65,52],[52,222],[19,125],[125,141],[141,19],[221,55],[55,65],[65,221],[3,195],[195,197],[197,3],[25,7],[7,33],[33,25],[220,237],[237,44],[44,220],[70,71],[71,139],[139,70],[122,193],[193,245],[245,122],[247,130],[130,33],[33,247],[71,21],[21,162],[162,71],[170,169],[169,150],[150,170],[188,174],[174,196],[196,188],[216,186],[186,92],[92,216],[2,97],[97,167],[167,2],[141,125],[125,241],[241,141],[164,167],[167,37],[37,164],[72,38],[38,12],[12,72],[38,82],[82,13],[13,38],[63,68],[68,71],[71,63],[226,35],[35,111],[111,226],[101,50],[50,205],[205,101],[206,92],[92,165],[165,206],[209,198],[198,217],[217,209],[165,167],[167,97],[97,165],[220,115],[115,218],[218,220],[133,112],[112,243],[243,133],[239,238],[238,241],[241,239],[214,135],[135,169],[169,214],[190,173],[173,133],[133,190],[171,208],[208,32],[32,171],[125,44],[44,237],[237,125],[86,87],[87,178],[178,86],[85,86],[86,179],[179,85],[84,85],[85,180],[180,84],[83,84],[84,181],[181,83],[201,83],[83,182],[182,201],[137,93],[93,132],[132,137],[76,62],[62,183],[183,76],[61,76],[76,184],[184,61],[57,61],[61,185],[185,57],[212,57],[57,186],[186,212],[214,207],[207,187],[187,214],[34,143],[143,156],[156,34],[79,239],[239,237],[237,79],[123,137],[137,177],[177,123],[44,1],[1,4],[4,44],[201,194],[194,32],[32,201],[64,102],[102,129],[129,64],[213,215],[215,138],[138,213],[59,166],[166,219],[219,59],[242,99],[99,97],[97,242],[2,94],[94,141],[141,2],[75,59],[59,235],[235,75],[24,110],[110,228],[228,24],[25,130],[130,226],[226,25],[23,24],[24,229],[229,23],[22,23],[23,230],[230,22],[26,22],[22,231],[231,26],[112,26],[26,232],[232,112],[189,190],[190,243],[243,189],[221,56],[56,190],[190,221],[28,56],[56,221],[221,28],[27,28],[28,222],[222,27],[29,27],[27,223],[223,29],[30,29],[29,224],[224,30],[247,30],[30,225],[225,247],[238,79],[79,20],[20,238],[166,59],[59,75],[75,166],[60,75],[75,240],[240,60],[147,177],[177,215],[215,147],[20,79],[79,166],[166,20],[187,147],[147,213],[213,187],[112,233],[233,244],[244,112],[233,128],[128,245],[245,233],[128,114],[114,188],[188,128],[114,217],[217,174],[174,114],[131,115],[115,220],[220,131],[217,198],[198,236],[236,217],[198,131],[131,134],[134,198],[177,132],[132,58],[58,177],[143,35],[35,124],[124,143],[110,163],[163,7],[7,110],[228,110],[110,25],[25,228],[356,389],[389,368],[368,356],[11,302],[302,267],[267,11],[452,350],[350,349],[349,452],[302,303],[303,269],[269,302],[357,343],[343,277],[277,357],[452,453],[453,357],[357,452],[333,332],[332,297],[297,333],[175,152],[152,377],[377,175],[347,348],[348,330],[330,347],[303,304],[304,270],[270,303],[9,336],[336,337],[337,9],[278,279],[279,360],[360,278],[418,262],[262,431],[431,418],[304,408],[408,409],[409,304],[310,415],[415,407],[407,310],[270,409],[409,410],[410,270],[450,348],[348,347],[347,450],[422,430],[430,434],[434,422],[313,314],[314,17],[17,313],[306,307],[307,375],[375,306],[387,388],[388,260],[260,387],[286,414],[414,398],[398,286],[335,406],[406,418],[418,335],[364,367],[367,416],[416,364],[423,358],[358,327],[327,423],[251,284],[284,298],[298,251],[281,5],[5,4],[4,281],[373,374],[374,253],[253,373],[307,320],[320,321],[321,307],[425,427],[427,411],[411,425],[421,313],[313,18],[18,421],[321,405],[405,406],[406,321],[320,404],[404,405],[405,320],[315,16],[16,17],[17,315],[426,425],[425,266],[266,426],[377,400],[400,369],[369,377],[322,391],[391,269],[269,322],[417,465],[465,464],[464,417],[386,257],[257,258],[258,386],[466,260],[260,388],[388,466],[456,399],[399,419],[419,456],[284,332],[332,333],[333,284],[417,285],[285,8],[8,417],[346,340],[340,261],[261,346],[413,441],[441,285],[285,413],[327,460],[460,328],[328,327],[355,371],[371,329],[329,355],[392,439],[439,438],[438,392],[382,341],[341,256],[256,382],[429,420],[420,360],[360,429],[364,394],[394,379],[379,364],[277,343],[343,437],[437,277],[443,444],[444,283],[283,443],[275,440],[440,363],[363,275],[431,262],[262,369],[369,431],[297,338],[338,337],[337,297],[273,375],[375,321],[321,273],[450,451],[451,349],[349,450],[446,342],[342,467],[467,446],[293,334],[334,282],[282,293],[458,461],[461,462],[462,458],[276,353],[353,383],[383,276],[308,324],[324,325],[325,308],[276,300],[300,293],[293,276],[372,345],[345,447],[447,372],[352,345],[345,340],[340,352],[274,1],[1,19],[19,274],[456,248],[248,281],[281,456],[436,427],[427,425],[425,436],[381,256],[256,252],[252,381],[269,391],[391,393],[393,269],[200,199],[199,428],[428,200],[266,330],[330,329],[329,266],[287,273],[273,422],[422,287],[250,462],[462,328],[328,250],[258,286],[286,384],[384,258],[265,353],[353,342],[342,265],[387,259],[259,257],[257,387],[424,431],[431,430],[430,424],[342,353],[353,276],[276,342],[273,335],[335,424],[424,273],[292,325],[325,307],[307,292],[366,447],[447,345],[345,366],[271,303],[303,302],[302,271],[423,266],[266,371],[371,423],[294,455],[455,460],[460,294],[279,278],[278,294],[294,279],[271,272],[272,304],[304,271],[432,434],[434,427],[427,432],[272,407],[407,408],[408,272],[394,430],[430,431],[431,394],[395,369],[369,400],[400,395],[334,333],[333,299],[299,334],[351,417],[417,168],[168,351],[352,280],[280,411],[411,352],[325,319],[319,320],[320,325],[295,296],[296,336],[336,295],[319,403],[403,404],[404,319],[330,348],[348,349],[349,330],[293,298],[298,333],[333,293],[323,454],[454,447],[447,323],[15,16],[16,315],[315,15],[358,429],[429,279],[279,358],[14,15],[15,316],[316,14],[285,336],[336,9],[9,285],[329,349],[349,350],[350,329],[374,380],[380,252],[252,374],[318,402],[402,403],[403,318],[6,197],[197,419],[419,6],[318,319],[319,325],[325,318],[367,364],[364,365],[365,367],[435,367],[367,397],[397,435],[344,438],[438,439],[439,344],[272,271],[271,311],[311,272],[195,5],[5,281],[281,195],[273,287],[287,291],[291,273],[396,428],[428,199],[199,396],[311,271],[271,268],[268,311],[283,444],[444,445],[445,283],[373,254],[254,339],[339,373],[282,334],[334,296],[296,282],[449,347],[347,346],[346,449],[264,447],[447,454],[454,264],[336,296],[296,299],[299,336],[338,10],[10,151],[151,338],[278,439],[439,455],[455,278],[292,407],[407,415],[415,292],[358,371],[371,355],[355,358],[340,345],[345,372],[372,340],[346,347],[347,280],[280,346],[442,443],[443,282],[282,442],[19,94],[94,370],[370,19],[441,442],[442,295],[295,441],[248,419],[419,197],[197,248],[263,255],[255,359],[359,263],[440,275],[275,274],[274,440],[300,383],[383,368],[368,300],[351,412],[412,465],[465,351],[263,467],[467,466],[466,263],[301,368],[368,389],[389,301],[395,378],[378,379],[379,395],[412,351],[351,419],[419,412],[436,426],[426,322],[322,436],[2,164],[164,393],[393,2],[370,462],[462,461],[461,370],[164,0],[0,267],[267,164],[302,11],[11,12],[12,302],[268,12],[12,13],[13,268],[293,300],[300,301],[301,293],[446,261],[261,340],[340,446],[330,266],[266,425],[425,330],[426,423],[423,391],[391,426],[429,355],[355,437],[437,429],[391,327],[327,326],[326,391],[440,457],[457,438],[438,440],[341,382],[382,362],[362,341],[459,457],[457,461],[461,459],[434,430],[430,394],[394,434],[414,463],[463,362],[362,414],[396,369],[369,262],[262,396],[354,461],[461,457],[457,354],[316,403],[403,402],[402,316],[315,404],[404,403],[403,315],[314,405],[405,404],[404,314],[313,406],[406,405],[405,313],[421,418],[418,406],[406,421],[366,401],[401,361],[361,366],[306,408],[408,407],[407,306],[291,409],[409,408],[408,291],[287,410],[410,409],[409,287],[432,436],[436,410],[410,432],[434,416],[416,411],[411,434],[264,368],[368,383],[383,264],[309,438],[438,457],[457,309],[352,376],[376,401],[401,352],[274,275],[275,4],[4,274],[421,428],[428,262],[262,421],[294,327],[327,358],[358,294],[433,416],[416,367],[367,433],[289,455],[455,439],[439,289],[462,370],[370,326],[326,462],[2,326],[326,370],[370,2],[305,460],[460,455],[455,305],[254,449],[449,448],[448,254],[255,261],[261,446],[446,255],[253,450],[450,449],[449,253],[252,451],[451,450],[450,252],[256,452],[452,451],[451,256],[341,453],[453,452],[452,341],[413,464],[464,463],[463,413],[441,413],[413,414],[414,441],[258,442],[442,441],[441,258],[257,443],[443,442],[442,257],[259,444],[444,443],[443,259],[260,445],[445,444],[444,260],[467,342],[342,445],[445,467],[459,458],[458,250],[250,459],[289,392],[392,290],[290,289],[290,328],[328,460],[460,290],[376,433],[433,435],[435,376],[250,290],[290,392],[392,250],[411,416],[416,433],[433,411],[341,463],[463,464],[464,341],[453,464],[464,465],[465,453],[357,465],[465,412],[412,357],[343,412],[412,399],[399,343],[360,363],[363,440],[440,360],[437,399],[399,456],[456,437],[420,456],[456,363],[363,420],[401,435],[435,288],[288,401],[372,383],[383,353],[353,372],[339,255],[255,249],[249,339],[448,261],[261,255],[255,448],[133,243],[243,190],[190,133],[133,155],[155,112],[112,133],[33,246],[246,247],[247,33],[33,130],[130,25],[25,33],[398,384],[384,286],[286,398],[362,398],[398,414],[414,362],[362,463],[463,341],[341,362],[263,359],[359,467],[467,263],[263,249],[249,255],[255,263],[466,467],[467,260],[260,466],[75,60],[60,166],[166,75],[238,239],[239,79],[79,238],[162,127],[127,139],[139,162],[72,11],[11,37],[37,72],[121,232],[232,120],[120,121],[73,72],[72,39],[39,73],[114,128],[128,47],[47,114],[233,232],[232,128],[128,233],[103,104],[104,67],[67,103],[152,175],[175,148],[148,152],[119,118],[118,101],[101,119],[74,73],[73,40],[40,74],[107,9],[9,108],[108,107],[49,48],[48,131],[131,49],[32,194],[194,211],[211,32],[184,74],[74,185],[185,184],[191,80],[80,183],[183,191],[185,40],[40,186],[186,185],[119,230],[230,118],[118,119],[210,202],[202,214],[214,210],[84,83],[83,17],[17,84],[77,76],[76,146],[146,77],[161,160],[160,30],[30,161],[190,56],[56,173],[173,190],[182,106],[106,194],[194,182],[138,135],[135,192],[192,138],[129,203],[203,98],[98,129],[54,21],[21,68],[68,54],[5,51],[51,4],[4,5],[145,144],[144,23],[23,145],[90,77],[77,91],[91,90],[207,205],[205,187],[187,207],[83,201],[201,18],[18,83],[181,91],[91,182],[182,181],[180,90],[90,181],[181,180],[16,85],[85,17],[17,16],[205,206],[206,36],[36,205],[176,148],[148,140],[140,176],[165,92],[92,39],[39,165],[245,193],[193,244],[244,245],[27,159],[159,28],[28,27],[30,247],[247,161],[161,30],[174,236],[236,196],[196,174],[103,54],[54,104],[104,103],[55,193],[193,8],[8,55],[111,117],[117,31],[31,111],[221,189],[189,55],[55,221],[240,98],[98,99],[99,240],[142,126],[126,100],[100,142],[219,166],[166,218],[218,219],[112,155],[155,26],[26,112],[198,209],[209,131],[131,198],[169,135],[135,150],[150,169],[114,47],[47,217],[217,114],[224,223],[223,53],[53,224],[220,45],[45,134],[134,220],[32,211],[211,140],[140,32],[109,67],[67,108],[108,109],[146,43],[43,91],[91,146],[231,230],[230,120],[120,231],[113,226],[226,247],[247,113],[105,63],[63,52],[52,105],[241,238],[238,242],[242,241],[124,46],[46,156],[156,124],[95,78],[78,96],[96,95],[70,46],[46,63],[63,70],[116,143],[143,227],[227,116],[116,123],[123,111],[111,116],[1,44],[44,19],[19,1],[3,236],[236,51],[51,3],[207,216],[216,205],[205,207],[26,154],[154,22],[22,26],[165,39],[39,167],[167,165],[199,200],[200,208],[208,199],[101,36],[36,100],[100,101],[43,57],[57,202],[202,43],[242,20],[20,99],[99,242],[56,28],[28,157],[157,56],[124,35],[35,113],[113,124],[29,160],[160,27],[27,29],[211,204],[204,210],[210,211],[124,113],[113,46],[46,124],[106,43],[43,204],[204,106],[96,62],[62,77],[77,96],[227,137],[137,116],[116,227],[73,41],[41,72],[72,73],[36,203],[203,142],[142,36],[235,64],[64,240],[240,235],[48,49],[49,64],[64,48],[42,41],[41,74],[74,42],[214,212],[212,207],[207,214],[183,42],[42,184],[184,183],[210,169],[169,211],[211,210],[140,170],[170,176],[176,140],[104,105],[105,69],[69,104],[193,122],[122,168],[168,193],[50,123],[123,187],[187,50],[89,96],[96,90],[90,89],[66,65],[65,107],[107,66],[179,89],[89,180],[180,179],[119,101],[101,120],[120,119],[68,63],[63,104],[104,68],[234,93],[93,227],[227,234],[16,15],[15,85],[85,16],[209,129],[129,49],[49,209],[15,14],[14,86],[86,15],[107,55],[55,9],[9,107],[120,100],[100,121],[121,120],[153,145],[145,22],[22,153],[178,88],[88,179],[179,178],[197,6],[6,196],[196,197],[89,88],[88,96],[96,89],[135,138],[138,136],[136,135],[138,215],[215,172],[172,138],[218,115],[115,219],[219,218],[41,42],[42,81],[81,41],[5,195],[195,51],[51,5],[57,43],[43,61],[61,57],[208,171],[171,199],[199,208],[41,81],[81,38],[38,41],[224,53],[53,225],[225,224],[24,144],[144,110],[110,24],[105,52],[52,66],[66,105],[118,229],[229,117],[117,118],[227,34],[34,234],[234,227],[66,107],[107,69],[69,66],[10,109],[109,151],[151,10],[219,48],[48,235],[235,219],[183,62],[62,191],[191,183],[142,129],[129,126],[126,142],[116,111],[111,143],[143,116],[118,117],[117,50],[50,118],[223,222],[222,52],[52,223],[94,19],[19,141],[141,94],[222,221],[221,65],[65,222],[196,3],[3,197],[197,196],[45,220],[220,44],[44,45],[156,70],[70,139],[139,156],[188,122],[122,245],[245,188],[139,71],[71,162],[162,139],[149,170],[170,150],[150,149],[122,188],[188,196],[196,122],[206,216],[216,92],[92,206],[164,2],[2,167],[167,164],[242,141],[141,241],[241,242],[0,164],[164,37],[37,0],[11,72],[72,12],[12,11],[12,38],[38,13],[13,12],[70,63],[63,71],[71,70],[31,226],[226,111],[111,31],[36,101],[101,205],[205,36],[203,206],[206,165],[165,203],[126,209],[209,217],[217,126],[98,165],[165,97],[97,98],[237,220],[220,218],[218,237],[237,239],[239,241],[241,237],[210,214],[214,169],[169,210],[140,171],[171,32],[32,140],[241,125],[125,237],[237,241],[179,86],[86,178],[178,179],[180,85],[85,179],[179,180],[181,84],[84,180],[180,181],[182,83],[83,181],[181,182],[194,201],[201,182],[182,194],[177,137],[137,132],[132,177],[184,76],[76,183],[183,184],[185,61],[61,184],[184,185],[186,57],[57,185],[185,186],[216,212],[212,186],[186,216],[192,214],[214,187],[187,192],[139,34],[34,156],[156,139],[218,79],[79,237],[237,218],[147,123],[123,177],[177,147],[45,44],[44,4],[4,45],[208,201],[201,32],[32,208],[98,64],[64,129],[129,98],[192,213],[213,138],[138,192],[235,59],[59,219],[219,235],[141,242],[242,97],[97,141],[97,2],[2,141],[141,97],[240,75],[75,235],[235,240],[229,24],[24,228],[228,229],[31,25],[25,226],[226,31],[230,23],[23,229],[229,230],[231,22],[22,230],[230,231],[232,26],[26,231],[231,232],[233,112],[112,232],[232,233],[244,189],[189,243],[243,244],[189,221],[221,190],[190,189],[222,28],[28,221],[221,222],[223,27],[27,222],[222,223],[224,29],[29,223],[223,224],[225,30],[30,224],[224,225],[113,247],[247,225],[225,113],[99,60],[60,240],[240,99],[213,147],[147,215],[215,213],[60,20],[20,166],[166,60],[192,187],[187,213],[213,192],[243,112],[112,244],[244,243],[244,233],[233,245],[245,244],[245,128],[128,188],[188,245],[188,114],[114,174],[174,188],[134,131],[131,220],[220,134],[174,217],[217,236],[236,174],[236,198],[198,134],[134,236],[215,177],[177,58],[58,215],[156,143],[143,124],[124,156],[25,110],[110,7],[7,25],[31,228],[228,25],[25,31],[264,356],[356,368],[368,264],[0,11],[11,267],[267,0],[451,452],[452,349],[349,451],[267,302],[302,269],[269,267],[350,357],[357,277],[277,350],[350,452],[452,357],[357,350],[299,333],[333,297],[297,299],[396,175],[175,377],[377,396],[280,347],[347,330],[330,280],[269,303],[303,270],[270,269],[151,9],[9,337],[337,151],[344,278],[278,360],[360,344],[424,418],[418,431],[431,424],[270,304],[304,409],[409,270],[272,310],[310,407],[407,272],[322,270],[270,410],[410,322],[449,450],[450,347],[347,449],[432,422],[422,434],[434,432],[18,313],[313,17],[17,18],[291,306],[306,375],[375,291],[259,387],[387,260],[260,259],[424,335],[335,418],[418,424],[434,364],[364,416],[416,434],[391,423],[423,327],[327,391],[301,251],[251,298],[298,301],[275,281],[281,4],[4,275],[254,373],[373,253],[253,254],[375,307],[307,321],[321,375],[280,425],[425,411],[411,280],[200,421],[421,18],[18,200],[335,321],[321,406],[406,335],[321,320],[320,405],[405,321],[314,315],[315,17],[17,314],[423,426],[426,266],[266,423],[396,377],[377,369],[369,396],[270,322],[322,269],[269,270],[413,417],[417,464],[464,413],[385,386],[386,258],[258,385],[248,456],[456,419],[419,248],[298,284],[284,333],[333,298],[168,417],[417,8],[8,168],[448,346],[346,261],[261,448],[417,413],[413,285],[285,417],[326,327],[327,328],[328,326],[277,355],[355,329],[329,277],[309,392],[392,438],[438,309],[381,382],[382,256],[256,381],[279,429],[429,360],[360,279],[365,364],[364,379],[379,365],[355,277],[277,437],[437,355],[282,443],[443,283],[283,282],[281,275],[275,363],[363,281],[395,431],[431,369],[369,395],[299,297],[297,337],[337,299],[335,273],[273,321],[321,335],[348,450],[450,349],[349,348],[359,446],[446,467],[467,359],[283,293],[293,282],[282,283],[250,458],[458,462],[462,250],[300,276],[276,383],[383,300],[292,308],[308,325],[325,292],[283,276],[276,293],[293,283],[264,372],[372,447],[447,264],[346,352],[352,340],[340,346],[354,274],[274,19],[19,354],[363,456],[456,281],[281,363],[426,436],[436,425],[425,426],[380,381],[381,252],[252,380],[267,269],[269,393],[393,267],[421,200],[200,428],[428,421],[371,266],[266,329],[329,371],[432,287],[287,422],[422,432],[290,250],[250,328],[328,290],[385,258],[258,384],[384,385],[446,265],[265,342],[342,446],[386,387],[387,257],[257,386],[422,424],[424,430],[430,422],[445,342],[342,276],[276,445],[422,273],[273,424],[424,422],[306,292],[292,307],[307,306],[352,366],[366,345],[345,352],[268,271],[271,302],[302,268],[358,423],[423,371],[371,358],[327,294],[294,460],[460,327],[331,279],[279,294],[294,331],[303,271],[271,304],[304,303],[436,432],[432,427],[427,436],[304,272],[272,408],[408,304],[395,394],[394,431],[431,395],[378,395],[395,400],[400,378],[296,334],[334,299],[299,296],[6,351],[351,168],[168,6],[376,352],[352,411],[411,376],[307,325],[325,320],[320,307],[285,295],[295,336],[336,285],[320,319],[319,404],[404,320],[329,330],[330,349],[349,329],[334,293],[293,333],[333,334],[366,323],[323,447],[447,366],[316,15],[15,315],[315,316],[331,358],[358,279],[279,331],[317,14],[14,316],[316,317],[8,285],[285,9],[9,8],[277,329],[329,350],[350,277],[253,374],[374,252],[252,253],[319,318],[318,403],[403,319],[351,6],[6,419],[419,351],[324,318],[318,325],[325,324],[397,367],[367,365],[365,397],[288,435],[435,397],[397,288],[278,344],[344,439],[439,278],[310,272],[272,311],[311,310],[248,195],[195,281],[281,248],[375,273],[273,291],[291,375],[175,396],[396,199],[199,175],[312,311],[311,268],[268,312],[276,283],[283,445],[445,276],[390,373],[373,339],[339,390],[295,282],[282,296],[296,295],[448,449],[449,346],[346,448],[356,264],[264,454],[454,356],[337,336],[336,299],[299,337],[337,338],[338,151],[151,337],[294,278],[278,455],[455,294],[308,292],[292,415],[415,308],[429,358],[358,355],[355,429],[265,340],[340,372],[372,265],[352,346],[346,280],[280,352],[295,442],[442,282],[282,295],[354,19],[19,370],[370,354],[285,441],[441,295],[295,285],[195,248],[248,197],[197,195],[457,440],[440,274],[274,457],[301,300],[300,368],[368,301],[417,351],[351,465],[465,417],[251,301],[301,389],[389,251],[394,395],[395,379],[379,394],[399,412],[412,419],[419,399],[410,436],[436,322],[322,410],[326,2],[2,393],[393,326],[354,370],[370,461],[461,354],[393,164],[164,267],[267,393],[268,302],[302,12],[12,268],[312,268],[268,13],[13,312],[298,293],[293,301],[301,298],[265,446],[446,340],[340,265],[280,330],[330,425],[425,280],[322,426],[426,391],[391,322],[420,429],[429,437],[437,420],[393,391],[391,326],[326,393],[344,440],[440,438],[438,344],[458,459],[459,461],[461,458],[364,434],[434,394],[394,364],[428,396],[396,262],[262,428],[274,354],[354,457],[457,274],[317,316],[316,402],[402,317],[316,315],[315,403],[403,316],[315,314],[314,404],[404,315],[314,313],[313,405],[405,314],[313,421],[421,406],[406,313],[323,366],[366,361],[361,323],[292,306],[306,407],[407,292],[306,291],[291,408],[408,306],[291,287],[287,409],[409,291],[287,432],[432,410],[410,287],[427,434],[434,411],[411,427],[372,264],[264,383],[383,372],[459,309],[309,457],[457,459],[366,352],[352,401],[401,366],[1,274],[274,4],[4,1],[418,421],[421,262],[262,418],[331,294],[294,358],[358,331],[435,433],[433,367],[367,435],[392,289],[289,439],[439,392],[328,462],[462,326],[326,328],[94,2],[2,370],[370,94],[289,305],[305,455],[455,289],[339,254],[254,448],[448,339],[359,255],[255,446],[446,359],[254,253],[253,449],[449,254],[253,252],[252,450],[450,253],[252,256],[256,451],[451,252],[256,341],[341,452],[452,256],[414,413],[413,463],[463,414],[286,441],[441,414],[414,286],[286,258],[258,441],[441,286],[258,257],[257,442],[442,258],[257,259],[259,443],[443,257],[259,260],[260,444],[444,259],[260,467],[467,445],[445,260],[309,459],[459,250],[250,309],[305,289],[289,290],[290,305],[305,290],[290,460],[460,305],[401,376],[376,435],[435,401],[309,250],[250,392],[392,309],[376,411],[411,433],[433,376],[453,341],[341,464],[464,453],[357,453],[453,465],[465,357],[343,357],[357,412],[412,343],[437,343],[343,399],[399,437],[344,360],[360,440],[440,344],[420,437],[437,456],[456,420],[360,420],[420,363],[363,360],[361,401],[401,288],[288,361],[265,372],[372,353],[353,265],[390,339],[339,249],[249,390],[339,448],[448,255],[255,339]],u2e=Object.entries(Kq).map(function(t){var n=t[0];return t[1].map(function(e){return[e,n]})}).flat(),Xq=new Map(u2e);function Gk(t){for(var n={locationData:{relativeKeypoints:[]}},e=Number.MAX_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER,o=Number.MAX_SAFE_INTEGER,s=Number.MIN_SAFE_INTEGER,i=0;i<t.length;++i){var a=t[i];e=Math.min(e,a.x),r=Math.max(r,a.x),o=Math.min(o,a.y),s=Math.max(s,a.y),n.locationData.relativeKeypoints.push({x:a.x,y:a.y})}return n.locationData.relativeBoundingBox={xMin:e,yMin:o,xMax:r,yMax:s,width:r-e,height:s-o},n}var Ok={runtime:"mediapipe",maxFaces:1,refineLandmarks:!1},p2e=(function(){function t(n){var e=this;this.width=0,this.height=0,this.selfieMode=!1,this.faceMeshSolution=new qq.FaceMesh({locateFile:function(r,o){return n.solutionPath?n.solutionPath.replace(/\/+$/,"")+"/"+r:o+"/"+r}}),this.faceMeshSolution.setOptions({refineLandmarks:n.refineLandmarks,selfieMode:this.selfieMode,maxNumFaces:n.maxFaces}),this.faceMeshSolution.onResults(function(r){if(e.height=r.image.height,e.width=r.image.width,e.faces=[],r.multiFaceLandmarks!==null)for(var o=r.multiFaceLandmarks,s=0;s<o.length;s++){var i=e.translateOutput(o[s]);e.faces.push({keypoints:i,box:Gk(i).locationData.relativeBoundingBox})}})}return t.prototype.translateOutput=function(n){var e=this;return n.map(function(r,o){var s={x:r.x*e.width,y:r.y*e.height,z:r.z*e.width},i=Xq.get(o);return i!=null&&(s.name=i),s})},t.prototype.estimateFaces=function(n,e){return Xl(this,void 0,void 0,function(){var r,o;return Yl(this,function(s){switch(s.label){case 0:return e&&e.flipHorizontal&&e.flipHorizontal!==this.selfieMode&&(this.selfieMode=e.flipHorizontal,this.faceMeshSolution.setOptions({selfieMode:this.selfieMode})),n instanceof ot?(o=ImageData.bind,[4,Ol.toPixels(n)]):[3,2];case 1:return r=new(o.apply(ImageData,[void 0,s.sent(),n.shape[1],n.shape[0]])),[3,3];case 2:r=n,s.label=3;case 3:return n=r,[4,this.faceMeshSolution.send({image:n})];case 4:return s.sent(),[2,this.faces]}})})},t.prototype.dispose=function(){this.faceMeshSolution.close()},t.prototype.reset=function(){this.faceMeshSolution.reset(),this.width=0,this.height=0,this.faces=null,this.selfieMode=!1},t.prototype.initialize=function(){return this.faceMeshSolution.initialize()},t})();function f2e(t){return Xl(this,void 0,void 0,function(){var n,e;return Yl(this,function(r){switch(r.label){case 0:return n=(function(o){if(o==null)return Ai({},Ok);var s=Ai({},o);return s.runtime="mediapipe",s.maxFaces==null&&(s.maxFaces=Ok.maxFaces),s.refineLandmarks==null&&(s.refineLandmarks=Ok.refineLandmarks),s})(t),[4,(e=new p2e(n)).initialize()];case 1:return r.sent(),[2,e]}})})}var Fk=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},d2e={};(function(){var t;function n(v){var N=0;return function(){return N<v.length?{done:!1,value:v[N++]}:{done:!0}}}var e=typeof Object.defineProperties=="function"?Object.defineProperty:function(v,N,M){return v==Array.prototype||v==Object.prototype||(v[N]=M.value),v},r=(function(v){v=[typeof globalThis=="object"&&globalThis,v,typeof window=="object"&&window,typeof self=="object"&&self,typeof Fk=="object"&&Fk];for(var N=0;N<v.length;++N){var M=v[N];if(M&&M.Math==Math)return M}throw Error("Cannot find global object")})(this);function o(v,N){if(N)e:{var M=r;v=v.split(".");for(var P=0;P<v.length-1;P++){var W=v[P];if(!(W in M))break e;M=M[W]}(N=N(P=M[v=v[v.length-1]]))!=P&&N!=null&&e(M,v,{configurable:!0,writable:!0,value:N})}}function s(v){return(v={next:v})[Symbol.iterator]=function(){return this},v}function i(v){var N=typeof Symbol<"u"&&Symbol.iterator&&v[Symbol.iterator];return N?N.call(v):{next:n(v)}}function a(v){if(!(v instanceof Array)){v=i(v);for(var N,M=[];!(N=v.next()).done;)M.push(N.value);v=M}return v}o("Symbol",function(v){function N(W,H){this.g=W,e(this,"description",{configurable:!0,writable:!0,value:H})}if(v)return v;N.prototype.toString=function(){return this.g};var M="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",P=0;return function W(H){if(this instanceof W)throw new TypeError("Symbol is not a constructor");return new N(M+(H||"")+"_"+P++,H)}}),o("Symbol.iterator",function(v){if(v)return v;v=Symbol("Symbol.iterator");for(var N="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),M=0;M<N.length;M++){var P=r[N[M]];typeof P=="function"&&typeof P.prototype[v]!="function"&&e(P.prototype,v,{configurable:!0,writable:!0,value:function(){return s(n(this))}})}return v});var l,c=typeof Object.create=="function"?Object.create:function(v){function N(){}return N.prototype=v,new N};if(typeof Object.setPrototypeOf=="function")l=Object.setPrototypeOf;else{var u;e:{var p={};try{p.__proto__={a:!0},u=p.a;break e}catch(v){}u=!1}l=u?function(v,N){if(v.__proto__=N,v.__proto__!==N)throw new TypeError(v+" is not extensible");return v}:null}var f=l;function d(v,N){if(v.prototype=c(N.prototype),v.prototype.constructor=v,f)f(v,N);else for(var M in N)if(M!="prototype")if(Object.defineProperties){var P=Object.getOwnPropertyDescriptor(N,M);P&&Object.defineProperty(v,M,P)}else v[M]=N[M];v.na=N.prototype}function h(){this.l=!1,this.i=null,this.h=void 0,this.g=1,this.u=this.o=0,this.j=null}function g(v){if(v.l)throw new TypeError("Generator is already running");v.l=!0}function m(v,N){v.j={da:N,ea:!0},v.g=v.o||v.u}function y(v,N,M){return v.g=M,{value:N}}function x(v){this.g=new h,this.h=v}function C(v,N,M,P){try{var W=N.call(v.g.i,M);if(!(W instanceof Object))throw new TypeError("Iterator result "+W+" is not an object");if(!W.done)return v.g.l=!1,W;var H=W.value}catch(K){return v.g.i=null,m(v.g,K),I(v)}return v.g.i=null,P.call(v.g,H),I(v)}function I(v){for(;v.g.g;)try{var N=v.h(v.g);if(N)return v.g.l=!1,{value:N.value,done:!1}}catch(M){v.g.h=void 0,m(v.g,M)}if(v.g.l=!1,v.g.j){if(N=v.g.j,v.g.j=null,N.ea)throw N.da;return{value:N.return,done:!0}}return{value:void 0,done:!0}}function D(v){this.next=function(N){return g(v.g),v.g.i?N=C(v,v.g.i.next,N,v.g.s):(v.g.s(N),N=I(v)),N},this.throw=function(N){return g(v.g),v.g.i?N=C(v,v.g.i.throw,N,v.g.s):(m(v.g,N),N=I(v)),N},this.return=function(N){return(function(M,P){g(M.g);var W=M.g.i;return W?C(M,"return"in W?W.return:function(H){return{value:H,done:!0}},P,M.g.return):(M.g.return(P),I(M))})(v,N)},this[Symbol.iterator]=function(){return this}}function O(v){return(function(N){function M(W){return N.next(W)}function P(W){return N.throw(W)}return new Promise(function(W,H){(function K(ne){ne.done?W(ne.value):Promise.resolve(ne.value).then(M,P).then(K,H)})(N.next())})})(new D(new x(v)))}h.prototype.s=function(v){this.h=v},h.prototype.return=function(v){this.j={return:v},this.g=this.u},o("Promise",function(v){function N(K){this.h=0,this.i=void 0,this.g=[],this.s=!1;var ne=this.j();try{K(ne.resolve,ne.reject)}catch(ue){ne.reject(ue)}}function M(){this.g=null}function P(K){return K instanceof N?K:new N(function(ne){ne(K)})}if(v)return v;M.prototype.h=function(K){if(this.g==null){this.g=[];var ne=this;this.i(function(){ne.l()})}this.g.push(K)};var W=r.setTimeout;M.prototype.i=function(K){W(K,0)},M.prototype.l=function(){for(;this.g&&this.g.length;){var K=this.g;this.g=[];for(var ne=0;ne<K.length;++ne){var ue=K[ne];K[ne]=null;try{ue()}catch(ge){this.j(ge)}}}this.g=null},M.prototype.j=function(K){this.i(function(){throw K})},N.prototype.j=function(){function K(ge){return function(Ce){ue||(ue=!0,ge.call(ne,Ce))}}var ne=this,ue=!1;return{resolve:K(this.D),reject:K(this.l)}},N.prototype.D=function(K){if(K===this)this.l(new TypeError("A Promise cannot resolve to itself"));else if(K instanceof N)this.H(K);else{e:switch(typeof K){case"object":var ne=K!=null;break e;case"function":ne=!0;break e;default:ne=!1}ne?this.A(K):this.o(K)}},N.prototype.A=function(K){var ne=void 0;try{ne=K.then}catch(ue){return void this.l(ue)}typeof ne=="function"?this.I(ne,K):this.o(K)},N.prototype.l=function(K){this.u(2,K)},N.prototype.o=function(K){this.u(1,K)},N.prototype.u=function(K,ne){if(this.h!=0)throw Error("Cannot settle("+K+", "+ne+"): Promise already settled in state"+this.h);this.h=K,this.i=ne,this.h===2&&this.G(),this.B()},N.prototype.G=function(){var K=this;W(function(){if(K.C()){var ne=r.console;ne!==void 0&&ne.error(K.i)}},1)},N.prototype.C=function(){if(this.s)return!1;var K=r.CustomEvent,ne=r.Event,ue=r.dispatchEvent;return ue===void 0||(typeof K=="function"?K=new K("unhandledrejection",{cancelable:!0}):typeof ne=="function"?K=new ne("unhandledrejection",{cancelable:!0}):(K=r.document.createEvent("CustomEvent")).initCustomEvent("unhandledrejection",!1,!0,K),K.promise=this,K.reason=this.i,ue(K))},N.prototype.B=function(){if(this.g!=null){for(var K=0;K<this.g.length;++K)H.h(this.g[K]);this.g=null}};var H=new M;return N.prototype.H=function(K){var ne=this.j();K.M(ne.resolve,ne.reject)},N.prototype.I=function(K,ne){var ue=this.j();try{K.call(ne,ue.resolve,ue.reject)}catch(ge){ue.reject(ge)}},N.prototype.then=function(K,ne){function ue(Me,Le){return typeof Me=="function"?function(ht){try{ge(Me(ht))}catch(Tt){Ce(Tt)}}:Le}var ge,Ce,_e=new N(function(Me,Le){ge=Me,Ce=Le});return this.M(ue(K,ge),ue(ne,Ce)),_e},N.prototype.catch=function(K){return this.then(void 0,K)},N.prototype.M=function(K,ne){function ue(){switch(ge.h){case 1:K(ge.i);break;case 2:ne(ge.i);break;default:throw Error("Unexpected state: "+ge.h)}}var ge=this;this.g==null?H.h(ue):this.g.push(ue),this.s=!0},N.resolve=P,N.reject=function(K){return new N(function(ne,ue){ue(K)})},N.race=function(K){return new N(function(ne,ue){for(var ge=i(K),Ce=ge.next();!Ce.done;Ce=ge.next())P(Ce.value).M(ne,ue)})},N.all=function(K){var ne=i(K),ue=ne.next();return ue.done?P([]):new N(function(ge,Ce){function _e(ht){return function(Tt){Me[ht]=Tt,--Le==0&&ge(Me)}}var Me=[],Le=0;do Me.push(void 0),Le++,P(ue.value).M(_e(Me.length-1),Ce),ue=ne.next();while(!ue.done)})},N});var L=typeof Object.assign=="function"?Object.assign:function(v,N){for(var M=1;M<arguments.length;M++){var P=arguments[M];if(P)for(var W in P)Object.prototype.hasOwnProperty.call(P,W)&&(v[W]=P[W])}return v};o("Object.assign",function(v){return v||L}),o("Object.is",function(v){return v||function(N,M){return N===M?N!==0||1/N==1/M:N!=N&&M!=M}}),o("Array.prototype.includes",function(v){return v||function(N,M){var P=this;P instanceof String&&(P=String(P));var W=P.length;for(0>(M=M||0)&&(M=Math.max(M+W,0));M<W;M++){var H=P[M];if(H===N||Object.is(H,N))return!0}return!1}}),o("String.prototype.includes",function(v){return v||function(N,M){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(N instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(N,M||0)!==-1}}),o("Array.prototype.keys",function(v){return v||function(){return(function(N,M){N instanceof String&&(N+="");var P=0,W=!1,H={next:function(){if(!W&&P<N.length){var K=P++;return{value:M(K,N[K]),done:!1}}return W=!0,{done:!0,value:void 0}}};return H[Symbol.iterator]=function(){return H},H})(this,function(N){return N})}});var B=this||self;function V(v,N){v=v.split(".");var M,P=B;for((v[0]in P)||P.execScript===void 0||P.execScript("var "+v[0]);v.length&&(M=v.shift());)v.length||N===void 0?P=P[M]&&P[M]!==Object.prototype[M]?P[M]:P[M]={}:P[M]=N}function F(){throw Error("Invalid UTF8")}function G(v,N){return N=String.fromCharCode.apply(null,N),v==null?N:v+N}var ee,Q,oe=typeof TextDecoder<"u",ae=typeof TextEncoder<"u",J={},re=null;function se(v){var N;N===void 0&&(N=0),xe(),N=J[N];for(var M=Array(Math.floor(v.length/3)),P=N[64]||"",W=0,H=0;W<v.length-2;W+=3){var K=v[W],ne=v[W+1],ue=v[W+2],ge=N[K>>2];K=N[(3&K)<<4|ne>>4],ne=N[(15&ne)<<2|ue>>6],ue=N[63&ue],M[H++]=ge+K+ne+ue}switch(ge=0,ue=P,v.length-W){case 2:ue=N[(15&(ge=v[W+1]))<<2]||P;case 1:v=v[W],M[H]=N[v>>2]+N[(3&v)<<4|ge>>4]+ue+P}return M.join("")}function pe(v){var N=v.length,M=3*N/4;M%3?M=Math.floor(M):"=.".indexOf(v[N-1])!=-1&&(M="=.".indexOf(v[N-2])!=-1?M-2:M-1);var P=new Uint8Array(M),W=0;return(function(H,K){function ne(Le){for(;ue<H.length;){var ht=H.charAt(ue++),Tt=re[ht];if(Tt!=null)return Tt;if(!/^[\s\xa0]*$/.test(ht))throw Error("Unknown base64 encoding at char: "+ht)}return Le}xe();for(var ue=0;;){var ge=ne(-1),Ce=ne(0),_e=ne(64),Me=ne(64);if(Me===64&&ge===-1)break;K(ge<<2|Ce>>4),_e!=64&&(K(Ce<<4&240|_e>>2),Me!=64&&K(_e<<6&192|Me))}})(v,function(H){P[W++]=H}),W!==M?P.subarray(0,W):P}function xe(){if(!re){re={};for(var v="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),N=["+/=","+/","-_=","-_.","-_"],M=0;5>M;M++){var P=v.concat(N[M].split(""));J[M]=P;for(var W=0;W<P.length;W++){var H=P[W];re[H]===void 0&&(re[H]=W)}}}}var be,Te=typeof Uint8Array=="function";function Se(v){return Te&&v!=null&&v instanceof Uint8Array}function Re(v){if(this.L=v,v!==null&&v.length===0)throw Error("ByteString should be constructed with non-empty values")}var De=typeof Uint8Array.prototype.slice=="function",Oe=0;function We(v,N){return Error("Invalid wire type: "+v+" (at position "+N+")")}function et(){return Error("Failed to read varint, encoding is invalid.")}function je(v,N){N=(N=N===void 0?{}:N).v!==void 0&&N.v,this.h=null,this.g=this.i=this.j=0,this.v=N,v&&tt(this,v)}function tt(v,N){v.h=(function(M,P){if(M.constructor===Uint8Array)return M;if(M.constructor===ArrayBuffer)return new Uint8Array(M);if(M.constructor===Array)return new Uint8Array(M);if(M.constructor===String)return pe(M);if(M.constructor===Re)return!P&&(P=M.L)&&P.constructor===Uint8Array?P:(P=(P=M.L)==null||Se(P)?P:typeof P=="string"?pe(P):null,(M=M.L=P)?new Uint8Array(M):be||(be=new Uint8Array(0)));if(M instanceof Uint8Array)return new Uint8Array(M.buffer,M.byteOffset,M.byteLength);throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, or Array of numbers")})(N,v.v),v.j=0,v.i=v.h.length,v.g=v.j}function qe(v){if(v.g>v.i)throw Error("Tried to read past the end of the data "+v.g+" > "+v.i)}function Rt(v){var N=v.h,M=N[v.g],P=127&M;if(128>M)return v.g+=1,qe(v),P;if(P|=(127&(M=N[v.g+1]))<<7,128>M)return v.g+=2,qe(v),P;if(P|=(127&(M=N[v.g+2]))<<14,128>M)return v.g+=3,qe(v),P;if(P|=(127&(M=N[v.g+3]))<<21,128>M)return v.g+=4,qe(v),P;if(M=N[v.g+4],v.g+=5,P|=(15&M)<<28,128>M)return qe(v),P;if(128<=N[v.g++]&&128<=N[v.g++]&&128<=N[v.g++]&&128<=N[v.g++]&&128<=N[v.g++])throw et();return qe(v),P}je.prototype.reset=function(){this.g=this.j};var Bt=[];function pn(){this.g=[]}function Nt(v,N){for(;127<N;)v.g.push(127&N|128),N>>>=7;v.g.push(N)}function St(v){var N={},M=N.W!==void 0&&N.W;this.l={v:N.v!==void 0&&N.v},this.W=M,N=this.l,Bt.length?(M=Bt.pop(),N&&(M.v=N.v),v&&tt(M,v),v=M):v=new je(v,N),this.g=v,this.j=this.g.g,this.h=this.i=-1}function Ht(v){var N=v.g;if(N.g==N.i)return!1;v.j=v.g.g;var M=Rt(v.g)>>>0;if(N=M>>>3,!(0<=(M&=7)&&5>=M))throw We(M,v.j);if(1>N)throw Error("Invalid field number: "+N+" (at position "+v.j+")");return v.i=N,v.h=M,!0}function Dt(v){switch(v.h){case 0:if(v.h!=0)Dt(v);else e:{for(var N=(v=v.g).g,M=N+10;N<M;)if((128&v.h[N++])==0){v.g=N,qe(v);break e}throw et()}break;case 1:(v=v.g).g+=8,qe(v);break;case 2:v.h!=2?Dt(v):(N=Rt(v.g)>>>0,(v=v.g).g+=N,qe(v));break;case 5:(v=v.g).g+=4,qe(v);break;case 3:for(N=v.i;;){if(!Ht(v))throw Error("Unmatched start-group tag: stream EOF");if(v.h==4){if(v.i!=N)throw Error("Unmatched end-group tag");break}Dt(v)}break;default:throw We(v.h,v.j)}}pn.prototype.length=function(){return this.g.length},pn.prototype.end=function(){var v=this.g;return this.g=[],v},St.prototype.reset=function(){this.g.reset(),this.j=this.g.g,this.h=this.i=-1};var or=[];function $n(){this.i=[],this.h=0,this.g=new pn}function yn(v,N){N.length!==0&&(v.i.push(N),v.h+=N.length)}var sr=typeof Symbol=="function"&&typeof Symbol()=="symbol"?Symbol(void 0):void 0;function cs(v,N){Object.isFrozen(v)||(sr?v[sr]|=N:v.N!==void 0?v.N|=N:Object.defineProperties(v,{N:{value:N,configurable:!0,writable:!0,enumerable:!1}}))}function jr(v){var N;return(N=sr?v[sr]:v.N)==null?0:N}function br(v){return cs(v,1),v}function ir(v){return!!Array.isArray(v)&&!!(2&jr(v))}function oo(v){if(!Array.isArray(v))throw Error("cannot mark non-array as immutable");cs(v,2)}function Hn(v){return v!==null&&typeof v=="object"&&!Array.isArray(v)&&v.constructor===Object}var us=Object.freeze(br([]));function ga(v){if(ir(v.m))throw Error("Cannot mutate an immutable Message")}var ya,Vf=typeof Symbol<"u"&&Symbol.hasInstance!==void 0;function xa(v){return{value:v,configurable:!1,writable:!1,enumerable:!1}}function wr(v,N,M){return N===-1?null:N>=v.i?v.g?v.g[N]:void 0:M!==void 0&&M&&v.g&&(M=v.g[N])!=null?M:v.m[N+v.h]}function Un(v,N,M,P){P=P!==void 0&&P,ga(v),N<v.i&&!P?v.m[N+v.h]=M:(v.g||(v.g=v.m[v.i+v.h]={}))[N]=M}function ar(v,N,M,P){M=M===void 0||M;var W=wr(v,N,P=P!==void 0&&P);return W==null&&(W=us),ir(v.m)?M&&(oo(W),Object.freeze(W)):(W===us||ir(W))&&Un(v,N,W=br(W.slice()),P),W}function Co(v,N,M){return(v=(v=wr(v,N))==null?v:+v)==null?M===void 0?0:M:v}function Wu(v,N,M,P){v.j||(v.j={});var W=ir(v.m),H=v.j[M];if(!H){P=ar(v,M,!0,P!==void 0&&P),H=[],W=W||ir(P);for(var K=0;K<P.length;K++)H[K]=new N(P[K]),W&&oo(H[K].m);W&&(oo(H),Object.freeze(H)),v.j[M]=H}return H}function In(v,N,M,P,W){var H=H!==void 0&&H;return ga(v),H=Wu(v,M,N,H),M=P||new M,v=ar(v,N),W!=null?(H.splice(W,0,M),v.splice(W,0,M.m)):(H.push(M),v.push(M.m)),M}function qu(v,N){return(v=wr(v,N))==null?0:v}function Lg(v,N){return(v=wr(v,N))==null?"":v}function _i(v){var N=Ex;return Mt(v,N=N===void 0?Uf:N)}function ps(v,N){if(v!=null){if(Array.isArray(v))v=Mt(v,N);else if(Hn(v)){var M,P={};for(M in v)P[M]=ps(v[M],N);v=P}else v=N(v);return v}}function Mt(v,N){for(var M=v.slice(),P=0;P<M.length;P++)M[P]=ps(M[P],N);return Array.isArray(v)&&1&jr(v)&&br(M),M}function Ex(v){return v&&typeof v=="object"&&v.toJSON?v.toJSON():(v=(function(N){switch(typeof N){case"number":return isFinite(N)?N:String(N);case"object":if(N&&!Array.isArray(N)){if(Se(N))return se(N);if(N instanceof Re){var M=N.L;return M=M==null||typeof M=="string"?M:Te&&M instanceof Uint8Array?se(M):null,(N.L=M)||""}}}return N})(v),Array.isArray(v)?_i(v):v)}function Uf(v){return Se(v)?new Uint8Array(v):v}function Ku(v,N,M){v||(v=ya),ya=null;var P=this.constructor.h;if(v||(v=P?[P]:[]),this.h=(P?0:-1)-(this.constructor.g||0),this.j=void 0,this.m=v,v=(P=this.m.length)-1,P&&Hn(P=this.m[v])?(this.i=v-this.h,this.g=P):N!==void 0&&-1<N?(this.i=Math.max(N,v+1-this.h),this.g=void 0):this.i=Number.MAX_VALUE,M)for(N=0;N<M.length;N++)if((v=M[N])<this.i)v+=this.h,(P=this.m[v])?Array.isArray(P)&&br(P):this.m[v]=us;else{var W=(P=this.g||(this.g=this.m[this.i+this.h]={}))[v];W?Array.isArray(W)&&br(W):P[v]=us}}function Xu(){Ku.apply(this,arguments)}if(Ku.prototype.toJSON=function(){return _i(this.m)},Ku.prototype.toString=function(){return this.m.toString()},d(Xu,Ku),Vf){var Ri={};Object.defineProperties(Xu,(Ri[Symbol.hasInstance]=xa(function(){throw Error("Cannot perform instanceof checks for MutableMessage")}),Ri))}function Gf(v,N,M){if(M){var P,W={};for(P in M){var H=M[P],K=H.ha;K||(W.F=H.la||H.fa.P,H.aa?(W.U=Dx(H.aa),K=(function(ne){return function(ue,ge,Ce){return ne.F(ue,ge,Ce,ne.U)}})(W)):H.ca?(W.T=jf(H.X.g,H.ca),K=(function(ne){return function(ue,ge,Ce){return ne.F(ue,ge,Ce,ne.T)}})(W)):K=W.F,H.ha=K),K(N,v,H.X),W={F:W.F,U:W.U,T:W.T}}}(function(ne,ue){if(ue=ue.ba){yn(ne,ne.g.end());for(var ge=0;ge<ue.length;ge++)yn(ne,ue[ge])}})(N,v)}var fs=Symbol();function Mi(v,N,M){return v[fs]||(v[fs]=function(P,W){return N(P,W,M)})}function Nx(v){var N=v[fs];if(!N){var M=Mx(v);N=function(P,W){return Pg(P,W,M)},v[fs]=N}return N}function dI(v){var N=(function(W){var H=W.aa;return H?Nx(H):(H=W.ka)?Mi(W.X.g,H,W.ca):void 0})(v),M=v.X,P=v.fa.O;return N?function(W,H){return P(W,H,M,N)}:function(W,H){return P(W,H,M)}}function Ar(v,N,M,P,W,H){var K=0;for((v=v()).length&&typeof v[0]!="number"&&(M(N,v[0]),K++);K<v.length;){M=v[K++];for(var ne=K+1;ne<v.length&&typeof v[ne]!="number";)ne++;var ue=v[K++];switch(ne-=K){case 0:P(N,M,ue);break;case 1:P(N,M,ue,v[K++]);break;case 2:W(N,M,ue,v[K++],v[K++]);break;case 3:ne=v[K++];var ge=v[K++],Ce=v[K++];Array.isArray(Ce)?W(N,M,ue,ne,ge,Ce):H(N,M,ue,ne,ge,Ce);break;case 4:H(N,M,ue,v[K++],v[K++],v[K++],v[K++]);break;default:throw Error("unexpected number of binary field arguments: "+ne)}}return N}var Oi=Symbol();function Dx(v){var N=v[Oi];if(!N){var M=Rx(v);N=function(P,W){return zg(P,W,M)},v[Oi]=N}return N}function jf(v,N){var M=v[Oi];return M||(M=function(P,W){return Gf(P,W,N)},v[Oi]=M),M}var kx=Symbol();function Jl(v,N){v.push(N)}function hI(v,N,M){v.push(N,M.P)}function Ax(v,N,M,P,W){var H=Dx(W),K=M.P;v.push(N,function(ne,ue,ge){return K(ne,ue,ge,P,H)})}function _x(v,N,M,P,W,H){var K=jf(P,H),ne=M.P;v.push(N,function(ue,ge,Ce){return ne(ue,ge,Ce,P,K)})}function Rx(v){var N=v[kx];return N||Ar(v,v[kx]=[],Jl,hI,Ax,_x)}var Hf=Symbol();function va(v,N){v[0]=N}function mI(v,N,M,P){var W=M.O;v[N]=P?function(H,K,ne){return W(H,K,ne,P)}:W}function gI(v,N,M,P,W,H){var K=M.O,ne=Nx(W);v[N]=function(ue,ge,Ce){return K(ue,ge,Ce,P,ne,H)}}function Wf(v,N,M,P,W,H,K){var ne=M.O,ue=Mi(P,W,H);v[N]=function(ge,Ce,_e){return ne(ge,Ce,_e,P,ue,K)}}function Mx(v){var N=v[Hf];return N||Ar(v,v[Hf]={},va,mI,gI,Wf)}function Pg(v,N,M){for(;Ht(N)&&N.h!=4;){var P=N.i,W=M[P];if(!W){var H=M[0];H&&(H=H[P])&&(W=M[P]=dI(H))}if(!(W&&W(N,v,P)||(W=N,P=v,H=W.j,Dt(W),W.W))){var K=W.g.h;W=H===(W=W.g.g)?be||(be=new Uint8Array(0)):De?K.slice(H,W):new Uint8Array(K.subarray(H,W)),(H=P.ba)?H.push(W):P.ba=[W]}}return v}function Bg(v,N,M){if(or.length){var P=or.pop();v&&(tt(P.g,v),P.i=-1,P.h=-1),v=P}else v=new St(v);try{return Pg(new N,v,Mx(M))}finally{(N=v.g).h=null,N.j=0,N.i=0,N.g=0,N.v=!1,v.i=-1,v.h=-1,100>or.length&&or.push(v)}}function zg(v,N,M){for(var P=M.length,W=P%2==1,H=W?1:0;H<P;H+=2)(0,M[H+1])(N,v,M[H]);Gf(v,N,W?M[0]:void 0)}function Yu(v,N){var M=new $n;zg(v,M,Rx(N)),yn(M,M.g.end()),v=new Uint8Array(M.h);for(var P=(N=M.i).length,W=0,H=0;H<P;H++){var K=N[H];v.set(K,W),W+=K.length}return M.i=[v],v}function ec(v,N){return{O:v,P:N}}var ds=ec(function(v,N,M){if(v.h!==5)return!1;var P=(v=v.g).h[v.g],W=v.h[v.g+1],H=v.h[v.g+2],K=v.h[v.g+3];return v.g+=4,qe(v),v=2*((W=(P<<0|W<<8|H<<16|K<<24)>>>0)>>31)+1,P=W>>>23&255,W&=8388607,Un(N,M,P==255?W?NaN:1/0*v:P==0?v*Math.pow(2,-149)*W:v*Math.pow(2,P-150)*(W+Math.pow(2,23))),!0},function(v,N,M){if((N=wr(N,M))!=null){Nt(v.g,8*M+5),v=v.g;var P=N;(P=(M=0>P?1:0)?-P:P)===0?0<1/P?Oe=0:Oe=2147483648:isNaN(P)?Oe=2147483647:34028234663852886e22<P?Oe=(M<<31|2139095040)>>>0:11754943508222875e-54>P?(P=Math.round(P/Math.pow(2,-149)),Oe=(M<<31|P)>>>0):(N=Math.floor(Math.log(P)/Math.LN2),P*=Math.pow(2,-N),16777216<=(P=Math.round(8388608*P))&&++N,Oe=(M<<31|N+127<<23|8388607&P)>>>0),M=Oe,v.g.push(M>>>0&255),v.g.push(M>>>8&255),v.g.push(M>>>16&255),v.g.push(M>>>24&255)}}),yI=ec(function(v,N,M){if(v.h!==0)return!1;for(var P=v.g,W=128,H=0,K=v=0;4>K&&128<=W;K++)W=P.h[P.g++],qe(P),H|=(127&W)<<7*K;if(128<=W&&(W=P.h[P.g++],qe(P),H|=(127&W)<<28,v|=(127&W)>>4),128<=W)for(K=0;5>K&&128<=W;K++)W=P.h[P.g++],qe(P),v|=(127&W)<<7*K+3;if(!(128>W))throw et();return P=H>>>0,(v=2147483648&(W=v>>>0))&&(W=~W>>>0,(P=1+~P>>>0)==0&&(W=W+1>>>0)),P=4294967296*W+(P>>>0),Un(N,M,v?-P:P),!0},function(v,N,M){if((N=wr(N,M))!=null&&N!=null){Nt(v.g,8*M),v=v.g;var P=N;for(M=0>P,N=(P=Math.abs(P))>>>0,P=Math.floor((P-N)/4294967296),P>>>=0,M&&(P=~P>>>0,4294967295<(N=1+(~N>>>0))&&(N=0,4294967295<++P&&(P=0))),M=Oe=N,N=P;0<N||127<M;)v.g.push(127&M|128),M=(M>>>7|N<<25)>>>0,N>>>=7;v.g.push(M)}}),xI=ec(function(v,N,M){return v.h===0&&(Un(N,M,Rt(v.g)),!0)},function(v,N,M){if((N=wr(N,M))!=null&&N!=null)if(Nt(v.g,8*M),v=v.g,0<=(M=N))Nt(v,M);else{for(N=0;9>N;N++)v.g.push(127&M|128),M>>=7;v.g.push(1)}}),Ox=ec(function(v,N,M){if(v.h!==2)return!1;var P,W=Rt(v.g)>>>0,H=(v=v.g).g;if(v.g+=W,qe(v),v=v.h,oe)(P=ee)||(P=ee=new TextDecoder("utf-8",{fatal:!0})),P=P.decode(v.subarray(H,H+W));else{W=H+W;for(var K,ne,ue,ge=[],Ce=null;H<W;)128>(K=v[H++])?ge.push(K):224>K?H>=W?F():(ne=v[H++],194>K||(192&ne)!=128?(H--,F()):ge.push((31&K)<<6|63&ne)):240>K?H>=W-1?F():(192&(ne=v[H++]))!=128||K===224&&160>ne||K===237&&160<=ne||(192&(P=v[H++]))!=128?(H--,F()):ge.push((15&K)<<12|(63&ne)<<6|63&P):244>=K?H>=W-2?F():(192&(ne=v[H++]))!=128||ne-144+(K<<28)>>30!=0||(192&(P=v[H++]))!=128||(192&(ue=v[H++]))!=128?(H--,F()):(K=(7&K)<<18|(63&ne)<<12|(63&P)<<6|63&ue,K-=65536,ge.push(55296+(K>>10&1023),56320+(1023&K))):F(),8192<=ge.length&&(Ce=G(Ce,ge),ge.length=0);P=G(Ce,ge)}return Un(N,M,P),!0},function(v,N,M){if((N=wr(N,M))!=null){var P=!1;if(P=P!==void 0&&P,ae){if(P&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(N))throw Error("Found an unpaired surrogate");N=(Q||(Q=new TextEncoder)).encode(N)}else{for(var W=0,H=new Uint8Array(3*N.length),K=0;K<N.length;K++){var ne=N.charCodeAt(K);if(128>ne)H[W++]=ne;else{if(2048>ne)H[W++]=ne>>6|192;else{if(55296<=ne&&57343>=ne){if(56319>=ne&&K<N.length){var ue=N.charCodeAt(++K);if(56320<=ue&&57343>=ue){ne=1024*(ne-55296)+ue-56320+65536,H[W++]=ne>>18|240,H[W++]=ne>>12&63|128,H[W++]=ne>>6&63|128,H[W++]=63&ne|128;continue}K--}if(P)throw Error("Found an unpaired surrogate");ne=65533}H[W++]=ne>>12|224,H[W++]=ne>>6&63|128}H[W++]=63&ne|128}}N=H.subarray(0,W)}Nt(v.g,8*M+2),Nt(v.g,N.length),yn(v,v.g.end()),yn(v,N)}}),Vg=ec(function(v,N,M,P,W){if(v.h!==2)return!1;N=In(N,M,P),M=v.g.i,P=Rt(v.g)>>>0;var H=v.g.g+P,K=H-M;if(0>=K&&(v.g.i=H,W(N,v),K=H-v.g.g),K)throw Error("Message parsing ended unexpectedly. Expected to read "+P+" bytes, instead read "+(P-K)+" bytes, either the data ended unexpectedly or the message misreported its own length");return v.g.g=H,v.g.i=M,!0},function(v,N,M,P,W){if((N=Wu(N,P,M))!=null)for(P=0;P<N.length;P++){var H=v;Nt(H.g,8*M+2);var K=H.g.end();yn(H,K),K.push(H.h),H=K,W(N[P],v),K=v;var ne=H.pop();for(ne=K.h+K.g.length()-ne;127<ne;)H.push(127&ne|128),ne>>>=7,K.h++;H.push(ne),K.h++}});function Vo(){Xu.apply(this,arguments)}if(d(Vo,Xu),Vf){var Fx={};Object.defineProperties(Vo,(Fx[Symbol.hasInstance]=xa(Object[Symbol.hasInstance]),Fx))}function ba(v){Vo.call(this,v)}function $x(){return[1,xI,2,ds,3,Ox,4,Ox]}function Ug(v){Vo.call(this,v,-1,bI)}function vI(){return[1,Vg,ba,$x]}d(ba,Vo),d(Ug,Vo),Ug.prototype.addClassification=function(v,N){return In(this,1,ba,v,N),this};var bI=[1];function tc(v){Vo.call(this,v)}function Lx(){return[1,ds,2,ds,3,ds,4,ds,5,ds]}function Px(v){Vo.call(this,v,-1,CI)}function wI(){return[1,Vg,tc,Lx]}d(tc,Vo),d(Px,Vo);var CI=[1];function Gg(v){Vo.call(this,v)}function jg(){return[1,ds,2,ds,3,ds,4,ds,5,ds,6,yI]}d(Gg,Vo);var Hg=[[61,146],[146,91],[91,181],[181,84],[84,17],[17,314],[314,405],[405,321],[321,375],[375,291],[61,185],[185,40],[40,39],[39,37],[37,0],[0,267],[267,269],[269,270],[270,409],[409,291],[78,95],[95,88],[88,178],[178,87],[87,14],[14,317],[317,402],[402,318],[318,324],[324,308],[78,191],[191,80],[80,81],[81,82],[82,13],[13,312],[312,311],[311,310],[310,415],[415,308]],Wg=[[263,249],[249,390],[390,373],[373,374],[374,380],[380,381],[381,382],[382,362],[263,466],[466,388],[388,387],[387,386],[386,385],[385,384],[384,398],[398,362]],qg=[[276,283],[283,282],[282,295],[295,285],[300,293],[293,334],[334,296],[296,336]],Kg=[[33,7],[7,163],[163,144],[144,145],[145,153],[153,154],[154,155],[155,133],[33,246],[246,161],[161,160],[160,159],[159,158],[158,157],[157,173],[173,133]],Xg=[[46,53],[53,52],[52,65],[65,55],[70,63],[63,105],[105,66],[66,107]],Bx=[[10,338],[338,297],[297,332],[332,284],[284,251],[251,389],[389,356],[356,454],[454,323],[323,361],[361,288],[288,397],[397,365],[365,379],[379,378],[378,400],[400,377],[377,152],[152,148],[148,176],[176,149],[149,150],[150,136],[136,172],[172,58],[58,132],[132,93],[93,234],[234,127],[127,162],[162,21],[21,54],[54,103],[103,67],[67,109],[109,10]],zx=[].concat(a(Hg),a(Wg),a(qg),a(Kg),a(Xg),a(Bx));function w(v,N,M){if(M=v.createShader(M===0?v.VERTEX_SHADER:v.FRAGMENT_SHADER),v.shaderSource(M,N),v.compileShader(M),!v.getShaderParameter(M,v.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+v.getShaderInfoLog(M));return M}function E(v){return Wu(v,ba,1).map(function(N){return{index:qu(N,1),ga:Co(N,2),label:wr(N,3)!=null?Lg(N,3):void 0,displayName:wr(N,4)!=null?Lg(N,4):void 0}})}function k(v){return{x:Co(v,1),y:Co(v,2),z:Co(v,3),visibility:wr(v,4)!=null?Co(v,4):void 0}}function q(v,N){this.h=v,this.g=N,this.l=0}function ie(v,N,M){return(function(P,W){var H=P.g;if(P.o===void 0){var K=w(H,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),ne=w(H,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),ue=H.createProgram();if(H.attachShader(ue,K),H.attachShader(ue,ne),H.linkProgram(ue),!H.getProgramParameter(ue,H.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+H.getProgramInfoLog(ue));K=P.o=ue,H.useProgram(K),ne=H.getUniformLocation(K,"sampler0"),P.j={K:H.getAttribLocation(K,"aVertex"),J:H.getAttribLocation(K,"aTex"),ma:ne},P.u=H.createBuffer(),H.bindBuffer(H.ARRAY_BUFFER,P.u),H.enableVertexAttribArray(P.j.K),H.vertexAttribPointer(P.j.K,2,H.FLOAT,!1,0,0),H.bufferData(H.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),H.STATIC_DRAW),H.bindBuffer(H.ARRAY_BUFFER,null),P.s=H.createBuffer(),H.bindBuffer(H.ARRAY_BUFFER,P.s),H.enableVertexAttribArray(P.j.J),H.vertexAttribPointer(P.j.J,2,H.FLOAT,!1,0,0),H.bufferData(H.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),H.STATIC_DRAW),H.bindBuffer(H.ARRAY_BUFFER,null),H.uniform1i(ne,0)}K=P.j,H.useProgram(P.o),H.canvas.width=W.width,H.canvas.height=W.height,H.viewport(0,0,W.width,W.height),H.activeTexture(H.TEXTURE0),P.h.bindTexture2d(W.glName),H.enableVertexAttribArray(K.K),H.bindBuffer(H.ARRAY_BUFFER,P.u),H.vertexAttribPointer(K.K,2,H.FLOAT,!1,0,0),H.enableVertexAttribArray(K.J),H.bindBuffer(H.ARRAY_BUFFER,P.s),H.vertexAttribPointer(K.J,2,H.FLOAT,!1,0,0),H.bindFramebuffer(H.DRAW_FRAMEBUFFER?H.DRAW_FRAMEBUFFER:H.FRAMEBUFFER,null),H.clearColor(0,0,0,0),H.clear(H.COLOR_BUFFER_BIT),H.colorMask(!0,!0,!0,!0),H.drawArrays(H.TRIANGLE_FAN,0,4),H.disableVertexAttribArray(K.K),H.disableVertexAttribArray(K.J),H.bindBuffer(H.ARRAY_BUFFER,null),P.h.bindTexture2d(0)})(v,N),typeof v.g.canvas.transferToImageBitmap=="function"?Promise.resolve(v.g.canvas.transferToImageBitmap()):M?Promise.resolve(v.g.canvas):typeof createImageBitmap=="function"?createImageBitmap(v.g.canvas):(v.i===void 0&&(v.i=document.createElement("canvas")),new Promise(function(P){v.i.height=v.g.canvas.height,v.i.width=v.g.canvas.width,v.i.getContext("2d",{}).drawImage(v.g.canvas,0,0,v.g.canvas.width,v.g.canvas.height),P(v.i)}))}function me(v){this.g=v}var ce=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function ye(v,N){return N+v}function ke(v,N){window[v]=N}function Pe(v){if(this.g=v,this.listeners={},this.j={},this.H={},this.o={},this.u={},this.I=this.s=this.Z=!0,this.D=Promise.resolve(),this.Y="",this.C={},this.locateFile=v&&v.locateFile||ye,typeof window=="object")var N=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else{if(typeof location>"u")throw Error("solutions can only be loaded on a web page or in a web worker");N=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/"}if(this.$=N,v.options)for(var M=(N=i(Object.keys(v.options))).next();!M.done;M=N.next()){M=M.value;var P=v.options[M].default;P!==void 0&&(this.j[M]=typeof P=="function"?P():P)}}function dt(v){var N,M,P,W,H,K,ne,ue,ge,Ce,_e;return O(function(Me){switch(Me.g){case 1:return v.Z?(N=v.g.files===void 0?[]:typeof v.g.files=="function"?v.g.files(v.j):v.g.files,y(Me,O(function(Le){switch(Le.g){case 1:return Le.o=2,y(Le,WebAssembly.instantiate(ce),4);case 4:Le.g=3,Le.o=0;break;case 2:return Le.o=0,Le.j=null,Le.return(!1);case 3:return Le.return(!0)}}),2)):Me.return();case 2:if(M=Me.h,typeof window=="object")return ke("createMediapipeSolutionsWasm",{locateFile:v.locateFile}),ke("createMediapipeSolutionsPackedAssets",{locateFile:v.locateFile}),K=N.filter(function(Le){return Le.data!==void 0}),ne=N.filter(function(Le){return Le.data===void 0}),ue=Promise.all(K.map(function(Le){var ht=zt(v,Le.url);if(Le.path!==void 0){var Tt=Le.path;ht=ht.then(function(xn){return v.overrideFile(Tt,xn),Promise.resolve(xn)})}return ht})),ge=Promise.all(ne.map(function(Le){return Le.simd===void 0||Le.simd&&M||!Le.simd&&!M?(function(ht){var Tt=document.createElement("script");return Tt.setAttribute("src",ht),Tt.setAttribute("crossorigin","anonymous"),new Promise(function(xn){Tt.addEventListener("load",function(){xn()},!1),Tt.addEventListener("error",function(){xn()},!1),document.body.appendChild(Tt)})})(v.locateFile(Le.url,v.$)):Promise.resolve()})).then(function(){var Le,ht,Tt;return O(function(xn){if(xn.g==1)return Le=window.createMediapipeSolutionsWasm,ht=window.createMediapipeSolutionsPackedAssets,Tt=v,y(xn,Le(ht),2);Tt.h=xn.h,xn.g=0})}),Ce=O(function(Le){return v.g.graph&&v.g.graph.url?Le=y(Le,zt(v,v.g.graph.url),0):(Le.g=0,Le=void 0),Le}),y(Me,Promise.all([ge,ue,Ce]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return P=N.filter(function(Le){return Le.simd===void 0||Le.simd&&M||!Le.simd&&!M}).map(function(Le){return v.locateFile(Le.url,v.$)}),importScripts.apply(null,a(P)),W=v,y(Me,createMediapipeSolutionsWasm(Module),6);case 6:W.h=Me.h,v.l=new OffscreenCanvas(1,1),v.h.canvas=v.l,H=v.h.GL.createContext(v.l,{antialias:!1,alpha:!1,ja:typeof WebGL2RenderingContext<"u"?2:1}),v.h.GL.makeContextCurrent(H),Me.g=4;break;case 7:if(v.l=document.createElement("canvas"),!(_e=v.l.getContext("webgl2",{}))&&!(_e=v.l.getContext("webgl",{})))return alert("Failed to create WebGL canvas context when passing video frame."),Me.return();v.G=_e,v.h.canvas=v.l,v.h.createContext(v.l,!0,!0,{});case 4:v.i=new v.h.SolutionWasm,v.Z=!1,Me.g=0}})}function zt(v,N){var M,P;return O(function(W){return N in v.H?W.return(v.H[N]):(M=v.locateFile(N,""),P=fetch(M).then(function(H){return H.arrayBuffer()}),v.H[N]=P,W.return(P))})}function kt(v,N,M){var P,W,H,K,ne,ue,ge,Ce,_e,Me,Le,ht,Tt,xn;return O(function(Rn){switch(Rn.g){case 1:if(!M)return Rn.return(N);for(P={},W=0,H=i(Object.keys(M)),K=H.next();!K.done;K=H.next())ne=K.value,typeof(ue=M[ne])!="string"&&ue.type==="texture"&&N[ue.stream]!==void 0&&++W;1<W&&(v.I=!1),ge=i(Object.keys(M)),K=ge.next();case 2:if(K.done){Rn.g=4;break}if(Ce=K.value,typeof(_e=M[Ce])=="string")return Tt=P,xn=Ce,y(Rn,(function(Zu,Xk,qf){var Vx;return O(function(II){return typeof qf=="number"||qf instanceof Uint8Array||qf instanceof Zu.h.Uint8BlobList?II.return(qf):qf instanceof Zu.h.Texture2dDataOut?((Vx=Zu.u[Xk])||(Vx=new q(Zu.h,Zu.G),Zu.u[Xk]=Vx),II.return(ie(Vx,qf,Zu.I))):II.return(void 0)})})(v,Ce,N[_e]),14);if(Me=N[_e.stream],_e.type==="detection_list"){if(Me){for(var Io=Me.getRectList(),Ns=Me.getLandmarksList(),Uo=Me.getClassificationsList(),en=[],Hr=0;Hr<Io.size();++Hr){var nc=Bg(Io.get(Hr),Gg,jg);nc={boundingBox:{xCenter:Co(nc,1),yCenter:Co(nc,2),height:Co(nc,3),width:Co(nc,4),rotation:Co(nc,5,0),rectId:qu(nc,6)},landmarks:Wu(Bg(Ns.get(Hr),Px,wI),tc,1).map(k),V:E(Bg(Uo.get(Hr),Ug,vI))},en.push(nc)}Io=en}else Io=[];P[Ce]=Io,Rn.g=7;break}if(_e.type==="proto_list"){if(Me){for(Io=Array(Me.size()),Ns=0;Ns<Me.size();Ns++)Io[Ns]=Me.get(Ns);Me.delete()}else Io=[];P[Ce]=Io,Rn.g=7;break}if(Me===void 0){Rn.g=3;break}if(_e.type==="float_list"){P[Ce]=Me,Rn.g=7;break}if(_e.type==="proto"){P[Ce]=Me,Rn.g=7;break}if(_e.type!=="texture")throw Error("Unknown output config type: '"+_e.type+"'");return(Le=v.u[Ce])||(Le=new q(v.h,v.G),v.u[Ce]=Le),y(Rn,ie(Le,Me,v.I),13);case 13:ht=Rn.h,P[Ce]=ht;case 7:_e.transform&&P[Ce]&&(P[Ce]=_e.transform(P[Ce])),Rn.g=3;break;case 14:Tt[xn]=Rn.h;case 3:K=ge.next(),Rn.g=2;break;case 4:return Rn.return(P)}})}function gt(v,N){for(var M=N.name||"$",P=[].concat(a(N.wants)),W=new v.h.StringList,H=i(N.wants),K=H.next();!K.done;K=H.next())W.push_back(K.value);H=v.h.PacketListener.implement({onResults:function(ne){for(var ue={},ge=0;ge<N.wants.length;++ge)ue[P[ge]]=ne.get(ge);var Ce=v.listeners[M];Ce&&(v.D=kt(v,ue,N.outs).then(function(_e){_e=Ce(_e);for(var Me=0;Me<N.wants.length;++Me){var Le=ue[P[Me]];typeof Le=="object"&&Le.hasOwnProperty&&Le.hasOwnProperty("delete")&&Le.delete()}_e&&(v.D=_e)}))}}),v.i.attachMultiListener(W,H),W.delete()}function Xe(v){var N=this;v=v||{};var M={url:"face_detection_short.binarypb"},P={type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"facedetectionshortrangegpu__facedetectionshortrangecommon__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}};this.g=new Pe({locateFile:v.locateFile,files:[{data:!0,url:"face_detection_short.binarypb"},{data:!0,url:"face_detection_short_range.tflite"},{simd:!0,url:"face_detection_solution_simd_wasm_bin.js"},{simd:!1,url:"face_detection_solution_wasm_bin.js"}],graph:M,listeners:[{wants:["detections","image_transformed"],outs:{image:"image_transformed",detections:{type:"detection_list",stream:"detections"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:typeof window=="object"&&window.navigator!==void 0&&("iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document)},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},model:{type:0,onChange:function(W){var H,K,ne,ue,ge;return O(function(Ce){switch(Ce.g){case 1:H=i(W==="short"?["face_detection_short_range.tflite"]:["face_detection_full_range_sparse.tflite"]),K=H.next();case 2:if(K.done){Ce.g=4;break}return ne=K.value,ue="third_party/mediapipe/modules/face_detection/"+ne,y(Ce,zt(N.g,ne),5);case 5:ge=Ce.h,N.g.overrideFile(ue,ge),K=H.next(),Ce.g=2;break;case 4:return M.url=W==="short"?"face_detection_short.binarypb":"face_detection_full.binarypb",P.graphOptionXref.calculatorName=W==="short"?"facedetectionshortrangegpu__facedetectionshortrangecommon__TensorsToDetectionsCalculator":"facedetectionfullrangegpu__facedetectionfullrangecommon__TensorsToDetectionsCalculator",Ce.return(!0)}})}},minDetectionConfidence:P}})}(t=Pe.prototype).close=function(){return this.i&&this.i.delete(),Promise.resolve()},t.reset=function(){var v=this;return O(function(N){v.i&&(v.i.reset(),v.o={},v.u={}),N.g=0})},t.setOptions=function(v,N){var M=this;if(N=N||this.g.options){for(var P=[],W=[],H={},K=i(Object.keys(v)),ne=K.next();!ne.done;H={R:H.R,S:H.S},ne=K.next()){var ue=ne.value;ue in this.j&&this.j[ue]===v[ue]||(this.j[ue]=v[ue],(ne=N[ue])!==void 0&&(ne.onChange&&(H.R=ne.onChange,H.S=v[ue],P.push((function(ge){return function(){return O(function(Ce){if(Ce.g==1)return y(Ce,ge.R(ge.S),2);Ce.h===!0&&(M.s=!0),Ce.g=0})}})(H))),ne.graphOptionXref&&(ue={valueNumber:ne.type===1?v[ue]:0,valueBoolean:ne.type===0&&v[ue],valueString:ne.type===2?v[ue]:""},ne=Object.assign(Object.assign(Object.assign({},{calculatorName:"",calculatorIndex:0}),ne.graphOptionXref),ue),W.push(ne))))}P.length===0&&W.length===0||(this.s=!0,this.B=(this.B===void 0?[]:this.B).concat(W),this.A=(this.A===void 0?[]:this.A).concat(P))}},t.initialize=function(){var v=this;return O(function(N){return N.g==1?y(N,dt(v),2):N.g!=3?y(N,(function(M){var P,W,H,K,ne,ue,ge,Ce;return O(function(_e){if(_e.g==1)return M.g.graph&&M.g.graph.url&&M.Y===M.g.graph.url?_e.return():(M.s=!0,M.g.graph&&M.g.graph.url?(M.Y=M.g.graph.url,y(_e,zt(M,M.g.graph.url),3)):void(_e.g=2));for(_e.g!=2&&(P=_e.h,M.i.loadGraph(P)),W=i(Object.keys(M.C)),H=W.next();!H.done;H=W.next())K=H.value,M.i.overrideFile(K,M.C[K]);if(M.C={},M.g.listeners)for(ne=i(M.g.listeners),ue=ne.next();!ue.done;ue=ne.next())ge=ue.value,gt(M,ge);Ce=M.j,M.j={},M.setOptions(Ce),_e.g=0})})(v),3):y(N,(function(M){var P,W,H,K,ne,ue;return O(function(ge){switch(ge.g){case 1:if(!M.s)return ge.return();if(!M.A){ge.g=2;break}P=i(M.A),W=P.next();case 3:if(W.done){ge.g=5;break}return y(ge,(0,W.value)(),4);case 4:W=P.next(),ge.g=3;break;case 5:M.A=void 0;case 2:if(M.B){for(H=new M.h.GraphOptionChangeRequestList,K=i(M.B),ne=K.next();!ne.done;ne=K.next())ue=ne.value,H.push_back(ue);M.i.changeOptions(H),H.delete(),M.B=void 0}M.s=!1,ge.g=0}})})(v),0)})},t.overrideFile=function(v,N){this.i?this.i.overrideFile(v,N):this.C[v]=N},t.clearOverriddenFiles=function(){this.C={},this.i&&this.i.clearOverriddenFiles()},t.send=function(v,N){var M,P,W,H,K,ne,ue,ge,Ce,_e=this;return O(function(Me){switch(Me.g){case 1:return _e.g.inputs?(M=1e3*(N??performance.now()),y(Me,_e.D,2)):Me.return();case 2:return y(Me,_e.initialize(),3);case 3:for(P=new _e.h.PacketDataList,W=i(Object.keys(v)),H=W.next();!H.done;H=W.next())if(K=H.value,ne=_e.g.inputs[K]){e:{var Le=v[K];switch(ne.type){case"video":var ht=_e.o[ne.stream];if(ht||(ht=new q(_e.h,_e.G),_e.o[ne.stream]=ht),ht.l===0&&(ht.l=ht.h.createTexture()),typeof HTMLVideoElement<"u"&&Le instanceof HTMLVideoElement)var Tt=Le.videoWidth,xn=Le.videoHeight;else typeof HTMLImageElement<"u"&&Le instanceof HTMLImageElement?(Tt=Le.naturalWidth,xn=Le.naturalHeight):(Tt=Le.width,xn=Le.height);xn={glName:ht.l,width:Tt,height:xn},(Tt=ht.g).canvas.width=xn.width,Tt.canvas.height=xn.height,Tt.activeTexture(Tt.TEXTURE0),ht.h.bindTexture2d(ht.l),Tt.texImage2D(Tt.TEXTURE_2D,0,Tt.RGBA,Tt.RGBA,Tt.UNSIGNED_BYTE,Le),ht.h.bindTexture2d(0),ht=xn;break e;case"detections":for((ht=_e.o[ne.stream])||(ht=new me(_e.h),_e.o[ne.stream]=ht),ht.data||(ht.data=new ht.g.DetectionListData),ht.data.reset(Le.length),xn=0;xn<Le.length;++xn){Tt=Le[xn];var Rn=ht.data,Io=Rn.setBoundingBox,Ns=xn,Uo=Tt.boundingBox,en=new Gg;if(Un(en,1,Uo.xCenter),Un(en,2,Uo.yCenter),Un(en,3,Uo.height),Un(en,4,Uo.width),Un(en,5,Uo.rotation),Un(en,6,Uo.rectId),Uo=Yu(en,jg),Io.call(Rn,Ns,Uo),Tt.landmarks)for(Rn=0;Rn<Tt.landmarks.length;++Rn){var Hr=!!(en=Tt.landmarks[Rn]).visibility;Ns=(Io=ht.data).addNormalizedLandmark,Uo=xn,en=Object.assign(Object.assign({},en),{visibility:Hr?en.visibility:0}),Un(Hr=new tc,1,en.x),Un(Hr,2,en.y),Un(Hr,3,en.z),en.visibility&&Un(Hr,4,en.visibility),en=Yu(Hr,Lx),Ns.call(Io,Uo,en)}if(Tt.V)for(Rn=0;Rn<Tt.V.length;++Rn)Ns=(Io=ht.data).addClassification,Uo=xn,en=Tt.V[Rn],Un(Hr=new ba,2,en.ga),en.index&&Un(Hr,1,en.index),en.label&&Un(Hr,3,en.label),en.displayName&&Un(Hr,4,en.displayName),en=Yu(Hr,$x),Ns.call(Io,Uo,en)}ht=ht.data;break e;default:ht={}}}switch(ue=ht,ge=ne.stream,ne.type){case"video":P.pushTexture2d(Object.assign(Object.assign({},ue),{stream:ge,timestamp:M}));break;case"detections":(Ce=ue).stream=ge,Ce.timestamp=M,P.pushDetectionList(Ce);break;default:throw Error("Unknown input config type: '"+ne.type+"'")}}return _e.i.send(P),y(Me,_e.D,4);case 4:P.delete(),Me.g=0}})},t.onResults=function(v,N){this.listeners[N||"$"]=v},V("Solution",Pe),V("OptionType",{BOOL:0,NUMBER:1,ia:2,0:"BOOL",1:"NUMBER",2:"STRING"}),(t=Xe.prototype).close=function(){return this.g.close(),Promise.resolve()},t.onResults=function(v){this.g.onResults(v)},t.initialize=function(){var v=this;return O(function(N){return y(N,v.g.initialize(),0)})},t.reset=function(){this.g.reset()},t.send=function(v){var N=this;return O(function(M){return y(M,N.g.send(v),0)})},t.setOptions=function(v){this.g.setOptions(v)},V("FaceDetection",Xe),V("FACEDETECTION_LIPS",Hg),V("FACEDETECTION_LEFT_EYE",Wg),V("FACEDETECTION_LEFT_EYEBROW",qg),V("FACEDETECTION_RIGHT_EYE",Kg),V("FACEDETECTION_RIGHT_EYEBROW",Xg),V("FACEDETECTION_FACE_OVAL",Bx),V("FACEDETECTION_CONTOURS",zx),V("FACEDETECTION_TESSELATION",[[127,34],[34,139],[139,127],[11,0],[0,37],[37,11],[232,231],[231,120],[120,232],[72,37],[37,39],[39,72],[128,121],[121,47],[47,128],[232,121],[121,128],[128,232],[104,69],[69,67],[67,104],[175,171],[171,148],[148,175],[118,50],[50,101],[101,118],[73,39],[39,40],[40,73],[9,151],[151,108],[108,9],[48,115],[115,131],[131,48],[194,204],[204,211],[211,194],[74,40],[40,185],[185,74],[80,42],[42,183],[183,80],[40,92],[92,186],[186,40],[230,229],[229,118],[118,230],[202,212],[212,214],[214,202],[83,18],[18,17],[17,83],[76,61],[61,146],[146,76],[160,29],[29,30],[30,160],[56,157],[157,173],[173,56],[106,204],[204,194],[194,106],[135,214],[214,192],[192,135],[203,165],[165,98],[98,203],[21,71],[71,68],[68,21],[51,45],[45,4],[4,51],[144,24],[24,23],[23,144],[77,146],[146,91],[91,77],[205,50],[50,187],[187,205],[201,200],[200,18],[18,201],[91,106],[106,182],[182,91],[90,91],[91,181],[181,90],[85,84],[84,17],[17,85],[206,203],[203,36],[36,206],[148,171],[171,140],[140,148],[92,40],[40,39],[39,92],[193,189],[189,244],[244,193],[159,158],[158,28],[28,159],[247,246],[246,161],[161,247],[236,3],[3,196],[196,236],[54,68],[68,104],[104,54],[193,168],[168,8],[8,193],[117,228],[228,31],[31,117],[189,193],[193,55],[55,189],[98,97],[97,99],[99,98],[126,47],[47,100],[100,126],[166,79],[79,218],[218,166],[155,154],[154,26],[26,155],[209,49],[49,131],[131,209],[135,136],[136,150],[150,135],[47,126],[126,217],[217,47],[223,52],[52,53],[53,223],[45,51],[51,134],[134,45],[211,170],[170,140],[140,211],[67,69],[69,108],[108,67],[43,106],[106,91],[91,43],[230,119],[119,120],[120,230],[226,130],[130,247],[247,226],[63,53],[53,52],[52,63],[238,20],[20,242],[242,238],[46,70],[70,156],[156,46],[78,62],[62,96],[96,78],[46,53],[53,63],[63,46],[143,34],[34,227],[227,143],[123,117],[117,111],[111,123],[44,125],[125,19],[19,44],[236,134],[134,51],[51,236],[216,206],[206,205],[205,216],[154,153],[153,22],[22,154],[39,37],[37,167],[167,39],[200,201],[201,208],[208,200],[36,142],[142,100],[100,36],[57,212],[212,202],[202,57],[20,60],[60,99],[99,20],[28,158],[158,157],[157,28],[35,226],[226,113],[113,35],[160,159],[159,27],[27,160],[204,202],[202,210],[210,204],[113,225],[225,46],[46,113],[43,202],[202,204],[204,43],[62,76],[76,77],[77,62],[137,123],[123,116],[116,137],[41,38],[38,72],[72,41],[203,129],[129,142],[142,203],[64,98],[98,240],[240,64],[49,102],[102,64],[64,49],[41,73],[73,74],[74,41],[212,216],[216,207],[207,212],[42,74],[74,184],[184,42],[169,170],[170,211],[211,169],[170,149],[149,176],[176,170],[105,66],[66,69],[69,105],[122,6],[6,168],[168,122],[123,147],[147,187],[187,123],[96,77],[77,90],[90,96],[65,55],[55,107],[107,65],[89,90],[90,180],[180,89],[101,100],[100,120],[120,101],[63,105],[105,104],[104,63],[93,137],[137,227],[227,93],[15,86],[86,85],[85,15],[129,102],[102,49],[49,129],[14,87],[87,86],[86,14],[55,8],[8,9],[9,55],[100,47],[47,121],[121,100],[145,23],[23,22],[22,145],[88,89],[89,179],[179,88],[6,122],[122,196],[196,6],[88,95],[95,96],[96,88],[138,172],[172,136],[136,138],[215,58],[58,172],[172,215],[115,48],[48,219],[219,115],[42,80],[80,81],[81,42],[195,3],[3,51],[51,195],[43,146],[146,61],[61,43],[171,175],[175,199],[199,171],[81,82],[82,38],[38,81],[53,46],[46,225],[225,53],[144,163],[163,110],[110,144],[52,65],[65,66],[66,52],[229,228],[228,117],[117,229],[34,127],[127,234],[234,34],[107,108],[108,69],[69,107],[109,108],[108,151],[151,109],[48,64],[64,235],[235,48],[62,78],[78,191],[191,62],[129,209],[209,126],[126,129],[111,35],[35,143],[143,111],[117,123],[123,50],[50,117],[222,65],[65,52],[52,222],[19,125],[125,141],[141,19],[221,55],[55,65],[65,221],[3,195],[195,197],[197,3],[25,7],[7,33],[33,25],[220,237],[237,44],[44,220],[70,71],[71,139],[139,70],[122,193],[193,245],[245,122],[247,130],[130,33],[33,247],[71,21],[21,162],[162,71],[170,169],[169,150],[150,170],[188,174],[174,196],[196,188],[216,186],[186,92],[92,216],[2,97],[97,167],[167,2],[141,125],[125,241],[241,141],[164,167],[167,37],[37,164],[72,38],[38,12],[12,72],[38,82],[82,13],[13,38],[63,68],[68,71],[71,63],[226,35],[35,111],[111,226],[101,50],[50,205],[205,101],[206,92],[92,165],[165,206],[209,198],[198,217],[217,209],[165,167],[167,97],[97,165],[220,115],[115,218],[218,220],[133,112],[112,243],[243,133],[239,238],[238,241],[241,239],[214,135],[135,169],[169,214],[190,173],[173,133],[133,190],[171,208],[208,32],[32,171],[125,44],[44,237],[237,125],[86,87],[87,178],[178,86],[85,86],[86,179],[179,85],[84,85],[85,180],[180,84],[83,84],[84,181],[181,83],[201,83],[83,182],[182,201],[137,93],[93,132],[132,137],[76,62],[62,183],[183,76],[61,76],[76,184],[184,61],[57,61],[61,185],[185,57],[212,57],[57,186],[186,212],[214,207],[207,187],[187,214],[34,143],[143,156],[156,34],[79,239],[239,237],[237,79],[123,137],[137,177],[177,123],[44,1],[1,4],[4,44],[201,194],[194,32],[32,201],[64,102],[102,129],[129,64],[213,215],[215,138],[138,213],[59,166],[166,219],[219,59],[242,99],[99,97],[97,242],[2,94],[94,141],[141,2],[75,59],[59,235],[235,75],[24,110],[110,228],[228,24],[25,130],[130,226],[226,25],[23,24],[24,229],[229,23],[22,23],[23,230],[230,22],[26,22],[22,231],[231,26],[112,26],[26,232],[232,112],[189,190],[190,243],[243,189],[221,56],[56,190],[190,221],[28,56],[56,221],[221,28],[27,28],[28,222],[222,27],[29,27],[27,223],[223,29],[30,29],[29,224],[224,30],[247,30],[30,225],[225,247],[238,79],[79,20],[20,238],[166,59],[59,75],[75,166],[60,75],[75,240],[240,60],[147,177],[177,215],[215,147],[20,79],[79,166],[166,20],[187,147],[147,213],[213,187],[112,233],[233,244],[244,112],[233,128],[128,245],[245,233],[128,114],[114,188],[188,128],[114,217],[217,174],[174,114],[131,115],[115,220],[220,131],[217,198],[198,236],[236,217],[198,131],[131,134],[134,198],[177,132],[132,58],[58,177],[143,35],[35,124],[124,143],[110,163],[163,7],[7,110],[228,110],[110,25],[25,228],[356,389],[389,368],[368,356],[11,302],[302,267],[267,11],[452,350],[350,349],[349,452],[302,303],[303,269],[269,302],[357,343],[343,277],[277,357],[452,453],[453,357],[357,452],[333,332],[332,297],[297,333],[175,152],[152,377],[377,175],[347,348],[348,330],[330,347],[303,304],[304,270],[270,303],[9,336],[336,337],[337,9],[278,279],[279,360],[360,278],[418,262],[262,431],[431,418],[304,408],[408,409],[409,304],[310,415],[415,407],[407,310],[270,409],[409,410],[410,270],[450,348],[348,347],[347,450],[422,430],[430,434],[434,422],[313,314],[314,17],[17,313],[306,307],[307,375],[375,306],[387,388],[388,260],[260,387],[286,414],[414,398],[398,286],[335,406],[406,418],[418,335],[364,367],[367,416],[416,364],[423,358],[358,327],[327,423],[251,284],[284,298],[298,251],[281,5],[5,4],[4,281],[373,374],[374,253],[253,373],[307,320],[320,321],[321,307],[425,427],[427,411],[411,425],[421,313],[313,18],[18,421],[321,405],[405,406],[406,321],[320,404],[404,405],[405,320],[315,16],[16,17],[17,315],[426,425],[425,266],[266,426],[377,400],[400,369],[369,377],[322,391],[391,269],[269,322],[417,465],[465,464],[464,417],[386,257],[257,258],[258,386],[466,260],[260,388],[388,466],[456,399],[399,419],[419,456],[284,332],[332,333],[333,284],[417,285],[285,8],[8,417],[346,340],[340,261],[261,346],[413,441],[441,285],[285,413],[327,460],[460,328],[328,327],[355,371],[371,329],[329,355],[392,439],[439,438],[438,392],[382,341],[341,256],[256,382],[429,420],[420,360],[360,429],[364,394],[394,379],[379,364],[277,343],[343,437],[437,277],[443,444],[444,283],[283,443],[275,440],[440,363],[363,275],[431,262],[262,369],[369,431],[297,338],[338,337],[337,297],[273,375],[375,321],[321,273],[450,451],[451,349],[349,450],[446,342],[342,467],[467,446],[293,334],[334,282],[282,293],[458,461],[461,462],[462,458],[276,353],[353,383],[383,276],[308,324],[324,325],[325,308],[276,300],[300,293],[293,276],[372,345],[345,447],[447,372],[352,345],[345,340],[340,352],[274,1],[1,19],[19,274],[456,248],[248,281],[281,456],[436,427],[427,425],[425,436],[381,256],[256,252],[252,381],[269,391],[391,393],[393,269],[200,199],[199,428],[428,200],[266,330],[330,329],[329,266],[287,273],[273,422],[422,287],[250,462],[462,328],[328,250],[258,286],[286,384],[384,258],[265,353],[353,342],[342,265],[387,259],[259,257],[257,387],[424,431],[431,430],[430,424],[342,353],[353,276],[276,342],[273,335],[335,424],[424,273],[292,325],[325,307],[307,292],[366,447],[447,345],[345,366],[271,303],[303,302],[302,271],[423,266],[266,371],[371,423],[294,455],[455,460],[460,294],[279,278],[278,294],[294,279],[271,272],[272,304],[304,271],[432,434],[434,427],[427,432],[272,407],[407,408],[408,272],[394,430],[430,431],[431,394],[395,369],[369,400],[400,395],[334,333],[333,299],[299,334],[351,417],[417,168],[168,351],[352,280],[280,411],[411,352],[325,319],[319,320],[320,325],[295,296],[296,336],[336,295],[319,403],[403,404],[404,319],[330,348],[348,349],[349,330],[293,298],[298,333],[333,293],[323,454],[454,447],[447,323],[15,16],[16,315],[315,15],[358,429],[429,279],[279,358],[14,15],[15,316],[316,14],[285,336],[336,9],[9,285],[329,349],[349,350],[350,329],[374,380],[380,252],[252,374],[318,402],[402,403],[403,318],[6,197],[197,419],[419,6],[318,319],[319,325],[325,318],[367,364],[364,365],[365,367],[435,367],[367,397],[397,435],[344,438],[438,439],[439,344],[272,271],[271,311],[311,272],[195,5],[5,281],[281,195],[273,287],[287,291],[291,273],[396,428],[428,199],[199,396],[311,271],[271,268],[268,311],[283,444],[444,445],[445,283],[373,254],[254,339],[339,373],[282,334],[334,296],[296,282],[449,347],[347,346],[346,449],[264,447],[447,454],[454,264],[336,296],[296,299],[299,336],[338,10],[10,151],[151,338],[278,439],[439,455],[455,278],[292,407],[407,415],[415,292],[358,371],[371,355],[355,358],[340,345],[345,372],[372,340],[346,347],[347,280],[280,346],[442,443],[443,282],[282,442],[19,94],[94,370],[370,19],[441,442],[442,295],[295,441],[248,419],[419,197],[197,248],[263,255],[255,359],[359,263],[440,275],[275,274],[274,440],[300,383],[383,368],[368,300],[351,412],[412,465],[465,351],[263,467],[467,466],[466,263],[301,368],[368,389],[389,301],[395,378],[378,379],[379,395],[412,351],[351,419],[419,412],[436,426],[426,322],[322,436],[2,164],[164,393],[393,2],[370,462],[462,461],[461,370],[164,0],[0,267],[267,164],[302,11],[11,12],[12,302],[268,12],[12,13],[13,268],[293,300],[300,301],[301,293],[446,261],[261,340],[340,446],[330,266],[266,425],[425,330],[426,423],[423,391],[391,426],[429,355],[355,437],[437,429],[391,327],[327,326],[326,391],[440,457],[457,438],[438,440],[341,382],[382,362],[362,341],[459,457],[457,461],[461,459],[434,430],[430,394],[394,434],[414,463],[463,362],[362,414],[396,369],[369,262],[262,396],[354,461],[461,457],[457,354],[316,403],[403,402],[402,316],[315,404],[404,403],[403,315],[314,405],[405,404],[404,314],[313,406],[406,405],[405,313],[421,418],[418,406],[406,421],[366,401],[401,361],[361,366],[306,408],[408,407],[407,306],[291,409],[409,408],[408,291],[287,410],[410,409],[409,287],[432,436],[436,410],[410,432],[434,416],[416,411],[411,434],[264,368],[368,383],[383,264],[309,438],[438,457],[457,309],[352,376],[376,401],[401,352],[274,275],[275,4],[4,274],[421,428],[428,262],[262,421],[294,327],[327,358],[358,294],[433,416],[416,367],[367,433],[289,455],[455,439],[439,289],[462,370],[370,326],[326,462],[2,326],[326,370],[370,2],[305,460],[460,455],[455,305],[254,449],[449,448],[448,254],[255,261],[261,446],[446,255],[253,450],[450,449],[449,253],[252,451],[451,450],[450,252],[256,452],[452,451],[451,256],[341,453],[453,452],[452,341],[413,464],[464,463],[463,413],[441,413],[413,414],[414,441],[258,442],[442,441],[441,258],[257,443],[443,442],[442,257],[259,444],[444,443],[443,259],[260,445],[445,444],[444,260],[467,342],[342,445],[445,467],[459,458],[458,250],[250,459],[289,392],[392,290],[290,289],[290,328],[328,460],[460,290],[376,433],[433,435],[435,376],[250,290],[290,392],[392,250],[411,416],[416,433],[433,411],[341,463],[463,464],[464,341],[453,464],[464,465],[465,453],[357,465],[465,412],[412,357],[343,412],[412,399],[399,343],[360,363],[363,440],[440,360],[437,399],[399,456],[456,437],[420,456],[456,363],[363,420],[401,435],[435,288],[288,401],[372,383],[383,353],[353,372],[339,255],[255,249],[249,339],[448,261],[261,255],[255,448],[133,243],[243,190],[190,133],[133,155],[155,112],[112,133],[33,246],[246,247],[247,33],[33,130],[130,25],[25,33],[398,384],[384,286],[286,398],[362,398],[398,414],[414,362],[362,463],[463,341],[341,362],[263,359],[359,467],[467,263],[263,249],[249,255],[255,263],[466,467],[467,260],[260,466],[75,60],[60,166],[166,75],[238,239],[239,79],[79,238],[162,127],[127,139],[139,162],[72,11],[11,37],[37,72],[121,232],[232,120],[120,121],[73,72],[72,39],[39,73],[114,128],[128,47],[47,114],[233,232],[232,128],[128,233],[103,104],[104,67],[67,103],[152,175],[175,148],[148,152],[119,118],[118,101],[101,119],[74,73],[73,40],[40,74],[107,9],[9,108],[108,107],[49,48],[48,131],[131,49],[32,194],[194,211],[211,32],[184,74],[74,185],[185,184],[191,80],[80,183],[183,191],[185,40],[40,186],[186,185],[119,230],[230,118],[118,119],[210,202],[202,214],[214,210],[84,83],[83,17],[17,84],[77,76],[76,146],[146,77],[161,160],[160,30],[30,161],[190,56],[56,173],[173,190],[182,106],[106,194],[194,182],[138,135],[135,192],[192,138],[129,203],[203,98],[98,129],[54,21],[21,68],[68,54],[5,51],[51,4],[4,5],[145,144],[144,23],[23,145],[90,77],[77,91],[91,90],[207,205],[205,187],[187,207],[83,201],[201,18],[18,83],[181,91],[91,182],[182,181],[180,90],[90,181],[181,180],[16,85],[85,17],[17,16],[205,206],[206,36],[36,205],[176,148],[148,140],[140,176],[165,92],[92,39],[39,165],[245,193],[193,244],[244,245],[27,159],[159,28],[28,27],[30,247],[247,161],[161,30],[174,236],[236,196],[196,174],[103,54],[54,104],[104,103],[55,193],[193,8],[8,55],[111,117],[117,31],[31,111],[221,189],[189,55],[55,221],[240,98],[98,99],[99,240],[142,126],[126,100],[100,142],[219,166],[166,218],[218,219],[112,155],[155,26],[26,112],[198,209],[209,131],[131,198],[169,135],[135,150],[150,169],[114,47],[47,217],[217,114],[224,223],[223,53],[53,224],[220,45],[45,134],[134,220],[32,211],[211,140],[140,32],[109,67],[67,108],[108,109],[146,43],[43,91],[91,146],[231,230],[230,120],[120,231],[113,226],[226,247],[247,113],[105,63],[63,52],[52,105],[241,238],[238,242],[242,241],[124,46],[46,156],[156,124],[95,78],[78,96],[96,95],[70,46],[46,63],[63,70],[116,143],[143,227],[227,116],[116,123],[123,111],[111,116],[1,44],[44,19],[19,1],[3,236],[236,51],[51,3],[207,216],[216,205],[205,207],[26,154],[154,22],[22,26],[165,39],[39,167],[167,165],[199,200],[200,208],[208,199],[101,36],[36,100],[100,101],[43,57],[57,202],[202,43],[242,20],[20,99],[99,242],[56,28],[28,157],[157,56],[124,35],[35,113],[113,124],[29,160],[160,27],[27,29],[211,204],[204,210],[210,211],[124,113],[113,46],[46,124],[106,43],[43,204],[204,106],[96,62],[62,77],[77,96],[227,137],[137,116],[116,227],[73,41],[41,72],[72,73],[36,203],[203,142],[142,36],[235,64],[64,240],[240,235],[48,49],[49,64],[64,48],[42,41],[41,74],[74,42],[214,212],[212,207],[207,214],[183,42],[42,184],[184,183],[210,169],[169,211],[211,210],[140,170],[170,176],[176,140],[104,105],[105,69],[69,104],[193,122],[122,168],[168,193],[50,123],[123,187],[187,50],[89,96],[96,90],[90,89],[66,65],[65,107],[107,66],[179,89],[89,180],[180,179],[119,101],[101,120],[120,119],[68,63],[63,104],[104,68],[234,93],[93,227],[227,234],[16,15],[15,85],[85,16],[209,129],[129,49],[49,209],[15,14],[14,86],[86,15],[107,55],[55,9],[9,107],[120,100],[100,121],[121,120],[153,145],[145,22],[22,153],[178,88],[88,179],[179,178],[197,6],[6,196],[196,197],[89,88],[88,96],[96,89],[135,138],[138,136],[136,135],[138,215],[215,172],[172,138],[218,115],[115,219],[219,218],[41,42],[42,81],[81,41],[5,195],[195,51],[51,5],[57,43],[43,61],[61,57],[208,171],[171,199],[199,208],[41,81],[81,38],[38,41],[224,53],[53,225],[225,224],[24,144],[144,110],[110,24],[105,52],[52,66],[66,105],[118,229],[229,117],[117,118],[227,34],[34,234],[234,227],[66,107],[107,69],[69,66],[10,109],[109,151],[151,10],[219,48],[48,235],[235,219],[183,62],[62,191],[191,183],[142,129],[129,126],[126,142],[116,111],[111,143],[143,116],[118,117],[117,50],[50,118],[223,222],[222,52],[52,223],[94,19],[19,141],[141,94],[222,221],[221,65],[65,222],[196,3],[3,197],[197,196],[45,220],[220,44],[44,45],[156,70],[70,139],[139,156],[188,122],[122,245],[245,188],[139,71],[71,162],[162,139],[149,170],[170,150],[150,149],[122,188],[188,196],[196,122],[206,216],[216,92],[92,206],[164,2],[2,167],[167,164],[242,141],[141,241],[241,242],[0,164],[164,37],[37,0],[11,72],[72,12],[12,11],[12,38],[38,13],[13,12],[70,63],[63,71],[71,70],[31,226],[226,111],[111,31],[36,101],[101,205],[205,36],[203,206],[206,165],[165,203],[126,209],[209,217],[217,126],[98,165],[165,97],[97,98],[237,220],[220,218],[218,237],[237,239],[239,241],[241,237],[210,214],[214,169],[169,210],[140,171],[171,32],[32,140],[241,125],[125,237],[237,241],[179,86],[86,178],[178,179],[180,85],[85,179],[179,180],[181,84],[84,180],[180,181],[182,83],[83,181],[181,182],[194,201],[201,182],[182,194],[177,137],[137,132],[132,177],[184,76],[76,183],[183,184],[185,61],[61,184],[184,185],[186,57],[57,185],[185,186],[216,212],[212,186],[186,216],[192,214],[214,187],[187,192],[139,34],[34,156],[156,139],[218,79],[79,237],[237,218],[147,123],[123,177],[177,147],[45,44],[44,4],[4,45],[208,201],[201,32],[32,208],[98,64],[64,129],[129,98],[192,213],[213,138],[138,192],[235,59],[59,219],[219,235],[141,242],[242,97],[97,141],[97,2],[2,141],[141,97],[240,75],[75,235],[235,240],[229,24],[24,228],[228,229],[31,25],[25,226],[226,31],[230,23],[23,229],[229,230],[231,22],[22,230],[230,231],[232,26],[26,231],[231,232],[233,112],[112,232],[232,233],[244,189],[189,243],[243,244],[189,221],[221,190],[190,189],[222,28],[28,221],[221,222],[223,27],[27,222],[222,223],[224,29],[29,223],[223,224],[225,30],[30,224],[224,225],[113,247],[247,225],[225,113],[99,60],[60,240],[240,99],[213,147],[147,215],[215,213],[60,20],[20,166],[166,60],[192,187],[187,213],[213,192],[243,112],[112,244],[244,243],[244,233],[233,245],[245,244],[245,128],[128,188],[188,245],[188,114],[114,174],[174,188],[134,131],[131,220],[220,134],[174,217],[217,236],[236,174],[236,198],[198,134],[134,236],[215,177],[177,58],[58,215],[156,143],[143,124],[124,156],[25,110],[110,7],[7,25],[31,228],[228,25],[25,31],[264,356],[356,368],[368,264],[0,11],[11,267],[267,0],[451,452],[452,349],[349,451],[267,302],[302,269],[269,267],[350,357],[357,277],[277,350],[350,452],[452,357],[357,350],[299,333],[333,297],[297,299],[396,175],[175,377],[377,396],[280,347],[347,330],[330,280],[269,303],[303,270],[270,269],[151,9],[9,337],[337,151],[344,278],[278,360],[360,344],[424,418],[418,431],[431,424],[270,304],[304,409],[409,270],[272,310],[310,407],[407,272],[322,270],[270,410],[410,322],[449,450],[450,347],[347,449],[432,422],[422,434],[434,432],[18,313],[313,17],[17,18],[291,306],[306,375],[375,291],[259,387],[387,260],[260,259],[424,335],[335,418],[418,424],[434,364],[364,416],[416,434],[391,423],[423,327],[327,391],[301,251],[251,298],[298,301],[275,281],[281,4],[4,275],[254,373],[373,253],[253,254],[375,307],[307,321],[321,375],[280,425],[425,411],[411,280],[200,421],[421,18],[18,200],[335,321],[321,406],[406,335],[321,320],[320,405],[405,321],[314,315],[315,17],[17,314],[423,426],[426,266],[266,423],[396,377],[377,369],[369,396],[270,322],[322,269],[269,270],[413,417],[417,464],[464,413],[385,386],[386,258],[258,385],[248,456],[456,419],[419,248],[298,284],[284,333],[333,298],[168,417],[417,8],[8,168],[448,346],[346,261],[261,448],[417,413],[413,285],[285,417],[326,327],[327,328],[328,326],[277,355],[355,329],[329,277],[309,392],[392,438],[438,309],[381,382],[382,256],[256,381],[279,429],[429,360],[360,279],[365,364],[364,379],[379,365],[355,277],[277,437],[437,355],[282,443],[443,283],[283,282],[281,275],[275,363],[363,281],[395,431],[431,369],[369,395],[299,297],[297,337],[337,299],[335,273],[273,321],[321,335],[348,450],[450,349],[349,348],[359,446],[446,467],[467,359],[283,293],[293,282],[282,283],[250,458],[458,462],[462,250],[300,276],[276,383],[383,300],[292,308],[308,325],[325,292],[283,276],[276,293],[293,283],[264,372],[372,447],[447,264],[346,352],[352,340],[340,346],[354,274],[274,19],[19,354],[363,456],[456,281],[281,363],[426,436],[436,425],[425,426],[380,381],[381,252],[252,380],[267,269],[269,393],[393,267],[421,200],[200,428],[428,421],[371,266],[266,329],[329,371],[432,287],[287,422],[422,432],[290,250],[250,328],[328,290],[385,258],[258,384],[384,385],[446,265],[265,342],[342,446],[386,387],[387,257],[257,386],[422,424],[424,430],[430,422],[445,342],[342,276],[276,445],[422,273],[273,424],[424,422],[306,292],[292,307],[307,306],[352,366],[366,345],[345,352],[268,271],[271,302],[302,268],[358,423],[423,371],[371,358],[327,294],[294,460],[460,327],[331,279],[279,294],[294,331],[303,271],[271,304],[304,303],[436,432],[432,427],[427,436],[304,272],[272,408],[408,304],[395,394],[394,431],[431,395],[378,395],[395,400],[400,378],[296,334],[334,299],[299,296],[6,351],[351,168],[168,6],[376,352],[352,411],[411,376],[307,325],[325,320],[320,307],[285,295],[295,336],[336,285],[320,319],[319,404],[404,320],[329,330],[330,349],[349,329],[334,293],[293,333],[333,334],[366,323],[323,447],[447,366],[316,15],[15,315],[315,316],[331,358],[358,279],[279,331],[317,14],[14,316],[316,317],[8,285],[285,9],[9,8],[277,329],[329,350],[350,277],[253,374],[374,252],[252,253],[319,318],[318,403],[403,319],[351,6],[6,419],[419,351],[324,318],[318,325],[325,324],[397,367],[367,365],[365,397],[288,435],[435,397],[397,288],[278,344],[344,439],[439,278],[310,272],[272,311],[311,310],[248,195],[195,281],[281,248],[375,273],[273,291],[291,375],[175,396],[396,199],[199,175],[312,311],[311,268],[268,312],[276,283],[283,445],[445,276],[390,373],[373,339],[339,390],[295,282],[282,296],[296,295],[448,449],[449,346],[346,448],[356,264],[264,454],[454,356],[337,336],[336,299],[299,337],[337,338],[338,151],[151,337],[294,278],[278,455],[455,294],[308,292],[292,415],[415,308],[429,358],[358,355],[355,429],[265,340],[340,372],[372,265],[352,346],[346,280],[280,352],[295,442],[442,282],[282,295],[354,19],[19,370],[370,354],[285,441],[441,295],[295,285],[195,248],[248,197],[197,195],[457,440],[440,274],[274,457],[301,300],[300,368],[368,301],[417,351],[351,465],[465,417],[251,301],[301,389],[389,251],[394,395],[395,379],[379,394],[399,412],[412,419],[419,399],[410,436],[436,322],[322,410],[326,2],[2,393],[393,326],[354,370],[370,461],[461,354],[393,164],[164,267],[267,393],[268,302],[302,12],[12,268],[312,268],[268,13],[13,312],[298,293],[293,301],[301,298],[265,446],[446,340],[340,265],[280,330],[330,425],[425,280],[322,426],[426,391],[391,322],[420,429],[429,437],[437,420],[393,391],[391,326],[326,393],[344,440],[440,438],[438,344],[458,459],[459,461],[461,458],[364,434],[434,394],[394,364],[428,396],[396,262],[262,428],[274,354],[354,457],[457,274],[317,316],[316,402],[402,317],[316,315],[315,403],[403,316],[315,314],[314,404],[404,315],[314,313],[313,405],[405,314],[313,421],[421,406],[406,313],[323,366],[366,361],[361,323],[292,306],[306,407],[407,292],[306,291],[291,408],[408,306],[291,287],[287,409],[409,291],[287,432],[432,410],[410,287],[427,434],[434,411],[411,427],[372,264],[264,383],[383,372],[459,309],[309,457],[457,459],[366,352],[352,401],[401,366],[1,274],[274,4],[4,1],[418,421],[421,262],[262,418],[331,294],[294,358],[358,331],[435,433],[433,367],[367,435],[392,289],[289,439],[439,392],[328,462],[462,326],[326,328],[94,2],[2,370],[370,94],[289,305],[305,455],[455,289],[339,254],[254,448],[448,339],[359,255],[255,446],[446,359],[254,253],[253,449],[449,254],[253,252],[252,450],[450,253],[252,256],[256,451],[451,252],[256,341],[341,452],[452,256],[414,413],[413,463],[463,414],[286,441],[441,414],[414,286],[286,258],[258,441],[441,286],[258,257],[257,442],[442,258],[257,259],[259,443],[443,257],[259,260],[260,444],[444,259],[260,467],[467,445],[445,260],[309,459],[459,250],[250,309],[305,289],[289,290],[290,305],[305,290],[290,460],[460,305],[401,376],[376,435],[435,401],[309,250],[250,392],[392,309],[376,411],[411,433],[433,376],[453,341],[341,464],[464,453],[357,453],[453,465],[465,357],[343,357],[357,412],[412,343],[437,343],[343,399],[399,437],[344,360],[360,440],[440,344],[420,437],[437,456],[456,420],[360,420],[420,363],[363,360],[361,401],[401,288],[288,361],[265,372],[372,353],[353,265],[390,339],[339,249],[249,390],[339,448],[448,255],[255,339]]),V("VERSION","0.4.1646425229")}).call(Fk);var Hu=function(){return Hu=Object.assign||function(t){for(var n,e=1,r=arguments.length;e<r;e++)for(var o in n=arguments[e])Object.prototype.hasOwnProperty.call(n,o)&&(t[o]=n[o]);return t},Hu.apply(this,arguments)};function Zl(t,n,e,r){return new(e||(e=Promise))(function(o,s){function i(c){try{l(r.next(c))}catch(u){s(u)}}function a(c){try{l(r.throw(c))}catch(u){s(u)}}function l(c){var u;c.done?o(c.value):(u=c.value,u instanceof e?u:new e(function(p){p(u)})).then(i,a)}l((r=r.apply(t,n||[])).next())})}function Ql(t,n){var e,r,o,s,i={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return s={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(s[Symbol.iterator]=function(){return this}),s;function a(l){return function(c){return(function(u){if(e)throw new TypeError("Generator is already executing.");for(;i;)try{if(e=1,r&&(o=2&u[0]?r.return:u[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,u[1])).done)return o;switch(r=0,o&&(u=[2&u[0],o.value]),u[0]){case 0:case 1:o=u;break;case 4:return i.label++,{value:u[1],done:!1};case 5:i.label++,r=u[1],u=[0];continue;case 7:u=i.ops.pop(),i.trys.pop();continue;default:if(!((o=(o=i.trys).length>0&&o[o.length-1])||u[0]!==6&&u[0]!==2)){i=0;continue}if(u[0]===3&&(!o||u[1]>o[0]&&u[1]<o[3])){i.label=u[1];break}if(u[0]===6&&i.label<o[1]){i.label=o[1],o=u;break}if(o&&i.label<o[2]){i.label=o[2],i.ops.push(u);break}o[2]&&i.ops.pop(),i.trys.pop();continue}u=n.call(t,i)}catch(p){u=[6,p],r=0}finally{e=o=0}if(5&u[0])throw u[1];return{value:u[0]?u[1]:void 0,done:!0}})([l,c])}}}var Yq=["rightEye","leftEye","noseTip","mouthCenter","rightEarTragion","leftEarTragion"],$k={modelType:"short",runtime:"mediapipe",maxFaces:1},h2e=(function(){function t(n){var e=this;this.width=0,this.height=0,this.selfieMode=!1,this.faceDetectorSolution=new d2e.FaceDetection({locateFile:function(r,o){if(n.solutionPath){var s=n.solutionPath.replace(/\/+$/,"");return"".concat(s,"/").concat(r)}return"".concat(o,"/").concat(r)}}),this.faceDetectorSolution.setOptions({selfieMode:this.selfieMode,model:n.modelType}),this.faceDetectorSolution.onResults(function(r){if(e.height=r.image.height,e.width=r.image.width,e.faces=[],r.detections!==null)for(var o=0,s=r.detections;o<s.length;o++){var i=s[o];e.faces.push(e.normalizedToAbsolute(i.landmarks,{xMin:l=(a=i.boundingBox).xCenter-a.width/2,xMax:l+a.width,yMin:c=a.yCenter-a.height/2,yMax:c+a.height,width:a.width,height:a.height}))}var a,l,c})}return t.prototype.normalizedToAbsolute=function(n,e){var r=this;return{keypoints:n.map(function(o,s){return{x:o.x*r.width,y:o.y*r.height,name:Yq[s]}}),box:{xMin:e.xMin*this.width,yMin:e.yMin*this.height,xMax:e.xMax*this.width,yMax:e.yMax*this.height,width:e.width*this.width,height:e.height*this.height}}},t.prototype.estimateFaces=function(n,e){return Zl(this,void 0,void 0,function(){var r,o;return Ql(this,function(s){switch(s.label){case 0:return e&&e.flipHorizontal&&e.flipHorizontal!==this.selfieMode&&(this.selfieMode=e.flipHorizontal,this.faceDetectorSolution.setOptions({selfieMode:this.selfieMode})),n instanceof ot?(o=ImageData.bind,[4,Ol.toPixels(n)]):[3,2];case 1:return r=new(o.apply(ImageData,[void 0,s.sent(),n.shape[1],n.shape[0]])),[3,3];case 2:r=n,s.label=3;case 3:return n=r,[4,this.faceDetectorSolution.send({image:n})];case 4:return s.sent(),[2,this.faces]}})})},t.prototype.dispose=function(){this.faceDetectorSolution.close()},t.prototype.reset=function(){this.faceDetectorSolution.reset(),this.width=0,this.height=0,this.faces=null,this.selfieMode=!1},t.prototype.initialize=function(){return this.faceDetectorSolution.initialize()},t})();function m2e(t){return Zl(this,void 0,void 0,function(){var n,e;return Ql(this,function(r){switch(r.label){case 0:return n=(function(o){if(o==null)return Hu({},$k);var s=Hu({},o);return s.runtime="mediapipe",s.modelType==null&&(s.modelType=$k.modelType),s.maxFaces==null&&(s.maxFaces=$k.maxFaces),s})(t),[4,(e=new h2e(n)).initialize()];case 1:return r.sent(),[2,e]}})})}function Zq(t){return t instanceof ot?{height:t.shape[0],width:t.shape[1]}:{height:t.height,width:t.width}}function Qq(t){return t instanceof ot?t:Ol.fromPixels(t)}function Lk(t,n){b.assert(t.width!==0,function(){return"".concat(n," width cannot be 0.")}),b.assert(t.height!==0,function(){return"".concat(n," height cannot be 0.")})}function g2e(t,n,e){var r=n.outputTensorSize,o=n.keepAspectRatio,s=n.borderMode,i=n.outputTensorFloatRange,a=Zq(t),l=(function(f,d){return d?{xCenter:d.xCenter*f.width,yCenter:d.yCenter*f.height,width:d.width*f.width,height:d.height*f.height,rotation:d.rotation}:{xCenter:.5*f.width,yCenter:.5*f.height,width:f.width,height:f.height,rotation:0}})(a,e),c=(function(f,d,h){if(h===void 0&&(h=!1),!h)return{top:0,left:0,right:0,bottom:0};var g=d.height,m=d.width;Lk(d,"targetSize"),Lk(f,"roi");var y,x,C=g/m,I=f.height/f.width,D=0,O=0;return C>I?(y=f.width,x=f.width*C,O=(1-I/C)/2):(y=f.height/C,x=f.height,D=(1-C/I)/2),f.width=y,f.height=x,{top:O,left:D,right:D,bottom:O}})(l,r,o),u=(function(f,d,h,g){var m=f.width,y=f.height,x=g?-1:1,C=Math.cos(f.rotation),I=Math.sin(f.rotation),D=f.xCenter,O=f.yCenter,L=1/d,B=1/h,V=new Array(16);return V[0]=m*C*x*L,V[1]=-y*I*L,V[2]=0,V[3]=(-.5*m*C*x+.5*y*I+D)*L,V[4]=m*I*x*B,V[5]=y*C*B,V[6]=0,V[7]=(-.5*y*C-.5*m*I*x+O)*B,V[8]=0,V[9]=0,V[10]=m*L,V[11]=0,V[12]=0,V[13]=0,V[14]=0,V[15]=1,(function(F){if(F.length!==16)throw new Error("Array length must be 16 but got ".concat(F.length));return[[F[0],F[1],F[2],F[3]],[F[4],F[5],F[6],F[7]],[F[8],F[9],F[10],F[11]],[F[12],F[13],F[14],F[15]]]})(V)})(l,a.width,a.height,!1),p=X(function(){var f=Qq(t),d=es((function(m,y,x){return Lk(x,"inputResolution"),[1/x.width*m[0][0]*y.width,1/x.height*m[0][1]*y.width,m[0][3]*y.width,1/x.width*m[1][0]*y.height,1/x.height*m[1][1]*y.height,m[1][3]*y.height,0,0]})(u,a,r),[1,8]),h=s==="zero"?"constant":"nearest",g=nr.transform(an(fe(f,"float32")),d,"bilinear",h,0,[r.height,r.width]);return i!=null?(function(m,y){var x=(function(C,I,D,O){var L=(O-D)/255;return{scale:L,offset:D-0*L}})(0,0,y[0],y[1]);return X(function(){return le(z(m,x.scale),x.offset)})})(g,i):g});return{imageTensor:p,padding:c,transformationMatrix:u}}function Fq(t){t.reduceBoxesInLowestLayer==null&&(t.reduceBoxesInLowestLayer=!1),t.interpolatedScaleAspectRatio==null&&(t.interpolatedScaleAspectRatio=1),t.fixedAnchorSize==null&&(t.fixedAnchorSize=!1);for(var n=[],e=0;e<t.numLayers;){for(var r=[],o=[],s=[],i=[],a=e;a<t.strides.length&&t.strides[a]===t.strides[e];){var l=$q(t.minScale,t.maxScale,a,t.strides.length);if(a===0&&t.reduceBoxesInLowestLayer)s.push(1),s.push(2),s.push(.5),i.push(.1),i.push(l),i.push(l);else{for(var c=0;c<t.aspectRatios.length;++c)s.push(t.aspectRatios[c]),i.push(l);if(t.interpolatedScaleAspectRatio>0){var u=a===t.strides.length-1?1:$q(t.minScale,t.maxScale,a+1,t.strides.length);i.push(Math.sqrt(l*u)),s.push(t.interpolatedScaleAspectRatio)}}a++}for(var p=0;p<s.length;++p){var f=Math.sqrt(s[p]);r.push(i[p]/f),o.push(i[p]*f)}var d=0,h=0;if(t.featureMapHeight.length>0)d=t.featureMapHeight[e],h=t.featureMapWidth[e];else{var g=t.strides[e];d=Math.ceil(t.inputSizeHeight/g),h=Math.ceil(t.inputSizeWidth/g)}for(var m=0;m<d;++m)for(var y=0;y<h;++y)for(var x=0;x<r.length;++x){var C={xCenter:(y+t.anchorOffsetX)/h,yCenter:(m+t.anchorOffsetY)/d,width:0,height:0};t.fixedAnchorSize?(C.width=1,C.height=1):(C.width=o[x],C.height=r[x]),n.push(C)}e=a}return n}function $q(t,n,e,r){return r===1?.5*(t+n):t+(n-t)*e/(r-1)}function Lq(t,n){var e=n[0],r=n[1];return[e*t[0]+r*t[1]+t[3],e*t[4]+r*t[5]+t[7]]}function y2e(t,n,e,r){return Zl(this,void 0,void 0,function(){var o,s,i,a,l;return Ql(this,function(c){switch(c.label){case 0:return t.sort(function(u,p){return Math.max.apply(Math,p.score)-Math.max.apply(Math,u.score)}),o=es(t.map(function(u){return[u.locationData.relativeBoundingBox.yMin,u.locationData.relativeBoundingBox.xMin,u.locationData.relativeBoundingBox.yMax,u.locationData.relativeBoundingBox.xMax]})),s=qt(t.map(function(u){return u.score[0]})),[4,nr.nonMaxSuppressionAsync(o,s,n,e)];case 1:return[4,(i=c.sent()).array()];case 2:return a=c.sent(),l=t.filter(function(u,p){return a.indexOf(p)>-1}),Ve([o,s,i]),[2,l]}})})}function x2e(t,n,e){return Zl(this,void 0,void 0,function(){var r,o,s,i,a;return Ql(this,function(l){switch(l.label){case 0:return r=t[0],o=t[1],s=(function(c,u,p){return X(function(){var f,d,h,g;p.reverseOutputOrder?(d=Zt(Ue(c,[0,p.boxCoordOffset+0],[-1,1])),f=Zt(Ue(c,[0,p.boxCoordOffset+1],[-1,1])),g=Zt(Ue(c,[0,p.boxCoordOffset+2],[-1,1])),h=Zt(Ue(c,[0,p.boxCoordOffset+3],[-1,1]))):(f=Zt(Ue(c,[0,p.boxCoordOffset+0],[-1,1])),d=Zt(Ue(c,[0,p.boxCoordOffset+1],[-1,1])),h=Zt(Ue(c,[0,p.boxCoordOffset+2],[-1,1])),g=Zt(Ue(c,[0,p.boxCoordOffset+3],[-1,1]))),d=le(z(ve(d,p.xScale),u.w),u.x),f=le(z(ve(f,p.yScale),u.h),u.y),p.applyExponentialOnBoxSize?(h=z(gn(ve(h,p.hScale)),u.h),g=z(gn(ve(g,p.wScale)),u.w)):(h=z(ve(h,p.hScale),u.h),g=z(ve(g,p.wScale),u.h));var m=Ie(f,ve(h,2)),y=Ie(d,ve(g,2)),x=le(f,ve(h,2)),C=le(d,ve(g,2)),I=Et([U(m,[p.numBoxes,1]),U(y,[p.numBoxes,1]),U(x,[p.numBoxes,1]),U(C,[p.numBoxes,1])],1);if(p.numKeypoints)for(var D=0;D<p.numKeypoints;++D){var O=p.keypointCoordOffset+D*p.numValuesPerKeypoint,L=void 0,B=void 0;p.reverseOutputOrder?(L=Zt(Ue(c,[0,O],[-1,1])),B=Zt(Ue(c,[0,O+1],[-1,1]))):(B=Zt(Ue(c,[0,O],[-1,1])),L=Zt(Ue(c,[0,O+1],[-1,1])));var V=le(z(ve(L,p.xScale),u.w),u.x),F=le(z(ve(B,p.yScale),u.h),u.y);I=Et([I,U(V,[p.numBoxes,1]),U(F,[p.numBoxes,1])],1)}return I})})(o,n,e),i=X(function(){var c=r;return e.sigmoidScore?(e.scoreClippingThresh!=null&&(c=Qn(r,-e.scoreClippingThresh,e.scoreClippingThresh)),c=Tr(c)):c}),[4,v2e(s,i,e)];case 1:return a=l.sent(),Ve([s,i]),[2,a]}})})}function v2e(t,n,e){return Zl(this,void 0,void 0,function(){var r,o,s,i,a,l,c,u,p,f,d,h;return Ql(this,function(g){switch(g.label){case 0:return r=[],[4,t.data()];case 1:return o=g.sent(),[4,n.data()];case 2:for(s=g.sent(),i=0;i<e.numBoxes;++i)if(!(e.minScoreThresh!=null&&s[i]<e.minScoreThresh||(a=i*e.numCoords,l=b2e(o[a+0],o[a+1],o[a+2],o[a+3],s[i],e.flipVertically,i),(c=l.locationData.relativeBoundingBox).width<0||c.height<0))){if(e.numKeypoints>0)for((u=l.locationData).relativeKeypoints=[],p=e.numKeypoints*e.numValuesPerKeypoint,f=0;f<p;f+=e.numValuesPerKeypoint)d=a+e.keypointCoordOffset+f,h={x:o[d+0],y:e.flipVertically?1-o[d+1]:o[d+1]},u.relativeKeypoints.push(h);r.push(l)}return[2,r]}})})}function b2e(t,n,e,r,o,s,i){return{score:[o],ind:i,locationData:{relativeBoundingBox:{xMin:n,yMin:s?1-e:t,xMax:r,yMax:s?1-t:e,width:r-n,height:e-t}}}}var cI,w2e={reduceBoxesInLowestLayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:4,minScale:.1484375,maxScale:.75,inputSizeHeight:128,inputSizeWidth:128,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,16,16],aspectRatios:[1],fixedAnchorSize:!0},C2e={reduceBoxesInLowestLayer:!1,interpolatedScaleAspectRatio:0,featureMapHeight:[],featureMapWidth:[],numLayers:1,minScale:.1484375,maxScale:.75,inputSizeHeight:192,inputSizeWidth:192,anchorOffsetX:.5,anchorOffsetY:.5,strides:[4],aspectRatios:[1],fixedAnchorSize:!0},Pk={runtime:"tfjs",modelType:"short",maxFaces:1,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/face_detection/short/1"},I2e={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:896,numCoords:16,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:6,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:128,yScale:128,hScale:128,wScale:128,minScoreThresh:.5},S2e={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2304,numCoords:16,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:6,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:192,yScale:192,hScale:192,wScale:192,minScoreThresh:.6},T2e={outputTensorSize:{width:128,height:128},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},E2e={outputTensorSize:{width:192,height:192},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},N2e=(function(){function t(n,e,r){this.detectorModel=e,this.maxFaces=r,n==="full"?(this.imageToTensorConfig=E2e,this.tensorsToDetectionConfig=S2e,this.anchors=Fq(C2e)):(this.imageToTensorConfig=T2e,this.tensorsToDetectionConfig=I2e,this.anchors=Fq(w2e));var o=qt(this.anchors.map(function(l){return l.width})),s=qt(this.anchors.map(function(l){return l.height})),i=qt(this.anchors.map(function(l){return l.xCenter})),a=qt(this.anchors.map(function(l){return l.yCenter}));this.anchorTensor={x:i,y:a,w:o,h:s}}return t.prototype.dispose=function(){this.detectorModel.dispose(),Ve([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h])},t.prototype.reset=function(){},t.prototype.detectFaces=function(n,e){return e===void 0&&(e=!1),Zl(this,void 0,void 0,function(){var r,o,s,i,a,l,c,u,p,f,d;return Ql(this,function(h){switch(h.label){case 0:return n==null?(this.reset(),[2,[]]):(r=X(function(){var g=fe(Qq(n),"float32");return e&&(g=Zt(nr.flipLeftRight(an(g,0)),[0])),g}),o=g2e(r,this.imageToTensorConfig),s=o.imageTensor,i=o.transformationMatrix,a=this.detectorModel.execute(s,"Identity:0"),l=(function(g){return X(function(){var m=(function(C){return X(function(){return[Ue(C,[0,0,0],[1,-1,1]),Ue(C,[0,0,1],[1,-1,-1])]})})(g),y=m[0],x=m[1];return{boxes:Zt(x),logits:Zt(y)}})})(a),c=l.boxes,[4,x2e([u=l.logits,c],this.anchorTensor,this.tensorsToDetectionConfig)]);case 1:return(p=h.sent()).length===0?(Ve([r,s,a,u,c]),[2,p]):[4,y2e(p,this.maxFaces,.3)];case 2:return f=h.sent(),d=(function(g,m){g===void 0&&(g=[]);var y,x=(y=m,[].concat.apply([],y));return g.forEach(function(C){var I=C.locationData;I.relativeKeypoints.forEach(function(F){var G=Lq(x,[F.x,F.y]),ee=G[0],Q=G[1];F.x=ee,F.y=Q});var D=I.relativeBoundingBox,O=Number.MAX_VALUE,L=Number.MAX_VALUE,B=Number.MIN_VALUE,V=Number.MIN_VALUE;[[D.xMin,D.yMin],[D.xMin+D.width,D.yMin],[D.xMin+D.width,D.yMin+D.height],[D.xMin,D.yMin+D.height]].forEach(function(F){var G=Lq(x,F),ee=G[0],Q=G[1];O=Math.min(O,ee),B=Math.max(B,ee),L=Math.min(L,Q),V=Math.max(V,Q)}),I.relativeBoundingBox={xMin:O,xMax:B,yMin:L,yMax:V,width:B-O,height:V-L}}),g})(f,i),Ve([r,s,a,u,c]),[2,d]}})})},t.prototype.estimateFaces=function(n,e){return Zl(this,void 0,void 0,function(){var r,o;return Ql(this,function(s){return r=Zq(n),o=!!e&&e.flipHorizontal,[2,this.detectFaces(n,o).then(function(i){return i.map(function(a){for(var l=a.locationData.relativeKeypoints.map(function(h,g){return Hu(Hu({},h),{x:h.x*r.width,y:h.y*r.height,name:Yq[g]})}),c=a.locationData.relativeBoundingBox,u=0,p=["width","xMax","xMin"];u<p.length;u++)c[p[u]]*=r.width;for(var f=0,d=["height","yMax","yMin"];f<d.length;f++)c[d[f]]*=r.height;return{keypoints:l,box:c}})})]})})},t})();function D2e(t){return Zl(this,void 0,void 0,function(){var n,e,r;return Ql(this,function(o){switch(o.label){case 0:return n=(function(s){if(s==null)return Hu({},Pk);var i=Hu({},s);return i.modelType==null&&(i.modelType=Pk.modelType),i.maxFaces==null&&(i.maxFaces=Pk.maxFaces),i.detectorModelUrl==null&&(i.modelType==="full"?i.detectorModelUrl="https://tfhub.dev/mediapipe/tfjs-model/face_detection/full/1":i.detectorModelUrl="https://tfhub.dev/mediapipe/tfjs-model/face_detection/short/1"),i})(t),e=typeof n.detectorModelUrl=="string"&&n.detectorModelUrl.indexOf("https://tfhub.dev")>-1,[4,nx(n.detectorModelUrl,{fromTFHub:e})];case 1:return r=o.sent(),[2,new N2e(n.modelType,r,n.maxFaces)]}})})}function k2e(t,n){return Zl(this,void 0,void 0,function(){var e,r;return Ql(this,function(o){if(t===cI.MediaPipeFaceDetector){if(r=void 0,(e=n)!=null){if(e.runtime==="tfjs")return[2,D2e(e)];if(e.runtime==="mediapipe")return[2,m2e(e)];r=e.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(r))}throw new Error("".concat(t," is not a supported model name."))})})}function Bk(t){return t.width*t.height}function Pq(t){var n=t.xCenter-t.width/2,e=n+t.width,r=t.yCenter-t.height/2;return{xMin:n,xMax:e,yMin:r,yMax:r+t.height,width:t.width,height:t.height}}function A2e(t,n){var e=Pq(t),r=Pq(n);if(!(function(i,a){return!(i.xMax<a.xMin||a.xMax<i.xMin||i.yMax<a.yMin||a.yMax<i.yMin)})(e,r))return 0;var o=Bk((function(i,a){var l=Math.max(i.xMin,a.xMin),c=Math.min(i.xMax,a.xMax),u=Math.max(i.yMin,a.yMin),p=Math.min(i.yMax,a.yMax);return{xMin:l,xMax:c,yMin:u,yMax:p,width:Math.max(c-l,0),height:Math.max(p-u,0)}})(e,r)),s=Bk(e)+Bk(r)-o;return s>0?o/s:0}function _2e(t,n,e,r){var o=t.width,s=t.height,i=r?-1:1,a=Math.cos(t.rotation),l=Math.sin(t.rotation),c=t.xCenter,u=t.yCenter,p=1/n,f=1/e,d=new Array(16);return d[0]=o*a*i*p,d[1]=-s*l*p,d[2]=0,d[3]=(-.5*o*a*i+.5*s*l+c)*p,d[4]=o*l*i*f,d[5]=s*a*f,d[6]=0,d[7]=(-.5*s*a-.5*o*l*i+u)*f,d[8]=0,d[9]=0,d[10]=o*p,d[11]=0,d[12]=0,d[13]=0,d[14]=0,d[15]=1,(function(h){if(h.length!==16)throw new Error("Array length must be 16 but got "+h.length);return[[h[0],h[1],h[2],h[3]],[h[4],h[5],h[6],h[7]],[h[8],h[9],h[10],h[11]],[h[12],h[13],h[14],h[15]]]})(d)}function Jq(t){return t instanceof ot?{height:t.shape[0],width:t.shape[1]}:{height:t.height,width:t.width}}function eK(t){return t-2*Math.PI*Math.floor((t+Math.PI)/(2*Math.PI))}function tK(t){return t instanceof ot?t:Ol.fromPixels(t)}function zk(t,n){b.assert(t.width!==0,function(){return n+" width cannot be 0."}),b.assert(t.height!==0,function(){return n+" height cannot be 0."})}function R2e(t,n){var e=(function(r,o,s,i){var a=o-r,l=i-s;if(a===0)throw new Error("Original min and max are both "+r+", range cannot be 0.");var c=l/a;return{scale:c,offset:s-r*c}})(0,255,n[0],n[1]);return X(function(){return le(z(t,e.scale),e.offset)})}function M2e(t,n,e){var r=n.outputTensorSize,o=n.keepAspectRatio,s=n.borderMode,i=n.outputTensorFloatRange,a=Jq(t),l=(function(f,d){return d?{xCenter:d.xCenter*f.width,yCenter:d.yCenter*f.height,width:d.width*f.width,height:d.height*f.height,rotation:d.rotation}:{xCenter:.5*f.width,yCenter:.5*f.height,width:f.width,height:f.height,rotation:0}})(a,e),c=(function(f,d,h){if(h===void 0&&(h=!1),!h)return{top:0,left:0,right:0,bottom:0};var g=d.height,m=d.width;zk(d,"targetSize"),zk(f,"roi");var y,x,C=g/m,I=f.height/f.width,D=0,O=0;return C>I?(y=f.width,x=f.width*C,O=(1-I/C)/2):(y=f.height/C,x=f.height,D=(1-C/I)/2),f.width=y,f.height=x,{top:O,left:D,right:D,bottom:O}})(l,r,o),u=_2e(l,a.width,a.height,!1),p=X(function(){var f=tK(t),d=es((function(m,y,x){return zk(x,"inputResolution"),[1/x.width*m[0][0]*y.width,1/x.height*m[0][1]*y.width,m[0][3]*y.width,1/x.width*m[1][0]*y.height,1/x.height*m[1][1]*y.height,m[1][3]*y.height,0,0]})(u,a,r),[1,8]),h=s==="zero"?"constant":"nearest",g=nr.transform(an(fe(f,"float32")),d,"bilinear",h,0,[r.height,r.width]);return i!=null?R2e(g,i):g});return{imageTensor:p,padding:c,transformationMatrix:u}}function Bq(t){return{xCenter:t.xMin+t.width/2,yCenter:t.yMin+t.height/2,width:t.width,height:t.height}}function zq(t){var n=t.relativeKeypoints;if(n.length<=1)throw new Error("2 or more keypoints required to calculate a rect.");var e=Number.MAX_VALUE,r=Number.MAX_VALUE,o=Number.MIN_VALUE,s=Number.MIN_VALUE;return n.forEach(function(i){e=Math.min(e,i.x),o=Math.max(o,i.x),r=Math.min(r,i.y),s=Math.max(s,i.y)}),{xCenter:(e+o)/2,yCenter:(r+s)/2,width:o-e,height:s-r}}function Vq(t,n,e,r,o){var s=e==="rect"?(function(i,a,l){var c,u=i.locationData;if(a==="boundingbox")c=Bq(u.boundingBox);else{c=zq(u);var p=l.width,f=l.height;c.xCenter=Math.round(c.xCenter*p),c.yCenter=Math.round(c.yCenter*f),c.width=Math.round(c.width*p),c.height=Math.round(c.height*f)}return c})(t,n,r):(function(i,a){var l=i.locationData;return a==="boundingbox"?Bq(l.relativeBoundingBox):zq(l)})(t,n);return o&&(s.rotation=(function(i,a,l){var c,u=i.locationData,p=l.rotationVectorStartKeypointIndex,f=l.rotationVectorEndKeypointIndex;c=l.rotationVectorTargetAngle?l.rotationVectorTargetAngle:Math.PI*l.rotationVectorTargetAngleDegree/180;var d=u.relativeKeypoints[p].x*a.width,h=u.relativeKeypoints[p].y*a.height,g=u.relativeKeypoints[f].x*a.width,m=u.relativeKeypoints[f].y*a.height;return eK(c-Math.atan2(-(m-h),g-d))})(t,r,o)),s}function O2e(t,n,e){for(var r=0;r<n.length;++r){var o=n[r],s=e[t[r]];s.x=o.x,s.y=o.y}}function F2e(t,n,e,r){if(typeof n=="string"){if(n==="copy")for(var o=0;o<e.length;++o)r[t[o]].z=e[o].z}else{var s=(function(i,a){for(var l=0,c=0;c<a.length;++c)l+=i[a[c]].z;return l/a.length})(r,n);for(o=0;o<t.length;++o)r[t[o]].z=s}}function $2e(t,n){for(var e=(function(a){var l=[].concat.apply([],a.map(function(d){return d.indexesMapping}));if(l.length===0)throw new Error("There should be at least one landmark in indexes mapping");var c=l[0],u=l[0],p=new Set(l);p.forEach(function(d){c=Math.min(c,d),u=Math.max(u,d)});var f=p.size;if(c!==0)throw new Error("Indexes are expected to start with 0 instead of "+c);if(u+1!==f)throw new Error("Indexes should have no gaps but "+(u-f+1)+" indexes are missing");return f})(n),r=new Array(e).fill(null).map(Object),o=0;o<t.length;++o){var s=t[o],i=n[o];if(s.length!==i.indexesMapping.length)throw new Error("There are "+s.length+" refinement landmarks while mapping has "+i.indexesMapping.length);O2e(i.indexesMapping,s,r),F2e(i.indexesMapping,i.zRefinement,s,r)}return r}function L2e(t,n){return t.map(function(e){var r=Ai(Ai({},e),{x:e.x*n.width,y:e.y*n.height});return e.z!=null&&(r.z=e.z*n.width),r})}function P2e(t,n){return t==="none"?n:(function(e){return 1/(1+Math.exp(-e))})(n)}function Pf(t,n,e,r){return Xl(this,void 0,void 0,function(){var o,s,i,a,l,c,u,p;return Yl(this,function(f){switch(f.label){case 0:return e=e||n.flipHorizontally||!1,r=r||n.flipVertically||!1,o=t.size,s=o/n.numLandmarks,[4,t.data()];case 1:for(i=f.sent(),a=[],l=0;l<n.numLandmarks;++l)c=l*s,(p={x:0,y:0}).x=e?n.inputImageWidth-i[c]:i[c],s>1&&(p.y=r?n.inputImageHeight-i[c+1]:i[c+1]),s>2&&(p.z=i[c+2]),s>3&&(p.score=P2e(n.visibilityActivation,i[c+3])),a.push(p);for(u=0;u<a.length;++u)(p=a[u]).x=p.x/n.inputImageWidth,p.y=p.y/n.inputImageHeight,p.z=p.z/n.inputImageWidth/(n.normalizeZ||1);return[2,a]}})})}function Uq(t,n,e){var r=t.width,o=t.height,s=t.rotation;if(e.rotation==null&&e.rotationDegree==null||(s=(function(u,p){return p.rotation!=null?u+=p.rotation:p.rotationDegree!=null&&(u+=Math.PI*p.rotationDegree/180),eK(u)})(s,e)),s===0)t.xCenter=t.xCenter+r*e.shiftX,t.yCenter=t.yCenter+o*e.shiftY;else{var i=(n.width*r*e.shiftX*Math.cos(s)-n.height*o*e.shiftY*Math.sin(s))/n.width,a=(n.width*r*e.shiftX*Math.sin(s)+n.height*o*e.shiftY*Math.cos(s))/n.height;t.xCenter=t.xCenter+i,t.yCenter=t.yCenter+a}if(e.squareLong){var l=Math.max(r*n.width,o*n.height);r=l/n.width,o=l/n.height}else if(e.squareShort){var c=Math.min(r*n.width,o*n.height);r=c/n.width,o=c/n.height}return t.width=r*e.scaleX,t.height=o*e.scaleY,t}(cI||(cI={})).MediaPipeFaceDetector="MediaPipeFaceDetector";var Vk={runtime:"tfjs",maxFaces:1,refineLandmarks:!1,landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/face_landmarks_detection/face_mesh/1"},Uk={flipHorizontal:!1,staticImageMode:!1},Gq={shiftX:0,shiftY:0,scaleX:1.5,scaleY:1.5,squareLong:!0},B2e={outputTensorSize:{width:192,height:192},outputTensorFloatRange:[0,1],borderMode:"replicate"},jq={numLandmarks:468,inputImageWidth:192,inputImageHeight:192,visibilityActivation:"none",flipHorizontally:!1,flipVertically:!1},z2e={numLandmarks:80,inputImageWidth:192,inputImageHeight:192,visibilityActivation:"none",flipHorizontally:!1,flipVertically:!1},Hq={numLandmarks:71,inputImageWidth:192,inputImageHeight:192,visibilityActivation:"none",flipHorizontally:!1,flipVertically:!1},Wq={numLandmarks:5,inputImageWidth:192,inputImageHeight:192,visibilityActivation:"none",flipHorizontally:!1,flipVertically:!1},V2e={indexesMapping:Array.from(Array(468).keys()),zRefinement:"copy"},U2e={indexesMapping:[61,146,91,181,84,17,314,405,321,375,291,185,40,39,37,0,267,269,270,409,78,95,88,178,87,14,317,402,318,324,308,191,80,81,82,13,312,311,310,415,76,77,90,180,85,16,315,404,320,307,306,184,74,73,72,11,302,303,304,408,62,96,89,179,86,15,316,403,319,325,292,183,42,41,38,12,268,271,272,407],zRefinement:"none"},G2e={indexesMapping:[33,7,163,144,145,153,154,155,133,246,161,160,159,158,157,173,130,25,110,24,23,22,26,112,243,247,30,29,27,28,56,190,226,31,228,229,230,231,232,233,244,113,225,224,223,222,221,189,35,124,46,53,52,65,143,111,117,118,119,120,121,128,245,156,70,63,105,66,107,55,193],zRefinement:"none"},j2e={indexesMapping:[263,249,390,373,374,380,381,382,362,466,388,387,386,385,384,398,359,255,339,254,253,252,256,341,463,467,260,259,257,258,286,414,446,261,448,449,450,451,452,453,464,342,445,444,443,442,441,413,265,353,276,283,282,295,372,340,346,347,348,349,350,357,465,383,300,293,334,296,336,285,417],zRefinement:"none"},H2e={indexesMapping:[468,469,470,471,472],zRefinement:[33,7,163,144,145,153,154,155,133,246,161,160,159,158,157,173]},W2e={indexesMapping:[473,474,475,476,477],zRefinement:[263,249,390,373,374,380,381,382,362,466,388,387,386,385,384,398]},Bf,q2e=(function(){function t(n,e,r,o){this.detector=n,this.landmarkModel=e,this.maxFaces=r,this.withAttention=o,this.prevFaceRectsFromLandmarks=null}return t.prototype.estimateFaces=function(n,e){return Xl(this,void 0,void 0,function(){var r,o,s,i,a,l,c,u,p,f,d,h,g,m=this;return Yl(this,function(y){switch(y.label){case 0:return r=(function(I){if(I==null)return Ai({},Uk);var D=Ai({},I);return D.flipHorizontal==null&&(D.flipHorizontal=Uk.flipHorizontal),D.staticImageMode==null&&(D.staticImageMode=Uk.staticImageMode),D})(e),n==null?(this.reset(),[2,[]]):(o=Jq(n),s=X(function(){var I=fe(tK(n),"float32");return r.flipHorizontal&&(I=Zt(nr.flipLeftRight(an(I,0)),[0])),I}),i=this.prevFaceRectsFromLandmarks,r.staticImageMode||i==null||i.length<this.maxFaces?[4,this.detector.detectFaces(s,!1)]:[3,2]);case 1:return(l=y.sent()).length===0?(this.reset(),s.dispose(),[2,[]]):(a=l.map(function(I){return m.faceDetectionFrontDetectionToRoi(I,o)}),[3,3]);case 2:a=[],y.label=3;case 3:return x=.5,C=[],[a,i||[]].forEach(function(I){return I.forEach(function(D){(C=C.filter(function(O){return A2e(D,O)<=x})).push(D)})}),c=C,[4,Promise.all(c.map(function(I){return m.faceLandmark(I,s)}))];case 4:for(u=y.sent(),p=[],this.prevFaceRectsFromLandmarks=[],f=0;f<u.length;++f)(d=u[f])!=null&&(this.prevFaceRectsFromLandmarks.push(this.faceLandmarksToRoi(d,o)),(h=L2e(d,o))!=null&&h.forEach(function(I,D){var O=Xq.get(D);O!=null&&(I.name=O)}),g=Gk(h),p.push({keypoints:h,box:g.locationData.relativeBoundingBox}));return s.dispose(),[2,p]}var x,C})})},t.prototype.dispose=function(){this.detector.dispose(),this.landmarkModel.dispose()},t.prototype.reset=function(){this.detector.reset(),this.prevFaceRectsFromLandmarks=null},t.prototype.faceDetectionFrontDetectionToRoi=function(n,e){return Uq(Vq(n,"boundingbox","normRect",e,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:0}),e,Gq)},t.prototype.faceLandmark=function(n,e){return Xl(this,void 0,void 0,function(){var r,o,s,i,a,l,c;return Yl(this,function(u){switch(u.label){case 0:return r=M2e(e,B2e,n).imageTensor,o=["output_faceflag"].concat(this.withAttention?["output_mesh_identity","output_lips","Identity_6:0","Identity_1:0","Identity_2:0","Identity_5:0"]:["output_mesh"]),s=this.landmarkModel.execute(r,o),i=s[0],a=s.slice(1),[4,i.data()];case 1:return u.sent()[0]<.5?(Ve(s),Ve(r),[2,null]):this.withAttention?[4,this.tensorsToFaceLandmarksWithAttention(a)]:[3,3];case 2:return l=u.sent(),[3,5];case 3:return[4,this.tensorsToFaceLandmarks(a)];case 4:l=u.sent(),u.label=5;case 5:return c=(function(p,f,d){d===void 0&&(d={ignoreRotation:!1});for(var h=[],g=0,m=p;g<m.length;g++){var y=m[g],x=y.x-.5,C=y.y-.5,I=d.ignoreRotation?0:f.rotation,D=Math.cos(I)*x-Math.sin(I)*C,O=Math.sin(I)*x+Math.cos(I)*C;D=D*f.width+f.xCenter,O=O*f.height+f.yCenter;var L=y.z*f.width,B=Ai({},y);B.x=D,B.y=O,B.z=L,h.push(B)}return h})(l,n),Ve(s),Ve(r),[2,c]}})})},t.prototype.tensorsToFaceLandmarks=function(n){return Xl(this,void 0,void 0,function(){return Yl(this,function(e){return[2,Pf(n[0],jq)]})})},t.prototype.tensorsToFaceLandmarksWithAttention=function(n){return Xl(this,void 0,void 0,function(){var e,r,o,s,i,a;return Yl(this,function(l){switch(l.label){case 0:return[4,Pf(n[0],jq)];case 1:return e=l.sent(),[4,Pf(n[1],z2e)];case 2:return r=l.sent(),[4,Pf(n[3],Hq)];case 3:return o=l.sent(),[4,Pf(n[5],Hq)];case 4:return s=l.sent(),[4,Pf(n[4],Wq)];case 5:return i=l.sent(),[4,Pf(n[2],Wq)];case 6:return a=l.sent(),[2,$2e([e,r,o,s,i,a],[V2e,U2e,G2e,j2e,H2e,W2e])]}})})},t.prototype.faceLandmarksToRoi=function(n,e){return Uq(Vq(Gk(n),"boundingbox","normRect",e,{rotationVectorStartKeypointIndex:33,rotationVectorEndKeypointIndex:263,rotationVectorTargetAngleDegree:0}),e,Gq)},t})();function K2e(t){return Xl(this,void 0,void 0,function(){var n,e,r,o;return Yl(this,function(s){switch(s.label){case 0:return n=(function(i){if(i==null)return Ai({},Vk);var a=Ai({},i);return a.runtime="tfjs",a.maxFaces==null&&(a.maxFaces=Vk.maxFaces),a.refineLandmarks==null&&(a.refineLandmarks=Vk.refineLandmarks),a.landmarkModelUrl==null&&(a.landmarkModelUrl=a.refineLandmarks?"https://tfhub.dev/mediapipe/tfjs-model/face_landmarks_detection/attention_mesh/1":"https://tfhub.dev/mediapipe/tfjs-model/face_landmarks_detection/face_mesh/1"),a})(t),e=typeof n.landmarkModelUrl=="string"&&n.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,nx(n.landmarkModelUrl,{fromTFHub:e})];case 1:return r=s.sent(),[4,k2e(cI.MediaPipeFaceDetector,{modelType:"short",maxFaces:n.maxFaces,detectorModelUrl:n.detectorModelUrl,runtime:n.runtime})];case 2:return o=s.sent(),[2,new q2e(o,r,n.maxFaces,n.refineLandmarks)]}})})}function nK(t,n){return Xl(this,void 0,void 0,function(){var e,r;return Yl(this,function(o){if(t===Bf.MediaPipeFaceMesh){if(r=void 0,(e=n)!=null){if(e.runtime==="tfjs")return[2,K2e(e)];if(e.runtime==="mediapipe")return[2,f2e(e)];r=e.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' or 'mediapipe', but got "+r)}throw new Error(t+" is not a supported model name.")})})}(function(t){t.MediaPipeFaceMesh="MediaPipeFaceMesh"})(Bf||(Bf={}));var Vyn=Object.freeze({__proto__:null,getKeypointIndexByContour:function(t){if(t===Bf.MediaPipeFaceMesh)return Kq;throw new Error("Model "+t+" is not supported.")},getAdjacentPairs:function(t){if(t===Bf.MediaPipeFaceMesh)return c2e;throw new Error("Model "+t+" is not supported.")}});var Y2e=["video2"],Z2e=["canvas2"],uI=class t{constructor(n){this.cdr=n}cameraGranted=!1;videoRef;canvasRef;video;canvas;ctx;detector;ngAfterViewInit(){this.video=this.videoRef?.nativeElement,this.canvas=this.canvasRef?.nativeElement;let n=this.canvas.getContext("2d");if(!n)throw new Error("No se pudo obtener el contexto del canvas");this.ctx=n}requestCamera(){return te(this,null,function*(){try{let n=yield navigator.mediaDevices.getUserMedia({video:{facingMode:{ideal:"user"}},audio:!1});this.cameraGranted=!0,this.cdr.detectChanges(),this.video.srcObject=n,yield this.video.play(),yield lN("webgl"),this.detector=yield nK(Bf.MediaPipeFaceMesh,{runtime:"tfjs",maxFaces:1,refineLandmarks:!0}),this.detectFaces()}catch(n){console.error("Error c\xE1mara:",n),alert("No se pudo acceder a la c\xE1mara. Revisa los permisos.")}})}detectFaces(){return te(this,null,function*(){if(!this.detector)return;let n=()=>te(this,null,function*(){if(!this.video.paused&&!this.video.ended){let e=yield this.detector.estimateFaces(this.video,{flipHorizontal:!1});this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height),this.ctx.drawImage(this.video,0,0,this.canvas.width,this.canvas.height),e.forEach(r=>{r.keypoints.forEach(o=>{this.ctx.beginPath(),this.ctx.arc(o.x,o.y,1.5,0,2*Math.PI),this.ctx.fillStyle="blue",this.ctx.fill()})})}requestAnimationFrame(n)});n()})}static \u0275fac=function(e){return new(e||t)(Oa(vp))};static \u0275cmp=Ho({type:t,selectors:[["app-camera"]],viewQuery:function(e,r){if(e&1&&Rd(Y2e,5)(Z2e,5),e&2){let o;$a(o=La())&&(r.videoRef=o.first),$a(o=La())&&(r.canvasRef=o.first)}},decls:12,vars:0,consts:[["video2",""],["canvas2",""],[1,"permission-card"],["mat-raised-button","","color","primary",3,"click"],["autoplay","","muted","","playsinline","","width","640","height","480",2,"display","none"],["width","640","height","480"]],template:function(e,r){if(e&1){let o=My();ko(0,"mat-card",2)(1,"mat-card-title"),li(2,"Tensorflow Js"),Qr(),ko(3,"mat-card-content")(4,"p"),li(5,"Se requiere acceso a la c\xE1mara."),Qr(),ko(6,"button",3),kd("click",function(){return fd(o),dd(r.requestCamera())}),li(7," Activar C\xE1mara "),Qr()(),Ms(8,"video",4,0)(10,"canvas",5,1),Qr()}},dependencies:[ov,tv,rv,nv,Od],styles:[".permission-container[_ngcontent-%COMP%]{display:flex;justify-content:center;align-items:center;height:80vh}.permission-card[_ngcontent-%COMP%]{text-align:center;padding:2rem}"]})};var pI=class{tracker;columnIndex=0;rowIndex=0;get rowCount(){return this.rowIndex+1}get rowspan(){let n=Math.max(...this.tracker);return n>1?this.rowCount+n-1:this.rowCount}positions;update(n,e){this.columnIndex=0,this.rowIndex=0,this.tracker=new Array(n),this.tracker.fill(0,0,this.tracker.length),this.positions=e.map(r=>this._trackTile(r))}_trackTile(n){let e=this._findMatchingGap(n.colspan);return this._markTilePosition(e,n),this.columnIndex=e+n.colspan,new jk(this.rowIndex,e)}_findMatchingGap(n){n>this.tracker.length;let e=-1,r=-1;do{if(this.columnIndex+n>this.tracker.length){this._nextRow(),e=this.tracker.indexOf(0,this.columnIndex),r=this._findGapEndIndex(e);continue}if(e=this.tracker.indexOf(0,this.columnIndex),e==-1){this._nextRow(),e=this.tracker.indexOf(0,this.columnIndex),r=this._findGapEndIndex(e);continue}r=this._findGapEndIndex(e),this.columnIndex=e+1}while(r-e<n||r==0);return Math.max(e,0)}_nextRow(){this.columnIndex=0,this.rowIndex++;for(let n=0;n<this.tracker.length;n++)this.tracker[n]=Math.max(0,this.tracker[n]-1)}_findGapEndIndex(n){for(let e=n+1;e<this.tracker.length;e++)if(this.tracker[e]!=0)return e;return this.tracker.length}_markTilePosition(n,e){for(let r=0;r<e.colspan;r++)this.tracker[n+r]=e.rowspan}},jk=class{row;col;constructor(n,e){this.row=n,this.col=e}};function Sx(t,n=0){return rK(t)?Number(t):arguments.length===2?n:0}function rK(t){return!isNaN(parseFloat(t))&&!isNaN(Number(t))}var oK=["*"];var Q2e=`.mat-grid-list{display:block;position:relative}.mat-grid-tile{display:block;position:absolute;overflow:hidden}.mat-grid-tile .mat-grid-tile-header,.mat-grid-tile .mat-grid-tile-footer{display:flex;align-items:center;height:48px;color:#fff;background:rgba(0,0,0,.38);overflow:hidden;padding:0 16px;position:absolute;left:0;right:0}.mat-grid-tile .mat-grid-tile-header>*,.mat-grid-tile .mat-grid-tile-footer>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-grid-tile .mat-grid-tile-header.mat-2-line,.mat-grid-tile .mat-grid-tile-footer.mat-2-line{height:68px}.mat-grid-tile .mat-grid-list-text{display:flex;flex-direction:column;flex:auto;box-sizing:border-box;overflow:hidden}.mat-grid-tile .mat-grid-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-grid-tile .mat-grid-list-text:empty{display:none}.mat-grid-tile .mat-grid-tile-header{top:0}.mat-grid-tile .mat-grid-tile-footer{bottom:0}.mat-grid-tile .mat-grid-avatar{padding-right:16px}[dir=rtl] .mat-grid-tile .mat-grid-avatar{padding-right:0;padding-left:16px}.mat-grid-tile .mat-grid-avatar:empty{display:none}.mat-grid-tile-header{font-size:var(--mat-grid-list-tile-header-primary-text-size, var(--mat-sys-body-large))}.mat-grid-tile-header .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-grid-tile-header .mat-line:nth-child(n+2){font-size:var(--mat-grid-list-tile-header-secondary-text-size, var(--mat-sys-body-medium))}.mat-grid-tile-footer{font-size:var(--mat-grid-list-tile-footer-primary-text-size, var(--mat-sys-body-large))}.mat-grid-tile-footer .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-grid-tile-footer .mat-line:nth-child(n+2){font-size:var(--mat-grid-list-tile-footer-secondary-text-size, var(--mat-sys-body-medium))}.mat-grid-tile-content{top:0;left:0;right:0;bottom:0;position:absolute;display:flex;align-items:center;justify-content:center;height:100%;padding:0;margin:0}
`,sK=new nt("MAT_GRID_LIST"),Kk=(()=>{class t{_element=Ae(Ma);_gridList=Ae(sK,{optional:!0});_rowspan=1;_colspan=1;constructor(){}get rowspan(){return this._rowspan}set rowspan(e){this._rowspan=Math.round(Sx(e))}get colspan(){return this._colspan}set colspan(e){this._colspan=Math.round(Sx(e))}_setStyle(e,r){this._element.nativeElement.style[e]=r}static \u0275fac=function(r){return new(r||t)};static \u0275cmp=Ho({type:t,selectors:[["mat-grid-tile"]],hostAttrs:[1,"mat-grid-tile"],hostVars:2,hostBindings:function(r,o){r&2&&Ed("rowspan",o.rowspan)("colspan",o.colspan)},inputs:{rowspan:"rowspan",colspan:"colspan"},exportAs:["matGridTile"],ngContentSelectors:oK,decls:2,vars:0,consts:[[1,"mat-grid-tile-content"]],template:function(r,o){r&1&&(Ad(),Nd(0,"div",0),_d(1),Dd())},styles:[`.mat-grid-list{display:block;position:relative}.mat-grid-tile{display:block;position:absolute;overflow:hidden}.mat-grid-tile .mat-grid-tile-header,.mat-grid-tile .mat-grid-tile-footer{display:flex;align-items:center;height:48px;color:#fff;background:rgba(0,0,0,.38);overflow:hidden;padding:0 16px;position:absolute;left:0;right:0}.mat-grid-tile .mat-grid-tile-header>*,.mat-grid-tile .mat-grid-tile-footer>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-grid-tile .mat-grid-tile-header.mat-2-line,.mat-grid-tile .mat-grid-tile-footer.mat-2-line{height:68px}.mat-grid-tile .mat-grid-list-text{display:flex;flex-direction:column;flex:auto;box-sizing:border-box;overflow:hidden}.mat-grid-tile .mat-grid-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-grid-tile .mat-grid-list-text:empty{display:none}.mat-grid-tile .mat-grid-tile-header{top:0}.mat-grid-tile .mat-grid-tile-footer{bottom:0}.mat-grid-tile .mat-grid-avatar{padding-right:16px}[dir=rtl] .mat-grid-tile .mat-grid-avatar{padding-right:0;padding-left:16px}.mat-grid-tile .mat-grid-avatar:empty{display:none}.mat-grid-tile-header{font-size:var(--mat-grid-list-tile-header-primary-text-size, var(--mat-sys-body-large))}.mat-grid-tile-header .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-grid-tile-header .mat-line:nth-child(n+2){font-size:var(--mat-grid-list-tile-header-secondary-text-size, var(--mat-sys-body-medium))}.mat-grid-tile-footer{font-size:var(--mat-grid-list-tile-footer-primary-text-size, var(--mat-sys-body-large))}.mat-grid-tile-footer .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-grid-tile-footer .mat-line:nth-child(n+2){font-size:var(--mat-grid-list-tile-footer-secondary-text-size, var(--mat-sys-body-medium))}.mat-grid-tile-content{top:0;left:0;right:0;bottom:0;position:absolute;display:flex;align-items:center;justify-content:center;height:100%;padding:0;margin:0}
`],encapsulation:2,changeDetection:0})}return t})();var J2e=/^-?\d+((\.\d+)?[A-Za-z%$]?)+$/,Tx=class{_gutterSize;_rows=0;_rowspan=0;_cols;_direction;init(n,e,r,o){this._gutterSize=iK(n),this._rows=e.rowCount,this._rowspan=e.rowspan,this._cols=r,this._direction=o}getBaseTileSize(n,e){return`(${n}% - (${this._gutterSize} * ${e}))`}getTilePosition(n,e){return e===0?"0":zf(`(${n} + ${this._gutterSize}) * ${e}`)}getTileSize(n,e){return`(${n} * ${e}) + (${e-1} * ${this._gutterSize})`}setStyle(n,e,r){let o=100/this._cols,s=(this._cols-1)/this._cols;this.setColStyles(n,r,o,s),this.setRowStyles(n,e,o,s)}setColStyles(n,e,r,o){let s=this.getBaseTileSize(r,o),i=this._direction==="rtl"?"right":"left";n._setStyle(i,this.getTilePosition(s,e)),n._setStyle("width",zf(this.getTileSize(s,n.colspan)))}getGutterSpan(){return`${this._gutterSize} * (${this._rowspan} - 1)`}getTileSpan(n){return`${this._rowspan} * ${this.getTileSize(n,1)}`}getComputedHeight(){return null}},Hk=class extends Tx{fixedRowHeight;constructor(n){super(),this.fixedRowHeight=n}init(n,e,r,o){super.init(n,e,r,o),this.fixedRowHeight=iK(this.fixedRowHeight),J2e.test(this.fixedRowHeight)}setRowStyles(n,e){n._setStyle("top",this.getTilePosition(this.fixedRowHeight,e)),n._setStyle("height",zf(this.getTileSize(this.fixedRowHeight,n.rowspan)))}getComputedHeight(){return["height",zf(`${this.getTileSpan(this.fixedRowHeight)} + ${this.getGutterSpan()}`)]}reset(n){n._setListStyle(["height",null]),n._tiles&&n._tiles.forEach(e=>{e._setStyle("top",null),e._setStyle("height",null)})}},Wk=class extends Tx{rowHeightRatio;baseTileHeight;constructor(n){super(),this._parseRatio(n)}setRowStyles(n,e,r,o){let s=r/this.rowHeightRatio;this.baseTileHeight=this.getBaseTileSize(s,o),n._setStyle("marginTop",this.getTilePosition(this.baseTileHeight,e)),n._setStyle("paddingTop",zf(this.getTileSize(this.baseTileHeight,n.rowspan)))}getComputedHeight(){return["paddingBottom",zf(`${this.getTileSpan(this.baseTileHeight)} + ${this.getGutterSpan()}`)]}reset(n){n._setListStyle(["paddingBottom",null]),n._tiles.forEach(e=>{e._setStyle("marginTop",null),e._setStyle("paddingTop",null)})}_parseRatio(n){let e=n.split(":");e.length,this.rowHeightRatio=parseFloat(e[0])/parseFloat(e[1])}},qk=class extends Tx{setRowStyles(n,e){let r=100/this._rowspan,o=(this._rows-1)/this._rows,s=this.getBaseTileSize(r,o);n._setStyle("top",this.getTilePosition(s,e)),n._setStyle("height",zf(this.getTileSize(s,n.rowspan)))}reset(n){n._tiles&&n._tiles.forEach(e=>{e._setStyle("top",null),e._setStyle("height",null)})}};function zf(t){return`calc(${t})`}function iK(t){return t.match(/([A-Za-z%]+)$/)?t:`${t}px`}var eve="fit",aK=(()=>{class t{_element=Ae(Ma);_dir=Ae($E,{optional:!0});_cols;_tileCoordinator;_rowHeight;_gutter="1px";_tileStyler;_tiles;constructor(){}get cols(){return this._cols}set cols(e){this._cols=Math.max(1,Math.round(Sx(e)))}get gutterSize(){return this._gutter}set gutterSize(e){this._gutter=`${e??""}`}get rowHeight(){return this._rowHeight}set rowHeight(e){let r=`${e??""}`;r!==this._rowHeight&&(this._rowHeight=r,this._setTileStyler(this._rowHeight))}ngOnInit(){this._checkCols(),this._checkRowHeight()}ngAfterContentChecked(){this._layoutTiles()}_checkCols(){this.cols}_checkRowHeight(){this._rowHeight||this._setTileStyler("1:1")}_setTileStyler(e){this._tileStyler&&this._tileStyler.reset(this),e===eve?this._tileStyler=new qk:e&&e.indexOf(":")>-1?this._tileStyler=new Wk(e):this._tileStyler=new Hk(e)}_layoutTiles(){this._tileCoordinator||(this._tileCoordinator=new pI);let e=this._tileCoordinator,r=this._tiles.filter(s=>!s._gridList||s._gridList===this),o=this._dir?this._dir.value:"ltr";this._tileCoordinator.update(this.cols,r),this._tileStyler.init(this.gutterSize,e,this.cols,o),r.forEach((s,i)=>{let a=e.positions[i];this._tileStyler.setStyle(s,a.row,a.col)}),this._setListStyle(this._tileStyler.getComputedHeight())}_setListStyle(e){e&&(this._element.nativeElement.style[e[0]]=e[1])}static \u0275fac=function(r){return new(r||t)};static \u0275cmp=Ho({type:t,selectors:[["mat-grid-list"]],contentQueries:function(r,o,s){if(r&1&&g2(s,Kk,5),r&2){let i;$a(i=La())&&(o._tiles=i)}},hostAttrs:[1,"mat-grid-list"],hostVars:1,hostBindings:function(r,o){r&2&&Ed("cols",o.cols)},inputs:{cols:"cols",gutterSize:"gutterSize",rowHeight:"rowHeight"},exportAs:["matGridList"],features:[x2([{provide:sK,useExisting:t}])],ngContentSelectors:oK,decls:2,vars:0,template:function(r,o){r&1&&(Ad(),Nd(0,"div"),_d(1),Dd())},styles:[Q2e],encapsulation:2,changeDetection:0})}return t})();var fI=class t{static \u0275fac=function(e){return new(e||t)};static \u0275cmp=Ho({type:t,selectors:[["app-root"]],decls:8,vars:0,consts:[["cols","2","rowHeight","1:1"]],template:function(e,r){e&1&&(ko(0,"h1"),li(1,"Demo Reconocimiento Facial"),Qr(),ko(2,"mat-grid-list",0)(3,"mat-grid-tile"),Ms(4,"app-cam"),Qr(),ko(5,"mat-grid-tile"),Ms(6,"app-camera"),Qr()(),Ms(7,"router-outlet"))},dependencies:[t1,sv,uI,aK,Kk],encapsulation:2})};uE(fI,aF).catch(t=>console.error(t));
